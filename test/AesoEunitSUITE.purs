module Aeso.Eunit.SUITE where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__all__0 :: ErlangFun
erlps__all__0 [] =
  let head_0 = ErlangTuple [ErlangAtom "group", ErlangAtom "eunit"]
  in ErlangCons head_0 ErlangEmptyList
erlps__all__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__groups__0 :: ErlangFun
erlps__groups__0 [] =
  let
    head_0 =
      ErlangTuple
        [ErlangAtom "eunit", ErlangEmptyList,
         ErlangCons (ErlangAtom "aeso_scan_tests")
           (ErlangCons (ErlangAtom "aeso_parser_tests")
              (ErlangCons (ErlangAtom "aeso_compiler_tests")
                 (ErlangCons (ErlangAtom "aeso_abi_tests")
                    (ErlangCons (ErlangAtom "aeso_aci_tests")
                       ErlangEmptyList))))]
  in ErlangCons head_0 ErlangEmptyList
erlps__groups__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__aeso_scan_tests__1 :: ErlangFun
erlps__aeso_scan_tests__1 [_config_0] =
  let
    match_final_1_3 =
      BIF.do_remote_fun_call "Eunit" "erlps__test__1"
        [ErlangAtom "aeso_scan_tests"]
  in
    case match_final_1_3 of
      (ErlangAtom "ok") -> match_final_1_3
      _ -> EXC.badmatch match_final_1_3
erlps__aeso_scan_tests__1 [arg_5] = EXC.function_clause unit
erlps__aeso_scan_tests__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__aeso_parser_tests__1 :: ErlangFun
erlps__aeso_parser_tests__1 [_config_0] =
  let
    match_final_1_3 =
      BIF.do_remote_fun_call "Eunit" "erlps__test__1"
        [ErlangAtom "aeso_parser_tests"]
  in
    case match_final_1_3 of
      (ErlangAtom "ok") -> match_final_1_3
      _ -> EXC.badmatch match_final_1_3
erlps__aeso_parser_tests__1 [arg_5] = EXC.function_clause unit
erlps__aeso_parser_tests__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__aeso_compiler_tests__1 :: ErlangFun
erlps__aeso_compiler_tests__1 [_config_0] =
  let
    match_final_1_3 =
      BIF.do_remote_fun_call "Eunit" "erlps__test__1"
        [ErlangAtom "aeso_compiler_tests"]
  in
    case match_final_1_3 of
      (ErlangAtom "ok") -> match_final_1_3
      _ -> EXC.badmatch match_final_1_3
erlps__aeso_compiler_tests__1 [arg_5] = EXC.function_clause unit
erlps__aeso_compiler_tests__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__aeso_abi_tests__1 :: ErlangFun
erlps__aeso_abi_tests__1 [_config_0] =
  let
    match_final_1_3 =
      BIF.do_remote_fun_call "Eunit" "erlps__test__1"
        [ErlangAtom "aeso_abi_tests"]
  in
    case match_final_1_3 of
      (ErlangAtom "ok") -> match_final_1_3
      _ -> EXC.badmatch match_final_1_3
erlps__aeso_abi_tests__1 [arg_5] = EXC.function_clause unit
erlps__aeso_abi_tests__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__aeso_aci_tests__1 :: ErlangFun
erlps__aeso_aci_tests__1 [_config_0] =
  let
    match_final_1_3 =
      BIF.do_remote_fun_call "Eunit" "erlps__test__1"
        [ErlangAtom "aeso_aci_tests"]
  in
    case match_final_1_3 of
      (ErlangAtom "ok") -> match_final_1_3
      _ -> EXC.badmatch match_final_1_3
erlps__aeso_aci_tests__1 [arg_5] = EXC.function_clause unit
erlps__aeso_aci_tests__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args