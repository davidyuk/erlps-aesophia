module Aeso.Aci.Tests(erlps__test__0, erlps__simple_aci_test___0,
                      erlps__aci_test___0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__simple_aci_test___0 :: ErlangFun
erlps__simple_aci_test___0 [] =
  let    head_1 = toErl 1
  in let head_3 = toErl 2
  in let head_5 = toErl 3
  in
    flmap
      (\ lc_8 ->
         let    lop_11 = toErl "Test contract "
         in let rop_12 = BIF.erlang__integer_to_list__1 [lc_8]
         in let tup_el_10 = BIF.erlang__op_append [lop_11, rop_12]
         in let
           tup_el_14 =
             ErlangFun 0
               (let
                  lambda_15 [] = erlps__test_contract__1 [lc_8]
                  lambda_15 [] = EXC.function_clause unit
                  lambda_15 args = EXC.badarity (ErlangFun 0 lambda_15) args
                in lambda_15)
         in let lcRet_9 = ErlangTuple [tup_el_10, tup_el_14]
         in ErlangCons lcRet_9 ErlangEmptyList)
      (ErlangCons head_1
         (ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)))
erlps__simple_aci_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__simple_aci_test___0) args

erlps__test_contract__1 :: ErlangFun
erlps__test_contract__1 [n_0] =
  let matchExpr_5 = erlps__test_cases__1 [n_0]
  in
    case matchExpr_5 of
      (ErlangTuple [contract_2, mapaci_3, decaci_4]) ->
        let
          matchExpr_9 =
            BIF.do_remote_fun_call "Aeso.Aci" "erlps__contract_interface__2"
              [ErlangAtom "json", contract_2]
        in
          case matchExpr_9 of
            (ErlangTuple [(ErlangAtom "ok"), json_8]) ->
              let   
                fun_10 =
                  ErlangFun 0
                    (let
                       lambda_11 [] =
                         case json_8 of
                           __x_16 | __x_16 ==
                                      (ErlangCons mapaci_3 ErlangEmptyList) ->
                             ErlangAtom "ok"
                           __v_17 ->
                             let   
                               head_21 =
                                 ErlangTuple
                                   [ErlangAtom "module",
                                    ErlangAtom "aeso_aci_tests"]
                             in let tup_el_27 = toErl 13
                             in let
                               head_25 =
                                 ErlangTuple [ErlangAtom "line", tup_el_27]
                             in let tup_el_31 = toErl "JSON"
                             in let
                               head_29 =
                                 ErlangTuple
                                   [ErlangAtom "expression", tup_el_31]
                             in let
                               head_33 =
                                 ErlangTuple
                                   [ErlangAtom "expected",
                                    ErlangCons mapaci_3 ErlangEmptyList]
                             in let
                               head_37 =
                                 ErlangTuple [ErlangAtom "value", __v_17]
                             in let
                               arg_18 =
                                 ErlangTuple
                                   [ErlangAtom "assertEqual",
                                    ErlangCons head_21
                                      (ErlangCons head_25
                                         (ErlangCons head_29
                                            (ErlangCons head_33
                                               (ErlangCons head_37
                                                  ErlangEmptyList))))]
                             in BIF.erlang__error__1 [arg_18]
                       lambda_11 [] = EXC.function_clause unit
                       lambda_11 args =
                         EXC.badarity (ErlangFun 0 lambda_11) args
                     in lambda_11)
                _ = BIF.erlang__apply__2 [fun_10, ErlangEmptyList]
              in let
                fun_41 =
                  ErlangFun 0
                    (let
                       lambda_42 [] =
                         let    __x_45 = ErlangTuple [ErlangAtom "ok", decaci_4]
                         in let
                           case_46 =
                             BIF.do_remote_fun_call "Aeso.Aci"
                               "erlps__render_aci_json__1" [json_8]
                         in
                           case case_46 of
                             __x_48 | __x_48 == __x_45 -> ErlangAtom "ok"
                             __v_49 ->
                               let   
                                 head_53 =
                                   ErlangTuple
                                     [ErlangAtom "module",
                                      ErlangAtom "aeso_aci_tests"]
                               in let tup_el_59 = toErl 14
                               in let
                                 head_57 =
                                   ErlangTuple [ErlangAtom "line", tup_el_59]
                               in let
                                 tup_el_63 =
                                   toErl "aeso_aci : render_aci_json ( JSON )"
                               in let
                                 head_61 =
                                   ErlangTuple
                                     [ErlangAtom "expression", tup_el_63]
                               in let
                                 head_65 =
                                   ErlangTuple [ErlangAtom "expected", __x_45]
                               in let
                                 head_69 =
                                   ErlangTuple [ErlangAtom "value", __v_49]
                               in let
                                 arg_50 =
                                   ErlangTuple
                                     [ErlangAtom "assertEqual",
                                      ErlangCons head_53
                                        (ErlangCons head_57
                                           (ErlangCons head_61
                                              (ErlangCons head_65
                                                 (ErlangCons head_69
                                                    ErlangEmptyList))))]
                               in BIF.erlang__error__1 [arg_50]
                       lambda_42 [] = EXC.function_clause unit
                       lambda_42 args =
                         EXC.badarity (ErlangFun 0 lambda_42) args
                     in lambda_42)
                _ = BIF.erlang__apply__2 [fun_41, ErlangEmptyList]
              in let
                head_75 = ErlangTuple [ErlangAtom "aci", ErlangAtom "json"]
              in let
                matchExpr_81 =
                  BIF.do_remote_fun_call "Aeso.Compiler" "erlps__from_string__2"
                    [contract_2, ErlangCons head_75 ErlangEmptyList]
              in
                case matchExpr_81 of
                  (ErlangTuple [(ErlangAtom "ok"),
                                (ErlangMap map_79)]) | (DM.Just json2_80) <-
                                                         (Map.lookup
                                                            (ErlangAtom "aci")
                                                            map_79) ->
                    let
                      fun_82 =
                        ErlangFun 0
                          (let
                             lambda_83 [] =
                               case json2_80 of
                                 __x_86 | __x_86 == json_8 -> ErlangAtom "ok"
                                 __v_87 ->
                                   let   
                                     head_91 =
                                       ErlangTuple
                                         [ErlangAtom "module",
                                          ErlangAtom "aeso_aci_tests"]
                                   in let tup_el_97 = toErl 17
                                   in let
                                     head_95 =
                                       ErlangTuple
                                         [ErlangAtom "line", tup_el_97]
                                   in let tup_el_101 = toErl "JSON2"
                                   in let
                                     head_99 =
                                       ErlangTuple
                                         [ErlangAtom "expression", tup_el_101]
                                   in let
                                     head_103 =
                                       ErlangTuple
                                         [ErlangAtom "expected", json_8]
                                   in let
                                     head_107 =
                                       ErlangTuple [ErlangAtom "value", __v_87]
                                   in let
                                     arg_88 =
                                       ErlangTuple
                                         [ErlangAtom "assertEqual",
                                          ErlangCons head_91
                                            (ErlangCons head_95
                                               (ErlangCons head_99
                                                  (ErlangCons head_103
                                                     (ErlangCons head_107
                                                        ErlangEmptyList))))]
                                   in BIF.erlang__error__1 [arg_88]
                             lambda_83 [] = EXC.function_clause unit
                             lambda_83 args =
                               EXC.badarity (ErlangFun 0 lambda_83) args
                           in lambda_83)
                    in BIF.erlang__apply__2 [fun_82, ErlangEmptyList]
                  _ -> EXC.badmatch matchExpr_81
            _ -> EXC.badmatch matchExpr_9
      _ -> EXC.badmatch matchExpr_5
erlps__test_contract__1 [arg_111] = EXC.function_clause unit
erlps__test_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__test_contract__1) args

erlps__test_cases__1 :: ErlangFun
erlps__test_cases__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 1) =
  let   
    contract_1 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "payable contract C =\n  payable stateful entrypoint a(i : int) = i+1\n")
           (toErl 8) 1 BIN.Big)
  in let
    val_9 =
      ErlangBinary (BIN.fromInts (toErl "C") (toErl 8) 1 BIN.Big)
  in let
    val_20 =
      ErlangBinary (BIN.fromInts (toErl "a") (toErl 8) 1 BIN.Big)
  in let
    val_25 =
      ErlangBinary (BIN.fromInts (toErl "i") (toErl 8) 1 BIN.Big)
  in let
    val_26 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_22 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_25,
            DT.Tuple (ErlangAtom "type") val_26])
  in let
    val_28 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_14 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_20,
            DT.Tuple (ErlangAtom "arguments")
              (ErlangCons head_22 ErlangEmptyList),
            DT.Tuple (ErlangAtom "returns") val_28,
            DT.Tuple (ErlangAtom "stateful") (ErlangAtom "true"),
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "true")])
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_9,
            DT.Tuple (ErlangAtom "type_defs") ErlangEmptyList,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "true"),
            DT.Tuple (ErlangAtom "kind") (ErlangAtom "contract_main"),
            DT.Tuple (ErlangAtom "functions")
              (ErlangCons head_14 ErlangEmptyList)])
  in let
    mapaci_32 =
      ErlangMap (Map.singleton (ErlangAtom "contract") val_3)
  in let
    decaci_33 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "payable main contract C =\n  payable entrypoint a : (int) => int\n")
           (toErl 8) 1 BIN.Big)
  in ErlangTuple [contract_1, mapaci_32, decaci_33]
erlps__test_cases__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 2) =
  let   
    contract_1 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "main contract C =\n  type allan = int\n  entrypoint a(i : allan) = i+1\n")
           (toErl 8) 1 BIN.Big)
  in let
    val_9 =
      ErlangBinary (BIN.fromInts (toErl "C") (toErl 8) 1 BIN.Big)
  in let
    val_17 =
      ErlangBinary (BIN.fromInts (toErl "allan") (toErl 8) 1 BIN.Big)
  in let
    val_18 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_13 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_17,
            DT.Tuple (ErlangAtom "typedef") val_18,
            DT.Tuple (ErlangAtom "vars") ErlangEmptyList])
  in let
    val_32 =
      ErlangBinary (BIN.fromInts (toErl "i") (toErl 8) 1 BIN.Big)
  in let
    val_33 =
      ErlangBinary (BIN.fromInts (toErl "C.allan") (toErl 8) 1 BIN.Big)
  in let
    head_29 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_32,
            DT.Tuple (ErlangAtom "type") val_33])
  in let
    val_35 =
      ErlangBinary (BIN.fromInts (toErl "a") (toErl 8) 1 BIN.Big)
  in let
    val_36 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_22 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "arguments")
              (ErlangCons head_29 ErlangEmptyList),
            DT.Tuple (ErlangAtom "name") val_35,
            DT.Tuple (ErlangAtom "returns") val_36,
            DT.Tuple (ErlangAtom "stateful") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false")])
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_9,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "kind") (ErlangAtom "contract_main"),
            DT.Tuple (ErlangAtom "type_defs")
              (ErlangCons head_13 ErlangEmptyList),
            DT.Tuple (ErlangAtom "functions")
              (ErlangCons head_22 ErlangEmptyList)])
  in let
    mapaci_40 =
      ErlangMap (Map.singleton (ErlangAtom "contract") val_3)
  in let
    decaci_41 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "main contract C =\n  type allan = int\n  entrypoint a : (C.allan) => int\n")
           (toErl 8) 1 BIN.Big)
  in ErlangTuple [contract_1, mapaci_40, decaci_41]
erlps__test_cases__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 3) =
  let   
    contract_1 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "main contract C =\n  type state = unit\n  datatype event = SingleEventDefined\n  datatype bert(\'a) = Bin(\'a)\n  entrypoint a(i : bert(string)) = 1\n")
           (toErl 8) 1 BIN.Big)
  in let
    val_22 =
      ErlangBinary (BIN.fromInts (toErl "i") (toErl 8) 1 BIN.Big)
  in let
    key_24 =
      ErlangBinary (BIN.fromInts (toErl "C.bert") (toErl 8) 1 BIN.Big)
  in let
    head_26 =
      ErlangBinary (BIN.fromInts (toErl "string") (toErl 8) 1 BIN.Big)
  in let
    val_23 =
      ErlangMap
        (Map.singleton key_24 (ErlangCons head_26 ErlangEmptyList))
  in let
    head_19 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_22,
            DT.Tuple (ErlangAtom "type") val_23])
  in let
    val_29 =
      ErlangBinary (BIN.fromInts (toErl "a") (toErl 8) 1 BIN.Big)
  in let
    val_30 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_12 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "arguments")
              (ErlangCons head_19 ErlangEmptyList),
            DT.Tuple (ErlangAtom "name") val_29,
            DT.Tuple (ErlangAtom "returns") val_30,
            DT.Tuple (ErlangAtom "stateful") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false")])
  in let
    val_34 =
      ErlangBinary (BIN.fromInts (toErl "C") (toErl 8) 1 BIN.Big)
  in let
    key_41 =
      ErlangBinary
        (BIN.fromInts (toErl "SingleEventDefined") (toErl 8) 1 BIN.Big)
  in let head_40 = ErlangMap (Map.singleton key_41 ErlangEmptyList)
  in let
    val_37 =
      ErlangMap
        (Map.singleton (ErlangAtom "variant")
           (ErlangCons head_40 ErlangEmptyList))
  in let
    val_44 =
      ErlangBinary (BIN.fromInts (toErl "unit") (toErl 8) 1 BIN.Big)
  in let
    val_50 =
      ErlangBinary (BIN.fromInts (toErl "bert") (toErl 8) 1 BIN.Big)
  in let
    key_55 =
      ErlangBinary (BIN.fromInts (toErl "Bin") (toErl 8) 1 BIN.Big)
  in let
    head_57 =
      ErlangBinary (BIN.fromInts (toErl "\'a") (toErl 8) 1 BIN.Big)
  in let
    head_54 =
      ErlangMap
        (Map.singleton key_55 (ErlangCons head_57 ErlangEmptyList))
  in let
    val_51 =
      ErlangMap
        (Map.singleton (ErlangAtom "variant")
           (ErlangCons head_54 ErlangEmptyList))
  in let
    val_63 =
      ErlangBinary (BIN.fromInts (toErl "\'a") (toErl 8) 1 BIN.Big)
  in let
    head_61 = ErlangMap (Map.singleton (ErlangAtom "name") val_63)
  in let
    head_46 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_50,
            DT.Tuple (ErlangAtom "typedef") val_51,
            DT.Tuple (ErlangAtom "vars")
              (ErlangCons head_61 ErlangEmptyList)])
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "functions")
              (ErlangCons head_12 ErlangEmptyList),
            DT.Tuple (ErlangAtom "name") val_34,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "kind") (ErlangAtom "contract_main"),
            DT.Tuple (ErlangAtom "event") val_37,
            DT.Tuple (ErlangAtom "state") val_44,
            DT.Tuple (ErlangAtom "type_defs")
              (ErlangCons head_46 ErlangEmptyList)])
  in let
    mapaci_66 =
      ErlangMap (Map.singleton (ErlangAtom "contract") val_3)
  in let
    decaci_67 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "main contract C =\n  type state = unit\n  datatype event = SingleEventDefined\n  datatype bert(\'a) = Bin(\'a)\n  entrypoint a : (C.bert(string)) => int\n")
           (toErl 8) 1 BIN.Big)
  in ErlangTuple [contract_1, mapaci_66, decaci_67]
erlps__test_cases__1 [arg_71] = EXC.function_clause unit
erlps__test_cases__1 args =
  EXC.badarity (ErlangFun 1 erlps__test_cases__1) args

erlps__aci_test___0 :: ErlangFun
erlps__aci_test___0 [] =
  let lcSrc_0 = erlps__all_contracts__0 []
  in
    flmap
      (\ lc_2 ->
         let    lop_5 = toErl "Testing ACI generation for "
         in let tup_el_4 = BIF.erlang__op_append [lop_5, lc_2]
         in let
           tup_el_7 =
             ErlangFun 0
               (let
                  lambda_8 [] = erlps__aci_test_contract__1 [lc_2]
                  lambda_8 [] = EXC.function_clause unit
                  lambda_8 args = EXC.badarity (ErlangFun 0 lambda_8) args
                in lambda_8)
         in let lcRet_3 = ErlangTuple [tup_el_4, tup_el_7]
         in ErlangCons lcRet_3 ErlangEmptyList)
      lcSrc_0
erlps__aci_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__aci_test___0) args

erlps__all_contracts__0 :: ErlangFun
erlps__all_contracts__0 [] =
  BIF.do_remote_fun_call "Aeso.Compiler.Tests"
    "erlps__compilable_contracts__0" []
erlps__all_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__all_contracts__0) args

erlps__aci_test_contract__1 :: ErlangFun
erlps__aci_test_contract__1 [name_0] =
  let   
    string_2 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__read_contract__1" [name_0]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeso.Compiler.Tests"
        "erlps__debug_mode_contracts__0" []
  in let case_4 = BIF.lists__member__2 [name_0, arg_6]
  in let
    lop_3 =
      case case_4 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "debug_mode") ErlangEmptyList
        (ErlangAtom "false") -> ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in let
    head_15 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__contract_path__0" []
  in let
    tup_el_12 =
      ErlangTuple
        [ErlangAtom "file_system", ErlangCons head_15 ErlangEmptyList]
  in let head_10 = ErlangTuple [ErlangAtom "include", tup_el_12]
  in let
    opts_18 =
      BIF.erlang__op_append [lop_3, ErlangCons head_10 ErlangEmptyList]
  in let
    case_19 =
      BIF.do_remote_fun_call "Aeso.Aci" "erlps__contract_interface__3"
        [ErlangAtom "json", string_2, opts_18]
  in let
    json_28 =
      case case_19 of
        (ErlangTuple [(ErlangAtom "ok"), j_23]) -> j_23
        (ErlangTuple [(ErlangAtom "error"), errorstringj_24]) | isEBinary
                                                                  errorstringj_24 ->
          BIF.erlang__error__1 [errorstringj_24]
        (ErlangTuple [(ErlangAtom "error"), errorj_26]) ->
          BIF.do_remote_fun_call "Aeso.Compiler.Tests"
            "erlps__print_and_throw__1" [errorj_26]
        something_else -> EXC.case_clause something_else
  in let
    head_32 = ErlangTuple [ErlangAtom "aci", ErlangAtom "json"]
  in let
    head_36 = ErlangTuple [ErlangAtom "backend", ErlangAtom "fate"]
  in let
    case_29 =
      BIF.do_remote_fun_call "Aeso.Compiler" "erlps__from_string__2"
        [string_2, ErlangCons head_32 (ErlangCons head_36 opts_18)]
  in
    case case_29 of
      (ErlangTuple [(ErlangAtom "ok"),
                    (ErlangMap map_40)]) | (DM.Just json1_41) <-
                                             (Map.lookup (ErlangAtom "aci")
                                                map_40) ->
        let   
          fun_42 =
            ErlangFun 0
              (let
                 lambda_43 [] =
                   case json1_41 of
                     __x_46 | __x_46 == json_28 -> ErlangAtom "ok"
                     __v_47 ->
                       let   
                         head_51 =
                           ErlangTuple
                             [ErlangAtom "module", ErlangAtom "aeso_aci_tests"]
                       in let tup_el_57 = toErl 113
                       in let
                         head_55 = ErlangTuple [ErlangAtom "line", tup_el_57]
                       in let tup_el_61 = toErl "JSON1"
                       in let
                         head_59 =
                           ErlangTuple [ErlangAtom "expression", tup_el_61]
                       in let
                         head_63 = ErlangTuple [ErlangAtom "expected", json_28]
                       in let head_67 = ErlangTuple [ErlangAtom "value", __v_47]
                       in let
                         arg_48 =
                           ErlangTuple
                             [ErlangAtom "assertEqual",
                              ErlangCons head_51
                                (ErlangCons head_55
                                   (ErlangCons head_59
                                      (ErlangCons head_63
                                         (ErlangCons head_67
                                            ErlangEmptyList))))]
                       in BIF.erlang__error__1 [arg_48]
                 lambda_43 [] = EXC.function_clause unit
                 lambda_43 args = EXC.badarity (ErlangFun 0 lambda_43) args
               in lambda_43)
          _ = BIF.erlang__apply__2 [fun_42, ErlangEmptyList]
        in let arg_71 = toErl "JSON:\n~p\n"
        in let
          _ =
            BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
              [arg_71, ErlangCons json_28 ErlangEmptyList]
        in let
          matchExpr_77 =
            BIF.do_remote_fun_call "Aeso.Aci" "erlps__render_aci_json__1"
              [json_28]
        in
          case matchExpr_77 of
            (ErlangTuple [(ErlangAtom "ok"), contractstub_76]) ->
              let    arg_78 = toErl "STUB:\n~s\n"
              in let
                _ =
                  BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                    [arg_78, ErlangCons contractstub_76 ErlangEmptyList]
              in let head_84 = ErlangTuple [ErlangAtom "src_file", name_0]
              in let
                _ =
                  erlps__check_stub__2
                    [contractstub_76, ErlangCons head_84 ErlangEmptyList]
              in ErlangAtom "ok"
            _ -> EXC.badmatch matchExpr_77
      (ErlangTuple [(ErlangAtom "error"), errorstring_88]) | isEBinary
                                                               errorstring_88 ->
        BIF.erlang__error__1 [errorstring_88]
      (ErlangTuple [(ErlangAtom "error"), error_90]) ->
        BIF.do_remote_fun_call "Aeso.Compiler.Tests"
          "erlps__print_and_throw__1" [error_90]
      something_else -> EXC.case_clause something_else
erlps__aci_test_contract__1 [arg_92] = EXC.function_clause unit
erlps__aci_test_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__aci_test_contract__1) args

erlps__check_stub__2 :: ErlangFun
erlps__check_stub__2 [stub_0, options_1] =
  EXC.tryOfCatch
    (\ _ ->
       let arg_2 = BIF.erlang__binary_to_list__1 [stub_0]
       in
         BIF.do_remote_fun_call "Aeso.Parser" "erlps__string__2"
           [arg_2, options_1])
    (\ of_5 ->
       EXC.tryCatch
         (\ _ ->
            BIF.do_remote_fun_call "Aeso.Ast.Infer.Types" "erlps__infer__2"
              [of_5, ErlangEmptyList])
         (\ ex_12 ->
            case ex_12 of
              (ErlangTuple [(ErlangAtom "throw"),
                            (ErlangTuple [(ErlangAtom "type_errors"), te_14]),
                            _]) ->
                let    arg_15 = toErl "Type error:\n~s\n"
                in let
                  _ =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_15, ErlangCons te_14 ErlangEmptyList]
                in BIF.erlang__error__1 [te_14]
              (ErlangTuple [_, r_20, _]) ->
                let    arg_21 = toErl "Error: ~p\n"
                in let
                  _ =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_21, ErlangCons r_20 ErlangEmptyList]
                in BIF.erlang__error__1 [r_20]
              ex_13 -> EXC.raise ex_13))
    (\ ex_6 ->
       case ex_6 of
         (ErlangTuple [(ErlangAtom "throw"),
                       (ErlangTuple [(ErlangAtom "error"), errs_26]), _]) ->
           let   
             matchExpr_36 =
               flmap
                 (\ lc_29 ->
                    let    arg_31 = toErl "~s\n"
                    in let
                      head_33 =
                        BIF.do_remote_fun_call "Aeso.Errors" "erlps__pp__1"
                          [lc_29]
                    in let
                      lcRet_30 =
                        BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                          [arg_31, ErlangCons head_33 ErlangEmptyList]
                    in ErlangCons lcRet_30 ErlangEmptyList)
                 errs_26
           in let arg_37 = ErlangTuple [ErlangAtom "parse_errors", errs_26]
           in BIF.erlang__error__1 [arg_37]
         ex_7 -> EXC.raise ex_7)
erlps__check_stub__2 [arg_40, arg_41] = EXC.function_clause unit
erlps__check_stub__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_stub__2) args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeso_aci_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 erlps__test__0) args