module Aeso.Aci.Tests(erlps__test__0, erlps__simple_aci_test___0,
                      erlps__aci_test___0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__simple_aci_test___0 :: ErlangFun
erlps__simple_aci_test___0 [] =
  let    head_1 = toErl 1
  in let head_3 = toErl 2
  in let head_5 = toErl 3
  in
    flmap
      (\ lc_8 ->
         let    lop_11 = toErl "Test contract "
         in let rop_12 = BIF.erlang__integer_to_list__1 [lc_8]
         in let tup_el_10 = BIF.erlang__op_append [lop_11, rop_12]
         in let
           tup_el_14 =
             ErlangFun 0
               (let
                  lambda_15 [] = erlps__test_contract__1 [lc_8]
                  lambda_15 [] = EXC.function_clause unit
                  lambda_15 args = EXC.badarity (ErlangFun 0 lambda_15) args
                in lambda_15)
         in let lcRet_9 = ErlangTuple [tup_el_10, tup_el_14]
         in ErlangCons lcRet_9 ErlangEmptyList)
      (ErlangCons head_1
         (ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)))
erlps__simple_aci_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__simple_aci_test___0) args

erlps__test_contract__1 :: ErlangFun
erlps__test_contract__1 [n_0] =
  let matchExpr_5 = erlps__test_cases__1 [n_0]
  in
    case matchExpr_5 of
      (ErlangTuple [contract_2, mapaci_3, decaci_4]) ->
        let
          matchExpr_9 =
            BIF.do_remote_fun_call "Aeso.Aci" "erlps__contract_interface__2"
              [ErlangAtom "json", contract_2]
        in
          case matchExpr_9 of
            (ErlangTuple [(ErlangAtom "ok"), json_8]) ->
              let   
                fun_10 =
                  ErlangFun 0
                    (let
                       lambda_11 [] =
                         case json_8 of
                           __x_16 | __x_16 ==
                                      (ErlangCons mapaci_3 ErlangEmptyList) ->
                             ErlangAtom "ok"
                           __v_17 ->
                             let   
                               head_21 =
                                 ErlangTuple
                                   [ErlangAtom "module",
                                    ErlangAtom "aeso_aci_tests"]
                             in let tup_el_27 = toErl 13
                             in let
                               head_25 =
                                 ErlangTuple [ErlangAtom "line", tup_el_27]
                             in let tup_el_31 = toErl "JSON"
                             in let
                               head_29 =
                                 ErlangTuple
                                   [ErlangAtom "expression", tup_el_31]
                             in let
                               head_33 =
                                 ErlangTuple
                                   [ErlangAtom "expected",
                                    ErlangCons mapaci_3 ErlangEmptyList]
                             in let
                               head_37 =
                                 ErlangTuple [ErlangAtom "value", __v_17]
                             in let
                               arg_18 =
                                 ErlangTuple
                                   [ErlangAtom "assertEqual",
                                    ErlangCons head_21
                                      (ErlangCons head_25
                                         (ErlangCons head_29
                                            (ErlangCons head_33
                                               (ErlangCons head_37
                                                  ErlangEmptyList))))]
                             in BIF.erlang__error__1 [arg_18]
                       lambda_11 [] = EXC.function_clause unit
                       lambda_11 args =
                         EXC.badarity (ErlangFun 0 lambda_11) args
                     in lambda_11)
                _ = BIF.erlang__apply__2 [fun_10, ErlangEmptyList]
              in let
                fun_41 =
                  ErlangFun 0
                    (let
                       lambda_42 [] =
                         let    __x_45 = ErlangTuple [ErlangAtom "ok", decaci_4]
                         in let
                           case_46 =
                             BIF.do_remote_fun_call "Aeso.Aci"
                               "erlps__render_aci_json__1" [json_8]
                         in
                           case case_46 of
                             __x_48 | __x_48 == __x_45 -> ErlangAtom "ok"
                             __v_49 ->
                               let   
                                 head_53 =
                                   ErlangTuple
                                     [ErlangAtom "module",
                                      ErlangAtom "aeso_aci_tests"]
                               in let tup_el_59 = toErl 14
                               in let
                                 head_57 =
                                   ErlangTuple [ErlangAtom "line", tup_el_59]
                               in let
                                 tup_el_63 =
                                   toErl "aeso_aci : render_aci_json ( JSON )"
                               in let
                                 head_61 =
                                   ErlangTuple
                                     [ErlangAtom "expression", tup_el_63]
                               in let
                                 head_65 =
                                   ErlangTuple [ErlangAtom "expected", __x_45]
                               in let
                                 head_69 =
                                   ErlangTuple [ErlangAtom "value", __v_49]
                               in let
                                 arg_50 =
                                   ErlangTuple
                                     [ErlangAtom "assertEqual",
                                      ErlangCons head_53
                                        (ErlangCons head_57
                                           (ErlangCons head_61
                                              (ErlangCons head_65
                                                 (ErlangCons head_69
                                                    ErlangEmptyList))))]
                               in BIF.erlang__error__1 [arg_50]
                       lambda_42 [] = EXC.function_clause unit
                       lambda_42 args =
                         EXC.badarity (ErlangFun 0 lambda_42) args
                     in lambda_42)
                _ = BIF.erlang__apply__2 [fun_41, ErlangEmptyList]
              in let
                head_75 = ErlangTuple [ErlangAtom "aci", ErlangAtom "json"]
              in let
                matchExpr_81 =
                  BIF.do_remote_fun_call "Aeso.Compiler" "erlps__from_string__2"
                    [contract_2, ErlangCons head_75 ErlangEmptyList]
              in
                case matchExpr_81 of
                  (ErlangTuple [(ErlangAtom "ok"),
                                (ErlangMap map_79)]) | (DM.Just json2_80) <-
                                                         (Map.lookup
                                                            (ErlangAtom "aci")
                                                            map_79) ->
                    let
                      fun_82 =
                        ErlangFun 0
                          (let
                             lambda_83 [] =
                               case json2_80 of
                                 __x_86 | __x_86 == json_8 -> ErlangAtom "ok"
                                 __v_87 ->
                                   let   
                                     head_91 =
                                       ErlangTuple
                                         [ErlangAtom "module",
                                          ErlangAtom "aeso_aci_tests"]
                                   in let tup_el_97 = toErl 17
                                   in let
                                     head_95 =
                                       ErlangTuple
                                         [ErlangAtom "line", tup_el_97]
                                   in let tup_el_101 = toErl "JSON2"
                                   in let
                                     head_99 =
                                       ErlangTuple
                                         [ErlangAtom "expression", tup_el_101]
                                   in let
                                     head_103 =
                                       ErlangTuple
                                         [ErlangAtom "expected", json_8]
                                   in let
                                     head_107 =
                                       ErlangTuple [ErlangAtom "value", __v_87]
                                   in let
                                     arg_88 =
                                       ErlangTuple
                                         [ErlangAtom "assertEqual",
                                          ErlangCons head_91
                                            (ErlangCons head_95
                                               (ErlangCons head_99
                                                  (ErlangCons head_103
                                                     (ErlangCons head_107
                                                        ErlangEmptyList))))]
                                   in BIF.erlang__error__1 [arg_88]
                             lambda_83 [] = EXC.function_clause unit
                             lambda_83 args =
                               EXC.badarity (ErlangFun 0 lambda_83) args
                           in lambda_83)
                    in BIF.erlang__apply__2 [fun_82, ErlangEmptyList]
                  _ -> EXC.badmatch matchExpr_81
            _ -> EXC.badmatch matchExpr_9
      _ -> EXC.badmatch matchExpr_5
erlps__test_contract__1 [arg_111] = EXC.function_clause unit
erlps__test_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__test_contract__1) args

erlps__test_cases__1 :: ErlangFun
erlps__test_cases__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 1) =
  let   
    contract_1 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "payable contract C =\n  payable stateful entrypoint a(i : int) = i+1\n")
           (toErl 8) 1 BIN.Big)
  in let
    val_8 =
      ErlangBinary (BIN.fromInts (toErl "C") (toErl 8) 1 BIN.Big)
  in let
    val_18 =
      ErlangBinary (BIN.fromInts (toErl "a") (toErl 8) 1 BIN.Big)
  in let
    val_23 =
      ErlangBinary (BIN.fromInts (toErl "i") (toErl 8) 1 BIN.Big)
  in let
    val_24 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_20 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_23,
            DT.Tuple (ErlangAtom "type") val_24])
  in let
    val_26 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_12 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_18,
            DT.Tuple (ErlangAtom "arguments")
              (ErlangCons head_20 ErlangEmptyList),
            DT.Tuple (ErlangAtom "returns") val_26,
            DT.Tuple (ErlangAtom "stateful") (ErlangAtom "true"),
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "true")])
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_8,
            DT.Tuple (ErlangAtom "type_defs") ErlangEmptyList,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "true"),
            DT.Tuple (ErlangAtom "functions")
              (ErlangCons head_12 ErlangEmptyList)])
  in let
    mapaci_30 =
      ErlangMap (Map.singleton (ErlangAtom "contract") val_3)
  in let
    decaci_31 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "payable contract C =\n  payable entrypoint a : (int) => int\n")
           (toErl 8) 1 BIN.Big)
  in ErlangTuple [contract_1, mapaci_30, decaci_31]
erlps__test_cases__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 2) =
  let   
    contract_1 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "contract C =\n  type allan = int\n  entrypoint a(i : allan) = i+1\n")
           (toErl 8) 1 BIN.Big)
  in let
    val_8 =
      ErlangBinary (BIN.fromInts (toErl "C") (toErl 8) 1 BIN.Big)
  in let
    val_15 =
      ErlangBinary (BIN.fromInts (toErl "allan") (toErl 8) 1 BIN.Big)
  in let
    val_16 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_11 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_15,
            DT.Tuple (ErlangAtom "typedef") val_16,
            DT.Tuple (ErlangAtom "vars") ErlangEmptyList])
  in let
    val_30 =
      ErlangBinary (BIN.fromInts (toErl "i") (toErl 8) 1 BIN.Big)
  in let
    val_31 =
      ErlangBinary (BIN.fromInts (toErl "C.allan") (toErl 8) 1 BIN.Big)
  in let
    head_27 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_30,
            DT.Tuple (ErlangAtom "type") val_31])
  in let
    val_33 =
      ErlangBinary (BIN.fromInts (toErl "a") (toErl 8) 1 BIN.Big)
  in let
    val_34 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_20 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "arguments")
              (ErlangCons head_27 ErlangEmptyList),
            DT.Tuple (ErlangAtom "name") val_33,
            DT.Tuple (ErlangAtom "returns") val_34,
            DT.Tuple (ErlangAtom "stateful") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false")])
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_8,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "type_defs")
              (ErlangCons head_11 ErlangEmptyList),
            DT.Tuple (ErlangAtom "functions")
              (ErlangCons head_20 ErlangEmptyList)])
  in let
    mapaci_38 =
      ErlangMap (Map.singleton (ErlangAtom "contract") val_3)
  in let
    decaci_39 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "contract C =\n  type allan = int\n  entrypoint a : (C.allan) => int\n")
           (toErl 8) 1 BIN.Big)
  in ErlangTuple [contract_1, mapaci_38, decaci_39]
erlps__test_cases__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 3) =
  let   
    contract_1 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "contract C =\n  type state = unit\n  datatype event = SingleEventDefined\n  datatype bert(\'a) = Bin(\'a)\n  entrypoint a(i : bert(string)) = 1\n")
           (toErl 8) 1 BIN.Big)
  in let
    val_21 =
      ErlangBinary (BIN.fromInts (toErl "i") (toErl 8) 1 BIN.Big)
  in let
    key_23 =
      ErlangBinary (BIN.fromInts (toErl "C.bert") (toErl 8) 1 BIN.Big)
  in let
    head_25 =
      ErlangBinary (BIN.fromInts (toErl "string") (toErl 8) 1 BIN.Big)
  in let
    val_22 =
      ErlangMap
        (Map.singleton key_23 (ErlangCons head_25 ErlangEmptyList))
  in let
    head_18 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_21,
            DT.Tuple (ErlangAtom "type") val_22])
  in let
    val_28 =
      ErlangBinary (BIN.fromInts (toErl "a") (toErl 8) 1 BIN.Big)
  in let
    val_29 =
      ErlangBinary (BIN.fromInts (toErl "int") (toErl 8) 1 BIN.Big)
  in let
    head_11 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "arguments")
              (ErlangCons head_18 ErlangEmptyList),
            DT.Tuple (ErlangAtom "name") val_28,
            DT.Tuple (ErlangAtom "returns") val_29,
            DT.Tuple (ErlangAtom "stateful") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false")])
  in let
    val_33 =
      ErlangBinary (BIN.fromInts (toErl "C") (toErl 8) 1 BIN.Big)
  in let
    key_39 =
      ErlangBinary
        (BIN.fromInts (toErl "SingleEventDefined") (toErl 8) 1 BIN.Big)
  in let head_38 = ErlangMap (Map.singleton key_39 ErlangEmptyList)
  in let
    val_35 =
      ErlangMap
        (Map.singleton (ErlangAtom "variant")
           (ErlangCons head_38 ErlangEmptyList))
  in let
    val_42 =
      ErlangBinary (BIN.fromInts (toErl "unit") (toErl 8) 1 BIN.Big)
  in let
    val_48 =
      ErlangBinary (BIN.fromInts (toErl "bert") (toErl 8) 1 BIN.Big)
  in let
    key_53 =
      ErlangBinary (BIN.fromInts (toErl "Bin") (toErl 8) 1 BIN.Big)
  in let
    head_55 =
      ErlangBinary (BIN.fromInts (toErl "\'a") (toErl 8) 1 BIN.Big)
  in let
    head_52 =
      ErlangMap
        (Map.singleton key_53 (ErlangCons head_55 ErlangEmptyList))
  in let
    val_49 =
      ErlangMap
        (Map.singleton (ErlangAtom "variant")
           (ErlangCons head_52 ErlangEmptyList))
  in let
    val_61 =
      ErlangBinary (BIN.fromInts (toErl "\'a") (toErl 8) 1 BIN.Big)
  in let
    head_59 = ErlangMap (Map.singleton (ErlangAtom "name") val_61)
  in let
    head_44 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_48,
            DT.Tuple (ErlangAtom "typedef") val_49,
            DT.Tuple (ErlangAtom "vars")
              (ErlangCons head_59 ErlangEmptyList)])
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "functions")
              (ErlangCons head_11 ErlangEmptyList),
            DT.Tuple (ErlangAtom "name") val_33,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "false"),
            DT.Tuple (ErlangAtom "event") val_35,
            DT.Tuple (ErlangAtom "state") val_42,
            DT.Tuple (ErlangAtom "type_defs")
              (ErlangCons head_44 ErlangEmptyList)])
  in let
    mapaci_64 =
      ErlangMap (Map.singleton (ErlangAtom "contract") val_3)
  in let
    decaci_65 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "contract C =\n  type state = unit\n  datatype event = SingleEventDefined\n  datatype bert(\'a) = Bin(\'a)\n  entrypoint a : (C.bert(string)) => int\n")
           (toErl 8) 1 BIN.Big)
  in ErlangTuple [contract_1, mapaci_64, decaci_65]
erlps__test_cases__1 [arg_69] = EXC.function_clause unit
erlps__test_cases__1 args =
  EXC.badarity (ErlangFun 1 erlps__test_cases__1) args

erlps__aci_test___0 :: ErlangFun
erlps__aci_test___0 [] =
  let lcSrc_0 = erlps__all_contracts__0 []
  in
    flmap
      (\ lc_2 ->
         let    lop_5 = toErl "Testing ACI generation for "
         in let tup_el_4 = BIF.erlang__op_append [lop_5, lc_2]
         in let
           tup_el_7 =
             ErlangFun 0
               (let
                  lambda_8 [] = erlps__aci_test_contract__1 [lc_2]
                  lambda_8 [] = EXC.function_clause unit
                  lambda_8 args = EXC.badarity (ErlangFun 0 lambda_8) args
                in lambda_8)
         in let lcRet_3 = ErlangTuple [tup_el_4, tup_el_7]
         in ErlangCons lcRet_3 ErlangEmptyList)
      lcSrc_0
erlps__aci_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__aci_test___0) args

erlps__all_contracts__0 :: ErlangFun
erlps__all_contracts__0 [] =
  BIF.do_remote_fun_call "Aeso.Compiler.Tests"
    "erlps__compilable_contracts__0" []
erlps__all_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__all_contracts__0) args

erlps__aci_test_contract__1 :: ErlangFun
erlps__aci_test_contract__1 [name_0] =
  let   
    string_2 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__read_contract__1" [name_0]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeso.Compiler.Tests"
        "erlps__debug_mode_contracts__0" []
  in let case_4 = BIF.lists__member__2 [name_0, arg_6]
  in let
    lop_3 =
      case case_4 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "debug_mode") ErlangEmptyList
        (ErlangAtom "false") -> ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in let
    head_15 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__contract_path__0" []
  in let
    tup_el_12 =
      ErlangTuple
        [ErlangAtom "file_system", ErlangCons head_15 ErlangEmptyList]
  in let head_10 = ErlangTuple [ErlangAtom "include", tup_el_12]
  in let
    opts_18 =
      BIF.erlang__op_append [lop_3, ErlangCons head_10 ErlangEmptyList]
  in let
    matchExpr_23 =
      BIF.do_remote_fun_call "Aeso.Aci" "erlps__contract_interface__3"
        [ErlangAtom "json", string_2, opts_18]
  in
    case matchExpr_23 of
      (ErlangTuple [(ErlangAtom "ok"), json_22]) ->
        let   
          head_26 = ErlangTuple [ErlangAtom "aci", ErlangAtom "json"]
        in let
          head_30 = ErlangTuple [ErlangAtom "backend", ErlangAtom "fate"]
        in let
          matchExpr_36 =
            BIF.do_remote_fun_call "Aeso.Compiler" "erlps__from_string__2"
              [string_2, ErlangCons head_26 (ErlangCons head_30 opts_18)]
        in
          case matchExpr_36 of
            (ErlangTuple [(ErlangAtom "ok"),
                          (ErlangMap map_34)]) | (DM.Just json1_35) <-
                                                   (Map.lookup
                                                      (ErlangAtom "aci")
                                                      map_34) ->
              let   
                fun_37 =
                  ErlangFun 0
                    (let
                       lambda_38 [] =
                         case json1_35 of
                           __x_41 | __x_41 == json_22 -> ErlangAtom "ok"
                           __v_42 ->
                             let   
                               head_46 =
                                 ErlangTuple
                                   [ErlangAtom "module",
                                    ErlangAtom "aeso_aci_tests"]
                             in let tup_el_52 = toErl 106
                             in let
                               head_50 =
                                 ErlangTuple [ErlangAtom "line", tup_el_52]
                             in let tup_el_56 = toErl "JSON1"
                             in let
                               head_54 =
                                 ErlangTuple
                                   [ErlangAtom "expression", tup_el_56]
                             in let
                               head_58 =
                                 ErlangTuple [ErlangAtom "expected", json_22]
                             in let
                               head_62 =
                                 ErlangTuple [ErlangAtom "value", __v_42]
                             in let
                               arg_43 =
                                 ErlangTuple
                                   [ErlangAtom "assertEqual",
                                    ErlangCons head_46
                                      (ErlangCons head_50
                                         (ErlangCons head_54
                                            (ErlangCons head_58
                                               (ErlangCons head_62
                                                  ErlangEmptyList))))]
                             in BIF.erlang__error__1 [arg_43]
                       lambda_38 [] = EXC.function_clause unit
                       lambda_38 args =
                         EXC.badarity (ErlangFun 0 lambda_38) args
                     in lambda_38)
                _ = BIF.erlang__apply__2 [fun_37, ErlangEmptyList]
              in let arg_66 = toErl "JSON:\n~p\n"
              in let
                _ =
                  BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                    [arg_66, ErlangCons json_22 ErlangEmptyList]
              in let
                matchExpr_72 =
                  BIF.do_remote_fun_call "Aeso.Aci" "erlps__render_aci_json__1"
                    [json_22]
              in
                case matchExpr_72 of
                  (ErlangTuple [(ErlangAtom "ok"), contractstub_71]) ->
                    let    arg_73 = toErl "STUB:\n~s\n"
                    in let
                      _ =
                        BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                          [arg_73, ErlangCons contractstub_71 ErlangEmptyList]
                    in let head_79 = ErlangTuple [ErlangAtom "src_file", name_0]
                    in let
                      _ =
                        erlps__check_stub__2
                          [contractstub_71, ErlangCons head_79 ErlangEmptyList]
                    in ErlangAtom "ok"
                  _ -> EXC.badmatch matchExpr_72
            _ -> EXC.badmatch matchExpr_36
      _ -> EXC.badmatch matchExpr_23
erlps__aci_test_contract__1 [arg_83] = EXC.function_clause unit
erlps__aci_test_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__aci_test_contract__1) args

erlps__check_stub__2 :: ErlangFun
erlps__check_stub__2 [stub_0, options_1] =
  EXC.tryOfCatch
    (\ _ ->
       let arg_2 = BIF.erlang__binary_to_list__1 [stub_0]
       in
         BIF.do_remote_fun_call "Aeso.Parser" "erlps__string__2"
           [arg_2, options_1])
    (\ of_5 ->
       EXC.tryCatch
         (\ _ ->
            BIF.do_remote_fun_call "Aeso.Ast.Infer.Types" "erlps__infer__2"
              [of_5, ErlangEmptyList])
         (\ ex_12 ->
            case ex_12 of
              (ErlangTuple [(ErlangAtom "throw"),
                            (ErlangTuple [(ErlangAtom "type_errors"), te_14]),
                            _]) ->
                let    arg_15 = toErl "Type error:\n~s\n"
                in let
                  _ =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_15, ErlangCons te_14 ErlangEmptyList]
                in BIF.erlang__error__1 [te_14]
              (ErlangTuple [_, r_20, _]) ->
                let    arg_21 = toErl "Error: ~p\n"
                in let
                  _ =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_21, ErlangCons r_20 ErlangEmptyList]
                in BIF.erlang__error__1 [r_20]
              ex_13 -> EXC.raise ex_13))
    (\ ex_6 ->
       case ex_6 of
         (ErlangTuple [(ErlangAtom "throw"),
                       (ErlangTuple [(ErlangAtom "error"), errs_26]), _]) ->
           let   
             matchExpr_36 =
               flmap
                 (\ lc_29 ->
                    let    arg_31 = toErl "~s\n"
                    in let
                      head_33 =
                        BIF.do_remote_fun_call "Aeso.Errors" "erlps__pp__1"
                          [lc_29]
                    in let
                      lcRet_30 =
                        BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                          [arg_31, ErlangCons head_33 ErlangEmptyList]
                    in ErlangCons lcRet_30 ErlangEmptyList)
                 errs_26
           in let arg_37 = ErlangTuple [ErlangAtom "parse_errors", errs_26]
           in BIF.erlang__error__1 [arg_37]
         ex_7 -> EXC.raise ex_7)
erlps__check_stub__2 [arg_40, arg_41] = EXC.function_clause unit
erlps__check_stub__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_stub__2) args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeso_aci_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 erlps__test__0) args