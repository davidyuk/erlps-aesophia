module Aeso.Calldata.Tests where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__calldata_test___0 :: ErlangFun
erlps__calldata_test___0 [] =
  let lcSrc_0 = erlps__compilable_contracts__0 []
  in
    flmap
      (\ lc_4 ->
         case lc_4 of
           (ErlangTuple [contractname_1, fun_2, args_3]) ->
             let    lop_7 = toErl "Testing "
             in let lop_11 = toErl " contract calling "
             in let rop_10 = BIF.erlang__op_append [lop_11, fun_2]
             in let rop_8 = BIF.erlang__op_append [contractname_1, rop_10]
             in let tup_el_6 = BIF.erlang__op_append [lop_7, rop_8]
             in let
               tup_el_13 =
                 ErlangFun 0
                   (let
                      lambda_14 [] =
                        let   
                          contractstring_16 =
                            BIF.do_remote_fun_call "Aeso.Test.Utils"
                              "erlps__read_contract__1" [contractname_1]
                        in let
                          arg_20 =
                            erlps__not_yet_compilable__1 [ErlangAtom "aevm"]
                        in let
                          op_arg_18 =
                            BIF.lists__member__2 [contractname_1, arg_20]
                        in let case_17 = BIF.erlang__not__1 [op_arg_18]
                        in let
                          aevmexprs_30 =
                            case case_17 of
                              (ErlangAtom "true") ->
                                let
                                  head_26 =
                                    ErlangTuple
                                      [ErlangAtom "backend", ErlangAtom "aevm"]
                                in
                                  erlps__ast_exprs__4
                                    [contractstring_16, fun_2, args_3,
                                     ErlangCons head_26 ErlangEmptyList]
                              (ErlangAtom "false") -> ErlangAtom "undefined"
                              something_else -> EXC.case_clause something_else
                        in let
                          arg_34 =
                            erlps__not_yet_compilable__1 [ErlangAtom "fate"]
                        in let
                          op_arg_32 =
                            BIF.lists__member__2 [contractname_1, arg_34]
                        in let case_31 = BIF.erlang__not__1 [op_arg_32]
                        in let
                          fateexprs_44 =
                            case case_31 of
                              (ErlangAtom "true") ->
                                let
                                  head_40 =
                                    ErlangTuple
                                      [ErlangAtom "backend", ErlangAtom "fate"]
                                in
                                  erlps__ast_exprs__4
                                    [contractstring_16, fun_2, args_3,
                                     ErlangCons head_40 ErlangEmptyList]
                              (ErlangAtom "false") -> ErlangAtom "undefined"
                              something_else -> EXC.case_clause something_else
                        in let
                          parsedexprs_47 = erlps__parse_args__2 [fun_2, args_3]
                        in let
                          cond_48 =
                            BIF.erlang__op_neq
                              [aevmexprs_30, ErlangAtom "undefined"]
                        in let
                          _ =
                            case cond_48 of
                              (ErlangAtom "true") ->
                                let
                                  fun_52 =
                                    ErlangFun 0
                                      (let
                                         lambda_53 [] =
                                           case aevmexprs_30 of
                                             __x_56 | __x_56 ==
                                                        parsedexprs_47 ->
                                               ErlangAtom "ok"
                                             __v_57 ->
                                               let   
                                                 head_61 =
                                                   ErlangTuple
                                                     [ErlangAtom "module",
                                                      ErlangAtom
                                                        "aeso_calldata_tests"]
                                               in let tup_el_67 = toErl 33
                                               in let
                                                 head_65 =
                                                   ErlangTuple
                                                     [ErlangAtom "line",
                                                      tup_el_67]
                                               in let
                                                 tup_el_71 = toErl "AevmExprs"
                                               in let
                                                 head_69 =
                                                   ErlangTuple
                                                     [ErlangAtom "expression",
                                                      tup_el_71]
                                               in let
                                                 head_73 =
                                                   ErlangTuple
                                                     [ErlangAtom "expected",
                                                      parsedexprs_47]
                                               in let
                                                 head_77 =
                                                   ErlangTuple
                                                     [ErlangAtom "value",
                                                      __v_57]
                                               in let
                                                 arg_58 =
                                                   ErlangTuple
                                                     [ErlangAtom "assertEqual",
                                                      ErlangCons head_61
                                                        (ErlangCons head_65
                                                           (ErlangCons head_69
                                                              (ErlangCons
                                                                 head_73
                                                                 (ErlangCons
                                                                    head_77
                                                                    ErlangEmptyList))))]
                                               in BIF.erlang__error__1 [arg_58]
                                         lambda_53 [] = EXC.function_clause unit
                                         lambda_53 args =
                                           EXC.badarity (ErlangFun 0 lambda_53)
                                             args
                                       in lambda_53)
                                  lcRet_51 =
                                    BIF.erlang__apply__2
                                      [fun_52, ErlangEmptyList]
                                in ErlangCons lcRet_51 ErlangEmptyList
                              _ -> ErlangEmptyList
                        in let
                          cond_81 =
                            BIF.erlang__op_neq
                              [fateexprs_44, ErlangAtom "undefined"]
                        in let
                          _ =
                            case cond_81 of
                              (ErlangAtom "true") ->
                                let
                                  fun_85 =
                                    ErlangFun 0
                                      (let
                                         lambda_86 [] =
                                           case fateexprs_44 of
                                             __x_89 | __x_89 ==
                                                        parsedexprs_47 ->
                                               ErlangAtom "ok"
                                             __v_90 ->
                                               let   
                                                 head_94 =
                                                   ErlangTuple
                                                     [ErlangAtom "module",
                                                      ErlangAtom
                                                        "aeso_calldata_tests"]
                                               in let tup_el_100 = toErl 34
                                               in let
                                                 head_98 =
                                                   ErlangTuple
                                                     [ErlangAtom "line",
                                                      tup_el_100]
                                               in let
                                                 tup_el_104 = toErl "FateExprs"
                                               in let
                                                 head_102 =
                                                   ErlangTuple
                                                     [ErlangAtom "expression",
                                                      tup_el_104]
                                               in let
                                                 head_106 =
                                                   ErlangTuple
                                                     [ErlangAtom "expected",
                                                      parsedexprs_47]
                                               in let
                                                 head_110 =
                                                   ErlangTuple
                                                     [ErlangAtom "value",
                                                      __v_90]
                                               in let
                                                 arg_91 =
                                                   ErlangTuple
                                                     [ErlangAtom "assertEqual",
                                                      ErlangCons head_94
                                                        (ErlangCons head_98
                                                           (ErlangCons head_102
                                                              (ErlangCons
                                                                 head_106
                                                                 (ErlangCons
                                                                    head_110
                                                                    ErlangEmptyList))))]
                                               in BIF.erlang__error__1 [arg_91]
                                         lambda_86 [] = EXC.function_clause unit
                                         lambda_86 args =
                                           EXC.badarity (ErlangFun 0 lambda_86)
                                             args
                                       in lambda_86)
                                  lcRet_84 =
                                    BIF.erlang__apply__2
                                      [fun_85, ErlangEmptyList]
                                in ErlangCons lcRet_84 ErlangEmptyList
                              _ -> ErlangEmptyList
                        in ErlangAtom "ok"
                      lambda_14 [] = EXC.function_clause unit
                      lambda_14 args = EXC.badarity (ErlangFun 0 lambda_14) args
                    in lambda_14)
             in let lcRet_5 = ErlangTuple [tup_el_6, tup_el_13]
             in ErlangCons lcRet_5 ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_0
erlps__calldata_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__calldata_test___0) args

erlps__calldata_aci_test___0 :: ErlangFun
erlps__calldata_aci_test___0 [] =
  let lcSrc_0 = erlps__compilable_contracts__0 []
  in
    flmap
      (\ lc_4 ->
         case lc_4 of
           (ErlangTuple [contractname_1, fun_2, args_3]) ->
             let    lop_7 = toErl "Testing "
             in let lop_11 = toErl " contract calling "
             in let rop_10 = BIF.erlang__op_append [lop_11, fun_2]
             in let rop_8 = BIF.erlang__op_append [contractname_1, rop_10]
             in let tup_el_6 = BIF.erlang__op_append [lop_7, rop_8]
             in let
               tup_el_13 =
                 ErlangFun 0
                   (let
                      lambda_14 [] =
                        let   
                          contractstring_16 =
                            BIF.do_remote_fun_call "Aeso.Test.Utils"
                              "erlps__read_contract__1" [contractname_1]
                        in let
                          matchExpr_20 =
                            BIF.do_remote_fun_call "Aeso.Aci"
                              "erlps__contract_interface__2"
                              [ErlangAtom "string", contractstring_16]
                        in
                          case matchExpr_20 of
                            (ErlangTuple [(ErlangAtom "ok"),
                                          contractacibin_19]) ->
                              let   
                                contractaci_22 =
                                  BIF.erlang__binary_to_list__1
                                    [contractacibin_19]
                              in let arg_23 = toErl "ACI:\n~s\n"
                              in let
                                _ =
                                  BIF.do_remote_fun_call "Erlang.Io"
                                    "erlps__format__2"
                                    [arg_23,
                                     ErlangCons contractacibin_19
                                       ErlangEmptyList]
                              in let
                                arg_30 =
                                  erlps__not_yet_compilable__1
                                    [ErlangAtom "aevm"]
                              in let
                                op_arg_28 =
                                  BIF.lists__member__2 [contractname_1, arg_30]
                              in let case_27 = BIF.erlang__not__1 [op_arg_28]
                              in let
                                aevmexprs_40 =
                                  case case_27 of
                                    (ErlangAtom "true") ->
                                      let
                                        head_36 =
                                          ErlangTuple
                                            [ErlangAtom "backend",
                                             ErlangAtom "aevm"]
                                      in
                                        erlps__ast_exprs__4
                                          [contractaci_22, fun_2, args_3,
                                           ErlangCons head_36 ErlangEmptyList]
                                    (ErlangAtom "false") ->
                                      ErlangAtom "undefined"
                                    something_else ->
                                      EXC.case_clause something_else
                              in let
                                arg_44 =
                                  erlps__not_yet_compilable__1
                                    [ErlangAtom "fate"]
                              in let
                                op_arg_42 =
                                  BIF.lists__member__2 [contractname_1, arg_44]
                              in let case_41 = BIF.erlang__not__1 [op_arg_42]
                              in let
                                fateexprs_54 =
                                  case case_41 of
                                    (ErlangAtom "true") ->
                                      let
                                        head_50 =
                                          ErlangTuple
                                            [ErlangAtom "backend",
                                             ErlangAtom "fate"]
                                      in
                                        erlps__ast_exprs__4
                                          [contractaci_22, fun_2, args_3,
                                           ErlangCons head_50 ErlangEmptyList]
                                    (ErlangAtom "false") ->
                                      ErlangAtom "undefined"
                                    something_else ->
                                      EXC.case_clause something_else
                              in let
                                parsedexprs_57 =
                                  erlps__parse_args__2 [fun_2, args_3]
                              in let
                                cond_58 =
                                  BIF.erlang__op_neq
                                    [aevmexprs_40, ErlangAtom "undefined"]
                              in let
                                _ =
                                  case cond_58 of
                                    (ErlangAtom "true") ->
                                      let
                                        fun_62 =
                                          ErlangFun 0
                                            (let
                                               lambda_63 [] =
                                                 case aevmexprs_40 of
                                                   __x_66 | __x_66 ==
                                                              parsedexprs_57 ->
                                                     ErlangAtom "ok"
                                                   __v_67 ->
                                                     let   
                                                       head_71 =
                                                         ErlangTuple
                                                           [ErlangAtom "module",
                                                            ErlangAtom
                                                              "aeso_calldata_tests"]
                                                     in let tup_el_77 = toErl 56
                                                     in let
                                                       head_75 =
                                                         ErlangTuple
                                                           [ErlangAtom "line",
                                                            tup_el_77]
                                                     in let
                                                       tup_el_81 =
                                                         toErl "AevmExprs"
                                                     in let
                                                       head_79 =
                                                         ErlangTuple
                                                           [ErlangAtom
                                                              "expression",
                                                            tup_el_81]
                                                     in let
                                                       head_83 =
                                                         ErlangTuple
                                                           [ErlangAtom
                                                              "expected",
                                                            parsedexprs_57]
                                                     in let
                                                       head_87 =
                                                         ErlangTuple
                                                           [ErlangAtom "value",
                                                            __v_67]
                                                     in let
                                                       arg_68 =
                                                         ErlangTuple
                                                           [ErlangAtom
                                                              "assertEqual",
                                                            ErlangCons head_71
                                                              (ErlangCons
                                                                 head_75
                                                                 (ErlangCons
                                                                    head_79
                                                                    (ErlangCons
                                                                       head_83
                                                                       (ErlangCons
                                                                          head_87
                                                                          ErlangEmptyList))))]
                                                     in
                                                       BIF.erlang__error__1
                                                         [arg_68]
                                               lambda_63 [] =
                                                 EXC.function_clause unit
                                               lambda_63 args =
                                                 EXC.badarity
                                                   (ErlangFun 0 lambda_63) args
                                             in lambda_63)
                                        lcRet_61 =
                                          BIF.erlang__apply__2
                                            [fun_62, ErlangEmptyList]
                                      in ErlangCons lcRet_61 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              in let
                                cond_91 =
                                  BIF.erlang__op_neq
                                    [fateexprs_54, ErlangAtom "undefined"]
                              in let
                                _ =
                                  case cond_91 of
                                    (ErlangAtom "true") ->
                                      let
                                        fun_95 =
                                          ErlangFun 0
                                            (let
                                               lambda_96 [] =
                                                 case fateexprs_54 of
                                                   __x_99 | __x_99 ==
                                                              parsedexprs_57 ->
                                                     ErlangAtom "ok"
                                                   __v_100 ->
                                                     let   
                                                       head_104 =
                                                         ErlangTuple
                                                           [ErlangAtom "module",
                                                            ErlangAtom
                                                              "aeso_calldata_tests"]
                                                     in let
                                                       tup_el_110 = toErl 57
                                                     in let
                                                       head_108 =
                                                         ErlangTuple
                                                           [ErlangAtom "line",
                                                            tup_el_110]
                                                     in let
                                                       tup_el_114 =
                                                         toErl "FateExprs"
                                                     in let
                                                       head_112 =
                                                         ErlangTuple
                                                           [ErlangAtom
                                                              "expression",
                                                            tup_el_114]
                                                     in let
                                                       head_116 =
                                                         ErlangTuple
                                                           [ErlangAtom
                                                              "expected",
                                                            parsedexprs_57]
                                                     in let
                                                       head_120 =
                                                         ErlangTuple
                                                           [ErlangAtom "value",
                                                            __v_100]
                                                     in let
                                                       arg_101 =
                                                         ErlangTuple
                                                           [ErlangAtom
                                                              "assertEqual",
                                                            ErlangCons head_104
                                                              (ErlangCons
                                                                 head_108
                                                                 (ErlangCons
                                                                    head_112
                                                                    (ErlangCons
                                                                       head_116
                                                                       (ErlangCons
                                                                          head_120
                                                                          ErlangEmptyList))))]
                                                     in
                                                       BIF.erlang__error__1
                                                         [arg_101]
                                               lambda_96 [] =
                                                 EXC.function_clause unit
                                               lambda_96 args =
                                                 EXC.badarity
                                                   (ErlangFun 0 lambda_96) args
                                             in lambda_96)
                                        lcRet_94 =
                                          BIF.erlang__apply__2
                                            [fun_95, ErlangEmptyList]
                                      in ErlangCons lcRet_94 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              in ErlangAtom "ok"
                            _ -> EXC.badmatch matchExpr_20
                      lambda_14 [] = EXC.function_clause unit
                      lambda_14 args = EXC.badarity (ErlangFun 0 lambda_14) args
                    in lambda_14)
             in let lcRet_5 = ErlangTuple [tup_el_6, tup_el_13]
             in ErlangCons lcRet_5 ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_0
erlps__calldata_aci_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__calldata_aci_test___0) args

erlps__parse_args__2 :: ErlangFun
erlps__parse_args__2 [fun_0, args_1] =
  let    lop_3 = toErl "contract Temp = function foo() = "
  in let lop_7 = toErl "("
  in let arg_11 = toErl ", "
  in let
    lop_9 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [args_1, arg_11]
  in let rop_12 = toErl ")"
  in let rop_8 = BIF.erlang__op_append [lop_9, rop_12]
  in let rop_6 = BIF.erlang__op_append [lop_7, rop_8]
  in let rop_4 = BIF.erlang__op_append [fun_0, rop_6]
  in let arg_2 = BIF.erlang__op_append [lop_3, rop_4]
  in let
    matchExpr_14 =
      BIF.do_remote_fun_call "Aeso.Parser" "erlps__string__1" [arg_2]
  in
    case matchExpr_14 of
      (ErlangCons (ErlangTuple [(ErlangAtom "contract"), _, _,
                                (ErlangCons (ErlangTuple [(ErlangAtom "letfun"),
                                                          _, _, _, _,
                                                          (ErlangTuple [(ErlangAtom "app"),
                                                                        _, _,
                                                                        ast_13])]) (ErlangEmptyList))]) (ErlangEmptyList)) ->
        erlps__strip_ann__1 [ast_13]
      _ -> EXC.badmatch matchExpr_14
erlps__parse_args__2 [arg_16, arg_17] = EXC.function_clause unit
erlps__parse_args__2 args =
  EXC.badarity (ErlangFun 2 erlps__parse_args__2) args

erlps__strip_ann__1 :: ErlangFun
erlps__strip_ann__1 [t_0] | isETuple t_0 =
  let    arg_2 = toErl 2
  in let
    arg_1 = BIF.erlang__setelement__3 [arg_2, t_0, ErlangEmptyList]
  in erlps__strip_ann1__1 [arg_1]
erlps__strip_ann__1 [x_0] = erlps__strip_ann1__1 [x_0]
erlps__strip_ann__1 [arg_2] = EXC.function_clause unit
erlps__strip_ann__1 args =
  EXC.badarity (ErlangFun 1 erlps__strip_ann__1) args

erlps__strip_ann1__1 :: ErlangFun
erlps__strip_ann1__1 [(ErlangTuple [(ErlangAtom "map"),
                                    (ErlangEmptyList), kvs_0])]
  =
  let
    tup_el_3 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [k_5, v_6]) ->
               let    tup_el_9 = erlps__strip_ann__1 [k_5]
               in let tup_el_11 = erlps__strip_ann__1 [v_6]
               in let lcRet_8 = ErlangTuple [tup_el_9, tup_el_11]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        kvs_0
  in ErlangTuple [ErlangAtom "map", ErlangEmptyList, tup_el_3]
erlps__strip_ann1__1 [t_0] | isETuple t_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [t_0]
  in let arg_1 = erlps__strip_ann1__1 [arg_2]
  in BIF.erlang__list_to_tuple__1 [arg_1]
erlps__strip_ann1__1 [l_0] | isEList l_0 =
  let arg_1 = ErlangFun 1 erlps__strip_ann__1
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_1, l_0]
erlps__strip_ann1__1 [x_0] = x_0
erlps__strip_ann1__1 [arg_1] = EXC.function_clause unit
erlps__strip_ann1__1 args =
  EXC.badarity (ErlangFun 1 erlps__strip_ann1__1) args

erlps__ast_exprs__4 :: ErlangFun
erlps__ast_exprs__4 [contractstring_0, fun_1, args_2, opts_3] =
  let
    matchExpr_22 =
      EXC.tryCatch
        (\ _ ->
           BIF.do_remote_fun_call "Aeso.Compiler"
             "erlps__create_calldata__4"
             [contractstring_0, fun_1, args_2, opts_3])
        (\ ex_9 ->
           case ex_9 of
             (ErlangTuple [(ErlangAtom "throw"), payload_11, _]) -> payload_11
             (ErlangTuple [(ErlangAtom "error"), payload_12, stack_13]) ->
               let tup_el_15 = ErlangTuple [payload_12, stack_13]
               in ErlangTuple [ErlangAtom "EXIT", tup_el_15]
             (ErlangTuple [(ErlangAtom "exit"), payload_18, _]) ->
               ErlangTuple [ErlangAtom "EXIT", payload_18]
             ex_10 -> EXC.raise ex_10)
  in
    case matchExpr_22 of
      (ErlangTuple [(ErlangAtom "ok"), data_21]) ->
        let
          matchExpr_42 =
            EXC.tryCatch
              (\ _ ->
                 BIF.do_remote_fun_call "Aeso.Compiler"
                   "erlps__decode_calldata__4"
                   [contractstring_0, fun_1, data_21, opts_3])
              (\ ex_28 ->
                 case ex_28 of
                   (ErlangTuple [(ErlangAtom "throw"), payload_30, _]) ->
                     payload_30
                   (ErlangTuple [(ErlangAtom "error"), payload_31, stack_32]) ->
                     let tup_el_34 = ErlangTuple [payload_31, stack_32]
                     in ErlangTuple [ErlangAtom "EXIT", tup_el_34]
                   (ErlangTuple [(ErlangAtom "exit"), payload_37, _]) ->
                     ErlangTuple [ErlangAtom "EXIT", payload_37]
                   ex_29 -> EXC.raise ex_29)
        in
          case matchExpr_42 of
            (ErlangTuple [(ErlangAtom "ok"), _types_40, exprs_41]) ->
              let
                fun_43 =
                  ErlangFun 0
                    (let
                       lambda_44 [] =
                         let    arg_45 = BIF.erlang__self__0 []
                         in let
                           __t_46 = BIF.erlang__is_process_alive__1 [arg_45]
                         in let case_47 = BIF.erlang__is_list__1 [exprs_41]
                         in
                           case case_47 of
                             __t_49 | __t_49 == __t_46 -> ErlangAtom "ok"
                             __v_50 ->
                               let   
                                 head_54 =
                                   ErlangTuple
                                     [ErlangAtom "module",
                                      ErlangAtom "aeso_calldata_tests"]
                               in let tup_el_60 = toErl 81
                               in let
                                 head_58 =
                                   ErlangTuple [ErlangAtom "line", tup_el_60]
                               in let tup_el_64 = toErl "is_list ( Exprs )"
                               in let
                                 head_62 =
                                   ErlangTuple
                                     [ErlangAtom "expression", tup_el_64]
                               in let
                                 head_66 =
                                   ErlangTuple
                                     [ErlangAtom "expected", ErlangAtom "true"]
                               in let case_71 = BIF.erlang__not__1 [__t_46]
                               in let
                                 head_70 =
                                   case case_71 of
                                     __v_73 | __v_73 == __v_50 ->
                                       ErlangTuple
                                         [ErlangAtom "value",
                                          ErlangAtom "false"]
                                     _ ->
                                       ErlangTuple
                                         [ErlangAtom "not_boolean", __v_50]
                               in let
                                 arg_51 =
                                   ErlangTuple
                                     [ErlangAtom "assert",
                                      ErlangCons head_54
                                        (ErlangCons head_58
                                           (ErlangCons head_62
                                              (ErlangCons head_66
                                                 (ErlangCons head_70
                                                    ErlangEmptyList))))]
                               in BIF.erlang__error__1 [arg_51]
                       lambda_44 [] = EXC.function_clause unit
                       lambda_44 args =
                         EXC.badarity (ErlangFun 0 lambda_44) args
                     in lambda_44)
                _ = BIF.erlang__apply__2 [fun_43, ErlangEmptyList]
              in erlps__strip_ann__1 [exprs_41]
            _ -> EXC.badmatch matchExpr_42
      _ -> EXC.badmatch matchExpr_22
erlps__ast_exprs__4 [arg_80, arg_81, arg_82, arg_83] =
  EXC.function_clause unit
erlps__ast_exprs__4 args =
  EXC.badarity (ErlangFun 4 erlps__ast_exprs__4) args

erlps__check_errors__2 :: ErlangFun
erlps__check_errors__2 [expect_0, errorstring_1] =
  let    bin_el_4 = toErl 10
  in let
    arg_2 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix errorstring_1 (BIN.packedSize errorstring_1) 8,
            BIN.fromInt bin_el_4 (toErl 8) 1 BIN.Big])
  in let
    arg_5 =
      ErlangBinary (BIN.fromInts (toErl "\n\n") (toErl 8) 1 BIN.Big)
  in let
    actual_11 =
      BIF.binary__split__3
        [arg_2, arg_5,
         ErlangCons (ErlangAtom "global")
           (ErlangCons (ErlangAtom "trim") ErlangEmptyList)]
  in let tup_el_13 = BIF.erlang__op_unAppend [expect_0, actual_11]
  in let tup_el_16 = BIF.erlang__op_unAppend [actual_11, expect_0]
  in let case_12 = ErlangTuple [tup_el_13, tup_el_16]
  in
    case case_12 of
      (ErlangTuple [(ErlangEmptyList), extra_19]) ->
        let
          fun_20 =
            ErlangFun 0
              (let
                 lambda_21 [] =
                   let case_22 = ErlangTuple [ErlangAtom "unexpected", extra_19]
                   in
                     case case_22 of
                       (ErlangTuple [(ErlangAtom "unexpected"),
                                     (ErlangEmptyList)]) ->
                         ErlangAtom "ok"
                       __v_25 ->
                         let   
                           head_29 =
                             ErlangTuple
                               [ErlangAtom "module",
                                ErlangAtom "aeso_calldata_tests"]
                         in let tup_el_35 = toErl 88
                         in let
                           head_33 = ErlangTuple [ErlangAtom "line", tup_el_35]
                         in let tup_el_39 = toErl "{ unexpected , Extra }"
                         in let
                           head_37 =
                             ErlangTuple [ErlangAtom "expression", tup_el_39]
                         in let tup_el_43 = toErl "{ unexpected , [ ] }"
                         in let
                           head_41 =
                             ErlangTuple [ErlangAtom "pattern", tup_el_43]
                         in let
                           head_45 = ErlangTuple [ErlangAtom "value", __v_25]
                         in let
                           arg_26 =
                             ErlangTuple
                               [ErlangAtom "assertMatch",
                                ErlangCons head_29
                                  (ErlangCons head_33
                                     (ErlangCons head_37
                                        (ErlangCons head_41
                                           (ErlangCons head_45
                                              ErlangEmptyList))))]
                         in BIF.erlang__error__1 [arg_26]
                 lambda_21 [] = EXC.function_clause unit
                 lambda_21 args = EXC.badarity (ErlangFun 0 lambda_21) args
               in lambda_21)
        in BIF.erlang__apply__2 [fun_20, ErlangEmptyList]
      (ErlangTuple [missing_49, (ErlangEmptyList)]) ->
        let
          fun_50 =
            ErlangFun 0
              (let
                 lambda_51 [] =
                   let case_52 = ErlangTuple [ErlangAtom "missing", missing_49]
                   in
                     case case_52 of
                       (ErlangTuple [(ErlangAtom "missing"),
                                     (ErlangEmptyList)]) ->
                         ErlangAtom "ok"
                       __v_55 ->
                         let   
                           head_59 =
                             ErlangTuple
                               [ErlangAtom "module",
                                ErlangAtom "aeso_calldata_tests"]
                         in let tup_el_65 = toErl 89
                         in let
                           head_63 = ErlangTuple [ErlangAtom "line", tup_el_65]
                         in let tup_el_69 = toErl "{ missing , Missing }"
                         in let
                           head_67 =
                             ErlangTuple [ErlangAtom "expression", tup_el_69]
                         in let tup_el_73 = toErl "{ missing , [ ] }"
                         in let
                           head_71 =
                             ErlangTuple [ErlangAtom "pattern", tup_el_73]
                         in let
                           head_75 = ErlangTuple [ErlangAtom "value", __v_55]
                         in let
                           arg_56 =
                             ErlangTuple
                               [ErlangAtom "assertMatch",
                                ErlangCons head_59
                                  (ErlangCons head_63
                                     (ErlangCons head_67
                                        (ErlangCons head_71
                                           (ErlangCons head_75
                                              ErlangEmptyList))))]
                         in BIF.erlang__error__1 [arg_56]
                 lambda_51 [] = EXC.function_clause unit
                 lambda_51 args = EXC.badarity (ErlangFun 0 lambda_51) args
               in lambda_51)
        in BIF.erlang__apply__2 [fun_50, ErlangEmptyList]
      (ErlangTuple [missing_79, extra_80]) ->
        let
          fun_81 =
            ErlangFun 0
              (let
                 lambda_82 [] =
                   case extra_80 of
                     __x_85 | __x_85 == missing_79 -> ErlangAtom "ok"
                     __v_86 ->
                       let   
                         head_90 =
                           ErlangTuple
                             [ErlangAtom "module",
                              ErlangAtom "aeso_calldata_tests"]
                       in let tup_el_96 = toErl 90
                       in let
                         head_94 = ErlangTuple [ErlangAtom "line", tup_el_96]
                       in let tup_el_100 = toErl "Extra"
                       in let
                         head_98 =
                           ErlangTuple [ErlangAtom "expression", tup_el_100]
                       in let
                         head_102 =
                           ErlangTuple [ErlangAtom "expected", missing_79]
                       in let
                         head_106 = ErlangTuple [ErlangAtom "value", __v_86]
                       in let
                         arg_87 =
                           ErlangTuple
                             [ErlangAtom "assertEqual",
                              ErlangCons head_90
                                (ErlangCons head_94
                                   (ErlangCons head_98
                                      (ErlangCons head_102
                                         (ErlangCons head_106
                                            ErlangEmptyList))))]
                       in BIF.erlang__error__1 [arg_87]
                 lambda_82 [] = EXC.function_clause unit
                 lambda_82 args = EXC.badarity (ErlangFun 0 lambda_82) args
               in lambda_82)
        in BIF.erlang__apply__2 [fun_81, ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__check_errors__2 [arg_110, arg_111] =
  EXC.function_clause unit
erlps__check_errors__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_errors__2) args

erlps__compilable_contracts__0 :: ErlangFun
erlps__compilable_contracts__0 [] =
  let    tup_el_1 = toErl "identity"
  in let tup_el_2 = toErl "init"
  in let head_0 = ErlangTuple [tup_el_1, tup_el_2, ErlangEmptyList]
  in let tup_el_6 = toErl "maps"
  in let tup_el_7 = toErl "init"
  in let head_5 = ErlangTuple [tup_el_6, tup_el_7, ErlangEmptyList]
  in let tup_el_11 = toErl "funargs"
  in let tup_el_12 = toErl "menot"
  in let head_14 = toErl "false"
  in let
    head_10 =
      ErlangTuple
        [tup_el_11, tup_el_12, ErlangCons head_14 ErlangEmptyList]
  in let tup_el_18 = toErl "funargs"
  in let tup_el_19 = toErl "append"
  in let
    head_21 = toErl "[\"false\", \" is\", \" not\", \" true\"]"
  in let
    head_17 =
      ErlangTuple
        [tup_el_18, tup_el_19, ErlangCons head_21 ErlangEmptyList]
  in let tup_el_25 = toErl "funargs"
  in let tup_el_26 = toErl "bitsum"
  in let head_28 = toErl "Bits.all"
  in let
    head_24 =
      ErlangTuple
        [tup_el_25, tup_el_26, ErlangCons head_28 ErlangEmptyList]
  in let tup_el_32 = toErl "funargs"
  in let tup_el_33 = toErl "bitsum"
  in let head_35 = toErl "Bits.clear(Bits.clear(Bits.all, 4), 2)"
  in let
    head_31 =
      ErlangTuple
        [tup_el_32, tup_el_33, ErlangCons head_35 ErlangEmptyList]
  in let tup_el_39 = toErl "funargs"
  in let tup_el_40 = toErl "bitsum"
  in let head_42 = toErl "Bits.set(Bits.set(Bits.none, 4), 2)"
  in let
    head_38 =
      ErlangTuple
        [tup_el_39, tup_el_40, ErlangCons head_42 ErlangEmptyList]
  in let tup_el_46 = toErl "funargs"
  in let tup_el_47 = toErl "read"
  in let head_49 = toErl "{label = \"question 1\", result = 4}"
  in let
    head_45 =
      ErlangTuple
        [tup_el_46, tup_el_47, ErlangCons head_49 ErlangEmptyList]
  in let tup_el_53 = toErl "funargs"
  in let tup_el_54 = toErl "sjutton"
  in let head_56 = toErl "#0011012003100011012003100011012003"
  in let
    head_52 =
      ErlangTuple
        [tup_el_53, tup_el_54, ErlangCons head_56 ErlangEmptyList]
  in let tup_el_60 = toErl "funargs"
  in let tup_el_61 = toErl "sextiosju"
  in let
    head_63 =
      toErl
        "#01020304050607080910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667"
  in let
    head_59 =
      ErlangTuple
        [tup_el_60, tup_el_61, ErlangCons head_63 ErlangEmptyList]
  in let tup_el_67 = toErl "funargs"
  in let tup_el_68 = toErl "trettiotva"
  in let
    head_70 =
      toErl
        "#0102030405060708091011121314151617181920212223242526272829303132"
  in let
    head_66 =
      ErlangTuple
        [tup_el_67, tup_el_68, ErlangCons head_70 ErlangEmptyList]
  in let tup_el_74 = toErl "funargs"
  in let tup_el_75 = toErl "find_oracle"
  in let
    head_77 =
      toErl "ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5"
  in let
    head_73 =
      ErlangTuple
        [tup_el_74, tup_el_75, ErlangCons head_77 ErlangEmptyList]
  in let tup_el_81 = toErl "funargs"
  in let tup_el_82 = toErl "find_query"
  in let
    head_84 =
      toErl "oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY"
  in let
    head_80 =
      ErlangTuple
        [tup_el_81, tup_el_82, ErlangCons head_84 ErlangEmptyList]
  in let tup_el_88 = toErl "funargs"
  in let tup_el_89 = toErl "traffic_light"
  in let head_91 = toErl "Green"
  in let
    head_87 =
      ErlangTuple
        [tup_el_88, tup_el_89, ErlangCons head_91 ErlangEmptyList]
  in let tup_el_95 = toErl "funargs"
  in let tup_el_96 = toErl "traffic_light"
  in let head_98 = toErl "Pantone(12)"
  in let
    head_94 =
      ErlangTuple
        [tup_el_95, tup_el_96, ErlangCons head_98 ErlangEmptyList]
  in let tup_el_102 = toErl "funargs"
  in let tup_el_103 = toErl "tuples"
  in let head_105 = toErl "()"
  in let
    head_101 =
      ErlangTuple
        [tup_el_102, tup_el_103, ErlangCons head_105 ErlangEmptyList]
  in let tup_el_109 = toErl "funargs"
  in let tup_el_110 = toErl "singleton_rec"
  in let head_112 = toErl "{x = 1000}"
  in let
    head_108 =
      ErlangTuple
        [tup_el_109, tup_el_110, ErlangCons head_112 ErlangEmptyList]
  in let tup_el_116 = toErl "variant_types"
  in let tup_el_117 = toErl "init"
  in let
    head_115 = ErlangTuple [tup_el_116, tup_el_117, ErlangEmptyList]
  in let tup_el_121 = toErl "basic_auth"
  in let tup_el_122 = toErl "init"
  in let
    head_120 = ErlangTuple [tup_el_121, tup_el_122, ErlangEmptyList]
  in let tup_el_126 = toErl "address_literals"
  in let tup_el_127 = toErl "init"
  in let
    head_125 = ErlangTuple [tup_el_126, tup_el_127, ErlangEmptyList]
  in let tup_el_131 = toErl "bytes_equality"
  in let tup_el_132 = toErl "init"
  in let
    head_130 = ErlangTuple [tup_el_131, tup_el_132, ErlangEmptyList]
  in let tup_el_136 = toErl "address_chain"
  in let tup_el_137 = toErl "init"
  in let
    head_135 = ErlangTuple [tup_el_136, tup_el_137, ErlangEmptyList]
  in let tup_el_141 = toErl "counter"
  in let tup_el_142 = toErl "init"
  in let
    head_144 =
      toErl "-3334353637383940202122232425262728293031323334353637"
  in let
    head_140 =
      ErlangTuple
        [tup_el_141, tup_el_142, ErlangCons head_144 ErlangEmptyList]
  in let tup_el_148 = toErl "dutch_auction"
  in let tup_el_149 = toErl "init"
  in let
    head_151 =
      toErl "ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt"
  in let head_153 = toErl "200000"
  in let head_155 = toErl "1000"
  in let
    head_147 =
      ErlangTuple
        [tup_el_148, tup_el_149,
         ErlangCons head_151
           (ErlangCons head_153 (ErlangCons head_155 ErlangEmptyList))]
  in let tup_el_159 = toErl "maps"
  in let tup_el_160 = toErl "fromlist_i"
  in let
    head_162 =
      toErl
        "[(1, {x = 1, y = 2}), (2, {x = 3, y = 4}), (3, {x = 4, y = 4})]"
  in let
    head_158 =
      ErlangTuple
        [tup_el_159, tup_el_160, ErlangCons head_162 ErlangEmptyList]
  in let tup_el_166 = toErl "maps"
  in let tup_el_167 = toErl "get_i"
  in let head_169 = toErl "1"
  in let head_171 = toErl "{}"
  in let
    head_165 =
      ErlangTuple
        [tup_el_166, tup_el_167,
         ErlangCons head_169 (ErlangCons head_171 ErlangEmptyList)]
  in let tup_el_175 = toErl "maps"
  in let tup_el_176 = toErl "get_i"
  in let head_178 = toErl "1"
  in let head_180 = toErl "{[1] = {x = 3, y = 4}}"
  in let
    head_174 =
      ErlangTuple
        [tup_el_175, tup_el_176,
         ErlangCons head_178 (ErlangCons head_180 ErlangEmptyList)]
  in let tup_el_184 = toErl "maps"
  in let tup_el_185 = toErl "get_i"
  in let head_187 = toErl "1"
  in let
    head_189 = toErl "{[1] = {x = 3, y = 4}, [2] = {x = 4, y = 5}}"
  in let
    head_183 =
      ErlangTuple
        [tup_el_184, tup_el_185,
         ErlangCons head_187 (ErlangCons head_189 ErlangEmptyList)]
  in let tup_el_193 = toErl "maps"
  in let tup_el_194 = toErl "get_i"
  in let head_196 = toErl "1"
  in let
    head_198 =
      toErl
        "{[1] = {x = 3, y = 4}, [2] = {x = 4, y = 5}, [3] = {x = 5, y = 6}}"
  in let
    head_192 =
      ErlangTuple
        [tup_el_193, tup_el_194,
         ErlangCons head_196 (ErlangCons head_198 ErlangEmptyList)]
  in let tup_el_202 = toErl "strings"
  in let tup_el_203 = toErl "str_concat"
  in let head_205 = toErl "\"test\""
  in let head_207 = toErl "\"me\""
  in let
    head_201 =
      ErlangTuple
        [tup_el_202, tup_el_203,
         ErlangCons head_205 (ErlangCons head_207 ErlangEmptyList)]
  in let tup_el_211 = toErl "complex_types"
  in let tup_el_212 = toErl "filter_some"
  in let head_214 = toErl "[Some(11), Some(12), None]"
  in let
    head_210 =
      ErlangTuple
        [tup_el_211, tup_el_212, ErlangCons head_214 ErlangEmptyList]
  in let tup_el_218 = toErl "complex_types"
  in let tup_el_219 = toErl "init"
  in let
    head_221 =
      toErl "ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ"
  in let
    head_217 =
      ErlangTuple
        [tup_el_218, tup_el_219, ErlangCons head_221 ErlangEmptyList]
  in let tup_el_225 = toErl "__callinit"
  in let head_224 = ErlangTuple [tup_el_225, ErlangEmptyList]
  in let tup_el_229 = toErl "bitcoin_auth"
  in let tup_el_230 = toErl "authorize"
  in let head_232 = toErl "1"
  in let
    head_234 =
      toErl
        "#0102030405060708090a0b0c0d0e0f101718192021222324252627282930313233343536373839401a1b1c1d1e1f20212223242526272829303132333435363738"
  in let
    head_228 =
      ErlangTuple
        [tup_el_229, tup_el_230,
         ErlangCons head_232 (ErlangCons head_234 ErlangEmptyList)]
  in let tup_el_238 = toErl "bitcoin_auth"
  in let tup_el_239 = toErl "to_sign"
  in let
    head_241 =
      toErl
        "#0102030405060708090a0b0c0d0e0f1017181920212223242526272829303132"
  in let head_243 = toErl "2"
  in let
    head_237 =
      ErlangTuple
        [tup_el_238, tup_el_239,
         ErlangCons head_241 (ErlangCons head_243 ErlangEmptyList)]
  in let tup_el_247 = toErl "stub"
  in let tup_el_248 = toErl "foo"
  in let head_250 = toErl "42"
  in let
    head_246 =
      ErlangTuple
        [tup_el_247, tup_el_248, ErlangCons head_250 ErlangEmptyList]
  in let tup_el_254 = toErl "stub"
  in let tup_el_255 = toErl "foo"
  in let head_257 = toErl "-42"
  in let
    head_253 =
      ErlangTuple
        [tup_el_254, tup_el_255, ErlangCons head_257 ErlangEmptyList]
  in let tup_el_261 = toErl "payable"
  in let tup_el_262 = toErl "foo"
  in let head_264 = toErl "42"
  in let
    head_260 =
      ErlangTuple
        [tup_el_261, tup_el_262, ErlangCons head_264 ErlangEmptyList]
  in
    ErlangCons head_0
      (ErlangCons head_5
         (ErlangCons head_10
            (ErlangCons head_17
               (ErlangCons head_24
                  (ErlangCons head_31
                     (ErlangCons head_38
                        (ErlangCons head_45
                           (ErlangCons head_52
                              (ErlangCons head_59
                                 (ErlangCons head_66
                                    (ErlangCons head_73
                                       (ErlangCons head_80
                                          (ErlangCons head_87
                                             (ErlangCons head_94
                                                (ErlangCons head_101
                                                   (ErlangCons head_108
                                                      (ErlangCons head_115
                                                         (ErlangCons head_120
                                                            (ErlangCons head_125
                                                               (ErlangCons
                                                                  head_130
                                                                  (ErlangCons
                                                                     head_135
                                                                     (ErlangCons
                                                                        head_140
                                                                        (ErlangCons
                                                                           head_147
                                                                           (ErlangCons
                                                                              head_158
                                                                              (ErlangCons
                                                                                 head_165
                                                                                 (ErlangCons
                                                                                    head_174
                                                                                    (ErlangCons
                                                                                       head_183
                                                                                       (ErlangCons
                                                                                          head_192
                                                                                          (ErlangCons
                                                                                             head_201
                                                                                             (ErlangCons
                                                                                                head_210
                                                                                                (ErlangCons
                                                                                                   head_217
                                                                                                   (ErlangCons
                                                                                                      head_224
                                                                                                      (ErlangCons
                                                                                                         head_228
                                                                                                         (ErlangCons
                                                                                                            head_237
                                                                                                            (ErlangCons
                                                                                                               head_246
                                                                                                               (ErlangCons
                                                                                                                  head_253
                                                                                                                  (ErlangCons
                                                                                                                     head_260
                                                                                                                     ErlangEmptyList)))))))))))))))))))))))))))))))))))))
erlps__compilable_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__compilable_contracts__0) args

erlps__not_yet_compilable__1 :: ErlangFun
erlps__not_yet_compilable__1 [(ErlangAtom "fate")] =
  ErlangEmptyList
erlps__not_yet_compilable__1 [(ErlangAtom "aevm")] =
  ErlangEmptyList
erlps__not_yet_compilable__1 [arg_0] = EXC.function_clause unit
erlps__not_yet_compilable__1 args =
  EXC.badarity (ErlangFun 1 erlps__not_yet_compilable__1) args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeso_calldata_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 erlps__test__0) args