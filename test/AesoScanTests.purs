module Aeso.Scan.Tests(erlps__test__0,
                       erlps__empty_contract_test___0,
                       erlps__all_tokens_test___0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__empty_contract_test___0 :: ErlangFun
erlps__empty_contract_test___0 [] =
  let   
    tup_el_1 =
      ErlangFun 0
        (let
           lambda_2 [] = ErlangAtom "ok"
           lambda_2 [] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 0 lambda_2) args
         in lambda_2)
  in let
    tup_el_3 =
      ErlangFun 1
        (let
           lambda_4 [_] = ErlangAtom "ok"
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let tup_el_8 = toErl "Scan an empty contract."
  in let
    tup_el_9 =
      ErlangFun 0
        (let
           lambda_10 [] =
             let    text_11 = toErl " "
             in let
               matchExpr_13 =
                 BIF.do_remote_fun_call "Aeso.Scan" "erlps__scan__1" [text_11]
             in
               case matchExpr_13 of
                 (ErlangTuple [(ErlangAtom "ok"), (ErlangEmptyList)]) ->
                   ErlangAtom "ok"
                 _ -> EXC.badmatch matchExpr_13
           lambda_10 [] = EXC.function_clause unit
           lambda_10 args = EXC.badarity (ErlangFun 0 lambda_10) args
         in lambda_10)
  in let head_7 = ErlangTuple [tup_el_8, tup_el_9]
  in
    ErlangTuple
      [ErlangAtom "foreach", tup_el_1, tup_el_3,
       ErlangCons head_7 ErlangEmptyList]
erlps__empty_contract_test___0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__all_tokens_test___0 :: ErlangFun
erlps__all_tokens_test___0 [] =
  let   
    tup_el_1 =
      ErlangFun 0
        (let
           lambda_2 [] = ErlangAtom "ok"
           lambda_2 [] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 0 lambda_2) args
         in lambda_2)
  in let
    tup_el_3 =
      ErlangFun 1
        (let
           lambda_4 [_] = ErlangAtom "ok"
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let tup_el_8 = toErl "Check that we can scan all tokens."
  in let
    tup_el_9 =
      ErlangFun 0
        (let
           lambda_10 [] =
             let    tokens_11 = erlps__all_tokens__0 []
             in let arg_13 = ErlangFun 1 erlps__show_token__1
             in let
               arg_12 =
                 BIF.do_remote_fun_call "Lists" "erlps__map__2"
                   [arg_13, tokens_11]
             in let arg_15 = toErl " "
             in let
               text_16 =
                 BIF.do_remote_fun_call "String" "erlps__join__2"
                   [arg_12, arg_15]
             in let arg_17 = toErl "~s\n"
             in let
               _ =
                 BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                   [arg_17, ErlangCons text_16 ErlangEmptyList]
             in let
               matchExpr_23 =
                 BIF.do_remote_fun_call "Aeso.Scan" "erlps__scan__1" [text_16]
             in
               case matchExpr_23 of
                 (ErlangTuple [(ErlangAtom "ok"), tokens1_22]) ->
                   let
                     matchExpr_26 =
                       erlps__compare_tokens__2 [tokens_11, tokens1_22]
                   in
                     case matchExpr_26 of
                       (ErlangAtom "true") -> ErlangAtom "ok"
                       _ -> EXC.badmatch matchExpr_26
                 _ -> EXC.badmatch matchExpr_23
           lambda_10 [] = EXC.function_clause unit
           lambda_10 args = EXC.badarity (ErlangFun 0 lambda_10) args
         in lambda_10)
  in let head_7 = ErlangTuple [tup_el_8, tup_el_9]
  in
    ErlangTuple
      [ErlangAtom "foreach", tup_el_1, tup_el_3,
       ErlangCons head_7 ErlangEmptyList]
erlps__all_tokens_test___0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__all_tokens__0 :: ErlangFun
erlps__all_tokens__0 [] =
  let   
    lit_5 =
      ErlangFun 1
        (let
           lambda_0 [t_2] =
             let tup_el_4 = toErl 1
             in ErlangTuple [t_2, tup_el_4]
           lambda_0 [arg_1] = EXC.function_clause unit
           lambda_0 args = EXC.badarity (ErlangFun 1 lambda_0) args
         in lambda_0)
  in let
    tok_14 =
      ErlangFun 2
        (let
           lambda_6 [t_9, v_10] =
             let tup_el_12 = toErl 1
             in ErlangTuple [t_9, tup_el_12, v_10]
           lambda_6 [arg_7, arg_8] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
         in lambda_6)
  in let arg_17 = toErl 0
  in let arg_18 = toErl 31
  in let
    lcSrc_16 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_17, arg_18]
  in let
    arg_15 =
      flmap
        (\ lc_20 ->
           let    rop_23 = toErl 8
           in let lcRet_21 = BIF.erlang__op_mult [lc_20, rop_23]
           in ErlangCons lcRet_21 ErlangEmptyList)
        lcSrc_16
  in let hash_24 = BIF.erlang__list_to_binary__1 [arg_15]
  in let
    lop_25 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [lit_5,
         ErlangCons (ErlangAtom ",")
           (ErlangCons (ErlangAtom ".")
              (ErlangCons (ErlangAtom ";")
                 (ErlangCons (ErlangAtom "|")
                    (ErlangCons (ErlangAtom ":")
                       (ErlangCons (ErlangAtom "(")
                          (ErlangCons (ErlangAtom ")")
                             (ErlangCons (ErlangAtom "[")
                                (ErlangCons (ErlangAtom "]")
                                   (ErlangCons (ErlangAtom "{")
                                      (ErlangCons (ErlangAtom "}")
                                         ErlangEmptyList))))))))))]
  in let
    lop_51 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [lit_5,
         ErlangCons (ErlangAtom "=")
           (ErlangCons (ErlangAtom "==")
              (ErlangCons (ErlangAtom "!=")
                 (ErlangCons (ErlangAtom ">")
                    (ErlangCons (ErlangAtom "<")
                       (ErlangCons (ErlangAtom ">=")
                          (ErlangCons (ErlangAtom "=<")
                             (ErlangCons (ErlangAtom "-")
                                (ErlangCons (ErlangAtom "+")
                                   (ErlangCons (ErlangAtom "++")
                                      (ErlangCons (ErlangAtom "*")
                                         (ErlangCons (ErlangAtom "/")
                                            (ErlangCons (ErlangAtom "mod")
                                               (ErlangCons (ErlangAtom ":")
                                                  (ErlangCons (ErlangAtom "::")
                                                     (ErlangCons
                                                        (ErlangAtom "->")
                                                        (ErlangCons
                                                           (ErlangAtom "=>")
                                                           (ErlangCons
                                                              (ErlangAtom "||")
                                                              (ErlangCons
                                                                 (ErlangAtom
                                                                    "&&")
                                                                 (ErlangCons
                                                                    (ErlangAtom
                                                                       "!")
                                                                    ErlangEmptyList)))))))))))))))))))]
  in let
    lop_95 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [lit_5,
         ErlangCons (ErlangAtom "contract")
           (ErlangCons (ErlangAtom "type")
              (ErlangCons (ErlangAtom "let")
                 (ErlangCons (ErlangAtom "switch") ErlangEmptyList)))]
  in let tup_el_110 = toErl 0
  in let tup_el_111 = toErl "// *Comment!\"\n"
  in let
    head_108 =
      ErlangTuple [ErlangAtom "comment", tup_el_110, tup_el_111]
  in let tup_el_115 = toErl 0
  in let tup_el_116 = toErl "/* bla /* bla bla */*/"
  in let
    head_113 =
      ErlangTuple [ErlangAtom "comment", tup_el_115, tup_el_116]
  in let
    head_119 =
      BIF.erlang__apply__2
        [lit_5, ErlangCons (ErlangAtom "true") ErlangEmptyList]
  in let
    head_123 =
      BIF.erlang__apply__2
        [lit_5, ErlangCons (ErlangAtom "false") ErlangEmptyList]
  in let arg_129 = toErl "foo"
  in let
    head_127 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "id")
           (ErlangCons arg_129 ErlangEmptyList)]
  in let arg_134 = toErl "_"
  in let
    head_132 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "id")
           (ErlangCons arg_134 ErlangEmptyList)]
  in let arg_139 = toErl "Foo"
  in let
    head_137 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "con")
           (ErlangCons arg_139 ErlangEmptyList)]
  in let
    head_142 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "bytes")
           (ErlangCons hash_24 ErlangEmptyList)]
  in let arg_149 = toErl 1234567890
  in let
    head_147 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "int")
           (ErlangCons arg_149 ErlangEmptyList)]
  in let
    arg_154 =
      toErl (unsafePartial (DM.fromJust (DBI.fromString "9876543210")))
  in let
    head_152 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "hex")
           (ErlangCons arg_154 ErlangEmptyList)]
  in let bin_el_160 = toErl 98
  in let bin_el_161 = toErl 108
  in let bin_el_162 = toErl 97
  in let bin_el_163 = toErl 34
  in let bin_el_164 = toErl 92
  in let bin_el_165 = toErl 8
  in let bin_el_166 = toErl 27
  in let bin_el_167 = toErl 12
  in let bin_el_168 = toErl 10
  in let bin_el_169 = toErl 13
  in let bin_el_170 = toErl 9
  in let bin_el_171 = toErl 11
  in let bin_el_172 = toErl 98
  in let bin_el_173 = toErl 108
  in let bin_el_174 = toErl 97
  in let
    arg_159 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_160 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_161 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_162 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_163 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_164 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_165 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_166 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_167 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_168 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_169 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_170 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_171 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_172 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_173 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_174 (toErl 8) 1 BIN.Big])
  in let
    head_157 =
      BIF.erlang__apply__2
        [tok_14,
         ErlangCons (ErlangAtom "string")
           (ErlangCons arg_159 ErlangEmptyList)]
  in let
    rop_106 =
      BIF.erlang__op_append
        [ErlangCons head_108 (ErlangCons head_113 ErlangEmptyList),
         ErlangCons head_119
           (ErlangCons head_123
              (ErlangCons head_127
                 (ErlangCons head_132
                    (ErlangCons head_137
                       (ErlangCons head_142
                          (ErlangCons head_147
                             (ErlangCons head_152
                                (ErlangCons head_157 ErlangEmptyList))))))))]
  in let rop_94 = BIF.erlang__op_append [lop_95, rop_106]
  in let rop_50 = BIF.erlang__op_append [lop_51, rop_94]
  in BIF.erlang__op_append [lop_25, rop_50]
erlps__all_tokens__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__compare_tokens__2 :: ErlangFun
erlps__compare_tokens__2 [(ErlangEmptyList), (ErlangEmptyList)] =
  ErlangAtom "true"
erlps__compare_tokens__2 [(ErlangCons (ErlangTuple [t_0,
                                                    _]) ts1_1),
                          (ErlangCons (ErlangTuple [t_2, _]) ts2_3)]
  | t_2 == t_0 =
  erlps__compare_tokens__2 [ts1_1, ts2_3]
erlps__compare_tokens__2 [(ErlangCons (ErlangTuple [t_0, _,
                                                    v_1]) ts1_2),
                          (ErlangCons (ErlangTuple [t_3, _, v_4]) ts2_5)]
  | t_3 == t_0
  , v_4 == v_1 =
  erlps__compare_tokens__2 [ts1_2, ts2_5]
erlps__compare_tokens__2 [(ErlangCons (ErlangTuple [(ErlangAtom "comment"),
                                                    _, _]) ts1_0),
                          ts2_1]
  =
  erlps__compare_tokens__2 [ts1_0, ts2_1]
erlps__compare_tokens__2 [ts1_0, ts2_1] =
  let    lop_3 = BIF.erlang__length__1 [ts1_0]
  in let rop_5 = BIF.erlang__length__1 [ts2_1]
  in let case_2 = BIF.erlang__op_eq [lop_3, rop_5]
  in
    case case_2 of
      (ErlangAtom "true") ->
        let   
          lcSrc_9 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [ts1_0, ts2_1]
        in let
          tup_el_8 =
            flmap
              (\ lc_14 ->
                 case lc_14 of
                   (ErlangTuple [t1_12, t2_13]) ->
                     let cond_15 = BIF.erlang__op_neq [t1_12, t2_13]
                     in
                       case cond_15 of
                         (ErlangAtom "true") ->
                           let
                             lcRet_18 =
                               ErlangTuple
                                 [ErlangAtom "expected", t1_12,
                                  ErlangAtom "got", t2_13]
                           in ErlangCons lcRet_18 ErlangEmptyList
                         _ -> ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_9
        in ErlangTuple [ErlangAtom "token_mismatch", tup_el_8]
      (ErlangAtom "false") ->
        let
          tup_el_24 =
            ErlangTuple
              [ErlangAtom "expected", ts1_0, ErlangAtom "got", ts2_1]
        in ErlangTuple [ErlangAtom "token_mismatch", tup_el_24]
      something_else -> EXC.case_clause something_else
erlps__compare_tokens__2 [arg_29, arg_30] =
  EXC.function_clause unit
erlps__compare_tokens__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fmt__1 :: ErlangFun
erlps__fmt__1 [x_0] =
  let arg_1 = toErl "~p"
  in erlps__fmt__2 [arg_1, x_0]
erlps__fmt__1 [arg_3] = EXC.function_clause unit
erlps__fmt__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fmt__2 :: ErlangFun
erlps__fmt__2 [fmt_0, x_1] =
  let
    arg_2 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [fmt_0, ErlangCons x_1 ErlangEmptyList]
  in BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_2]
erlps__fmt__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__fmt__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__show_token__1 :: ErlangFun
erlps__show_token__1 [(ErlangTuple [t_0, _])] =
  BIF.erlang__atom_to_list__1 [t_0]
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "id"), _, x_0])]
  =
  x_0
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "con"), _, c_0])]
  =
  c_0
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "param"), _,
                                    p_0])]
  =
  let lop_1 = toErl "@"
  in BIF.erlang__op_append [lop_1, p_0]
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "string"), _,
                                    s_0])]
  =
  let arg_1 = BIF.erlang__binary_to_list__1 [s_0]
  in erlps__fmt__1 [arg_1]
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "int"), _, n_0])]
  =
  erlps__fmt__1 [n_0]
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "hex"), _, n_0])]
  =
  let arg_1 = toErl "0x~.16b"
  in erlps__fmt__2 [arg_1, n_0]
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "bytes"), _,
                                    (ErlangBinary binSeg_0)])]
  | (ErlangInt size_1) <- (toErl 256)
  , (BIN.Ok n_3 bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , BIN.empty bin_2 =
  let arg_4 = toErl "#~64.16.0b"
  in erlps__fmt__2 [arg_4, n_3]
erlps__show_token__1 [(ErlangTuple [(ErlangAtom "comment"), _,
                                    s_0])]
  =
  s_0
erlps__show_token__1 [(ErlangTuple [_, _, _])] = toErl "TODO"
erlps__show_token__1 [arg_0] = EXC.function_clause unit
erlps__show_token__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeso_scan_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args