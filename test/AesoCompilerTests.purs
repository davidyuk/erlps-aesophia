module Aeso.Compiler.Tests where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__run_test__1 :: ErlangFun
erlps__run_test__1 [test_0] =
  let    head_5 = toErl "_test_"
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__concat__1"
        [ErlangCons test_0 (ErlangCons head_5 ErlangEmptyList)]
  in let testfun_7 = BIF.erlang__list_to_atom__1 [arg_1]
  in let
    lcSrc_8 =
      BIF.erlang__apply__3
        [ErlangAtom "aeso_compiler_tests", testfun_7, ErlangEmptyList]
  in let
    _ =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [label_12, fun_13]) ->
               let    arg_16 = toErl "~s\n"
               in let
                 _ =
                   BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                     [arg_16, ErlangCons label_12 ErlangEmptyList]
               in let lcRet_15 = BIF.erlang__apply__2 [fun_13, ErlangEmptyList]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_8
  in ErlangAtom "ok"
erlps__run_test__1 [arg_21] = EXC.function_clause unit
erlps__run_test__1 args =
  EXC.badarity (ErlangFun 1 erlps__run_test__1) args

erlps__simple_compile_test___0 :: ErlangFun
erlps__simple_compile_test___0 [] =
  let    lcSrc_1 = erlps__compilable_contracts__0 []
  in let
    lop_0 =
      flmap
        (\ lc_3 ->
           flmap
             (\ lc_10 ->
                let    arg_14 = erlps__not_compilable_on__1 [lc_10]
                in let op_arg_12 = BIF.lists__member__2 [lc_3, arg_14]
                in let cond_11 = BIF.erlang__not__1 [op_arg_12]
                in
                  case cond_11 of
                    (ErlangAtom "true") ->
                      let    lop_18 = toErl "Testing the "
                      in let lop_22 = toErl " contract with the "
                      in let lop_24 = BIF.erlang__atom_to_list__1 [lc_10]
                      in let rop_26 = toErl " backend"
                      in let rop_23 = BIF.erlang__op_append [lop_24, rop_26]
                      in let rop_21 = BIF.erlang__op_append [lop_22, rop_23]
                      in let rop_19 = BIF.erlang__op_append [lc_3, rop_21]
                      in let tup_el_17 = BIF.erlang__op_append [lop_18, rop_19]
                      in let
                        tup_el_27 =
                          ErlangFun 0
                            (let
                               lambda_28 [] =
                                 let case_29 = erlps__compile__2 [lc_10, lc_3]
                                 in
                                   case case_29 of
                                     (ErlangMap map_32) | (DM.Just _) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "type_info")
                                                               map_32)
                                                        , (DM.Just _) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "contract_source")
                                                               map_32)
                                                        , (DM.Just bytecode_33) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "byte_code")
                                                               map_32)
                                                        , weakEq lc_10
                                                            (ErlangAtom
                                                               "aevm") ->
                                       let
                                         fun_34 =
                                           ErlangFun 0
                                             (let
                                                lambda_35 [] =
                                                  case bytecode_33 of
                                                    code_37 | isEBinary
                                                                code_37 ->
                                                      ErlangAtom "ok"
                                                    __v_38 ->
                                                      let   
                                                        head_42 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "module",
                                                             ErlangAtom
                                                               "aeso_compiler_tests"]
                                                      in let
                                                        tup_el_48 = toErl 33
                                                      in let
                                                        head_46 =
                                                          ErlangTuple
                                                            [ErlangAtom "line",
                                                             tup_el_48]
                                                      in let
                                                        tup_el_52 =
                                                          toErl "ByteCode"
                                                      in let
                                                        head_50 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "expression",
                                                             tup_el_52]
                                                      in let
                                                        tup_el_56 =
                                                          toErl
                                                            "Code when is_binary ( Code )"
                                                      in let
                                                        head_54 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "pattern",
                                                             tup_el_56]
                                                      in let
                                                        head_58 =
                                                          ErlangTuple
                                                            [ErlangAtom "value",
                                                             __v_38]
                                                      in let
                                                        arg_39 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "assertMatch",
                                                             ErlangCons head_42
                                                               (ErlangCons
                                                                  head_46
                                                                  (ErlangCons
                                                                     head_50
                                                                     (ErlangCons
                                                                        head_54
                                                                        (ErlangCons
                                                                           head_58
                                                                           ErlangEmptyList))))]
                                                      in
                                                        BIF.erlang__error__1
                                                          [arg_39]
                                                lambda_35 [] =
                                                  EXC.function_clause unit
                                                lambda_35 args =
                                                  EXC.badarity
                                                    (ErlangFun 0 lambda_35) args
                                              in lambda_35)
                                       in
                                         BIF.erlang__apply__2
                                           [fun_34, ErlangEmptyList]
                                     (ErlangMap map_62) | (DM.Just code_63) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "fate_code")
                                                               map_62)
                                                        , weakEq lc_10
                                                            (ErlangAtom
                                                               "fate") ->
                                       let   
                                         arg_64 =
                                           BIF.do_remote_fun_call
                                             "Aeb.Fate.Code"
                                             "erlps__serialize__1" [code_63]
                                       in let
                                         code1_66 =
                                           BIF.do_remote_fun_call
                                             "Aeb.Fate.Code"
                                             "erlps__deserialize__1" [arg_64]
                                       in let
                                         fun_67 =
                                           ErlangFun 0
                                             (let
                                                lambda_68 [] =
                                                  let
                                                    case_69 =
                                                      ErlangTuple
                                                        [code1_66, code_63]
                                                  in
                                                    case case_69 of
                                                      (ErlangTuple [x_72,
                                                                    x_73]) | x_73 ==
                                                                               x_72 ->
                                                        ErlangAtom "ok"
                                                      __v_74 ->
                                                        let   
                                                          head_78 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "module",
                                                               ErlangAtom
                                                                 "aeso_compiler_tests"]
                                                        in let
                                                          tup_el_84 = toErl 36
                                                        in let
                                                          head_82 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "line",
                                                               tup_el_84]
                                                        in let
                                                          tup_el_88 =
                                                            toErl
                                                              "{ Code1 , Code }"
                                                        in let
                                                          head_86 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "expression",
                                                               tup_el_88]
                                                        in let
                                                          tup_el_92 =
                                                            toErl "{ X , X }"
                                                        in let
                                                          head_90 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "pattern",
                                                               tup_el_92]
                                                        in let
                                                          head_94 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "value",
                                                               __v_74]
                                                        in let
                                                          arg_75 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "assertMatch",
                                                               ErlangCons
                                                                 head_78
                                                                 (ErlangCons
                                                                    head_82
                                                                    (ErlangCons
                                                                       head_86
                                                                       (ErlangCons
                                                                          head_90
                                                                          (ErlangCons
                                                                             head_94
                                                                             ErlangEmptyList))))]
                                                        in
                                                          BIF.erlang__error__1
                                                            [arg_75]
                                                lambda_68 [] =
                                                  EXC.function_clause unit
                                                lambda_68 args =
                                                  EXC.badarity
                                                    (ErlangFun 0 lambda_68) args
                                              in lambda_68)
                                       in
                                         BIF.erlang__apply__2
                                           [fun_67, ErlangEmptyList]
                                     errbin_98 ->
                                       let    arg_99 = toErl "\n~s"
                                       in let
                                         _ =
                                           BIF.do_remote_fun_call "Erlang.Io"
                                             "erlps__format__2"
                                             [arg_99,
                                              ErlangCons errbin_98
                                                ErlangEmptyList]
                                       in BIF.erlang__error__1 [errbin_98]
                               lambda_28 [] = EXC.function_clause unit
                               lambda_28 args =
                                 EXC.badarity (ErlangFun 0 lambda_28) args
                             in lambda_28)
                      in let lcRet_16 = ErlangTuple [tup_el_17, tup_el_27]
                      in ErlangCons lcRet_16 ErlangEmptyList
                    _ -> ErlangEmptyList)
             (ErlangCons (ErlangAtom "aevm")
                (ErlangCons (ErlangAtom "fate") ErlangEmptyList)))
        lcSrc_1
  in let tup_el_107 = toErl "Test file not found error"
  in let
    tup_el_108 =
      ErlangFun 0
        (let
           lambda_109 [] =
             let    arg_110 = toErl "does_not_exist.aes"
             in let
               matchExpr_112 =
                 BIF.do_remote_fun_call "Aeso.Compiler" "erlps__file__1"
                   [arg_110]
             in
               case matchExpr_112 of
                 (ErlangTuple [(ErlangAtom "error"), errors_111]) ->
                   let
                     experr_113 =
                       ErlangBinary
                         (BIN.fromInts
                            (toErl
                               "File error:\ndoes_not_exist.aes: no such file or directory")
                            (toErl 8) 1 BIN.Big)
                   in
                     erlps__check_errors__2
                       [ErlangCons experr_113 ErlangEmptyList, errors_111]
                 _ -> EXC.badmatch matchExpr_112
           lambda_109 [] = EXC.function_clause unit
           lambda_109 args = EXC.badarity (ErlangFun 0 lambda_109) args
         in lambda_109)
  in let head_106 = ErlangTuple [tup_el_107, tup_el_108]
  in let lcSrc_121 = erlps__failing_contracts__0 []
  in let
    lop_120 =
      flmap
        (\ lc_124 ->
           case lc_124 of
             (ErlangTuple [contractname_122, expectederrors_123]) ->
               let    lop_127 = toErl "Testing error messages of "
               in let
                 tup_el_126 = BIF.erlang__op_append [lop_127, contractname_122]
               in let
                 tup_el_129 =
                   ErlangFun 0
                     (let
                        lambda_130 [] =
                          let
                            errors_133 =
                              erlps__compile__2
                                [ErlangAtom "aevm", contractname_122]
                          in
                            erlps__check_errors__2
                              [expectederrors_123, errors_133]
                        lambda_130 [] = EXC.function_clause unit
                        lambda_130 args =
                          EXC.badarity (ErlangFun 0 lambda_130) args
                      in lambda_130)
               in let lcRet_125 = ErlangTuple [tup_el_126, tup_el_129]
               in ErlangCons lcRet_125 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_121
  in let lcSrc_138 = erlps__failing_code_gen_contracts__0 []
  in let
    lop_137 =
      flmap
        (\ lc_141 ->
           case lc_141 of
             (ErlangTuple [contractname_139, expectederror_140]) ->
               flmap
                 (\ lc_148 ->
                    let    lop_151 = toErl "Testing "
                    in let lop_153 = BIF.erlang__atom_to_list__1 [lc_148]
                    in let lop_156 = toErl " code generation error messages of "
                    in let
                      rop_155 =
                        BIF.erlang__op_append [lop_156, contractname_139]
                    in let rop_152 = BIF.erlang__op_append [lop_153, rop_155]
                    in let tup_el_150 = BIF.erlang__op_append [lop_151, rop_152]
                    in let
                      tup_el_158 =
                        ErlangFun 0
                          (let
                             lambda_159 [] =
                               let   
                                 errors_162 =
                                   erlps__compile__2 [lc_148, contractname_139]
                               in let
                                 case_163 =
                                   BIF.erlang__is_binary__1 [expectederror_140]
                               in let
                                 expect_174 =
                                   case case_163 of
                                     (ErlangAtom "true") ->
                                       ErlangCons expectederror_140
                                         ErlangEmptyList
                                     (ErlangAtom "false") ->
                                       let
                                         case_167 =
                                           BIF.do_remote_fun_call "Proplists"
                                             "erlps__get_value__3"
                                             [lc_148, expectederror_140,
                                              ErlangAtom "no_error"]
                                       in
                                         case case_167 of
                                           (ErlangAtom "no_error") ->
                                             ErlangAtom "no_error"
                                           err_171 ->
                                             ErlangCons err_171 ErlangEmptyList
                                     something_else ->
                                       EXC.case_clause something_else
                               in
                                 erlps__check_errors__2 [expect_174, errors_162]
                             lambda_159 [] = EXC.function_clause unit
                             lambda_159 args =
                               EXC.badarity (ErlangFun 0 lambda_159) args
                           in lambda_159)
                    in let lcRet_149 = ErlangTuple [tup_el_150, tup_el_158]
                    in ErlangCons lcRet_149 ErlangEmptyList)
                 (ErlangCons (ErlangAtom "aevm")
                    (ErlangCons (ErlangAtom "fate") ErlangEmptyList))
             _ -> ErlangEmptyList)
        lcSrc_138
  in let tup_el_180 = toErl "Testing include with explicit files"
  in let
    tup_el_181 =
      ErlangFun 0
        (let
           lambda_182 [] =
             let    head_185 = toErl "included.aes"
             in let head_187 = toErl "../contracts/included2.aes"
             in let
               arg_183 =
                 flmap
                   (\ lc_190 ->
                      let   
                        head_194 =
                          BIF.do_remote_fun_call "Aeso.Test.Utils"
                            "erlps__contract_path__0" []
                      in let
                        arg_192 =
                          BIF.do_remote_fun_call "Filename" "erlps__join__1"
                            [ErlangCons head_194
                               (ErlangCons lc_190 ErlangEmptyList)]
                      in let
                        matchExpr_199 =
                          BIF.do_remote_fun_call "File" "erlps__read_file__1"
                            [arg_192]
                      in
                        case matchExpr_199 of
                          (ErlangTuple [(ErlangAtom "ok"), bin_198]) ->
                            let lcRet_191 = ErlangTuple [lc_190, bin_198]
                            in ErlangCons lcRet_191 ErlangEmptyList
                          _ -> EXC.badmatch matchExpr_199)
                   (ErlangCons head_185 (ErlangCons head_187 ErlangEmptyList))
             in let filesystem_202 = BIF.maps__from_list__1 [arg_183]
             in let arg_204 = toErl "include"
             in let
               tup_el_208 =
                 ErlangTuple [ErlangAtom "explicit_files", filesystem_202]
             in let head_206 = ErlangTuple [ErlangAtom "include", tup_el_208]
             in let
               matchExpr_214 =
                 erlps__compile__3
                   [ErlangAtom "aevm", arg_204,
                    ErlangCons head_206 ErlangEmptyList]
             in
               case matchExpr_214 of
                 (ErlangMap map_212) | (DM.Just code1_213) <-
                                         (Map.lookup (ErlangAtom "byte_code")
                                            map_212) ->
                   let    arg_216 = toErl "include"
                   in let
                     matchExpr_219 =
                       erlps__compile__2 [ErlangAtom "aevm", arg_216]
                   in
                     case matchExpr_219 of
                       (ErlangMap map_217) | (DM.Just code2_218) <-
                                               (Map.lookup
                                                  (ErlangAtom "byte_code")
                                                  map_217) ->
                         let
                           fun_220 =
                             ErlangFun 0
                               (let
                                  lambda_221 [] =
                                    let
                                      case_222 =
                                        BIF.erlang__op_eq [code1_213, code2_218]
                                    in
                                      case case_222 of
                                        (ErlangAtom "true") -> ErlangAtom "ok"
                                        __v_225 ->
                                          let   
                                            head_229 =
                                              ErlangTuple
                                                [ErlangAtom "module",
                                                 ErlangAtom
                                                   "aeso_compiler_tests"]
                                          in let tup_el_235 = toErl 80
                                          in let
                                            head_233 =
                                              ErlangTuple
                                                [ErlangAtom "line", tup_el_235]
                                          in let
                                            tup_el_239 = toErl "Code1 == Code2"
                                          in let
                                            head_237 =
                                              ErlangTuple
                                                [ErlangAtom "expression",
                                                 tup_el_239]
                                          in let tup_el_243 = toErl "true"
                                          in let
                                            head_241 =
                                              ErlangTuple
                                                [ErlangAtom "pattern",
                                                 tup_el_243]
                                          in let
                                            head_245 =
                                              ErlangTuple
                                                [ErlangAtom "value", __v_225]
                                          in let
                                            arg_226 =
                                              ErlangTuple
                                                [ErlangAtom "assertMatch",
                                                 ErlangCons head_229
                                                   (ErlangCons head_233
                                                      (ErlangCons head_237
                                                         (ErlangCons head_241
                                                            (ErlangCons head_245
                                                               ErlangEmptyList))))]
                                          in BIF.erlang__error__1 [arg_226]
                                  lambda_221 [] = EXC.function_clause unit
                                  lambda_221 args =
                                    EXC.badarity (ErlangFun 0 lambda_221) args
                                in lambda_221)
                         in BIF.erlang__apply__2 [fun_220, ErlangEmptyList]
                       _ -> EXC.badmatch matchExpr_219
                 _ -> EXC.badmatch matchExpr_214
           lambda_182 [] = EXC.function_clause unit
           lambda_182 args = EXC.badarity (ErlangFun 0 lambda_182) args
         in lambda_182)
  in let head_179 = ErlangTuple [tup_el_180, tup_el_181]
  in let
    lop_251 =
      flmap
        (\ lc_258 ->
           let    lop_261 = toErl "Testing deadcode elimination for "
           in let rop_262 = BIF.erlang__atom_to_list__1 [lc_258]
           in let tup_el_260 = BIF.erlang__op_append [lop_261, rop_262]
           in let
             tup_el_264 =
               ErlangFun 0
                 (let
                    lambda_265 [] =
                      let    arg_267 = toErl "nodeadcode"
                      in let matchExpr_270 = erlps__compile__2 [lc_258, arg_267]
                      in
                        case matchExpr_270 of
                          (ErlangMap map_268) | (DM.Just nodeadcode_269) <-
                                                  (Map.lookup
                                                     (ErlangAtom "byte_code")
                                                     map_268) ->
                            let    arg_272 = toErl "deadcode"
                            in let
                              matchExpr_275 =
                                erlps__compile__2 [lc_258, arg_272]
                            in
                              case matchExpr_275 of
                                (ErlangMap map_273) | (DM.Just deadcode_274) <-
                                                        (Map.lookup
                                                           (ErlangAtom
                                                              "byte_code")
                                                           map_273) ->
                                  let   
                                    sizenodeadcode_277 =
                                      BIF.erlang__byte_size__1 [nodeadcode_269]
                                  in let
                                    sizedeadcode_279 =
                                      BIF.erlang__byte_size__1 [deadcode_274]
                                  in let
                                    delta_280 =
                                      case ErlangAtom "true" of
                                        _ | weakEq lc_258 (ErlangAtom "aevm") ->
                                          toErl 40
                                        _ | weakEq lc_258 (ErlangAtom "fate") ->
                                          toErl 20
                                        _ -> EXC.if_clause unit
                                  in let
                                    fun_281 =
                                      ErlangFun 0
                                        (let
                                           lambda_282 [] =
                                             let   
                                               lop_287 =
                                                 BIF.erlang__op_plus
                                                   [sizedeadcode_279, delta_280]
                                             in let
                                               tup_el_286 =
                                                 BIF.erlang__op_lesser
                                                   [lop_287, sizenodeadcode_277]
                                             in let
                                               case_283 =
                                                 ErlangTuple
                                                   [sizedeadcode_279,
                                                    sizenodeadcode_277,
                                                    tup_el_286]
                                             in
                                               case case_283 of
                                                 (ErlangTuple [_, _,
                                                               (ErlangAtom "true")]) ->
                                                   ErlangAtom "ok"
                                                 __v_291 ->
                                                   let   
                                                     head_295 =
                                                       ErlangTuple
                                                         [ErlangAtom "module",
                                                          ErlangAtom
                                                            "aeso_compiler_tests"]
                                                   in let tup_el_301 = toErl 90
                                                   in let
                                                     head_299 =
                                                       ErlangTuple
                                                         [ErlangAtom "line",
                                                          tup_el_301]
                                                   in let
                                                     tup_el_305 =
                                                       toErl
                                                         "{ SizeDeadCode , SizeNoDeadCode , SizeDeadCode + Delta < SizeNoDeadCode }"
                                                   in let
                                                     head_303 =
                                                       ErlangTuple
                                                         [ErlangAtom
                                                            "expression",
                                                          tup_el_305]
                                                   in let
                                                     tup_el_309 =
                                                       toErl "{ _ , _ , true }"
                                                   in let
                                                     head_307 =
                                                       ErlangTuple
                                                         [ErlangAtom "pattern",
                                                          tup_el_309]
                                                   in let
                                                     head_311 =
                                                       ErlangTuple
                                                         [ErlangAtom "value",
                                                          __v_291]
                                                   in let
                                                     arg_292 =
                                                       ErlangTuple
                                                         [ErlangAtom
                                                            "assertMatch",
                                                          ErlangCons head_295
                                                            (ErlangCons head_299
                                                               (ErlangCons
                                                                  head_303
                                                                  (ErlangCons
                                                                     head_307
                                                                     (ErlangCons
                                                                        head_311
                                                                        ErlangEmptyList))))]
                                                   in
                                                     BIF.erlang__error__1
                                                       [arg_292]
                                           lambda_282 [] =
                                             EXC.function_clause unit
                                           lambda_282 args =
                                             EXC.badarity
                                               (ErlangFun 0 lambda_282) args
                                         in lambda_282)
                                    _ =
                                      BIF.erlang__apply__2
                                        [fun_281, ErlangEmptyList]
                                  in ErlangAtom "ok"
                                _ -> EXC.badmatch matchExpr_275
                          _ -> EXC.badmatch matchExpr_270
                    lambda_265 [] = EXC.function_clause unit
                    lambda_265 args = EXC.badarity (ErlangFun 0 lambda_265) args
                  in lambda_265)
           in let lcRet_259 = ErlangTuple [tup_el_260, tup_el_264]
           in ErlangCons lcRet_259 ErlangEmptyList)
        (ErlangCons (ErlangAtom "aevm")
           (ErlangCons (ErlangAtom "fate") ErlangEmptyList))
  in let rop_250 = BIF.erlang__op_append [lop_251, ErlangEmptyList]
  in let
    rop_177 =
      BIF.erlang__op_append
        [ErlangCons head_179 ErlangEmptyList, rop_250]
  in let rop_136 = BIF.erlang__op_append [lop_137, rop_177]
  in let rop_119 = BIF.erlang__op_append [lop_120, rop_136]
  in let
    rop_104 =
      BIF.erlang__op_append
        [ErlangCons head_106 ErlangEmptyList, rop_119]
  in BIF.erlang__op_append [lop_0, rop_104]
erlps__simple_compile_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__simple_compile_test___0) args

erlps__check_errors__2 :: ErlangFun
erlps__check_errors__2 [(ErlangAtom "no_error"), actual_0] =
  let
    fun_1 =
      ErlangFun 0
        (let
           lambda_2 [] =
             case actual_0 of
               (ErlangMap map_4) -> ErlangAtom "ok"
               __v_5 ->
                 let   
                   head_9 =
                     ErlangTuple
                       [ErlangAtom "module", ErlangAtom "aeso_compiler_tests"]
                 in let tup_el_15 = toErl 95
                 in let head_13 = ErlangTuple [ErlangAtom "line", tup_el_15]
                 in let tup_el_19 = toErl "Actual"
                 in let
                   head_17 = ErlangTuple [ErlangAtom "expression", tup_el_19]
                 in let tup_el_23 = toErl "# { }"
                 in let head_21 = ErlangTuple [ErlangAtom "pattern", tup_el_23]
                 in let head_25 = ErlangTuple [ErlangAtom "value", __v_5]
                 in let
                   arg_6 =
                     ErlangTuple
                       [ErlangAtom "assertMatch",
                        ErlangCons head_9
                          (ErlangCons head_13
                             (ErlangCons head_17
                                (ErlangCons head_21
                                   (ErlangCons head_25 ErlangEmptyList))))]
                 in BIF.erlang__error__1 [arg_6]
           lambda_2 [] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 0 lambda_2) args
         in lambda_2)
  in BIF.erlang__apply__2 [fun_1, ErlangEmptyList]
erlps__check_errors__2 [expect_0, (ErlangMap map_1)] =
  let
    fun_2 =
      ErlangFun 0
        (let
           lambda_3 [] =
             let __x_6 = ErlangTuple [ErlangAtom "error", expect_0]
             in
               case ErlangAtom "ok" of
                 __x_8 | __x_8 == __x_6 -> ErlangAtom "ok"
                 __v_9 ->
                   let   
                     head_13 =
                       ErlangTuple
                         [ErlangAtom "module", ErlangAtom "aeso_compiler_tests"]
                   in let tup_el_19 = toErl 97
                   in let head_17 = ErlangTuple [ErlangAtom "line", tup_el_19]
                   in let tup_el_23 = toErl "ok"
                   in let
                     head_21 = ErlangTuple [ErlangAtom "expression", tup_el_23]
                   in let head_25 = ErlangTuple [ErlangAtom "expected", __x_6]
                   in let head_29 = ErlangTuple [ErlangAtom "value", __v_9]
                   in let
                     arg_10 =
                       ErlangTuple
                         [ErlangAtom "assertEqual",
                          ErlangCons head_13
                            (ErlangCons head_17
                               (ErlangCons head_21
                                  (ErlangCons head_25
                                     (ErlangCons head_29 ErlangEmptyList))))]
                   in BIF.erlang__error__1 [arg_10]
           lambda_3 [] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 0 lambda_3) args
         in lambda_3)
  in BIF.erlang__apply__2 [fun_2, ErlangEmptyList]
erlps__check_errors__2 [expect0_0, actual0_1] =
  let   
    expect_3 =
      BIF.do_remote_fun_call "Lists" "erlps__sort__1" [expect0_0]
  in let
    actual_11 =
      flmap
        (\ lc_6 ->
           let   
             arg_9 =
               BIF.do_remote_fun_call "Aeso.Errors" "erlps__pp__1" [lc_6]
           in let
             arg_8 = BIF.do_remote_fun_call "String" "erlps__trim__1" [arg_9]
           in let lcRet_7 = BIF.erlang__list_to_binary__1 [arg_8]
           in ErlangCons lcRet_7 ErlangEmptyList)
        actual0_1
  in let tup_el_13 = BIF.erlang__op_unAppend [expect_3, actual_11]
  in let tup_el_16 = BIF.erlang__op_unAppend [actual_11, expect_3]
  in let case_12 = ErlangTuple [tup_el_13, tup_el_16]
  in
    case case_12 of
      (ErlangTuple [(ErlangEmptyList), extra_19]) ->
        let
          fun_20 =
            ErlangFun 0
              (let
                 lambda_21 [] =
                   let case_22 = ErlangTuple [ErlangAtom "unexpected", extra_19]
                   in
                     case case_22 of
                       (ErlangTuple [(ErlangAtom "unexpected"),
                                     (ErlangEmptyList)]) ->
                         ErlangAtom "ok"
                       __v_25 ->
                         let   
                           head_29 =
                             ErlangTuple
                               [ErlangAtom "module",
                                ErlangAtom "aeso_compiler_tests"]
                         in let tup_el_35 = toErl 102
                         in let
                           head_33 = ErlangTuple [ErlangAtom "line", tup_el_35]
                         in let tup_el_39 = toErl "{ unexpected , Extra }"
                         in let
                           head_37 =
                             ErlangTuple [ErlangAtom "expression", tup_el_39]
                         in let tup_el_43 = toErl "{ unexpected , [ ] }"
                         in let
                           head_41 =
                             ErlangTuple [ErlangAtom "pattern", tup_el_43]
                         in let
                           head_45 = ErlangTuple [ErlangAtom "value", __v_25]
                         in let
                           arg_26 =
                             ErlangTuple
                               [ErlangAtom "assertMatch",
                                ErlangCons head_29
                                  (ErlangCons head_33
                                     (ErlangCons head_37
                                        (ErlangCons head_41
                                           (ErlangCons head_45
                                              ErlangEmptyList))))]
                         in BIF.erlang__error__1 [arg_26]
                 lambda_21 [] = EXC.function_clause unit
                 lambda_21 args = EXC.badarity (ErlangFun 0 lambda_21) args
               in lambda_21)
        in BIF.erlang__apply__2 [fun_20, ErlangEmptyList]
      (ErlangTuple [missing_49, (ErlangEmptyList)]) ->
        let
          fun_50 =
            ErlangFun 0
              (let
                 lambda_51 [] =
                   let case_52 = ErlangTuple [ErlangAtom "missing", missing_49]
                   in
                     case case_52 of
                       (ErlangTuple [(ErlangAtom "missing"),
                                     (ErlangEmptyList)]) ->
                         ErlangAtom "ok"
                       __v_55 ->
                         let   
                           head_59 =
                             ErlangTuple
                               [ErlangAtom "module",
                                ErlangAtom "aeso_compiler_tests"]
                         in let tup_el_65 = toErl 103
                         in let
                           head_63 = ErlangTuple [ErlangAtom "line", tup_el_65]
                         in let tup_el_69 = toErl "{ missing , Missing }"
                         in let
                           head_67 =
                             ErlangTuple [ErlangAtom "expression", tup_el_69]
                         in let tup_el_73 = toErl "{ missing , [ ] }"
                         in let
                           head_71 =
                             ErlangTuple [ErlangAtom "pattern", tup_el_73]
                         in let
                           head_75 = ErlangTuple [ErlangAtom "value", __v_55]
                         in let
                           arg_56 =
                             ErlangTuple
                               [ErlangAtom "assertMatch",
                                ErlangCons head_59
                                  (ErlangCons head_63
                                     (ErlangCons head_67
                                        (ErlangCons head_71
                                           (ErlangCons head_75
                                              ErlangEmptyList))))]
                         in BIF.erlang__error__1 [arg_56]
                 lambda_51 [] = EXC.function_clause unit
                 lambda_51 args = EXC.badarity (ErlangFun 0 lambda_51) args
               in lambda_51)
        in BIF.erlang__apply__2 [fun_50, ErlangEmptyList]
      (ErlangTuple [missing_79, extra_80]) ->
        let
          fun_81 =
            ErlangFun 0
              (let
                 lambda_82 [] =
                   case extra_80 of
                     __x_85 | __x_85 == missing_79 -> ErlangAtom "ok"
                     __v_86 ->
                       let   
                         head_90 =
                           ErlangTuple
                             [ErlangAtom "module",
                              ErlangAtom "aeso_compiler_tests"]
                       in let tup_el_96 = toErl 104
                       in let
                         head_94 = ErlangTuple [ErlangAtom "line", tup_el_96]
                       in let tup_el_100 = toErl "Extra"
                       in let
                         head_98 =
                           ErlangTuple [ErlangAtom "expression", tup_el_100]
                       in let
                         head_102 =
                           ErlangTuple [ErlangAtom "expected", missing_79]
                       in let
                         head_106 = ErlangTuple [ErlangAtom "value", __v_86]
                       in let
                         arg_87 =
                           ErlangTuple
                             [ErlangAtom "assertEqual",
                              ErlangCons head_90
                                (ErlangCons head_94
                                   (ErlangCons head_98
                                      (ErlangCons head_102
                                         (ErlangCons head_106
                                            ErlangEmptyList))))]
                       in BIF.erlang__error__1 [arg_87]
                 lambda_82 [] = EXC.function_clause unit
                 lambda_82 args = EXC.badarity (ErlangFun 0 lambda_82) args
               in lambda_82)
        in BIF.erlang__apply__2 [fun_81, ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__check_errors__2 [arg_110, arg_111] =
  EXC.function_clause unit
erlps__check_errors__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_errors__2) args

erlps__compile__2 :: ErlangFun
erlps__compile__2 [backend_0, name_1] =
  let   
    head_10 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__contract_path__0" []
  in let
    tup_el_7 =
      ErlangTuple
        [ErlangAtom "file_system", ErlangCons head_10 ErlangEmptyList]
  in let head_5 = ErlangTuple [ErlangAtom "include", tup_el_7]
  in
    erlps__compile__3
      [backend_0, name_1, ErlangCons head_5 ErlangEmptyList]
erlps__compile__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__compile__2 args =
  EXC.badarity (ErlangFun 2 erlps__compile__2) args

erlps__compile__3 :: ErlangFun
erlps__compile__3 [backend_0, name_1, options_2] =
  let   
    string_4 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__read_contract__1" [name_1]
  in let arg_8 = erlps__debug_mode_contracts__0 []
  in let case_6 = BIF.lists__member__2 [name_1, arg_8]
  in let
    lop_5 =
      case case_6 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "debug_mode") ErlangEmptyList
        (ErlangAtom "false") -> ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in let rop_17 = toErl ".aes"
  in let tup_el_15 = BIF.erlang__op_append [name_1, rop_17]
  in let head_13 = ErlangTuple [ErlangAtom "src_file", tup_el_15]
  in let head_19 = ErlangTuple [ErlangAtom "backend", backend_0]
  in let
    head_28 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__contract_path__0" []
  in let
    tup_el_25 =
      ErlangTuple
        [ErlangAtom "file_system", ErlangCons head_28 ErlangEmptyList]
  in let head_23 = ErlangTuple [ErlangAtom "include", tup_el_25]
  in let
    rop_11 =
      BIF.erlang__op_append
        [ErlangCons head_13
           (ErlangCons head_19 (ErlangCons head_23 ErlangEmptyList)),
         options_2]
  in let options1_32 = BIF.erlang__op_append [lop_5, rop_11]
  in let
    case_33 =
      BIF.do_remote_fun_call "Aeso.Compiler" "erlps__from_string__2"
        [string_4, options1_32]
  in
    case case_33 of
      (ErlangTuple [(ErlangAtom "ok"), map_36]) -> map_36
      (ErlangTuple [(ErlangAtom "error"), errorstring_37]) | isEBinary
                                                               errorstring_37 ->
        errorstring_37
      (ErlangTuple [(ErlangAtom "error"), errors_38]) -> errors_38
      something_else -> EXC.case_clause something_else
erlps__compile__3 [arg_39, arg_40, arg_41] =
  EXC.function_clause unit
erlps__compile__3 args =
  EXC.badarity (ErlangFun 3 erlps__compile__3) args

erlps__compilable_contracts__0 :: ErlangFun
erlps__compilable_contracts__0 [] =
  let    head_0 = toErl "complex_types"
  in let head_2 = toErl "counter"
  in let head_4 = toErl "dutch_auction"
  in let head_6 = toErl "environment"
  in let head_8 = toErl "factorial"
  in let head_10 = toErl "functions"
  in let head_12 = toErl "fundme"
  in let head_14 = toErl "identity"
  in let head_16 = toErl "maps"
  in let head_18 = toErl "oracles"
  in let head_20 = toErl "remote_call"
  in let head_22 = toErl "simple"
  in let head_24 = toErl "simple_storage"
  in let head_26 = toErl "spend_test"
  in let head_28 = toErl "stack"
  in let head_30 = toErl "test"
  in let head_32 = toErl "builtin_bug"
  in let head_34 = toErl "builtin_map_get_bug"
  in let head_36 = toErl "lc_record_bug"
  in let head_38 = toErl "nodeadcode"
  in let head_40 = toErl "deadcode"
  in let head_42 = toErl "variant_types"
  in let head_44 = toErl "state_handling"
  in let head_46 = toErl "events"
  in let head_48 = toErl "include"
  in let head_50 = toErl "basic_auth"
  in let head_52 = toErl "bitcoin_auth"
  in let head_54 = toErl "address_literals"
  in let head_56 = toErl "bytes_equality"
  in let head_58 = toErl "address_chain"
  in let head_60 = toErl "namespace_bug"
  in let head_62 = toErl "bytes_to_x"
  in let head_64 = toErl "bytes_concat"
  in let head_66 = toErl "aens"
  in let head_68 = toErl "tuple_match"
  in let head_70 = toErl "cyclic_include"
  in let head_72 = toErl "stdlib_include"
  in let head_74 = toErl "double_include"
  in let head_76 = toErl "manual_stdlib_include"
  in let head_78 = toErl "list_comp"
  in let head_80 = toErl "payable"
  in let head_82 = toErl "unapplied_builtins"
  in let head_84 = toErl "underscore_number_literals"
  in let head_86 = toErl "qualified_constructor"
  in let head_88 = toErl "let_patterns"
  in let head_90 = toErl "lhs_matching"
  in let head_92 = toErl "hermetization_turnoff"
  in
    ErlangCons head_0
      (ErlangCons head_2
         (ErlangCons head_4
            (ErlangCons head_6
               (ErlangCons head_8
                  (ErlangCons head_10
                     (ErlangCons head_12
                        (ErlangCons head_14
                           (ErlangCons head_16
                              (ErlangCons head_18
                                 (ErlangCons head_20
                                    (ErlangCons head_22
                                       (ErlangCons head_24
                                          (ErlangCons head_26
                                             (ErlangCons head_28
                                                (ErlangCons head_30
                                                   (ErlangCons head_32
                                                      (ErlangCons head_34
                                                         (ErlangCons head_36
                                                            (ErlangCons head_38
                                                               (ErlangCons
                                                                  head_40
                                                                  (ErlangCons
                                                                     head_42
                                                                     (ErlangCons
                                                                        head_44
                                                                        (ErlangCons
                                                                           head_46
                                                                           (ErlangCons
                                                                              head_48
                                                                              (ErlangCons
                                                                                 head_50
                                                                                 (ErlangCons
                                                                                    head_52
                                                                                    (ErlangCons
                                                                                       head_54
                                                                                       (ErlangCons
                                                                                          head_56
                                                                                          (ErlangCons
                                                                                             head_58
                                                                                             (ErlangCons
                                                                                                head_60
                                                                                                (ErlangCons
                                                                                                   head_62
                                                                                                   (ErlangCons
                                                                                                      head_64
                                                                                                      (ErlangCons
                                                                                                         head_66
                                                                                                         (ErlangCons
                                                                                                            head_68
                                                                                                            (ErlangCons
                                                                                                               head_70
                                                                                                               (ErlangCons
                                                                                                                  head_72
                                                                                                                  (ErlangCons
                                                                                                                     head_74
                                                                                                                     (ErlangCons
                                                                                                                        head_76
                                                                                                                        (ErlangCons
                                                                                                                           head_78
                                                                                                                           (ErlangCons
                                                                                                                              head_80
                                                                                                                              (ErlangCons
                                                                                                                                 head_82
                                                                                                                                 (ErlangCons
                                                                                                                                    head_84
                                                                                                                                    (ErlangCons
                                                                                                                                       head_86
                                                                                                                                       (ErlangCons
                                                                                                                                          head_88
                                                                                                                                          (ErlangCons
                                                                                                                                             head_90
                                                                                                                                             (ErlangCons
                                                                                                                                                head_92
                                                                                                                                                ErlangEmptyList))))))))))))))))))))))))))))))))))))))))))))))
erlps__compilable_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__compilable_contracts__0) args

erlps__not_compilable_on__1 :: ErlangFun
erlps__not_compilable_on__1 [(ErlangAtom "fate")] =
  ErlangEmptyList
erlps__not_compilable_on__1 [(ErlangAtom "aevm")] =
  let    head_0 = toErl "stdlib_include"
  in let head_2 = toErl "manual_stdlib_include"
  in let head_4 = toErl "hermetization_turnoff"
  in
    ErlangCons head_0
      (ErlangCons head_2 (ErlangCons head_4 ErlangEmptyList))
erlps__not_compilable_on__1 [arg_6] = EXC.function_clause unit
erlps__not_compilable_on__1 args =
  EXC.badarity (ErlangFun 1 erlps__not_compilable_on__1) args

erlps__debug_mode_contracts__0 :: ErlangFun
erlps__debug_mode_contracts__0 [] =
  let head_0 = toErl "hermetization_turnoff"
  in ErlangCons head_0 ErlangEmptyList
erlps__debug_mode_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__debug_mode_contracts__0) args

erlps__failing_contracts__0 :: ErlangFun
erlps__failing_contracts__0 [] =
  let
    matchExpr_1 =
      BIF.do_remote_fun_call "Aeso.Compiler"
        "erlps__numeric_version__0" []
  in
    case matchExpr_1 of
      (ErlangTuple [(ErlangAtom "ok"), v_0]) ->
        let   
          arg_3 =
            flmap
              (\ lc_6 ->
                 let lcRet_7 = BIF.erlang__integer_to_list__1 [lc_6]
                 in ErlangCons lcRet_7 ErlangEmptyList)
              v_0
        in let arg_9 = toErl "."
        in let
          arg_2 =
            BIF.do_remote_fun_call "String" "erlps__join__2" [arg_3, arg_9]
        in let version_10 = BIF.erlang__list_to_binary__1 [arg_2]
        in let
          fun_12 =
            ErlangFun 0
              (let
                 lambda_13 [] =
                   let    __kind_14 = toErl "Parse"
                   in let __file_15 = toErl "field_parse_error"
                   in let bin_el_19 = BIF.erlang__list_to_binary__1 [__kind_14]
                   in let bin_el_21 = BIF.erlang__list_to_binary__1 [__file_15]
                   in let
                     head_18 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_19 (BIN.packedSize bin_el_19)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_21 (BIN.packedSize bin_el_21)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 26:\nCannot use nested fields or keys in record construction: p.x")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_15, ErlangCons head_18 ErlangEmptyList]
                 lambda_13 [] = EXC.function_clause unit
                 lambda_13 args = EXC.badarity (ErlangFun 0 lambda_13) args
               in lambda_13)
        in let head_11 = BIF.erlang__apply__2 [fun_12, ErlangEmptyList]
        in let
          fun_26 =
            ErlangFun 0
              (let
                 lambda_27 [] =
                   let    __kind_28 = toErl "Parse"
                   in let __file_29 = toErl "vsemi"
                   in let bin_el_33 = BIF.erlang__list_to_binary__1 [__kind_28]
                   in let bin_el_35 = BIF.erlang__list_to_binary__1 [__file_29]
                   in let
                     head_32 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_33 (BIN.packedSize bin_el_33)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_35 (BIN.packedSize bin_el_35)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 3:\nUnexpected indentation. Did you forget a \'}\'?")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_29, ErlangCons head_32 ErlangEmptyList]
                 lambda_27 [] = EXC.function_clause unit
                 lambda_27 args = EXC.badarity (ErlangFun 0 lambda_27) args
               in lambda_27)
        in let head_25 = BIF.erlang__apply__2 [fun_26, ErlangEmptyList]
        in let
          fun_40 =
            ErlangFun 0
              (let
                 lambda_41 [] =
                   let    __kind_42 = toErl "Parse"
                   in let __file_43 = toErl "vclose"
                   in let bin_el_47 = BIF.erlang__list_to_binary__1 [__kind_42]
                   in let bin_el_49 = BIF.erlang__list_to_binary__1 [__file_43]
                   in let
                     head_46 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_47 (BIN.packedSize bin_el_47)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_49 (BIN.packedSize bin_el_49)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 3:\nUnexpected indentation. Did you forget a \']\'?")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_43, ErlangCons head_46 ErlangEmptyList]
                 lambda_41 [] = EXC.function_clause unit
                 lambda_41 args = EXC.badarity (ErlangFun 0 lambda_41) args
               in lambda_41)
        in let head_39 = BIF.erlang__apply__2 [fun_40, ErlangEmptyList]
        in let
          fun_54 =
            ErlangFun 0
              (let
                 lambda_55 [] =
                   let    __kind_56 = toErl "Parse"
                   in let __file_57 = toErl "indent_fail"
                   in let bin_el_61 = BIF.erlang__list_to_binary__1 [__kind_56]
                   in let bin_el_63 = BIF.erlang__list_to_binary__1 [__file_57]
                   in let
                     head_60 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_61 (BIN.packedSize bin_el_61)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_63 (BIN.packedSize bin_el_63)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 2:\nUnexpected token \'entrypoint\'.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_57, ErlangCons head_60 ErlangEmptyList]
                 lambda_55 [] = EXC.function_clause unit
                 lambda_55 args = EXC.badarity (ErlangFun 0 lambda_55) args
               in lambda_55)
        in let head_53 = BIF.erlang__apply__2 [fun_54, ErlangEmptyList]
        in let
          fun_68 =
            ErlangFun 0
              (let
                 lambda_69 [] =
                   let    __kind_70 = toErl "Type"
                   in let __file_71 = toErl "name_clash"
                   in let bin_el_75 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_77 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_74 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_75 (BIN.packedSize bin_el_75)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_77 (BIN.packedSize bin_el_77)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 3:\nDuplicate definitions of abort at\n  - (builtin location)\n  - line 14, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_81 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_83 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_80 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_81 (BIN.packedSize bin_el_81)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_83 (BIN.packedSize bin_el_83)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 3:\nDuplicate definitions of require at\n  - (builtin location)\n  - line 15, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_87 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_89 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_86 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_87 (BIN.packedSize bin_el_87)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_89 (BIN.packedSize bin_el_89)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 3:\nDuplicate definitions of double_def at\n  - line 10, column 3\n  - line 11, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_93 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_95 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_92 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_93 (BIN.packedSize bin_el_93)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_95 (BIN.packedSize bin_el_95)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 3:\nDuplicate definitions of double_proto at\n  - line 4, column 3\n  - line 5, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_99 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_101 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_98 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_99 (BIN.packedSize bin_el_99)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_101
                               (BIN.packedSize bin_el_101) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 8, col 3:\nDuplicate definitions of proto_and_def at\n  - line 7, column 3\n  - line 8, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_105 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_107 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_104 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_105
                               (BIN.packedSize bin_el_105) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_107
                               (BIN.packedSize bin_el_107) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 3:\nDuplicate definitions of put at\n  - (builtin location)\n  - line 16, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_111 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_113 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_110 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_111
                               (BIN.packedSize bin_el_111) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_113
                               (BIN.packedSize bin_el_113) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 17, col 3:\nDuplicate definitions of state at\n  - (builtin location)\n  - line 17, column 3")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_71,
                        ErlangCons head_74
                          (ErlangCons head_80
                             (ErlangCons head_86
                                (ErlangCons head_92
                                   (ErlangCons head_98
                                      (ErlangCons head_104
                                         (ErlangCons head_110
                                            ErlangEmptyList))))))]
                 lambda_69 [] = EXC.function_clause unit
                 lambda_69 args = EXC.badarity (ErlangFun 0 lambda_69) args
               in lambda_69)
        in let head_67 = BIF.erlang__apply__2 [fun_68, ErlangEmptyList]
        in let
          fun_118 =
            ErlangFun 0
              (let
                 lambda_119 [] =
                   let    __kind_120 = toErl "Type"
                   in let __file_121 = toErl "type_errors"
                   in let
                     bin_el_125 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_127 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_124 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_125
                               (BIN.packedSize bin_el_125) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_127
                               (BIN.packedSize bin_el_127) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 17, col 23:\nUnbound variable zz at line 17, column 23")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_131 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_133 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_130 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_131
                               (BIN.packedSize bin_el_131) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_133
                               (BIN.packedSize bin_el_133) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 26, col 9:\nCannot unify int\n         and list(int)\nwhen checking the application at line 26, column 9 of\n  (::) : (int, list(int)) => list(int)\nto arguments\n  x : int\n  x : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_137 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_139 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_136 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_137
                               (BIN.packedSize bin_el_137) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_139
                               (BIN.packedSize bin_el_139) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 48:\nCannot unify string\n         and int\nwhen checking the assignment of the field\n  x : map(string, string) (at line 9, column 48)\nto the old value __x and the new value\n  __x {[\"foo\"] @ x = x + 1} : map(string, int)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_143 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_145 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_142 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_143
                               (BIN.packedSize bin_el_143) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_145
                               (BIN.packedSize bin_el_145) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 34, col 47:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 34, column 47\n  1 : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_149 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_151 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_148 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_149
                               (BIN.packedSize bin_el_149) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_151
                               (BIN.packedSize bin_el_151) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 34, col 52:\nCannot unify string\n         and int\nwhen checking the type of the expression at line 34, column 52\n  \"bla\" : string\nagainst the expected type\n  int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_155 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_157 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_154 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_155
                               (BIN.packedSize bin_el_155) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_157
                               (BIN.packedSize bin_el_157) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 32, col 18:\nCannot unify string\n         and int\nwhen checking the type of the expression at line 32, column 18\n  \"x\" : string\nagainst the expected type\n  int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_161 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_163 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_160 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_161
                               (BIN.packedSize bin_el_161) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_163
                               (BIN.packedSize bin_el_163) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 58:\nCannot unify string\n         and int\nwhen checking the type of the expression at line 11, column 58\n  \"foo\" : string\nagainst the expected type\n  int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_167 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_169 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_166 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_167
                               (BIN.packedSize bin_el_167) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_169
                               (BIN.packedSize bin_el_169) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 38, col 13:\nCannot unify int\n         and string\nwhen comparing the types of the if-branches\n  - w : int (at line 38, column 13)\n  - z : string (at line 39, column 10)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_173 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_175 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_172 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_173
                               (BIN.packedSize bin_el_173) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_175
                               (BIN.packedSize bin_el_175) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 22, col 40:\nNot a record type: string\narising from the projection of the field y (at line 22, column 40)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_179 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_181 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_178 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_179
                               (BIN.packedSize bin_el_179) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_181
                               (BIN.packedSize bin_el_181) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 21, col 44:\nNot a record type: string\narising from an assignment of the field y (at line 21, column 44)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_185 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_187 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_184 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_185
                               (BIN.packedSize bin_el_185) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_187
                               (BIN.packedSize bin_el_187) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 20, col 40:\nNot a record type: string\narising from an assignment of the field y (at line 20, column 40)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_191 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_193 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_190 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_191
                               (BIN.packedSize bin_el_191) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_193
                               (BIN.packedSize bin_el_193) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 19, col 37:\nNot a record type: string\narising from an assignment of the field y (at line 19, column 37)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_197 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_199 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_196 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_197
                               (BIN.packedSize bin_el_197) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_199
                               (BIN.packedSize bin_el_199) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 27:\nAmbiguous record type with field y (at line 13, column 27) could be one of\n  - r (at line 4, column 10)\n  - r\' (at line 5, column 10)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_203 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_205 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_202 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_203
                               (BIN.packedSize bin_el_203) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_205
                               (BIN.packedSize bin_el_205) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 26, col 7:\nRepeated name x in pattern\n  x :: x (at line 26, column 7)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_209 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_211 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_208 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_209
                               (BIN.packedSize bin_el_209) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_211
                               (BIN.packedSize bin_el_211) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 44, col 14:\nRepeated names x, y in pattern\n  (x : int, y, x : string, y : bool) (at line 44, column 14)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_215 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_217 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_214 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_215
                               (BIN.packedSize bin_el_215) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_217
                               (BIN.packedSize bin_el_217) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 44, col 39:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 44, column 39\n  x : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_221 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_223 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_220 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_221
                               (BIN.packedSize bin_el_221) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_223
                               (BIN.packedSize bin_el_223) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 44, col 72:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 44, column 72\n  x : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_227 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_229 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_226 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_227
                               (BIN.packedSize bin_el_227) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_229
                               (BIN.packedSize bin_el_229) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 24:\nNo record type with fields y, z (at line 14, column 24)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_233 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_235 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_232 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_233
                               (BIN.packedSize bin_el_233) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_235
                               (BIN.packedSize bin_el_235) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 26:\nThe field z is missing when constructing an element of type r2 (at line 15, column 26)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_239 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_241 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_238 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_239
                               (BIN.packedSize bin_el_239) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_241
                               (BIN.packedSize bin_el_241) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 24:\nRecord type r2 does not have field y (at line 15, column 24)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_245 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_247 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_244 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_245
                               (BIN.packedSize bin_el_245) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_247
                               (BIN.packedSize bin_el_247) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 47, col 5:\nLet binding at line 47, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_251 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_253 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_250 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_251
                               (BIN.packedSize bin_el_251) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_253
                               (BIN.packedSize bin_el_253) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 50, col 5:\nLet binding at line 50, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_257 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_259 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_256 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_257
                               (BIN.packedSize bin_el_257) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_259
                               (BIN.packedSize bin_el_259) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 54, col 5:\nLet binding at line 54, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_263 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_265 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_262 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_263
                               (BIN.packedSize bin_el_263) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_265
                               (BIN.packedSize bin_el_265) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 58, col 5:\nLet binding at line 58, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_269 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_271 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_268 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_269
                               (BIN.packedSize bin_el_269) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_271
                               (BIN.packedSize bin_el_271) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 63, col 5:\nCannot unify int\n         and bool\nwhen checking the type of the expression at line 63, column 5\n  id(n) : int\nagainst the expected type\n  bool")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_121,
                        ErlangCons head_124
                          (ErlangCons head_130
                             (ErlangCons head_136
                                (ErlangCons head_142
                                   (ErlangCons head_148
                                      (ErlangCons head_154
                                         (ErlangCons head_160
                                            (ErlangCons head_166
                                               (ErlangCons head_172
                                                  (ErlangCons head_178
                                                     (ErlangCons head_184
                                                        (ErlangCons head_190
                                                           (ErlangCons head_196
                                                              (ErlangCons
                                                                 head_202
                                                                 (ErlangCons
                                                                    head_208
                                                                    (ErlangCons
                                                                       head_214
                                                                       (ErlangCons
                                                                          head_220
                                                                          (ErlangCons
                                                                             head_226
                                                                             (ErlangCons
                                                                                head_232
                                                                                (ErlangCons
                                                                                   head_238
                                                                                   (ErlangCons
                                                                                      head_244
                                                                                      (ErlangCons
                                                                                         head_250
                                                                                         (ErlangCons
                                                                                            head_256
                                                                                            (ErlangCons
                                                                                               head_262
                                                                                               (ErlangCons
                                                                                                  head_268
                                                                                                  ErlangEmptyList))))))))))))))))))))))))]
                 lambda_119 [] = EXC.function_clause unit
                 lambda_119 args = EXC.badarity (ErlangFun 0 lambda_119) args
               in lambda_119)
        in let head_117 = BIF.erlang__apply__2 [fun_118, ErlangEmptyList]
        in let
          fun_276 =
            ErlangFun 0
              (let
                 lambda_277 [] =
                   let    __kind_278 = toErl "Type"
                   in let __file_279 = toErl "init_type_error"
                   in let
                     bin_el_283 = BIF.erlang__list_to_binary__1 [__kind_278]
                   in let
                     bin_el_285 = BIF.erlang__list_to_binary__1 [__file_279]
                   in let
                     head_282 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_283
                               (BIN.packedSize bin_el_283) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_285
                               (BIN.packedSize bin_el_285) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 3:\nCannot unify string\n         and map(int, int)\nwhen checking that \'init\' returns a value of type \'state\' at line 7, column 3")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_279, ErlangCons head_282 ErlangEmptyList]
                 lambda_277 [] = EXC.function_clause unit
                 lambda_277 args = EXC.badarity (ErlangFun 0 lambda_277) args
               in lambda_277)
        in let head_275 = BIF.erlang__apply__2 [fun_276, ErlangEmptyList]
        in let
          fun_290 =
            ErlangFun 0
              (let
                 lambda_291 [] =
                   let    __kind_292 = toErl "Type"
                   in let __file_293 = toErl "missing_state_type"
                   in let
                     bin_el_297 = BIF.erlang__list_to_binary__1 [__kind_292]
                   in let
                     bin_el_299 = BIF.erlang__list_to_binary__1 [__file_293]
                   in let
                     head_296 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_297
                               (BIN.packedSize bin_el_297) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_299
                               (BIN.packedSize bin_el_299) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 3:\nCannot unify string\n         and unit\nwhen checking that \'init\' returns a value of type \'state\' at line 5, column 3")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_293, ErlangCons head_296 ErlangEmptyList]
                 lambda_291 [] = EXC.function_clause unit
                 lambda_291 args = EXC.badarity (ErlangFun 0 lambda_291) args
               in lambda_291)
        in let head_289 = BIF.erlang__apply__2 [fun_290, ErlangEmptyList]
        in let
          fun_304 =
            ErlangFun 0
              (let
                 lambda_305 [] =
                   let    __kind_306 = toErl "Type"
                   in let
                     __file_307 = toErl "missing_fields_in_record_expression"
                   in let
                     bin_el_311 = BIF.erlang__list_to_binary__1 [__kind_306]
                   in let
                     bin_el_313 = BIF.erlang__list_to_binary__1 [__file_307]
                   in let
                     head_310 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_311
                               (BIN.packedSize bin_el_311) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_313
                               (BIN.packedSize bin_el_313) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 42:\nThe field x is missing when constructing an element of type r(\'a) (at line 7, column 42)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_317 = BIF.erlang__list_to_binary__1 [__kind_306]
                   in let
                     bin_el_319 = BIF.erlang__list_to_binary__1 [__file_307]
                   in let
                     head_316 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_317
                               (BIN.packedSize bin_el_317) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_319
                               (BIN.packedSize bin_el_319) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 8, col 42:\nThe field y is missing when constructing an element of type r(int) (at line 8, column 42)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_323 = BIF.erlang__list_to_binary__1 [__kind_306]
                   in let
                     bin_el_325 = BIF.erlang__list_to_binary__1 [__file_307]
                   in let
                     head_322 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_323
                               (BIN.packedSize bin_el_323) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_325
                               (BIN.packedSize bin_el_325) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 42:\nThe fields y, z are missing when constructing an element of type r(\'a) (at line 6, column 42)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_307,
                        ErlangCons head_310
                          (ErlangCons head_316
                             (ErlangCons head_322 ErlangEmptyList))]
                 lambda_305 [] = EXC.function_clause unit
                 lambda_305 args = EXC.badarity (ErlangFun 0 lambda_305) args
               in lambda_305)
        in let head_303 = BIF.erlang__apply__2 [fun_304, ErlangEmptyList]
        in let
          fun_330 =
            ErlangFun 0
              (let
                 lambda_331 [] =
                   let    __kind_332 = toErl "Type"
                   in let __file_333 = toErl "namespace_clash"
                   in let
                     bin_el_337 = BIF.erlang__list_to_binary__1 [__kind_332]
                   in let
                     bin_el_339 = BIF.erlang__list_to_binary__1 [__file_333]
                   in let
                     head_336 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_337
                               (BIN.packedSize bin_el_337) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_339
                               (BIN.packedSize bin_el_339) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 10:\nThe contract Call (at line 4, column 10) has the same name as a namespace at (builtin location)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_333, ErlangCons head_336 ErlangEmptyList]
                 lambda_331 [] = EXC.function_clause unit
                 lambda_331 args = EXC.badarity (ErlangFun 0 lambda_331) args
               in lambda_331)
        in let head_329 = BIF.erlang__apply__2 [fun_330, ErlangEmptyList]
        in let
          fun_344 =
            ErlangFun 0
              (let
                 lambda_345 [] =
                   let    __kind_346 = toErl "Type"
                   in let __file_347 = toErl "bad_events"
                   in let
                     bin_el_351 = BIF.erlang__list_to_binary__1 [__kind_346]
                   in let
                     bin_el_353 = BIF.erlang__list_to_binary__1 [__file_347]
                   in let
                     head_350 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_351
                               (BIN.packedSize bin_el_351) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_353
                               (BIN.packedSize bin_el_353) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 25:\nThe indexed type string (at line 9, column 25) is not a word type")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_357 = BIF.erlang__list_to_binary__1 [__kind_346]
                   in let
                     bin_el_359 = BIF.erlang__list_to_binary__1 [__file_347]
                   in let
                     head_356 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_357
                               (BIN.packedSize bin_el_357) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_359
                               (BIN.packedSize bin_el_359) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 25:\nThe indexed type alias_string (at line 10, column 25) equals string which is not a word type")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_347,
                        ErlangCons head_350
                          (ErlangCons head_356 ErlangEmptyList)]
                 lambda_345 [] = EXC.function_clause unit
                 lambda_345 args = EXC.badarity (ErlangFun 0 lambda_345) args
               in lambda_345)
        in let head_343 = BIF.erlang__apply__2 [fun_344, ErlangEmptyList]
        in let
          fun_364 =
            ErlangFun 0
              (let
                 lambda_365 [] =
                   let    __kind_366 = toErl "Type"
                   in let __file_367 = toErl "bad_events2"
                   in let
                     bin_el_371 = BIF.erlang__list_to_binary__1 [__kind_366]
                   in let
                     bin_el_373 = BIF.erlang__list_to_binary__1 [__file_367]
                   in let
                     head_370 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_371
                               (BIN.packedSize bin_el_371) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_373
                               (BIN.packedSize bin_el_373) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 7:\nThe event constructor BadEvent1 (at line 9, column 7) has too many non-indexed values (max 1)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_377 = BIF.erlang__list_to_binary__1 [__kind_366]
                   in let
                     bin_el_379 = BIF.erlang__list_to_binary__1 [__file_367]
                   in let
                     head_376 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_377
                               (BIN.packedSize bin_el_377) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_379
                               (BIN.packedSize bin_el_379) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 7:\nThe event constructor BadEvent2 (at line 10, column 7) has too many indexed values (max 3)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_367,
                        ErlangCons head_370
                          (ErlangCons head_376 ErlangEmptyList)]
                 lambda_365 [] = EXC.function_clause unit
                 lambda_365 args = EXC.badarity (ErlangFun 0 lambda_365) args
               in lambda_365)
        in let head_363 = BIF.erlang__apply__2 [fun_364, ErlangEmptyList]
        in let
          fun_384 =
            ErlangFun 0
              (let
                 lambda_385 [] =
                   let    __kind_386 = toErl "Type"
                   in let __file_387 = toErl "type_clash"
                   in let
                     bin_el_391 = BIF.erlang__list_to_binary__1 [__kind_386]
                   in let
                     bin_el_393 = BIF.erlang__list_to_binary__1 [__file_387]
                   in let
                     head_390 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_391
                               (BIN.packedSize bin_el_391) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_393
                               (BIN.packedSize bin_el_393) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 42:\nCannot unify int\n         and string\nwhen checking the record projection at line 12, column 42\n  r.foo : (gas : int, value : int) => Remote.themap\nagainst the expected type\n  (gas : int, value : int) => map(string, int)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_387, ErlangCons head_390 ErlangEmptyList]
                 lambda_385 [] = EXC.function_clause unit
                 lambda_385 args = EXC.badarity (ErlangFun 0 lambda_385) args
               in lambda_385)
        in let head_383 = BIF.erlang__apply__2 [fun_384, ErlangEmptyList]
        in let
          fun_398 =
            ErlangFun 0
              (let
                 lambda_399 [] =
                   let    __kind_400 = toErl "Type"
                   in let __file_401 = toErl "not_toplevel_include"
                   in let
                     bin_el_405 = BIF.erlang__list_to_binary__1 [__kind_400]
                   in let
                     bin_el_407 = BIF.erlang__list_to_binary__1 [__file_401]
                   in let
                     head_404 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_405
                               (BIN.packedSize bin_el_405) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_407
                               (BIN.packedSize bin_el_407) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 11:\nInclude of \'included.aes\' at line 2, column 11\nnot allowed, include only allowed at top level.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_401, ErlangCons head_404 ErlangEmptyList]
                 lambda_399 [] = EXC.function_clause unit
                 lambda_399 args = EXC.badarity (ErlangFun 0 lambda_399) args
               in lambda_399)
        in let head_397 = BIF.erlang__apply__2 [fun_398, ErlangEmptyList]
        in let
          fun_412 =
            ErlangFun 0
              (let
                 lambda_413 [] =
                   let    __kind_414 = toErl "Type"
                   in let __file_415 = toErl "not_toplevel_namespace"
                   in let
                     bin_el_419 = BIF.erlang__list_to_binary__1 [__kind_414]
                   in let
                     bin_el_421 = BIF.erlang__list_to_binary__1 [__file_415]
                   in let
                     head_418 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_419
                               (BIN.packedSize bin_el_419) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_421
                               (BIN.packedSize bin_el_421) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 13:\nNested namespaces are not allowed\nNamespace \'Foo\' at line 2, column 13 not defined at top level.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_415, ErlangCons head_418 ErlangEmptyList]
                 lambda_413 [] = EXC.function_clause unit
                 lambda_413 args = EXC.badarity (ErlangFun 0 lambda_413) args
               in lambda_413)
        in let head_411 = BIF.erlang__apply__2 [fun_412, ErlangEmptyList]
        in let
          fun_426 =
            ErlangFun 0
              (let
                 lambda_427 [] =
                   let    __kind_428 = toErl "Type"
                   in let __file_429 = toErl "not_toplevel_contract"
                   in let
                     bin_el_433 = BIF.erlang__list_to_binary__1 [__kind_428]
                   in let
                     bin_el_435 = BIF.erlang__list_to_binary__1 [__file_429]
                   in let
                     head_432 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_433
                               (BIN.packedSize bin_el_433) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_435
                               (BIN.packedSize bin_el_435) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 12:\nNested contracts are not allowed\nContract \'Con\' at line 2, column 12 not defined at top level.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_429, ErlangCons head_432 ErlangEmptyList]
                 lambda_427 [] = EXC.function_clause unit
                 lambda_427 args = EXC.badarity (ErlangFun 0 lambda_427) args
               in lambda_427)
        in let head_425 = BIF.erlang__apply__2 [fun_426, ErlangEmptyList]
        in let
          fun_440 =
            ErlangFun 0
              (let
                 lambda_441 [] =
                   let    __kind_442 = toErl "Type"
                   in let __file_443 = toErl "bad_address_literals"
                   in let
                     bin_el_447 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_449 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_446 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_447
                               (BIN.packedSize bin_el_447) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_449
                               (BIN.packedSize bin_el_449) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 5:\nCannot unify address\n         and oracle(int, bool)\nwhen checking the type of the expression at line 11, column 5\n  ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt : address\nagainst the expected type\n  oracle(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_453 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_455 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_452 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_453
                               (BIN.packedSize bin_el_453) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_455
                               (BIN.packedSize bin_el_455) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 5:\nCannot unify address\n         and Remote\nwhen checking the type of the expression at line 9, column 5\n  ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt : address\nagainst the expected type\n  Remote")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_459 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_461 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_458 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_459
                               (BIN.packedSize bin_el_459) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_461
                               (BIN.packedSize bin_el_461) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 5:\nCannot unify address\n         and bytes(32)\nwhen checking the type of the expression at line 7, column 5\n  ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt : address\nagainst the expected type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_465 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_467 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_464 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_465
                               (BIN.packedSize bin_el_465) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_467
                               (BIN.packedSize bin_el_467) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 5:\nCannot unify oracle(\'a, \'b)\n         and oracle_query(int, bool)\nwhen checking the type of the expression at line 14, column 5\n  ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 :\n    oracle(\'a, \'b)\nagainst the expected type\n  oracle_query(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_471 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_473 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_470 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_471
                               (BIN.packedSize bin_el_471) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_473
                               (BIN.packedSize bin_el_473) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 5:\nCannot unify oracle(\'c, \'d)\n         and bytes(32)\nwhen checking the type of the expression at line 16, column 5\n  ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 :\n    oracle(\'c, \'d)\nagainst the expected type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_477 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_479 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_476 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_477
                               (BIN.packedSize bin_el_477) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_479
                               (BIN.packedSize bin_el_479) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 18, col 5:\nCannot unify oracle(\'e, \'f)\n         and Remote\nwhen checking the type of the expression at line 18, column 5\n  ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 :\n    oracle(\'e, \'f)\nagainst the expected type\n  Remote")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_483 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_485 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_482 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_483
                               (BIN.packedSize bin_el_483) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_485
                               (BIN.packedSize bin_el_485) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 21, col 5:\nCannot unify oracle_query(\'g, \'h)\n         and oracle(int, bool)\nwhen checking the type of the expression at line 21, column 5\n  oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY :\n    oracle_query(\'g, \'h)\nagainst the expected type\n  oracle(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_489 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_491 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_488 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_489
                               (BIN.packedSize bin_el_489) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_491
                               (BIN.packedSize bin_el_491) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 23, col 5:\nCannot unify oracle_query(\'i, \'j)\n         and bytes(32)\nwhen checking the type of the expression at line 23, column 5\n  oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY :\n    oracle_query(\'i, \'j)\nagainst the expected type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_495 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_497 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_494 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_495
                               (BIN.packedSize bin_el_495) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_497
                               (BIN.packedSize bin_el_497) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 25, col 5:\nCannot unify oracle_query(\'k, \'l)\n         and Remote\nwhen checking the type of the expression at line 25, column 5\n  oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY :\n    oracle_query(\'k, \'l)\nagainst the expected type\n  Remote")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_501 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_503 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_500 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_501
                               (BIN.packedSize bin_el_501) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_503
                               (BIN.packedSize bin_el_503) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 28, col 5:\nThe type address is not a contract type\nwhen checking that the contract literal\n  ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\nhas the type\n  address")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_507 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_509 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_506 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_507
                               (BIN.packedSize bin_el_507) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_509
                               (BIN.packedSize bin_el_509) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 30, col 5:\nThe type oracle(int, bool) is not a contract type\nwhen checking that the contract literal\n  ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\nhas the type\n  oracle(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_513 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_515 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_512 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_513
                               (BIN.packedSize bin_el_513) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_515
                               (BIN.packedSize bin_el_515) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 32, col 5:\nThe type bytes(32) is not a contract type\nwhen checking that the contract literal\n  ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\nhas the type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_519 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_521 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_518 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_519
                               (BIN.packedSize bin_el_519) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_521
                               (BIN.packedSize bin_el_521) 8,
                             BIN.fromInts (toErl ".aes\' at line 34, col 5:\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "The type address is not a contract type\nwhen checking that the call to\n  Address.to_contract\nhas the type\n  address")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_443,
                        ErlangCons head_446
                          (ErlangCons head_452
                             (ErlangCons head_458
                                (ErlangCons head_464
                                   (ErlangCons head_470
                                      (ErlangCons head_476
                                         (ErlangCons head_482
                                            (ErlangCons head_488
                                               (ErlangCons head_494
                                                  (ErlangCons head_500
                                                     (ErlangCons head_506
                                                        (ErlangCons head_512
                                                           (ErlangCons head_518
                                                              ErlangEmptyList))))))))))))]
                 lambda_441 [] = EXC.function_clause unit
                 lambda_441 args = EXC.badarity (ErlangFun 0 lambda_441) args
               in lambda_441)
        in let head_439 = BIF.erlang__apply__2 [fun_440, ErlangEmptyList]
        in let
          fun_526 =
            ErlangFun 0
              (let
                 lambda_527 [] =
                   let    __kind_528 = toErl "Type"
                   in let __file_529 = toErl "stateful"
                   in let
                     bin_el_533 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_535 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_532 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_533
                               (BIN.packedSize bin_el_533) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_535
                               (BIN.packedSize bin_el_535) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 35:\nCannot reference stateful function Chain.spend (at line 13, column 35)\nin the definition of non-stateful function fail1.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_539 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_541 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_538 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_539
                               (BIN.packedSize bin_el_539) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_541
                               (BIN.packedSize bin_el_541) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 35:\nCannot reference stateful function local_spend (at line 14, column 35)\nin the definition of non-stateful function fail2.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_545 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_547 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_544 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_545
                               (BIN.packedSize bin_el_545) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_547
                               (BIN.packedSize bin_el_547) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 15:\nCannot reference stateful function Chain.spend (at line 16, column 15)\nin the definition of non-stateful function fail3.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_551 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_553 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_550 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_551
                               (BIN.packedSize bin_el_551) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_553
                               (BIN.packedSize bin_el_553) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 20, col 31:\nCannot reference stateful function Chain.spend (at line 20, column 31)\nin the definition of non-stateful function fail4.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_557 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_559 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_556 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_557
                               (BIN.packedSize bin_el_557) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_559
                               (BIN.packedSize bin_el_559) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 35, col 47:\nCannot reference stateful function Chain.spend (at line 35, column 47)\nin the definition of non-stateful function fail5.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_563 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_565 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_562 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_563
                               (BIN.packedSize bin_el_563) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_565
                               (BIN.packedSize bin_el_565) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 48, col 57:\nCannot pass non-zero value argument 1000 (at line 48, column 57)\nin the definition of non-stateful function fail6.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_569 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_571 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_568 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_569
                               (BIN.packedSize bin_el_569) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_571
                               (BIN.packedSize bin_el_571) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 49, col 56:\nCannot pass non-zero value argument 1000 (at line 49, column 56)\nin the definition of non-stateful function fail7.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_575 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_577 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_574 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_575
                               (BIN.packedSize bin_el_575) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_577
                               (BIN.packedSize bin_el_577) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 52, col 17:\nCannot pass non-zero value argument 1000 (at line 52, column 17)\nin the definition of non-stateful function fail8.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_529,
                        ErlangCons head_532
                          (ErlangCons head_538
                             (ErlangCons head_544
                                (ErlangCons head_550
                                   (ErlangCons head_556
                                      (ErlangCons head_562
                                         (ErlangCons head_568
                                            (ErlangCons head_574
                                               ErlangEmptyList)))))))]
                 lambda_527 [] = EXC.function_clause unit
                 lambda_527 args = EXC.badarity (ErlangFun 0 lambda_527) args
               in lambda_527)
        in let head_525 = BIF.erlang__apply__2 [fun_526, ErlangEmptyList]
        in let
          fun_582 =
            ErlangFun 0
              (let
                 lambda_583 [] =
                   let    __kind_584 = toErl "Type"
                   in let __file_585 = toErl "bad_init_state_access"
                   in let
                     bin_el_589 = BIF.erlang__list_to_binary__1 [__kind_584]
                   in let
                     bin_el_591 = BIF.erlang__list_to_binary__1 [__file_585]
                   in let
                     head_588 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_589
                               (BIN.packedSize bin_el_589) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_591
                               (BIN.packedSize bin_el_591) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 5:\nThe init function should return the initial state as its result and cannot write the state,\nbut it calls\n  - set_state (at line 11, column 5), which calls\n  - roundabout (at line 8, column 38), which calls\n  - put (at line 7, column 39)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_595 = BIF.erlang__list_to_binary__1 [__kind_584]
                   in let
                     bin_el_597 = BIF.erlang__list_to_binary__1 [__file_585]
                   in let
                     head_594 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_595
                               (BIN.packedSize bin_el_595) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_597
                               (BIN.packedSize bin_el_597) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 5:\nThe init function should return the initial state as its result and cannot read the state,\nbut it calls\n  - new_state (at line 12, column 5), which calls\n  - state (at line 5, column 29)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_601 = BIF.erlang__list_to_binary__1 [__kind_584]
                   in let
                     bin_el_603 = BIF.erlang__list_to_binary__1 [__file_585]
                   in let
                     head_600 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_601
                               (BIN.packedSize bin_el_601) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_603
                               (BIN.packedSize bin_el_603) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 13:\nThe init function should return the initial state as its result and cannot read the state,\nbut it calls\n  - state (at line 13, column 13)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_585,
                        ErlangCons head_588
                          (ErlangCons head_594
                             (ErlangCons head_600 ErlangEmptyList))]
                 lambda_583 [] = EXC.function_clause unit
                 lambda_583 args = EXC.badarity (ErlangFun 0 lambda_583) args
               in lambda_583)
        in let head_581 = BIF.erlang__apply__2 [fun_582, ErlangEmptyList]
        in let
          fun_608 =
            ErlangFun 0
              (let
                 lambda_609 [] =
                   let    __kind_610 = toErl "Type"
                   in let __file_611 = toErl "modifier_checks"
                   in let
                     bin_el_615 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_617 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_614 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_615
                               (BIN.packedSize bin_el_615) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_617
                               (BIN.packedSize bin_el_617) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 3:\nThe function all_the_things (at line 11, column 3) cannot be both public and private.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_621 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_623 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_620 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_621
                               (BIN.packedSize bin_el_621) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_623
                               (BIN.packedSize bin_el_623) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 3:\nNamespaces cannot contain entrypoints (at line 3, column 3). Use \'function\' instead.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_627 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_629 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_626 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_627
                               (BIN.packedSize bin_el_627) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_629
                               (BIN.packedSize bin_el_629) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 10:\nThe contract Remote (at line 5, column 10) has no entrypoints. Since Sophia version 3.2, public\ncontract functions must be declared with the \'entrypoint\' keyword instead of\n\'function\'.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_633 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_635 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_632 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_633
                               (BIN.packedSize bin_el_633) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_635
                               (BIN.packedSize bin_el_635) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 3:\nThe entrypoint wha (at line 12, column 3) cannot be private. Use \'function\' instead.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_639 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_641 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_638 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_639
                               (BIN.packedSize bin_el_639) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_641
                               (BIN.packedSize bin_el_641) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 3:\nUse \'entrypoint\' for declaration of foo (at line 6, column 3):\n  entrypoint foo : () => unit")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_645 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_647 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_644 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_645
                               (BIN.packedSize bin_el_645) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_647
                               (BIN.packedSize bin_el_647) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 3:\nUse \'entrypoint\' instead of \'function\' for public function foo (at line 10, column 3):\n  entrypoint foo() = ()")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_651 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_653 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_650 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_651
                               (BIN.packedSize bin_el_651) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_653
                               (BIN.packedSize bin_el_653) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 3:\nUse \'entrypoint\' instead of \'function\' for public function foo (at line 6, column 3):\n  entrypoint foo : () => unit")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_611,
                        ErlangCons head_614
                          (ErlangCons head_620
                             (ErlangCons head_626
                                (ErlangCons head_632
                                   (ErlangCons head_638
                                      (ErlangCons head_644
                                         (ErlangCons head_650
                                            ErlangEmptyList))))))]
                 lambda_609 [] = EXC.function_clause unit
                 lambda_609 args = EXC.badarity (ErlangFun 0 lambda_609) args
               in lambda_609)
        in let head_607 = BIF.erlang__apply__2 [fun_608, ErlangEmptyList]
        in let
          fun_658 =
            ErlangFun 0
              (let
                 lambda_659 [] =
                   let    __kind_660 = toErl "Type"
                   in let __file_661 = toErl "list_comp_not_a_list"
                   in let
                     bin_el_665 = BIF.erlang__list_to_binary__1 [__kind_660]
                   in let
                     bin_el_667 = BIF.erlang__list_to_binary__1 [__file_661]
                   in let
                     head_664 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_665
                               (BIN.packedSize bin_el_665) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_667
                               (BIN.packedSize bin_el_667) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 36:\nCannot unify int\n         and list(\'a)\nwhen checking rvalue of list comprehension binding at line 2, column 36\n  1 : int\nagainst type \n  list(\'a)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_661, ErlangCons head_664 ErlangEmptyList]
                 lambda_659 [] = EXC.function_clause unit
                 lambda_659 args = EXC.badarity (ErlangFun 0 lambda_659) args
               in lambda_659)
        in let head_657 = BIF.erlang__apply__2 [fun_658, ErlangEmptyList]
        in let
          fun_672 =
            ErlangFun 0
              (let
                 lambda_673 [] =
                   let    __kind_674 = toErl "Type"
                   in let __file_675 = toErl "list_comp_if_not_bool"
                   in let
                     bin_el_679 = BIF.erlang__list_to_binary__1 [__kind_674]
                   in let
                     bin_el_681 = BIF.erlang__list_to_binary__1 [__file_675]
                   in let
                     head_678 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_679
                               (BIN.packedSize bin_el_679) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_681
                               (BIN.packedSize bin_el_681) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 44:\nCannot unify int\n         and bool\nwhen checking the type of the expression at line 2, column 44\n  3 : int\nagainst the expected type\n  bool")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_675, ErlangCons head_678 ErlangEmptyList]
                 lambda_673 [] = EXC.function_clause unit
                 lambda_673 args = EXC.badarity (ErlangFun 0 lambda_673) args
               in lambda_673)
        in let head_671 = BIF.erlang__apply__2 [fun_672, ErlangEmptyList]
        in let
          fun_686 =
            ErlangFun 0
              (let
                 lambda_687 [] =
                   let    __kind_688 = toErl "Type"
                   in let __file_689 = toErl "list_comp_bad_shadow"
                   in let
                     bin_el_693 = BIF.erlang__list_to_binary__1 [__kind_688]
                   in let
                     bin_el_695 = BIF.erlang__list_to_binary__1 [__file_689]
                   in let
                     head_692 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_693
                               (BIN.packedSize bin_el_693) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_695
                               (BIN.packedSize bin_el_695) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 53:\nCannot unify int\n         and string\nwhen checking the type of the pattern at line 2, column 53\n  x : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_689, ErlangCons head_692 ErlangEmptyList]
                 lambda_687 [] = EXC.function_clause unit
                 lambda_687 args = EXC.badarity (ErlangFun 0 lambda_687) args
               in lambda_687)
        in let head_685 = BIF.erlang__apply__2 [fun_686, ErlangEmptyList]
        in let
          fun_700 =
            ErlangFun 0
              (let
                 lambda_701 [] =
                   let    __kind_702 = toErl "Type"
                   in let __file_703 = toErl "map_as_map_key"
                   in let
                     bin_el_707 = BIF.erlang__list_to_binary__1 [__kind_702]
                   in let
                     bin_el_709 = BIF.erlang__list_to_binary__1 [__file_703]
                   in let
                     head_706 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_707
                               (BIN.packedSize bin_el_707) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_709
                               (BIN.packedSize bin_el_709) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 25:\nInvalid key type\n  map(int, int)\nMap keys cannot contain other maps.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_713 = BIF.erlang__list_to_binary__1 [__kind_702]
                   in let
                     bin_el_715 = BIF.erlang__list_to_binary__1 [__file_703]
                   in let
                     head_712 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_713
                               (BIN.packedSize bin_el_713) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_715
                               (BIN.packedSize bin_el_715) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 25:\nInvalid key type\n  lm\nMap keys cannot contain other maps.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_703,
                        ErlangCons head_706
                          (ErlangCons head_712 ErlangEmptyList)]
                 lambda_701 [] = EXC.function_clause unit
                 lambda_701 args = EXC.badarity (ErlangFun 0 lambda_701) args
               in lambda_701)
        in let head_699 = BIF.erlang__apply__2 [fun_700, ErlangEmptyList]
        in let
          fun_720 =
            ErlangFun 0
              (let
                 lambda_721 [] =
                   let    __kind_722 = toErl "Type"
                   in let __file_723 = toErl "calling_init_function"
                   in let
                     bin_el_727 = BIF.erlang__list_to_binary__1 [__kind_722]
                   in let
                     bin_el_729 = BIF.erlang__list_to_binary__1 [__file_723]
                   in let
                     head_726 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_727
                               (BIN.packedSize bin_el_727) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_729
                               (BIN.packedSize bin_el_729) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 28:\nThe \'init\' function is called exclusively by the create contract transaction\nand cannot be called from the contract code.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_723, ErlangCons head_726 ErlangEmptyList]
                 lambda_721 [] = EXC.function_clause unit
                 lambda_721 args = EXC.badarity (ErlangFun 0 lambda_721) args
               in lambda_721)
        in let head_719 = BIF.erlang__apply__2 [fun_720, ErlangEmptyList]
        in let
          fun_734 =
            ErlangFun 0
              (let
                 lambda_735 [] =
                   let    __kind_736 = toErl "Type"
                   in let __file_737 = toErl "bad_top_level_decl"
                   in let
                     bin_el_741 = BIF.erlang__list_to_binary__1 [__kind_736]
                   in let
                     bin_el_743 = BIF.erlang__list_to_binary__1 [__file_737]
                   in let
                     head_740 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_741
                               (BIN.packedSize bin_el_741) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_743
                               (BIN.packedSize bin_el_743) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 1, col 1:\nThe definition of \'square\' must appear inside a contract or namespace.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_737, ErlangCons head_740 ErlangEmptyList]
                 lambda_735 [] = EXC.function_clause unit
                 lambda_735 args = EXC.badarity (ErlangFun 0 lambda_735) args
               in lambda_735)
        in let head_733 = BIF.erlang__apply__2 [fun_734, ErlangEmptyList]
        in let
          fun_748 =
            ErlangFun 0
              (let
                 lambda_749 [] =
                   let    __kind_750 = toErl "Type"
                   in let __file_751 = toErl "missing_event_type"
                   in let
                     bin_el_755 = BIF.erlang__list_to_binary__1 [__kind_750]
                   in let
                     bin_el_757 = BIF.erlang__list_to_binary__1 [__file_751]
                   in let
                     head_754 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_755
                               (BIN.packedSize bin_el_755) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_757
                               (BIN.packedSize bin_el_757) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 5:\nUnbound variable Chain.event at line 3, column 5\nDid you forget to define the event type?")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_751, ErlangCons head_754 ErlangEmptyList]
                 lambda_749 [] = EXC.function_clause unit
                 lambda_749 args = EXC.badarity (ErlangFun 0 lambda_749) args
               in lambda_749)
        in let head_747 = BIF.erlang__apply__2 [fun_748, ErlangEmptyList]
        in let
          fun_762 =
            ErlangFun 0
              (let
                 lambda_763 [] =
                   let    __kind_764 = toErl "Type"
                   in let __file_765 = toErl "bad_bytes_concat"
                   in let
                     bin_el_769 = BIF.erlang__list_to_binary__1 [__kind_764]
                   in let
                     bin_el_771 = BIF.erlang__list_to_binary__1 [__file_765]
                   in let
                     head_768 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_769
                               (BIN.packedSize bin_el_769) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_771
                               (BIN.packedSize bin_el_771) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 40:\nFailed to resolve byte array lengths in call to Bytes.concat with arguments of type\n  - \'g  (at line 12, column 20)\n  - \'h  (at line 12, column 23)\nand result type\n  - bytes(10)  (at line 12, column 28)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_775 = BIF.erlang__list_to_binary__1 [__kind_764]
                   in let
                     bin_el_777 = BIF.erlang__list_to_binary__1 [__file_765]
                   in let
                     head_774 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_775
                               (BIN.packedSize bin_el_775) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_777
                               (BIN.packedSize bin_el_777) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 28:\nFailed to resolve byte array lengths in call to Bytes.concat with arguments of type\n  - \'d  (at line 13, column 20)\n  - \'e  (at line 13, column 23)\nand result type\n  - \'f  (at line 13, column 14)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_781 = BIF.erlang__list_to_binary__1 [__kind_764]
                   in let
                     bin_el_783 = BIF.erlang__list_to_binary__1 [__file_765]
                   in let
                     head_780 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_781
                               (BIN.packedSize bin_el_781) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_783
                               (BIN.packedSize bin_el_783) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 5:\nCannot unify bytes(26)\n         and bytes(25)\nat line 15, column 5")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_787 = BIF.erlang__list_to_binary__1 [__kind_764]
                   in let
                     bin_el_789 = BIF.erlang__list_to_binary__1 [__file_765]
                   in let
                     head_786 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_787
                               (BIN.packedSize bin_el_787) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_789
                               (BIN.packedSize bin_el_789) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 17, col 5:\nFailed to resolve byte array lengths in call to Bytes.concat with arguments of type\n  - bytes(6)  (at line 16, column 24)\n  - \'b  (at line 16, column 34)\nand result type\n  - \'c  (at line 16, column 39)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_793 = BIF.erlang__list_to_binary__1 [__kind_764]
                   in let
                     bin_el_795 = BIF.erlang__list_to_binary__1 [__file_765]
                   in let
                     head_792 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_793
                               (BIN.packedSize bin_el_793) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_795
                               (BIN.packedSize bin_el_795) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 19, col 25:\nCannot resolve length of byte array.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_765,
                        ErlangCons head_768
                          (ErlangCons head_774
                             (ErlangCons head_780
                                (ErlangCons head_786
                                   (ErlangCons head_792 ErlangEmptyList))))]
                 lambda_763 [] = EXC.function_clause unit
                 lambda_763 args = EXC.badarity (ErlangFun 0 lambda_763) args
               in lambda_763)
        in let head_761 = BIF.erlang__apply__2 [fun_762, ErlangEmptyList]
        in let
          fun_800 =
            ErlangFun 0
              (let
                 lambda_801 [] =
                   let    __kind_802 = toErl "Type"
                   in let __file_803 = toErl "bad_bytes_split"
                   in let
                     bin_el_807 = BIF.erlang__list_to_binary__1 [__kind_802]
                   in let
                     bin_el_809 = BIF.erlang__list_to_binary__1 [__file_803]
                   in let
                     head_806 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_807
                               (BIN.packedSize bin_el_807) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_809
                               (BIN.packedSize bin_el_809) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 5:\nFailed to resolve byte array lengths in call to Bytes.split with argument of type\n  - \'f  (at line 12, column 20)\nand result types\n  - \'e  (at line 12, column 25)\n  - bytes(20)  (at line 12, column 29)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_813 = BIF.erlang__list_to_binary__1 [__kind_802]
                   in let
                     bin_el_815 = BIF.erlang__list_to_binary__1 [__file_803]
                   in let
                     head_812 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_813
                               (BIN.packedSize bin_el_813) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_815
                               (BIN.packedSize bin_el_815) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 5:\nFailed to resolve byte array lengths in call to Bytes.split with argument of type\n  - bytes(15)  (at line 15, column 24)\nand result types\n  - \'c  (at line 16, column 5)\n  - \'d  (at line 16, column 5)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_819 = BIF.erlang__list_to_binary__1 [__kind_802]
                   in let
                     bin_el_821 = BIF.erlang__list_to_binary__1 [__file_803]
                   in let
                     head_818 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_819
                               (BIN.packedSize bin_el_819) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_821
                               (BIN.packedSize bin_el_821) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 19, col 5:\nFailed to resolve byte array lengths in call to Bytes.split with argument of type\n  - \'b  (at line 18, column 20)\nand result types\n  - bytes(20)  (at line 18, column 25)\n  - \'a  (at line 18, column 37)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_803,
                        ErlangCons head_806
                          (ErlangCons head_812
                             (ErlangCons head_818 ErlangEmptyList))]
                 lambda_801 [] = EXC.function_clause unit
                 lambda_801 args = EXC.badarity (ErlangFun 0 lambda_801) args
               in lambda_801)
        in let head_799 = BIF.erlang__apply__2 [fun_800, ErlangEmptyList]
        in let
          fun_826 =
            ErlangFun 0
              (let
                 lambda_827 [] =
                   let    __kind_828 = toErl "Type"
                   in let __file_829 = toErl "wrong_compiler_version"
                   in let
                     bin_el_833 = BIF.erlang__list_to_binary__1 [__kind_828]
                   in let
                     bin_el_835 = BIF.erlang__list_to_binary__1 [__file_829]
                   in let
                     head_832 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_833
                               (BIN.packedSize bin_el_833) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_835
                               (BIN.packedSize bin_el_835) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 1, col 1:\nCannot compile with this version of the compiler,\nbecause it does not satisfy the constraint ")
                               (toErl 8) 1 BIN.Big,
                             BIN.binPrefix version_10
                               (BIN.packedSize version_10) 8,
                             BIN.fromInts (toErl " < 1.0") (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_840 = BIF.erlang__list_to_binary__1 [__kind_828]
                   in let
                     bin_el_842 = BIF.erlang__list_to_binary__1 [__file_829]
                   in let
                     head_839 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_840
                               (BIN.packedSize bin_el_840) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_842
                               (BIN.packedSize bin_el_842) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 1:\nCannot compile with this version of the compiler,\nbecause it does not satisfy the constraint ")
                               (toErl 8) 1 BIN.Big,
                             BIN.binPrefix version_10
                               (BIN.packedSize version_10) 8,
                             BIN.fromInts (toErl " == 9.9.9") (toErl 8) 1
                               BIN.Big])
                   in
                     ErlangTuple
                       [__file_829,
                        ErlangCons head_832
                          (ErlangCons head_839 ErlangEmptyList)]
                 lambda_827 [] = EXC.function_clause unit
                 lambda_827 args = EXC.badarity (ErlangFun 0 lambda_827) args
               in lambda_827)
        in let head_825 = BIF.erlang__apply__2 [fun_826, ErlangEmptyList]
        in let
          fun_848 =
            ErlangFun 0
              (let
                 lambda_849 [] =
                   let    __kind_850 = toErl "Type"
                   in let __file_851 = toErl "multiple_contracts"
                   in let
                     bin_el_855 = BIF.erlang__list_to_binary__1 [__kind_850]
                   in let
                     bin_el_857 = BIF.erlang__list_to_binary__1 [__file_851]
                   in let
                     head_854 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_855
                               (BIN.packedSize bin_el_855) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_857
                               (BIN.packedSize bin_el_857) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 3:\nOnly the main contract can contain defined functions or entrypoints.\nFix: replace the definition of \'foo\' by a type signature.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_851, ErlangCons head_854 ErlangEmptyList]
                 lambda_849 [] = EXC.function_clause unit
                 lambda_849 args = EXC.badarity (ErlangFun 0 lambda_849) args
               in lambda_849)
        in let head_847 = BIF.erlang__apply__2 [fun_848, ErlangEmptyList]
        in let
          fun_862 =
            ErlangFun 0
              (let
                 lambda_863 [] =
                   let    __kind_864 = toErl "Type"
                   in let __file_865 = toErl "contract_as_namespace"
                   in let
                     bin_el_869 = BIF.erlang__list_to_binary__1 [__kind_864]
                   in let
                     bin_el_871 = BIF.erlang__list_to_binary__1 [__file_865]
                   in let
                     head_868 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_869
                               (BIN.packedSize bin_el_869) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_871
                               (BIN.packedSize bin_el_871) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 28:\nInvalid call to contract entrypoint \'Foo.foo\'.\nIt must be called as \'c.foo\' for some c : Foo.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_865, ErlangCons head_868 ErlangEmptyList]
                 lambda_863 [] = EXC.function_clause unit
                 lambda_863 args = EXC.badarity (ErlangFun 0 lambda_863) args
               in lambda_863)
        in let head_861 = BIF.erlang__apply__2 [fun_862, ErlangEmptyList]
        in let
          fun_876 =
            ErlangFun 0
              (let
                 lambda_877 [] =
                   let    __kind_878 = toErl "Type"
                   in let __file_879 = toErl "toplevel_let"
                   in let
                     bin_el_883 = BIF.erlang__list_to_binary__1 [__kind_878]
                   in let
                     bin_el_885 = BIF.erlang__list_to_binary__1 [__file_879]
                   in let
                     head_882 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_883
                               (BIN.packedSize bin_el_883) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_885
                               (BIN.packedSize bin_el_885) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 7:\nToplevel \"let\" definitions are not supported\nValue this_is_illegal at line 2, column 7 could be replaced by 0-argument function")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_879, ErlangCons head_882 ErlangEmptyList]
                 lambda_877 [] = EXC.function_clause unit
                 lambda_877 args = EXC.badarity (ErlangFun 0 lambda_877) args
               in lambda_877)
        in let head_875 = BIF.erlang__apply__2 [fun_876, ErlangEmptyList]
        in let
          fun_890 =
            ErlangFun 0
              (let
                 lambda_891 [] =
                   let    __kind_892 = toErl "Type"
                   in let __file_893 = toErl "empty_typedecl"
                   in let
                     bin_el_897 = BIF.erlang__list_to_binary__1 [__kind_892]
                   in let
                     bin_el_899 = BIF.erlang__list_to_binary__1 [__file_893]
                   in let
                     head_896 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_897
                               (BIN.packedSize bin_el_897) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_899
                               (BIN.packedSize bin_el_899) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 8:\nEmpty type declarations are not supported\nType t at line 2, column 8 lacks a definition")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_893, ErlangCons head_896 ErlangEmptyList]
                 lambda_891 [] = EXC.function_clause unit
                 lambda_891 args = EXC.badarity (ErlangFun 0 lambda_891) args
               in lambda_891)
        in let head_889 = BIF.erlang__apply__2 [fun_890, ErlangEmptyList]
        in let
          fun_904 =
            ErlangFun 0
              (let
                 lambda_905 [] =
                   let    __kind_906 = toErl "Type"
                   in let __file_907 = toErl "higher_kinded_type"
                   in let
                     bin_el_911 = BIF.erlang__list_to_binary__1 [__kind_906]
                   in let
                     bin_el_913 = BIF.erlang__list_to_binary__1 [__file_907]
                   in let
                     head_910 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_911
                               (BIN.packedSize bin_el_911) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_913
                               (BIN.packedSize bin_el_913) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 35:\nType \'m is a higher kinded type variable\n(takes another type as an argument)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_907, ErlangCons head_910 ErlangEmptyList]
                 lambda_905 [] = EXC.function_clause unit
                 lambda_905 args = EXC.badarity (ErlangFun 0 lambda_905) args
               in lambda_905)
        in let head_903 = BIF.erlang__apply__2 [fun_904, ErlangEmptyList]
        in let
          fun_918 =
            ErlangFun 0
              (let
                 lambda_919 [] =
                   let    __kind_920 = toErl "Type"
                   in let __file_921 = toErl "bad_arity"
                   in let
                     bin_el_925 = BIF.erlang__list_to_binary__1 [__kind_920]
                   in let
                     bin_el_927 = BIF.erlang__list_to_binary__1 [__file_921]
                   in let
                     head_924 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_925
                               (BIN.packedSize bin_el_925) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_927
                               (BIN.packedSize bin_el_927) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 20:\nArity for id doesn\'t match. Expected 1, got 0")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_931 = BIF.erlang__list_to_binary__1 [__kind_920]
                   in let
                     bin_el_933 = BIF.erlang__list_to_binary__1 [__file_921]
                   in let
                     head_930 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_931
                               (BIN.packedSize bin_el_931) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_933
                               (BIN.packedSize bin_el_933) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 25:\nCannot unify int\n         and id\nwhen checking the type of the expression at line 3, column 25\n  123 : int\nagainst the expected type\n  id")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_937 = BIF.erlang__list_to_binary__1 [__kind_920]
                   in let
                     bin_el_939 = BIF.erlang__list_to_binary__1 [__file_921]
                   in let
                     head_936 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_937
                               (BIN.packedSize bin_el_937) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_939
                               (BIN.packedSize bin_el_939) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 20:\nArity for id doesn\'t match. Expected 1, got 2")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_943 = BIF.erlang__list_to_binary__1 [__kind_920]
                   in let
                     bin_el_945 = BIF.erlang__list_to_binary__1 [__file_921]
                   in let
                     head_942 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_943
                               (BIN.packedSize bin_el_943) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_945
                               (BIN.packedSize bin_el_945) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 35:\nCannot unify int\n         and id(int, int)\nwhen checking the type of the expression at line 4, column 35\n  123 : int\nagainst the expected type\n  id(int, int)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_921,
                        ErlangCons head_924
                          (ErlangCons head_930
                             (ErlangCons head_936
                                (ErlangCons head_942 ErlangEmptyList)))]
                 lambda_919 [] = EXC.function_clause unit
                 lambda_919 args = EXC.badarity (ErlangFun 0 lambda_919) args
               in lambda_919)
        in let head_917 = BIF.erlang__apply__2 [fun_918, ErlangEmptyList]
        in let
          fun_950 =
            ErlangFun 0
              (let
                 lambda_951 [] =
                   let    __kind_952 = toErl "Type"
                   in let __file_953 = toErl "bad_unnamed_map_update_default"
                   in let
                     bin_el_957 = BIF.erlang__list_to_binary__1 [__kind_952]
                   in let
                     bin_el_959 = BIF.erlang__list_to_binary__1 [__file_953]
                   in let
                     head_956 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_957
                               (BIN.packedSize bin_el_957) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_959
                               (BIN.packedSize bin_el_959) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 17:\nInvalid map update with default")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_953, ErlangCons head_956 ErlangEmptyList]
                 lambda_951 [] = EXC.function_clause unit
                 lambda_951 args = EXC.badarity (ErlangFun 0 lambda_951) args
               in lambda_951)
        in let head_949 = BIF.erlang__apply__2 [fun_950, ErlangEmptyList]
        in let
          fun_964 =
            ErlangFun 0
              (let
                 lambda_965 [] =
                   let    __kind_966 = toErl "Type"
                   in let __file_967 = toErl "non_functional_entrypoint"
                   in let
                     bin_el_971 = BIF.erlang__list_to_binary__1 [__kind_966]
                   in let
                     bin_el_973 = BIF.erlang__list_to_binary__1 [__file_967]
                   in let
                     head_970 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_971
                               (BIN.packedSize bin_el_971) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_973
                               (BIN.packedSize bin_el_973) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 14:\nf at line 2, column 14 was declared with an invalid type int.\nEntrypoints and functions must have functional types")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_967, ErlangCons head_970 ErlangEmptyList]
                 lambda_965 [] = EXC.function_clause unit
                 lambda_965 args = EXC.badarity (ErlangFun 0 lambda_965) args
               in lambda_965)
        in let head_963 = BIF.erlang__apply__2 [fun_964, ErlangEmptyList]
        in let
          fun_978 =
            ErlangFun 0
              (let
                 lambda_979 [] =
                   let    __kind_980 = toErl "Type"
                   in let __file_981 = toErl "bad_records"
                   in let
                     bin_el_985 = BIF.erlang__list_to_binary__1 [__kind_980]
                   in let
                     bin_el_987 = BIF.erlang__list_to_binary__1 [__file_981]
                   in let
                     head_984 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_985
                               (BIN.packedSize bin_el_985) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_987
                               (BIN.packedSize bin_el_987) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 16:\nMixed record fields and map keys in\n  {x = 0, [0] = 1}")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_991 = BIF.erlang__list_to_binary__1 [__kind_980]
                   in let
                     bin_el_993 = BIF.erlang__list_to_binary__1 [__file_981]
                   in let
                     head_990 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_991
                               (BIN.packedSize bin_el_991) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_993
                               (BIN.packedSize bin_el_993) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 6:\nMixed record fields and map keys in\n  r {x = 0, [0] = 1}")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_997 = BIF.erlang__list_to_binary__1 [__kind_980]
                   in let
                     bin_el_999 = BIF.erlang__list_to_binary__1 [__file_981]
                   in let
                     head_996 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_997
                               (BIN.packedSize bin_el_997) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_999
                               (BIN.packedSize bin_el_999) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 6:\nEmpty record/map update\n  r {}")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_981,
                        ErlangCons head_984
                          (ErlangCons head_990
                             (ErlangCons head_996 ErlangEmptyList))]
                 lambda_979 [] = EXC.function_clause unit
                 lambda_979 args = EXC.badarity (ErlangFun 0 lambda_979) args
               in lambda_979)
        in let head_977 = BIF.erlang__apply__2 [fun_978, ErlangEmptyList]
        in let
          fun_1004 =
            ErlangFun 0
              (let
                 lambda_1005 [] =
                   let    __kind_1006 = toErl "Type"
                   in let __file_1007 = toErl "bad_function_block"
                   in let
                     bin_el_1011 = BIF.erlang__list_to_binary__1 [__kind_1006]
                   in let
                     bin_el_1013 = BIF.erlang__list_to_binary__1 [__file_1007]
                   in let
                     head_1010 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1011
                               (BIN.packedSize bin_el_1011) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1013
                               (BIN.packedSize bin_el_1013) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 5:\nMismatch in the function block. Expected implementation/type declaration of g function")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1017 = BIF.erlang__list_to_binary__1 [__kind_1006]
                   in let
                     bin_el_1019 = BIF.erlang__list_to_binary__1 [__file_1007]
                   in let
                     head_1016 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1017
                               (BIN.packedSize bin_el_1017) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1019
                               (BIN.packedSize bin_el_1019) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 5:\nMismatch in the function block. Expected implementation/type declaration of g function")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1007,
                        ErlangCons head_1010
                          (ErlangCons head_1016 ErlangEmptyList)]
                 lambda_1005 [] = EXC.function_clause unit
                 lambda_1005 args = EXC.badarity (ErlangFun 0 lambda_1005) args
               in lambda_1005)
        in let
          head_1003 = BIF.erlang__apply__2 [fun_1004, ErlangEmptyList]
        in let
          fun_1024 =
            ErlangFun 0
              (let
                 lambda_1025 [] =
                   let    __kind_1026 = toErl "Type"
                   in let __file_1027 = toErl "just_an_empty_file"
                   in let
                     bin_el_1031 = BIF.erlang__list_to_binary__1 [__kind_1026]
                   in let
                     bin_el_1033 = BIF.erlang__list_to_binary__1 [__file_1027]
                   in let
                     head_1030 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1031
                               (BIN.packedSize bin_el_1031) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1033
                               (BIN.packedSize bin_el_1033) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 0, col 0:\nEmpty contract")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1027, ErlangCons head_1030 ErlangEmptyList]
                 lambda_1025 [] = EXC.function_clause unit
                 lambda_1025 args = EXC.badarity (ErlangFun 0 lambda_1025) args
               in lambda_1025)
        in let
          head_1023 = BIF.erlang__apply__2 [fun_1024, ErlangEmptyList]
        in let
          fun_1038 =
            ErlangFun 0
              (let
                 lambda_1039 [] =
                   let    __kind_1040 = toErl "Type"
                   in let __file_1041 = toErl "bad_number_of_args"
                   in let
                     bin_el_1045 = BIF.erlang__list_to_binary__1 [__kind_1040]
                   in let
                     bin_el_1047 = BIF.erlang__list_to_binary__1 [__file_1041]
                   in let
                     head_1044 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1045
                               (BIN.packedSize bin_el_1045) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1047
                               (BIN.packedSize bin_el_1047) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 39:\nCannot unify () => unit\n         and (int) => \'a\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "when checking the application at line 3, column 39 of\n  f : () => unit\nto arguments\n  1 : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1051 = BIF.erlang__list_to_binary__1 [__kind_1040]
                   in let
                     bin_el_1053 = BIF.erlang__list_to_binary__1 [__file_1041]
                   in let
                     head_1050 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1051
                               (BIN.packedSize bin_el_1051) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1053
                               (BIN.packedSize bin_el_1053) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 20:\nCannot unify (int, string) => \'e\n         and (int) => \'d\nwhen checking the application at line 4, column 20 of\n  g : (int, string) => \'e\nto arguments\n  1 : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1057 = BIF.erlang__list_to_binary__1 [__kind_1040]
                   in let
                     bin_el_1059 = BIF.erlang__list_to_binary__1 [__file_1041]
                   in let
                     head_1056 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1057
                               (BIN.packedSize bin_el_1057) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1059
                               (BIN.packedSize bin_el_1059) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 20:\nCannot unify (int, string) => \'c\n         and (string) => \'b\nwhen checking the application at line 5, column 20 of\n  g : (int, string) => \'c\nto arguments\n  \"Litwo, ojczyzno moja\" : string")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1041,
                        ErlangCons head_1044
                          (ErlangCons head_1050
                             (ErlangCons head_1056 ErlangEmptyList))]
                 lambda_1039 [] = EXC.function_clause unit
                 lambda_1039 args = EXC.badarity (ErlangFun 0 lambda_1039) args
               in lambda_1039)
        in let
          head_1037 = BIF.erlang__apply__2 [fun_1038, ErlangEmptyList]
        in let
          fun_1064 =
            ErlangFun 0
              (let
                 lambda_1065 [] =
                   let    __kind_1066 = toErl "Type"
                   in let __file_1067 = toErl "bad_state"
                   in let
                     bin_el_1071 = BIF.erlang__list_to_binary__1 [__kind_1066]
                   in let
                     bin_el_1073 = BIF.erlang__list_to_binary__1 [__file_1067]
                   in let
                     head_1070 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1071
                               (BIN.packedSize bin_el_1071) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1073
                               (BIN.packedSize bin_el_1073) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 16:\nConflicting updates for field \'foo\'")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1067, ErlangCons head_1070 ErlangEmptyList]
                 lambda_1065 [] = EXC.function_clause unit
                 lambda_1065 args = EXC.badarity (ErlangFun 0 lambda_1065) args
               in lambda_1065)
        in let
          head_1063 = BIF.erlang__apply__2 [fun_1064, ErlangEmptyList]
        in
          ErlangCons head_11
            (ErlangCons head_25
               (ErlangCons head_39
                  (ErlangCons head_53
                     (ErlangCons head_67
                        (ErlangCons head_117
                           (ErlangCons head_275
                              (ErlangCons head_289
                                 (ErlangCons head_303
                                    (ErlangCons head_329
                                       (ErlangCons head_343
                                          (ErlangCons head_363
                                             (ErlangCons head_383
                                                (ErlangCons head_397
                                                   (ErlangCons head_411
                                                      (ErlangCons head_425
                                                         (ErlangCons head_439
                                                            (ErlangCons head_525
                                                               (ErlangCons
                                                                  head_581
                                                                  (ErlangCons
                                                                     head_607
                                                                     (ErlangCons
                                                                        head_657
                                                                        (ErlangCons
                                                                           head_671
                                                                           (ErlangCons
                                                                              head_685
                                                                              (ErlangCons
                                                                                 head_699
                                                                                 (ErlangCons
                                                                                    head_719
                                                                                    (ErlangCons
                                                                                       head_733
                                                                                       (ErlangCons
                                                                                          head_747
                                                                                          (ErlangCons
                                                                                             head_761
                                                                                             (ErlangCons
                                                                                                head_799
                                                                                                (ErlangCons
                                                                                                   head_825
                                                                                                   (ErlangCons
                                                                                                      head_847
                                                                                                      (ErlangCons
                                                                                                         head_861
                                                                                                         (ErlangCons
                                                                                                            head_875
                                                                                                            (ErlangCons
                                                                                                               head_889
                                                                                                               (ErlangCons
                                                                                                                  head_903
                                                                                                                  (ErlangCons
                                                                                                                     head_917
                                                                                                                     (ErlangCons
                                                                                                                        head_949
                                                                                                                        (ErlangCons
                                                                                                                           head_963
                                                                                                                           (ErlangCons
                                                                                                                              head_977
                                                                                                                              (ErlangCons
                                                                                                                                 head_1003
                                                                                                                                 (ErlangCons
                                                                                                                                    head_1023
                                                                                                                                    (ErlangCons
                                                                                                                                       head_1037
                                                                                                                                       (ErlangCons
                                                                                                                                          head_1063
                                                                                                                                          ErlangEmptyList))))))))))))))))))))))))))))))))))))))))))
      _ -> EXC.badmatch matchExpr_1
erlps__failing_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__failing_contracts__0) args

erlps__failing_code_gen_contracts__0 :: ErlangFun
erlps__failing_code_gen_contracts__0 [] =
  let   
    tup_el_1 = toErl "code_errors/last_declaration_must_be_contract"
  in let arg_4 = toErl "Code generation"
  in let bin_el_3 = BIF.erlang__list_to_binary__1 [arg_4]
  in let
    arg_6 = toErl "code_errors/last_declaration_must_be_contract"
  in let bin_el_5 = BIF.erlang__list_to_binary__1 [arg_6]
  in let
    tup_el_2 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_5 (BIN.packedSize bin_el_5) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 1, col 1:\nExpected a contract as the last declaration instead of the namespace \'LastDeclarationIsNotAContract\'")
              (toErl 8) 1 BIN.Big])
  in let head_0 = ErlangTuple [tup_el_1, tup_el_2]
  in let tup_el_9 = toErl "code_errors/missing_definition"
  in let arg_12 = toErl "Code generation"
  in let bin_el_11 = BIF.erlang__list_to_binary__1 [arg_12]
  in let arg_14 = toErl "code_errors/missing_definition"
  in let bin_el_13 = BIF.erlang__list_to_binary__1 [arg_14]
  in let
    tup_el_10 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_11 (BIN.packedSize bin_el_11) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_13 (BIN.packedSize bin_el_13) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 14:\nMissing definition of function \'foo\'.")
              (toErl 8) 1 BIN.Big])
  in let head_8 = ErlangTuple [tup_el_9, tup_el_10]
  in let tup_el_17 = toErl "code_errors/polymorphic_entrypoint"
  in let arg_23 = toErl "Code generation"
  in let bin_el_22 = BIF.erlang__list_to_binary__1 [arg_23]
  in let arg_25 = toErl "code_errors/polymorphic_entrypoint"
  in let bin_el_24 = BIF.erlang__list_to_binary__1 [arg_25]
  in let
    tup_el_21 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_22 (BIN.packedSize bin_el_22) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_24 (BIN.packedSize bin_el_24) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 17:\nThe argument\n  x : \'a\nof entrypoint \'id\' has a polymorphic (contains type variables) type.\nUse the FATE backend if you want polymorphic entrypoints.")
              (toErl 8) 1 BIN.Big])
  in let head_19 = ErlangTuple [ErlangAtom "aevm", tup_el_21]
  in let
    head_16 =
      ErlangTuple [tup_el_17, ErlangCons head_19 ErlangEmptyList]
  in let
    tup_el_29 = toErl "code_errors/polymorphic_entrypoint_return"
  in let arg_35 = toErl "Code generation"
  in let bin_el_34 = BIF.erlang__list_to_binary__1 [arg_35]
  in let arg_37 = toErl "code_errors/polymorphic_entrypoint_return"
  in let bin_el_36 = BIF.erlang__list_to_binary__1 [arg_37]
  in let
    tup_el_33 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_34 (BIN.packedSize bin_el_34) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_36 (BIN.packedSize bin_el_36) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 3:\nThe return type\n  \'a\nof entrypoint \'fail\' is polymorphic (contains type variables).\nUse the FATE backend if you want polymorphic entrypoints.")
              (toErl 8) 1 BIN.Big])
  in let head_31 = ErlangTuple [ErlangAtom "aevm", tup_el_33]
  in let
    head_28 =
      ErlangTuple [tup_el_29, ErlangCons head_31 ErlangEmptyList]
  in let tup_el_41 = toErl "code_errors/higher_order_entrypoint"
  in let arg_44 = toErl "Code generation"
  in let bin_el_43 = BIF.erlang__list_to_binary__1 [arg_44]
  in let arg_46 = toErl "code_errors/higher_order_entrypoint"
  in let bin_el_45 = BIF.erlang__list_to_binary__1 [arg_46]
  in let
    tup_el_42 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_43 (BIN.packedSize bin_el_43) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_45 (BIN.packedSize bin_el_45) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 20:\nThe argument\n  f : (int) => int\nof entrypoint \'apply\' has a higher-order (contains function types) type.")
              (toErl 8) 1 BIN.Big])
  in let head_40 = ErlangTuple [tup_el_41, tup_el_42]
  in let
    tup_el_49 = toErl "code_errors/higher_order_entrypoint_return"
  in let arg_52 = toErl "Code generation"
  in let bin_el_51 = BIF.erlang__list_to_binary__1 [arg_52]
  in let
    arg_54 = toErl "code_errors/higher_order_entrypoint_return"
  in let bin_el_53 = BIF.erlang__list_to_binary__1 [arg_54]
  in let
    tup_el_50 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_51 (BIN.packedSize bin_el_51) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_53 (BIN.packedSize bin_el_53) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 3:\nThe return type\n  (int) => int\nof entrypoint \'add\' is higher-order (contains function types).")
              (toErl 8) 1 BIN.Big])
  in let head_48 = ErlangTuple [tup_el_49, tup_el_50]
  in let tup_el_57 = toErl "code_errors/missing_init_function"
  in let arg_60 = toErl "Code generation"
  in let bin_el_59 = BIF.erlang__list_to_binary__1 [arg_60]
  in let arg_62 = toErl "code_errors/missing_init_function"
  in let bin_el_61 = BIF.erlang__list_to_binary__1 [arg_62]
  in let
    tup_el_58 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_59 (BIN.packedSize bin_el_59) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_61 (BIN.packedSize bin_el_61) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 1, col 10:\nMissing init function for the contract \'MissingInitFunction\'.\nThe \'init\' function can only be omitted if the state type is \'unit\'.")
              (toErl 8) 1 BIN.Big])
  in let head_56 = ErlangTuple [tup_el_57, tup_el_58]
  in let tup_el_65 = toErl "code_errors/parameterised_state"
  in let arg_68 = toErl "Code generation"
  in let bin_el_67 = BIF.erlang__list_to_binary__1 [arg_68]
  in let arg_70 = toErl "code_errors/parameterised_state"
  in let bin_el_69 = BIF.erlang__list_to_binary__1 [arg_70]
  in let
    tup_el_66 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_67 (BIN.packedSize bin_el_67) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_69 (BIN.packedSize bin_el_69) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 8:\nThe state type cannot be parameterized.")
              (toErl 8) 1 BIN.Big])
  in let head_64 = ErlangTuple [tup_el_65, tup_el_66]
  in let tup_el_73 = toErl "code_errors/parameterised_event"
  in let arg_76 = toErl "Code generation"
  in let bin_el_75 = BIF.erlang__list_to_binary__1 [arg_76]
  in let arg_78 = toErl "code_errors/parameterised_event"
  in let bin_el_77 = BIF.erlang__list_to_binary__1 [arg_78]
  in let
    tup_el_74 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_75 (BIN.packedSize bin_el_75) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_77 (BIN.packedSize bin_el_77) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 12:\nThe event type cannot be parameterized.")
              (toErl 8) 1 BIN.Big])
  in let head_72 = ErlangTuple [tup_el_73, tup_el_74]
  in let tup_el_81 = toErl "code_errors/polymorphic_aens_resolve"
  in let arg_84 = toErl "Code generation"
  in let bin_el_83 = BIF.erlang__list_to_binary__1 [arg_84]
  in let arg_86 = toErl "code_errors/polymorphic_aens_resolve"
  in let bin_el_85 = BIF.erlang__list_to_binary__1 [arg_86]
  in let
    tup_el_82 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_83 (BIN.packedSize bin_el_83) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_85 (BIN.packedSize bin_el_85) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nInvalid return type of AENS.resolve:\n  \'a\nIt must be a string or a pubkey type (address, oracle, etc).")
              (toErl 8) 1 BIN.Big])
  in let head_80 = ErlangTuple [tup_el_81, tup_el_82]
  in let tup_el_89 = toErl "code_errors/bad_aens_resolve"
  in let arg_92 = toErl "Code generation"
  in let bin_el_91 = BIF.erlang__list_to_binary__1 [arg_92]
  in let arg_94 = toErl "code_errors/bad_aens_resolve"
  in let bin_el_93 = BIF.erlang__list_to_binary__1 [arg_94]
  in let
    tup_el_90 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_91 (BIN.packedSize bin_el_91) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_93 (BIN.packedSize bin_el_93) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 6, col 5:\nInvalid return type of AENS.resolve:\n  list(int)\nIt must be a string or a pubkey type (address, oracle, etc).")
              (toErl 8) 1 BIN.Big])
  in let head_88 = ErlangTuple [tup_el_89, tup_el_90]
  in let tup_el_97 = toErl "code_errors/polymorphic_compare"
  in let arg_103 = toErl "Code generation"
  in let bin_el_102 = BIF.erlang__list_to_binary__1 [arg_103]
  in let arg_105 = toErl "code_errors/polymorphic_compare"
  in let bin_el_104 = BIF.erlang__list_to_binary__1 [arg_105]
  in let
    tup_el_101 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_102 (BIN.packedSize bin_el_102) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_104 (BIN.packedSize bin_el_104) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  \'a\nThe AEVM only supports \'==\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\n- type string\n- tuple or record of word type\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_99 = ErlangTuple [ErlangAtom "aevm", tup_el_101]
  in let
    head_96 =
      ErlangTuple [tup_el_97, ErlangCons head_99 ErlangEmptyList]
  in let tup_el_109 = toErl "code_errors/complex_compare"
  in let arg_115 = toErl "Code generation"
  in let bin_el_114 = BIF.erlang__list_to_binary__1 [arg_115]
  in let arg_117 = toErl "code_errors/complex_compare"
  in let bin_el_116 = BIF.erlang__list_to_binary__1 [arg_117]
  in let
    tup_el_113 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_114 (BIN.packedSize bin_el_114) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_116 (BIN.packedSize bin_el_116) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  (string * int)\nThe AEVM only supports \'!=\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\n- type string\n- tuple or record of word type\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_111 = ErlangTuple [ErlangAtom "aevm", tup_el_113]
  in let
    head_108 =
      ErlangTuple [tup_el_109, ErlangCons head_111 ErlangEmptyList]
  in let tup_el_121 = toErl "code_errors/complex_compare_leq"
  in let arg_127 = toErl "Code generation"
  in let bin_el_126 = BIF.erlang__list_to_binary__1 [arg_127]
  in let arg_129 = toErl "code_errors/complex_compare_leq"
  in let bin_el_128 = BIF.erlang__list_to_binary__1 [arg_129]
  in let
    tup_el_125 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_126 (BIN.packedSize bin_el_126) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_128 (BIN.packedSize bin_el_128) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  (int * int)\nThe AEVM only supports \'=<\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_123 = ErlangTuple [ErlangAtom "aevm", tup_el_125]
  in let
    head_120 =
      ErlangTuple [tup_el_121, ErlangCons head_123 ErlangEmptyList]
  in let tup_el_133 = toErl "code_errors/higher_order_compare"
  in let arg_139 = toErl "Code generation"
  in let bin_el_138 = BIF.erlang__list_to_binary__1 [arg_139]
  in let arg_141 = toErl "code_errors/higher_order_compare"
  in let bin_el_140 = BIF.erlang__list_to_binary__1 [arg_141]
  in let
    tup_el_137 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_138 (BIN.packedSize bin_el_138) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_140 (BIN.packedSize bin_el_140) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  (int) => int\nThe AEVM only supports \'<\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_135 = ErlangTuple [ErlangAtom "aevm", tup_el_137]
  in let
    head_132 =
      ErlangTuple [tup_el_133, ErlangCons head_135 ErlangEmptyList]
  in let tup_el_145 = toErl "code_errors/unapplied_contract_call"
  in let arg_151 = toErl "Code generation"
  in let bin_el_150 = BIF.erlang__list_to_binary__1 [arg_151]
  in let arg_153 = toErl "code_errors/unapplied_contract_call"
  in let bin_el_152 = BIF.erlang__list_to_binary__1 [arg_153]
  in let
    tup_el_149 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_150 (BIN.packedSize bin_el_150) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_152 (BIN.packedSize bin_el_152) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 6, col 19:\nThe AEVM does not support unapplied contract call to\n  r : Remote\nUse FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_147 = ErlangTuple [ErlangAtom "aevm", tup_el_149]
  in let
    head_144 =
      ErlangTuple [tup_el_145, ErlangCons head_147 ErlangEmptyList]
  in let
    tup_el_157 = toErl "code_errors/unapplied_named_arg_builtin"
  in let arg_163 = toErl "Code generation"
  in let bin_el_162 = BIF.erlang__list_to_binary__1 [arg_163]
  in let arg_165 = toErl "code_errors/unapplied_named_arg_builtin"
  in let bin_el_164 = BIF.erlang__list_to_binary__1 [arg_165]
  in let
    tup_el_161 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_162 (BIN.packedSize bin_el_162) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_164 (BIN.packedSize bin_el_164) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 15:\nThe AEVM does not support unapplied use of Oracle.register.\nUse FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_159 = ErlangTuple [ErlangAtom "aevm", tup_el_161]
  in let
    head_156 =
      ErlangTuple [tup_el_157, ErlangCons head_159 ErlangEmptyList]
  in let tup_el_169 = toErl "code_errors/polymorphic_map_keys"
  in let arg_175 = toErl "Code generation"
  in let bin_el_174 = BIF.erlang__list_to_binary__1 [arg_175]
  in let arg_177 = toErl "code_errors/polymorphic_map_keys"
  in let bin_el_176 = BIF.erlang__list_to_binary__1 [arg_177]
  in let
    tup_el_173 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_174 (BIN.packedSize bin_el_174) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_176 (BIN.packedSize bin_el_176) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 34:\nInvalid map key type\n  \'a\nMap keys cannot be polymorphic in the AEVM. Use FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_171 = ErlangTuple [ErlangAtom "aevm", tup_el_173]
  in let
    head_168 =
      ErlangTuple [tup_el_169, ErlangCons head_171 ErlangEmptyList]
  in let tup_el_181 = toErl "code_errors/higher_order_map_keys"
  in let arg_187 = toErl "Code generation"
  in let bin_el_186 = BIF.erlang__list_to_binary__1 [arg_187]
  in let arg_189 = toErl "code_errors/higher_order_map_keys"
  in let bin_el_188 = BIF.erlang__list_to_binary__1 [arg_189]
  in let
    tup_el_185 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_186 (BIN.packedSize bin_el_186) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_188 (BIN.packedSize bin_el_188) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 42:\nInvalid map key type\n  (int) => int\nMap keys cannot be higher-order.")
              (toErl 8) 1 BIN.Big])
  in let head_183 = ErlangTuple [ErlangAtom "aevm", tup_el_185]
  in let
    head_180 =
      ErlangTuple [tup_el_181, ErlangCons head_183 ErlangEmptyList]
  in let tup_el_193 = toErl "code_errors/polymorphic_query_type"
  in let arg_196 = toErl "Code generation"
  in let bin_el_195 = BIF.erlang__list_to_binary__1 [arg_196]
  in let arg_198 = toErl "code_errors/polymorphic_query_type"
  in let bin_el_197 = BIF.erlang__list_to_binary__1 [arg_198]
  in let
    tup_el_194 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_195 (BIN.packedSize bin_el_195) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_197 (BIN.packedSize bin_el_197) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle(\'a, \'b)\nThe query type must not be polymorphic (contain type variables).")
              (toErl 8) 1 BIN.Big])
  in let head_192 = ErlangTuple [tup_el_193, tup_el_194]
  in let tup_el_201 = toErl "code_errors/polymorphic_response_type"
  in let arg_204 = toErl "Code generation"
  in let bin_el_203 = BIF.erlang__list_to_binary__1 [arg_204]
  in let arg_206 = toErl "code_errors/polymorphic_response_type"
  in let bin_el_205 = BIF.erlang__list_to_binary__1 [arg_206]
  in let
    tup_el_202 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_203 (BIN.packedSize bin_el_203) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_205 (BIN.packedSize bin_el_205) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle(string, \'r)\nThe response type must not be polymorphic (contain type variables).")
              (toErl 8) 1 BIN.Big])
  in let head_200 = ErlangTuple [tup_el_201, tup_el_202]
  in let tup_el_209 = toErl "code_errors/higher_order_query_type"
  in let arg_212 = toErl "Code generation"
  in let bin_el_211 = BIF.erlang__list_to_binary__1 [arg_212]
  in let arg_214 = toErl "code_errors/higher_order_query_type"
  in let bin_el_213 = BIF.erlang__list_to_binary__1 [arg_214]
  in let
    tup_el_210 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_211 (BIN.packedSize bin_el_211) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_213 (BIN.packedSize bin_el_213) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle((int) => int, string)\nThe query type must not be higher-order (contain function types).")
              (toErl 8) 1 BIN.Big])
  in let head_208 = ErlangTuple [tup_el_209, tup_el_210]
  in let
    tup_el_217 = toErl "code_errors/higher_order_response_type"
  in let arg_220 = toErl "Code generation"
  in let bin_el_219 = BIF.erlang__list_to_binary__1 [arg_220]
  in let arg_222 = toErl "code_errors/higher_order_response_type"
  in let bin_el_221 = BIF.erlang__list_to_binary__1 [arg_222]
  in let
    tup_el_218 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_219 (BIN.packedSize bin_el_219) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_221 (BIN.packedSize bin_el_221) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle(string, (int) => int)\nThe response type must not be higher-order (contain function types).")
              (toErl 8) 1 BIN.Big])
  in let head_216 = ErlangTuple [tup_el_217, tup_el_218]
  in let tup_el_225 = toErl "code_errors/higher_order_state"
  in let arg_231 = toErl "Code generation"
  in let bin_el_230 = BIF.erlang__list_to_binary__1 [arg_231]
  in let arg_233 = toErl "code_errors/higher_order_state"
  in let bin_el_232 = BIF.erlang__list_to_binary__1 [arg_233]
  in let
    tup_el_229 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_230 (BIN.packedSize bin_el_230) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_232 (BIN.packedSize bin_el_232) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 3:\nInvalid state type\n  {f : (int) => int}\nThe state cannot contain functions in the AEVM. Use FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_227 = ErlangTuple [ErlangAtom "aevm", tup_el_229]
  in let
    head_224 =
      ErlangTuple [tup_el_225, ErlangCons head_227 ErlangEmptyList]
  in
    ErlangCons head_0
      (ErlangCons head_8
         (ErlangCons head_16
            (ErlangCons head_28
               (ErlangCons head_40
                  (ErlangCons head_48
                     (ErlangCons head_56
                        (ErlangCons head_64
                           (ErlangCons head_72
                              (ErlangCons head_80
                                 (ErlangCons head_88
                                    (ErlangCons head_96
                                       (ErlangCons head_108
                                          (ErlangCons head_120
                                             (ErlangCons head_132
                                                (ErlangCons head_144
                                                   (ErlangCons head_156
                                                      (ErlangCons head_168
                                                         (ErlangCons head_180
                                                            (ErlangCons head_192
                                                               (ErlangCons
                                                                  head_200
                                                                  (ErlangCons
                                                                     head_208
                                                                     (ErlangCons
                                                                        head_216
                                                                        (ErlangCons
                                                                           head_224
                                                                           ErlangEmptyList)))))))))))))))))))))))
erlps__failing_code_gen_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__failing_code_gen_contracts__0)
    args

erlps__validation_test___0 :: ErlangFun
erlps__validation_test___0 [] =
  let    lcSrc_1 = erlps__validation_fails__0 []
  in let
    lop_0 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             (ErlangTuple [c1_2, c2_3, expect_4]) ->
               let    lop_8 = toErl "Validation fail: "
               in let lop_12 = toErl " /= "
               in let rop_11 = BIF.erlang__op_append [lop_12, c2_3]
               in let rop_9 = BIF.erlang__op_append [c1_2, rop_11]
               in let tup_el_7 = BIF.erlang__op_append [lop_8, rop_9]
               in let
                 tup_el_14 =
                   ErlangFun 0
                     (let
                        lambda_15 [] =
                          let    case_16 = erlps__validate__2 [c1_2, c2_3]
                          in let
                            actual_20 =
                              case case_16 of
                                (ErlangTuple [(ErlangAtom "error"), errs_19]) ->
                                  errs_19
                                (ErlangAtom "ok") -> ErlangMap Map.empty
                                something_else -> EXC.case_clause something_else
                          in erlps__check_errors__2 [expect_4, actual_20]
                        lambda_15 [] = EXC.function_clause unit
                        lambda_15 args =
                          EXC.badarity (ErlangFun 0 lambda_15) args
                      in lambda_15)
               in let lcRet_6 = ErlangTuple [tup_el_7, tup_el_14]
               in ErlangCons lcRet_6 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_1
  in let lcSrc_24 = erlps__compilable_contracts__0 []
  in let
    rop_23 =
      flmap
        (\ lc_26 ->
           let    lop_29 = toErl "Validation of "
           in let tup_el_28 = BIF.erlang__op_append [lop_29, lc_26]
           in let
             tup_el_31 =
               ErlangFun 0
                 (let
                    lambda_32 [] =
                      let
                        fun_33 =
                          ErlangFun 0
                            (let
                               lambda_34 [] =
                                 let case_36 = erlps__validate__2 [lc_26, lc_26]
                                 in
                                   case case_36 of
                                     __x_39 | __x_39 == (ErlangAtom "ok") ->
                                       ErlangAtom "ok"
                                     __v_40 ->
                                       let   
                                         head_44 =
                                           ErlangTuple
                                             [ErlangAtom "module",
                                              ErlangAtom "aeso_compiler_tests"]
                                       in let tup_el_50 = toErl 845
                                       in let
                                         head_48 =
                                           ErlangTuple
                                             [ErlangAtom "line", tup_el_50]
                                       in let
                                         tup_el_54 = toErl "validate ( C , C )"
                                       in let
                                         head_52 =
                                           ErlangTuple
                                             [ErlangAtom "expression",
                                              tup_el_54]
                                       in let
                                         head_56 =
                                           ErlangTuple
                                             [ErlangAtom "expected",
                                              ErlangAtom "ok"]
                                       in let
                                         head_60 =
                                           ErlangTuple
                                             [ErlangAtom "value", __v_40]
                                       in let
                                         arg_41 =
                                           ErlangTuple
                                             [ErlangAtom "assertEqual",
                                              ErlangCons head_44
                                                (ErlangCons head_48
                                                   (ErlangCons head_52
                                                      (ErlangCons head_56
                                                         (ErlangCons head_60
                                                            ErlangEmptyList))))]
                                       in BIF.erlang__error__1 [arg_41]
                               lambda_34 [] = EXC.function_clause unit
                               lambda_34 args =
                                 EXC.badarity (ErlangFun 0 lambda_34) args
                             in lambda_34)
                      in BIF.erlang__apply__2 [fun_33, ErlangEmptyList]
                    lambda_32 [] = EXC.function_clause unit
                    lambda_32 args = EXC.badarity (ErlangFun 0 lambda_32) args
                  in lambda_32)
           in let lcRet_27 = ErlangTuple [tup_el_28, tup_el_31]
           in ErlangCons lcRet_27 ErlangEmptyList)
        lcSrc_24
  in BIF.erlang__op_append [lop_0, rop_23]
erlps__validation_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__validation_test___0) args

erlps__validation_fails__0 :: ErlangFun
erlps__validation_fails__0 [] =
  let    tup_el_1 = toErl "deadcode"
  in let tup_el_2 = toErl "nodeadcode"
  in let
    head_4 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "Data error:\nByte code does not match source code.\n- Functions in the source code but not in the byte code:\n    .MyList.map2")
           (toErl 8) 1 BIN.Big)
  in let
    head_0 =
      ErlangTuple
        [tup_el_1, tup_el_2, ErlangCons head_4 ErlangEmptyList]
  in let tup_el_8 = toErl "validation_test1"
  in let tup_el_9 = toErl "validation_test2"
  in let
    head_11 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "Data error:\nByte code does not match source code.\n- The implementation of the function code_fail is different.\n- The attributes of the function attr_fail differ:\n    Byte code:   payable\n    Source code: \n- The type of the function type_fail differs:\n    Byte code:   integer => integer\n    Source code: {tvar,0} => {tvar,0}")
           (toErl 8) 1 BIN.Big)
  in let
    head_7 =
      ErlangTuple
        [tup_el_8, tup_el_9, ErlangCons head_11 ErlangEmptyList]
  in let tup_el_15 = toErl "validation_test1"
  in let tup_el_16 = toErl "validation_test3"
  in let
    head_18 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "Data error:\nByte code contract is not payable, but source code contract is.")
           (toErl 8) 1 BIN.Big)
  in let
    head_14 =
      ErlangTuple
        [tup_el_15, tup_el_16, ErlangCons head_18 ErlangEmptyList]
  in
    ErlangCons head_0
      (ErlangCons head_7 (ErlangCons head_14 ErlangEmptyList))
erlps__validation_fails__0 args =
  EXC.badarity (ErlangFun 0 erlps__validation_fails__0) args

erlps__validate__2 :: ErlangFun
erlps__validate__2 [contract1_0, contract2_1] =
  let
    matchExpr_6 = erlps__compile__2 [ErlangAtom "fate", contract1_0]
  in
    case matchExpr_6 of
      (ErlangMap map_4) | (DM.Just fcode_5) <-
                            (Map.lookup (ErlangAtom "fate_code") map_4) ->
        let   
          arg_8 =
            BIF.do_remote_fun_call "Aeb.Fate.Code"
              "erlps__strip_init_function__1" [fcode_5]
        in let
          fcode1_10 =
            BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__serialize__1"
              [arg_8]
        in let
          source_12 =
            BIF.do_remote_fun_call "Aeso.Test.Utils"
              "erlps__read_contract__1" [contract2_1]
        in let
          mapExt_17 =
            ErlangMap (Map.singleton (ErlangAtom "byte_code") fcode1_10)
        in let
          arg_13 =
            case findMissingKey matchExpr_6 [ErlangAtom "byte_code"] of
              (DM.Nothing) -> BIF.maps__merge__2 [matchExpr_6, mapExt_17]
              (DM.Just missing_19) -> EXC.badkey missing_19
        in let arg_25 = erlps__debug_mode_contracts__0 []
        in let case_23 = BIF.lists__member__2 [contract2_1, arg_25]
        in let
          lop_22 =
            case case_23 of
              (ErlangAtom "true") ->
                ErlangCons (ErlangAtom "debug_mode") ErlangEmptyList
              (ErlangAtom "false") -> ErlangEmptyList
              something_else -> EXC.case_clause something_else
        in let
          head_29 = ErlangTuple [ErlangAtom "backend", ErlangAtom "fate"]
        in let
          head_38 =
            BIF.do_remote_fun_call "Aeso.Test.Utils"
              "erlps__contract_path__0" []
        in let
          tup_el_35 =
            ErlangTuple
              [ErlangAtom "file_system", ErlangCons head_38 ErlangEmptyList]
        in let head_33 = ErlangTuple [ErlangAtom "include", tup_el_35]
        in let
          arg_21 =
            BIF.erlang__op_append
              [lop_22, ErlangCons head_29 (ErlangCons head_33 ErlangEmptyList)]
        in
          BIF.do_remote_fun_call "Aeso.Compiler"
            "erlps__validate_byte_code__3" [arg_13, source_12, arg_21]
      _ -> EXC.badmatch matchExpr_6
erlps__validate__2 [arg_41, arg_42] = EXC.function_clause unit
erlps__validate__2 args =
  EXC.badarity (ErlangFun 2 erlps__validate__2) args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeso_compiler_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 erlps__test__0) args