module Aeso.Compiler.Tests where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__run_test__1 :: ErlangFun
erlps__run_test__1 [test_0] =
  let    head_5 = toErl "_test_"
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__concat__1"
        [ErlangCons test_0 (ErlangCons head_5 ErlangEmptyList)]
  in let testfun_7 = BIF.erlang__list_to_atom__1 [arg_1]
  in let
    lcSrc_8 =
      BIF.erlang__apply__3
        [ErlangAtom "aeso_compiler_tests", testfun_7, ErlangEmptyList]
  in let
    _ =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [label_12, fun_13]) ->
               let    arg_16 = toErl "~s\n"
               in let
                 _ =
                   BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                     [arg_16, ErlangCons label_12 ErlangEmptyList]
               in let lcRet_15 = BIF.erlang__apply__2 [fun_13, ErlangEmptyList]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_8
  in ErlangAtom "ok"
erlps__run_test__1 [arg_21] = EXC.function_clause unit
erlps__run_test__1 args =
  EXC.badarity (ErlangFun 1 erlps__run_test__1) args

erlps__simple_compile_test___0 :: ErlangFun
erlps__simple_compile_test___0 [] =
  let    lcSrc_1 = erlps__compilable_contracts__0 []
  in let
    lop_0 =
      flmap
        (\ lc_3 ->
           flmap
             (\ lc_10 ->
                let    arg_14 = erlps__not_compilable_on__1 [lc_10]
                in let op_arg_12 = BIF.lists__member__2 [lc_3, arg_14]
                in let cond_11 = BIF.erlang__not__1 [op_arg_12]
                in
                  case cond_11 of
                    (ErlangAtom "true") ->
                      let    lop_18 = toErl "Testing the "
                      in let lop_22 = toErl " contract with the "
                      in let lop_24 = BIF.erlang__atom_to_list__1 [lc_10]
                      in let rop_26 = toErl " backend"
                      in let rop_23 = BIF.erlang__op_append [lop_24, rop_26]
                      in let rop_21 = BIF.erlang__op_append [lop_22, rop_23]
                      in let rop_19 = BIF.erlang__op_append [lc_3, rop_21]
                      in let tup_el_17 = BIF.erlang__op_append [lop_18, rop_19]
                      in let
                        tup_el_27 =
                          ErlangFun 0
                            (let
                               lambda_28 [] =
                                 let case_29 = erlps__compile__2 [lc_10, lc_3]
                                 in
                                   case case_29 of
                                     (ErlangMap map_32) | (DM.Just _) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "type_info")
                                                               map_32)
                                                        , (DM.Just _) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "contract_source")
                                                               map_32)
                                                        , (DM.Just bytecode_33) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "byte_code")
                                                               map_32)
                                                        , weakEq lc_10
                                                            (ErlangAtom
                                                               "aevm") ->
                                       let
                                         fun_34 =
                                           ErlangFun 0
                                             (let
                                                lambda_35 [] =
                                                  case bytecode_33 of
                                                    code_37 | isEBinary
                                                                code_37 ->
                                                      ErlangAtom "ok"
                                                    __v_38 ->
                                                      let   
                                                        head_42 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "module",
                                                             ErlangAtom
                                                               "aeso_compiler_tests"]
                                                      in let
                                                        tup_el_48 = toErl 33
                                                      in let
                                                        head_46 =
                                                          ErlangTuple
                                                            [ErlangAtom "line",
                                                             tup_el_48]
                                                      in let
                                                        tup_el_52 =
                                                          toErl "ByteCode"
                                                      in let
                                                        head_50 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "expression",
                                                             tup_el_52]
                                                      in let
                                                        tup_el_56 =
                                                          toErl
                                                            "Code when is_binary ( Code )"
                                                      in let
                                                        head_54 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "pattern",
                                                             tup_el_56]
                                                      in let
                                                        head_58 =
                                                          ErlangTuple
                                                            [ErlangAtom "value",
                                                             __v_38]
                                                      in let
                                                        arg_39 =
                                                          ErlangTuple
                                                            [ErlangAtom
                                                               "assertMatch",
                                                             ErlangCons head_42
                                                               (ErlangCons
                                                                  head_46
                                                                  (ErlangCons
                                                                     head_50
                                                                     (ErlangCons
                                                                        head_54
                                                                        (ErlangCons
                                                                           head_58
                                                                           ErlangEmptyList))))]
                                                      in
                                                        BIF.erlang__error__1
                                                          [arg_39]
                                                lambda_35 [] =
                                                  EXC.function_clause unit
                                                lambda_35 args =
                                                  EXC.badarity
                                                    (ErlangFun 0 lambda_35) args
                                              in lambda_35)
                                       in
                                         BIF.erlang__apply__2
                                           [fun_34, ErlangEmptyList]
                                     (ErlangMap map_62) | (DM.Just code_63) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "fate_code")
                                                               map_62)
                                                        , weakEq lc_10
                                                            (ErlangAtom
                                                               "fate") ->
                                       let   
                                         arg_64 =
                                           BIF.do_remote_fun_call
                                             "Aeb.Fate.Code"
                                             "erlps__serialize__1" [code_63]
                                       in let
                                         code1_66 =
                                           BIF.do_remote_fun_call
                                             "Aeb.Fate.Code"
                                             "erlps__deserialize__1" [arg_64]
                                       in let
                                         fun_67 =
                                           ErlangFun 0
                                             (let
                                                lambda_68 [] =
                                                  let
                                                    case_69 =
                                                      ErlangTuple
                                                        [code1_66, code_63]
                                                  in
                                                    case case_69 of
                                                      (ErlangTuple [x_72,
                                                                    x_73]) | x_73 ==
                                                                               x_72 ->
                                                        ErlangAtom "ok"
                                                      __v_74 ->
                                                        let   
                                                          head_78 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "module",
                                                               ErlangAtom
                                                                 "aeso_compiler_tests"]
                                                        in let
                                                          tup_el_84 = toErl 36
                                                        in let
                                                          head_82 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "line",
                                                               tup_el_84]
                                                        in let
                                                          tup_el_88 =
                                                            toErl
                                                              "{ Code1 , Code }"
                                                        in let
                                                          head_86 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "expression",
                                                               tup_el_88]
                                                        in let
                                                          tup_el_92 =
                                                            toErl "{ X , X }"
                                                        in let
                                                          head_90 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "pattern",
                                                               tup_el_92]
                                                        in let
                                                          head_94 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "value",
                                                               __v_74]
                                                        in let
                                                          arg_75 =
                                                            ErlangTuple
                                                              [ErlangAtom
                                                                 "assertMatch",
                                                               ErlangCons
                                                                 head_78
                                                                 (ErlangCons
                                                                    head_82
                                                                    (ErlangCons
                                                                       head_86
                                                                       (ErlangCons
                                                                          head_90
                                                                          (ErlangCons
                                                                             head_94
                                                                             ErlangEmptyList))))]
                                                        in
                                                          BIF.erlang__error__1
                                                            [arg_75]
                                                lambda_68 [] =
                                                  EXC.function_clause unit
                                                lambda_68 args =
                                                  EXC.badarity
                                                    (ErlangFun 0 lambda_68) args
                                              in lambda_68)
                                       in
                                         BIF.erlang__apply__2
                                           [fun_67, ErlangEmptyList]
                                     error_98 ->
                                       let    arg_99 = toErl "\n\n~p\n\n"
                                       in let
                                         _ =
                                           BIF.do_remote_fun_call "Erlang.Io"
                                             "erlps__format__2"
                                             [arg_99,
                                              ErlangCons error_98
                                                ErlangEmptyList]
                                       in erlps__print_and_throw__1 [error_98]
                               lambda_28 [] = EXC.function_clause unit
                               lambda_28 args =
                                 EXC.badarity (ErlangFun 0 lambda_28) args
                             in lambda_28)
                      in let lcRet_16 = ErlangTuple [tup_el_17, tup_el_27]
                      in ErlangCons lcRet_16 ErlangEmptyList
                    _ -> ErlangEmptyList)
             (ErlangCons (ErlangAtom "aevm")
                (ErlangCons (ErlangAtom "fate") ErlangEmptyList)))
        lcSrc_1
  in let tup_el_107 = toErl "Test file not found error"
  in let
    tup_el_108 =
      ErlangFun 0
        (let
           lambda_109 [] =
             let    arg_110 = toErl "does_not_exist.aes"
             in let
               matchExpr_112 =
                 BIF.do_remote_fun_call "Aeso.Compiler" "erlps__file__1"
                   [arg_110]
             in
               case matchExpr_112 of
                 (ErlangTuple [(ErlangAtom "error"), errors_111]) ->
                   let
                     experr_113 =
                       ErlangBinary
                         (BIN.fromInts
                            (toErl
                               "File error:\ndoes_not_exist.aes: no such file or directory")
                            (toErl 8) 1 BIN.Big)
                   in
                     erlps__check_errors__2
                       [ErlangCons experr_113 ErlangEmptyList, errors_111]
                 _ -> EXC.badmatch matchExpr_112
           lambda_109 [] = EXC.function_clause unit
           lambda_109 args = EXC.badarity (ErlangFun 0 lambda_109) args
         in lambda_109)
  in let head_106 = ErlangTuple [tup_el_107, tup_el_108]
  in let lcSrc_121 = erlps__failing_contracts__0 []
  in let
    lop_120 =
      flmap
        (\ lc_124 ->
           case lc_124 of
             (ErlangTuple [contractname_122, expectederrors_123]) ->
               let    lop_127 = toErl "Testing error messages of "
               in let
                 tup_el_126 = BIF.erlang__op_append [lop_127, contractname_122]
               in let
                 tup_el_129 =
                   ErlangFun 0
                     (let
                        lambda_130 [] =
                          let
                            errors_133 =
                              erlps__compile__2
                                [ErlangAtom "aevm", contractname_122]
                          in
                            erlps__check_errors__2
                              [expectederrors_123, errors_133]
                        lambda_130 [] = EXC.function_clause unit
                        lambda_130 args =
                          EXC.badarity (ErlangFun 0 lambda_130) args
                      in lambda_130)
               in let lcRet_125 = ErlangTuple [tup_el_126, tup_el_129]
               in ErlangCons lcRet_125 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_121
  in let lcSrc_138 = erlps__failing_code_gen_contracts__0 []
  in let
    lop_137 =
      flmap
        (\ lc_141 ->
           case lc_141 of
             (ErlangTuple [contractname_139, expectederror_140]) ->
               flmap
                 (\ lc_148 ->
                    let    lop_151 = toErl "Testing "
                    in let lop_153 = BIF.erlang__atom_to_list__1 [lc_148]
                    in let lop_156 = toErl " code generation error messages of "
                    in let
                      rop_155 =
                        BIF.erlang__op_append [lop_156, contractname_139]
                    in let rop_152 = BIF.erlang__op_append [lop_153, rop_155]
                    in let tup_el_150 = BIF.erlang__op_append [lop_151, rop_152]
                    in let
                      tup_el_158 =
                        ErlangFun 0
                          (let
                             lambda_159 [] =
                               let   
                                 errors_162 =
                                   erlps__compile__2 [lc_148, contractname_139]
                               in let
                                 case_163 =
                                   BIF.erlang__is_binary__1 [expectederror_140]
                               in let
                                 expect_174 =
                                   case case_163 of
                                     (ErlangAtom "true") ->
                                       ErlangCons expectederror_140
                                         ErlangEmptyList
                                     (ErlangAtom "false") ->
                                       let
                                         case_167 =
                                           BIF.do_remote_fun_call "Proplists"
                                             "erlps__get_value__3"
                                             [lc_148, expectederror_140,
                                              ErlangAtom "no_error"]
                                       in
                                         case case_167 of
                                           (ErlangAtom "no_error") ->
                                             ErlangAtom "no_error"
                                           err_171 ->
                                             ErlangCons err_171 ErlangEmptyList
                                     something_else ->
                                       EXC.case_clause something_else
                               in
                                 erlps__check_errors__2 [expect_174, errors_162]
                             lambda_159 [] = EXC.function_clause unit
                             lambda_159 args =
                               EXC.badarity (ErlangFun 0 lambda_159) args
                           in lambda_159)
                    in let lcRet_149 = ErlangTuple [tup_el_150, tup_el_158]
                    in ErlangCons lcRet_149 ErlangEmptyList)
                 (ErlangCons (ErlangAtom "aevm")
                    (ErlangCons (ErlangAtom "fate") ErlangEmptyList))
             _ -> ErlangEmptyList)
        lcSrc_138
  in let tup_el_180 = toErl "Testing include with explicit files"
  in let
    tup_el_181 =
      ErlangFun 0
        (let
           lambda_182 [] =
             let    head_185 = toErl "included.aes"
             in let head_187 = toErl "../contracts/included2.aes"
             in let
               arg_183 =
                 flmap
                   (\ lc_190 ->
                      let   
                        head_194 =
                          BIF.do_remote_fun_call "Aeso.Test.Utils"
                            "erlps__contract_path__0" []
                      in let
                        arg_192 =
                          BIF.do_remote_fun_call "Filename" "erlps__join__1"
                            [ErlangCons head_194
                               (ErlangCons lc_190 ErlangEmptyList)]
                      in let
                        matchExpr_199 =
                          BIF.do_remote_fun_call "File" "erlps__read_file__1"
                            [arg_192]
                      in
                        case matchExpr_199 of
                          (ErlangTuple [(ErlangAtom "ok"), bin_198]) ->
                            let lcRet_191 = ErlangTuple [lc_190, bin_198]
                            in ErlangCons lcRet_191 ErlangEmptyList
                          _ -> EXC.badmatch matchExpr_199)
                   (ErlangCons head_185 (ErlangCons head_187 ErlangEmptyList))
             in let filesystem_202 = BIF.maps__from_list__1 [arg_183]
             in let arg_204 = toErl "include"
             in let
               tup_el_208 =
                 ErlangTuple [ErlangAtom "explicit_files", filesystem_202]
             in let head_206 = ErlangTuple [ErlangAtom "include", tup_el_208]
             in let
               matchExpr_214 =
                 erlps__compile__3
                   [ErlangAtom "aevm", arg_204,
                    ErlangCons head_206 ErlangEmptyList]
             in
               case matchExpr_214 of
                 (ErlangMap map_212) | (DM.Just code1_213) <-
                                         (Map.lookup (ErlangAtom "byte_code")
                                            map_212) ->
                   let    arg_216 = toErl "include"
                   in let
                     matchExpr_219 =
                       erlps__compile__2 [ErlangAtom "aevm", arg_216]
                   in
                     case matchExpr_219 of
                       (ErlangMap map_217) | (DM.Just code2_218) <-
                                               (Map.lookup
                                                  (ErlangAtom "byte_code")
                                                  map_217) ->
                         let
                           fun_220 =
                             ErlangFun 0
                               (let
                                  lambda_221 [] =
                                    let
                                      case_222 =
                                        BIF.erlang__op_eq [code1_213, code2_218]
                                    in
                                      case case_222 of
                                        (ErlangAtom "true") -> ErlangAtom "ok"
                                        __v_225 ->
                                          let   
                                            head_229 =
                                              ErlangTuple
                                                [ErlangAtom "module",
                                                 ErlangAtom
                                                   "aeso_compiler_tests"]
                                          in let tup_el_235 = toErl 78
                                          in let
                                            head_233 =
                                              ErlangTuple
                                                [ErlangAtom "line", tup_el_235]
                                          in let
                                            tup_el_239 = toErl "Code1 == Code2"
                                          in let
                                            head_237 =
                                              ErlangTuple
                                                [ErlangAtom "expression",
                                                 tup_el_239]
                                          in let tup_el_243 = toErl "true"
                                          in let
                                            head_241 =
                                              ErlangTuple
                                                [ErlangAtom "pattern",
                                                 tup_el_243]
                                          in let
                                            head_245 =
                                              ErlangTuple
                                                [ErlangAtom "value", __v_225]
                                          in let
                                            arg_226 =
                                              ErlangTuple
                                                [ErlangAtom "assertMatch",
                                                 ErlangCons head_229
                                                   (ErlangCons head_233
                                                      (ErlangCons head_237
                                                         (ErlangCons head_241
                                                            (ErlangCons head_245
                                                               ErlangEmptyList))))]
                                          in BIF.erlang__error__1 [arg_226]
                                  lambda_221 [] = EXC.function_clause unit
                                  lambda_221 args =
                                    EXC.badarity (ErlangFun 0 lambda_221) args
                                in lambda_221)
                         in BIF.erlang__apply__2 [fun_220, ErlangEmptyList]
                       _ -> EXC.badmatch matchExpr_219
                 _ -> EXC.badmatch matchExpr_214
           lambda_182 [] = EXC.function_clause unit
           lambda_182 args = EXC.badarity (ErlangFun 0 lambda_182) args
         in lambda_182)
  in let head_179 = ErlangTuple [tup_el_180, tup_el_181]
  in let
    lop_251 =
      flmap
        (\ lc_258 ->
           let    lop_261 = toErl "Testing deadcode elimination for "
           in let rop_262 = BIF.erlang__atom_to_list__1 [lc_258]
           in let tup_el_260 = BIF.erlang__op_append [lop_261, rop_262]
           in let
             tup_el_264 =
               ErlangFun 0
                 (let
                    lambda_265 [] =
                      let    arg_267 = toErl "nodeadcode"
                      in let matchExpr_270 = erlps__compile__2 [lc_258, arg_267]
                      in
                        case matchExpr_270 of
                          (ErlangMap map_268) | (DM.Just nodeadcode_269) <-
                                                  (Map.lookup
                                                     (ErlangAtom "byte_code")
                                                     map_268) ->
                            let    arg_272 = toErl "deadcode"
                            in let
                              matchExpr_275 =
                                erlps__compile__2 [lc_258, arg_272]
                            in
                              case matchExpr_275 of
                                (ErlangMap map_273) | (DM.Just deadcode_274) <-
                                                        (Map.lookup
                                                           (ErlangAtom
                                                              "byte_code")
                                                           map_273) ->
                                  let   
                                    sizenodeadcode_277 =
                                      BIF.erlang__byte_size__1 [nodeadcode_269]
                                  in let
                                    sizedeadcode_279 =
                                      BIF.erlang__byte_size__1 [deadcode_274]
                                  in let
                                    delta_280 =
                                      case ErlangAtom "true" of
                                        _ | weakEq lc_258 (ErlangAtom "aevm") ->
                                          toErl 40
                                        _ | weakEq lc_258 (ErlangAtom "fate") ->
                                          toErl 20
                                        _ -> EXC.if_clause unit
                                  in let
                                    fun_281 =
                                      ErlangFun 0
                                        (let
                                           lambda_282 [] =
                                             let   
                                               lop_287 =
                                                 BIF.erlang__op_plus
                                                   [sizedeadcode_279, delta_280]
                                             in let
                                               tup_el_286 =
                                                 BIF.erlang__op_lesser
                                                   [lop_287, sizenodeadcode_277]
                                             in let
                                               case_283 =
                                                 ErlangTuple
                                                   [sizedeadcode_279,
                                                    sizenodeadcode_277,
                                                    tup_el_286]
                                             in
                                               case case_283 of
                                                 (ErlangTuple [_, _,
                                                               (ErlangAtom "true")]) ->
                                                   ErlangAtom "ok"
                                                 __v_291 ->
                                                   let   
                                                     head_295 =
                                                       ErlangTuple
                                                         [ErlangAtom "module",
                                                          ErlangAtom
                                                            "aeso_compiler_tests"]
                                                   in let tup_el_301 = toErl 88
                                                   in let
                                                     head_299 =
                                                       ErlangTuple
                                                         [ErlangAtom "line",
                                                          tup_el_301]
                                                   in let
                                                     tup_el_305 =
                                                       toErl
                                                         "{ SizeDeadCode , SizeNoDeadCode , SizeDeadCode + Delta < SizeNoDeadCode }"
                                                   in let
                                                     head_303 =
                                                       ErlangTuple
                                                         [ErlangAtom
                                                            "expression",
                                                          tup_el_305]
                                                   in let
                                                     tup_el_309 =
                                                       toErl "{ _ , _ , true }"
                                                   in let
                                                     head_307 =
                                                       ErlangTuple
                                                         [ErlangAtom "pattern",
                                                          tup_el_309]
                                                   in let
                                                     head_311 =
                                                       ErlangTuple
                                                         [ErlangAtom "value",
                                                          __v_291]
                                                   in let
                                                     arg_292 =
                                                       ErlangTuple
                                                         [ErlangAtom
                                                            "assertMatch",
                                                          ErlangCons head_295
                                                            (ErlangCons head_299
                                                               (ErlangCons
                                                                  head_303
                                                                  (ErlangCons
                                                                     head_307
                                                                     (ErlangCons
                                                                        head_311
                                                                        ErlangEmptyList))))]
                                                   in
                                                     BIF.erlang__error__1
                                                       [arg_292]
                                           lambda_282 [] =
                                             EXC.function_clause unit
                                           lambda_282 args =
                                             EXC.badarity
                                               (ErlangFun 0 lambda_282) args
                                         in lambda_282)
                                    _ =
                                      BIF.erlang__apply__2
                                        [fun_281, ErlangEmptyList]
                                  in ErlangAtom "ok"
                                _ -> EXC.badmatch matchExpr_275
                          _ -> EXC.badmatch matchExpr_270
                    lambda_265 [] = EXC.function_clause unit
                    lambda_265 args = EXC.badarity (ErlangFun 0 lambda_265) args
                  in lambda_265)
           in let lcRet_259 = ErlangTuple [tup_el_260, tup_el_264]
           in ErlangCons lcRet_259 ErlangEmptyList)
        (ErlangCons (ErlangAtom "aevm")
           (ErlangCons (ErlangAtom "fate") ErlangEmptyList))
  in let rop_250 = BIF.erlang__op_append [lop_251, ErlangEmptyList]
  in let
    rop_177 =
      BIF.erlang__op_append
        [ErlangCons head_179 ErlangEmptyList, rop_250]
  in let rop_136 = BIF.erlang__op_append [lop_137, rop_177]
  in let rop_119 = BIF.erlang__op_append [lop_120, rop_136]
  in let
    rop_104 =
      BIF.erlang__op_append
        [ErlangCons head_106 ErlangEmptyList, rop_119]
  in BIF.erlang__op_append [lop_0, rop_104]
erlps__simple_compile_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__simple_compile_test___0) args

erlps__check_errors__2 :: ErlangFun
erlps__check_errors__2 [(ErlangAtom "no_error"), actual_0] =
  let
    fun_1 =
      ErlangFun 0
        (let
           lambda_2 [] =
             case actual_0 of
               (ErlangMap map_4) -> ErlangAtom "ok"
               __v_5 ->
                 let   
                   head_9 =
                     ErlangTuple
                       [ErlangAtom "module", ErlangAtom "aeso_compiler_tests"]
                 in let tup_el_15 = toErl 93
                 in let head_13 = ErlangTuple [ErlangAtom "line", tup_el_15]
                 in let tup_el_19 = toErl "Actual"
                 in let
                   head_17 = ErlangTuple [ErlangAtom "expression", tup_el_19]
                 in let tup_el_23 = toErl "# { }"
                 in let head_21 = ErlangTuple [ErlangAtom "pattern", tup_el_23]
                 in let head_25 = ErlangTuple [ErlangAtom "value", __v_5]
                 in let
                   arg_6 =
                     ErlangTuple
                       [ErlangAtom "assertMatch",
                        ErlangCons head_9
                          (ErlangCons head_13
                             (ErlangCons head_17
                                (ErlangCons head_21
                                   (ErlangCons head_25 ErlangEmptyList))))]
                 in BIF.erlang__error__1 [arg_6]
           lambda_2 [] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 0 lambda_2) args
         in lambda_2)
  in BIF.erlang__apply__2 [fun_1, ErlangEmptyList]
erlps__check_errors__2 [expect_0, (ErlangMap map_1)] =
  let
    fun_2 =
      ErlangFun 0
        (let
           lambda_3 [] =
             let __x_6 = ErlangTuple [ErlangAtom "error", expect_0]
             in
               case ErlangAtom "ok" of
                 __x_8 | __x_8 == __x_6 -> ErlangAtom "ok"
                 __v_9 ->
                   let   
                     head_13 =
                       ErlangTuple
                         [ErlangAtom "module", ErlangAtom "aeso_compiler_tests"]
                   in let tup_el_19 = toErl 95
                   in let head_17 = ErlangTuple [ErlangAtom "line", tup_el_19]
                   in let tup_el_23 = toErl "ok"
                   in let
                     head_21 = ErlangTuple [ErlangAtom "expression", tup_el_23]
                   in let head_25 = ErlangTuple [ErlangAtom "expected", __x_6]
                   in let head_29 = ErlangTuple [ErlangAtom "value", __v_9]
                   in let
                     arg_10 =
                       ErlangTuple
                         [ErlangAtom "assertEqual",
                          ErlangCons head_13
                            (ErlangCons head_17
                               (ErlangCons head_21
                                  (ErlangCons head_25
                                     (ErlangCons head_29 ErlangEmptyList))))]
                   in BIF.erlang__error__1 [arg_10]
           lambda_3 [] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 0 lambda_3) args
         in lambda_3)
  in BIF.erlang__apply__2 [fun_2, ErlangEmptyList]
erlps__check_errors__2 [expect0_0, actual0_1] =
  let   
    expect_3 =
      BIF.do_remote_fun_call "Lists" "erlps__sort__1" [expect0_0]
  in let
    actual_11 =
      flmap
        (\ lc_6 ->
           let   
             arg_9 =
               BIF.do_remote_fun_call "Aeso.Errors" "erlps__pp__1" [lc_6]
           in let
             arg_8 = BIF.do_remote_fun_call "String" "erlps__trim__1" [arg_9]
           in let lcRet_7 = BIF.erlang__list_to_binary__1 [arg_8]
           in ErlangCons lcRet_7 ErlangEmptyList)
        actual0_1
  in let tup_el_13 = BIF.erlang__op_unAppend [expect_3, actual_11]
  in let tup_el_16 = BIF.erlang__op_unAppend [actual_11, expect_3]
  in let case_12 = ErlangTuple [tup_el_13, tup_el_16]
  in
    case case_12 of
      (ErlangTuple [(ErlangEmptyList), extra_19]) ->
        let
          fun_20 =
            ErlangFun 0
              (let
                 lambda_21 [] =
                   let case_22 = ErlangTuple [ErlangAtom "unexpected", extra_19]
                   in
                     case case_22 of
                       (ErlangTuple [(ErlangAtom "unexpected"),
                                     (ErlangEmptyList)]) ->
                         ErlangAtom "ok"
                       __v_25 ->
                         let   
                           head_29 =
                             ErlangTuple
                               [ErlangAtom "module",
                                ErlangAtom "aeso_compiler_tests"]
                         in let tup_el_35 = toErl 100
                         in let
                           head_33 = ErlangTuple [ErlangAtom "line", tup_el_35]
                         in let tup_el_39 = toErl "{ unexpected , Extra }"
                         in let
                           head_37 =
                             ErlangTuple [ErlangAtom "expression", tup_el_39]
                         in let tup_el_43 = toErl "{ unexpected , [ ] }"
                         in let
                           head_41 =
                             ErlangTuple [ErlangAtom "pattern", tup_el_43]
                         in let
                           head_45 = ErlangTuple [ErlangAtom "value", __v_25]
                         in let
                           arg_26 =
                             ErlangTuple
                               [ErlangAtom "assertMatch",
                                ErlangCons head_29
                                  (ErlangCons head_33
                                     (ErlangCons head_37
                                        (ErlangCons head_41
                                           (ErlangCons head_45
                                              ErlangEmptyList))))]
                         in BIF.erlang__error__1 [arg_26]
                 lambda_21 [] = EXC.function_clause unit
                 lambda_21 args = EXC.badarity (ErlangFun 0 lambda_21) args
               in lambda_21)
        in BIF.erlang__apply__2 [fun_20, ErlangEmptyList]
      (ErlangTuple [missing_49, (ErlangEmptyList)]) ->
        let
          fun_50 =
            ErlangFun 0
              (let
                 lambda_51 [] =
                   let case_52 = ErlangTuple [ErlangAtom "missing", missing_49]
                   in
                     case case_52 of
                       (ErlangTuple [(ErlangAtom "missing"),
                                     (ErlangEmptyList)]) ->
                         ErlangAtom "ok"
                       __v_55 ->
                         let   
                           head_59 =
                             ErlangTuple
                               [ErlangAtom "module",
                                ErlangAtom "aeso_compiler_tests"]
                         in let tup_el_65 = toErl 101
                         in let
                           head_63 = ErlangTuple [ErlangAtom "line", tup_el_65]
                         in let tup_el_69 = toErl "{ missing , Missing }"
                         in let
                           head_67 =
                             ErlangTuple [ErlangAtom "expression", tup_el_69]
                         in let tup_el_73 = toErl "{ missing , [ ] }"
                         in let
                           head_71 =
                             ErlangTuple [ErlangAtom "pattern", tup_el_73]
                         in let
                           head_75 = ErlangTuple [ErlangAtom "value", __v_55]
                         in let
                           arg_56 =
                             ErlangTuple
                               [ErlangAtom "assertMatch",
                                ErlangCons head_59
                                  (ErlangCons head_63
                                     (ErlangCons head_67
                                        (ErlangCons head_71
                                           (ErlangCons head_75
                                              ErlangEmptyList))))]
                         in BIF.erlang__error__1 [arg_56]
                 lambda_51 [] = EXC.function_clause unit
                 lambda_51 args = EXC.badarity (ErlangFun 0 lambda_51) args
               in lambda_51)
        in BIF.erlang__apply__2 [fun_50, ErlangEmptyList]
      (ErlangTuple [missing_79, extra_80]) ->
        let
          fun_81 =
            ErlangFun 0
              (let
                 lambda_82 [] =
                   case extra_80 of
                     __x_85 | __x_85 == missing_79 -> ErlangAtom "ok"
                     __v_86 ->
                       let   
                         head_90 =
                           ErlangTuple
                             [ErlangAtom "module",
                              ErlangAtom "aeso_compiler_tests"]
                       in let tup_el_96 = toErl 102
                       in let
                         head_94 = ErlangTuple [ErlangAtom "line", tup_el_96]
                       in let tup_el_100 = toErl "Extra"
                       in let
                         head_98 =
                           ErlangTuple [ErlangAtom "expression", tup_el_100]
                       in let
                         head_102 =
                           ErlangTuple [ErlangAtom "expected", missing_79]
                       in let
                         head_106 = ErlangTuple [ErlangAtom "value", __v_86]
                       in let
                         arg_87 =
                           ErlangTuple
                             [ErlangAtom "assertEqual",
                              ErlangCons head_90
                                (ErlangCons head_94
                                   (ErlangCons head_98
                                      (ErlangCons head_102
                                         (ErlangCons head_106
                                            ErlangEmptyList))))]
                       in BIF.erlang__error__1 [arg_87]
                 lambda_82 [] = EXC.function_clause unit
                 lambda_82 args = EXC.badarity (ErlangFun 0 lambda_82) args
               in lambda_82)
        in BIF.erlang__apply__2 [fun_81, ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__check_errors__2 [arg_110, arg_111] =
  EXC.function_clause unit
erlps__check_errors__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_errors__2) args

erlps__compile__2 :: ErlangFun
erlps__compile__2 [backend_0, name_1] =
  let   
    head_10 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__contract_path__0" []
  in let
    tup_el_7 =
      ErlangTuple
        [ErlangAtom "file_system", ErlangCons head_10 ErlangEmptyList]
  in let head_5 = ErlangTuple [ErlangAtom "include", tup_el_7]
  in
    erlps__compile__3
      [backend_0, name_1, ErlangCons head_5 ErlangEmptyList]
erlps__compile__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__compile__2 args =
  EXC.badarity (ErlangFun 2 erlps__compile__2) args

erlps__compile__3 :: ErlangFun
erlps__compile__3 [backend_0, name_1, options_2] =
  let   
    string_4 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__read_contract__1" [name_1]
  in let arg_8 = erlps__debug_mode_contracts__0 []
  in let case_6 = BIF.lists__member__2 [name_1, arg_8]
  in let
    lop_5 =
      case case_6 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "debug_mode") ErlangEmptyList
        (ErlangAtom "false") -> ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in let rop_17 = toErl ".aes"
  in let tup_el_15 = BIF.erlang__op_append [name_1, rop_17]
  in let head_13 = ErlangTuple [ErlangAtom "src_file", tup_el_15]
  in let head_19 = ErlangTuple [ErlangAtom "backend", backend_0]
  in let
    head_28 =
      BIF.do_remote_fun_call "Aeso.Test.Utils"
        "erlps__contract_path__0" []
  in let
    tup_el_25 =
      ErlangTuple
        [ErlangAtom "file_system", ErlangCons head_28 ErlangEmptyList]
  in let head_23 = ErlangTuple [ErlangAtom "include", tup_el_25]
  in let
    rop_11 =
      BIF.erlang__op_append
        [ErlangCons head_13
           (ErlangCons head_19 (ErlangCons head_23 ErlangEmptyList)),
         options_2]
  in let options1_32 = BIF.erlang__op_append [lop_5, rop_11]
  in let
    case_33 =
      BIF.do_remote_fun_call "Aeso.Compiler" "erlps__from_string__2"
        [string_4, options1_32]
  in
    case case_33 of
      (ErlangTuple [(ErlangAtom "ok"), map_36]) -> map_36
      (ErlangTuple [(ErlangAtom "error"), errorstring_37]) | isEBinary
                                                               errorstring_37 ->
        errorstring_37
      (ErlangTuple [(ErlangAtom "error"), errors_38]) -> errors_38
      something_else -> EXC.case_clause something_else
erlps__compile__3 [arg_39, arg_40, arg_41] =
  EXC.function_clause unit
erlps__compile__3 args =
  EXC.badarity (ErlangFun 3 erlps__compile__3) args

erlps__compilable_contracts__0 :: ErlangFun
erlps__compilable_contracts__0 [] =
  let    head_0 = toErl "complex_types"
  in let head_2 = toErl "counter"
  in let head_4 = toErl "dutch_auction"
  in let head_6 = toErl "environment"
  in let head_8 = toErl "factorial"
  in let head_10 = toErl "functions"
  in let head_12 = toErl "fundme"
  in let head_14 = toErl "identity"
  in let head_16 = toErl "maps"
  in let head_18 = toErl "oracles"
  in let head_20 = toErl "remote_call"
  in let head_22 = toErl "simple"
  in let head_24 = toErl "simple_storage"
  in let head_26 = toErl "spend_test"
  in let head_28 = toErl "stack"
  in let head_30 = toErl "test"
  in let head_32 = toErl "builtin_bug"
  in let head_34 = toErl "builtin_map_get_bug"
  in let head_36 = toErl "lc_record_bug"
  in let head_38 = toErl "nodeadcode"
  in let head_40 = toErl "deadcode"
  in let head_42 = toErl "variant_types"
  in let head_44 = toErl "state_handling"
  in let head_46 = toErl "events"
  in let head_48 = toErl "include"
  in let head_50 = toErl "basic_auth"
  in let head_52 = toErl "basic_auth_tx"
  in let head_54 = toErl "bitcoin_auth"
  in let head_56 = toErl "address_literals"
  in let head_58 = toErl "bytes_equality"
  in let head_60 = toErl "address_chain"
  in let head_62 = toErl "namespace_bug"
  in let head_64 = toErl "bytes_to_x"
  in let head_66 = toErl "bytes_concat"
  in let head_68 = toErl "aens"
  in let head_70 = toErl "aens_update"
  in let head_72 = toErl "tuple_match"
  in let head_74 = toErl "cyclic_include"
  in let head_76 = toErl "stdlib_include"
  in let head_78 = toErl "double_include"
  in let head_80 = toErl "manual_stdlib_include"
  in let head_82 = toErl "list_comp"
  in let head_84 = toErl "payable"
  in let head_86 = toErl "unapplied_builtins"
  in let head_88 = toErl "underscore_number_literals"
  in let head_90 = toErl "pairing_crypto"
  in let head_92 = toErl "qualified_constructor"
  in let head_94 = toErl "let_patterns"
  in let head_96 = toErl "lhs_matching"
  in let head_98 = toErl "more_strings"
  in let head_100 = toErl "protected_call"
  in let head_102 = toErl "hermetization_turnoff"
  in let head_104 = toErl "multiple_contracts"
  in let head_106 = toErl "clone"
  in let head_108 = toErl "clone_simple"
  in let head_110 = toErl "create"
  in let head_112 = toErl "test"
  in
    ErlangCons head_0
      (ErlangCons head_2
         (ErlangCons head_4
            (ErlangCons head_6
               (ErlangCons head_8
                  (ErlangCons head_10
                     (ErlangCons head_12
                        (ErlangCons head_14
                           (ErlangCons head_16
                              (ErlangCons head_18
                                 (ErlangCons head_20
                                    (ErlangCons head_22
                                       (ErlangCons head_24
                                          (ErlangCons head_26
                                             (ErlangCons head_28
                                                (ErlangCons head_30
                                                   (ErlangCons head_32
                                                      (ErlangCons head_34
                                                         (ErlangCons head_36
                                                            (ErlangCons head_38
                                                               (ErlangCons
                                                                  head_40
                                                                  (ErlangCons
                                                                     head_42
                                                                     (ErlangCons
                                                                        head_44
                                                                        (ErlangCons
                                                                           head_46
                                                                           (ErlangCons
                                                                              head_48
                                                                              (ErlangCons
                                                                                 head_50
                                                                                 (ErlangCons
                                                                                    head_52
                                                                                    (ErlangCons
                                                                                       head_54
                                                                                       (ErlangCons
                                                                                          head_56
                                                                                          (ErlangCons
                                                                                             head_58
                                                                                             (ErlangCons
                                                                                                head_60
                                                                                                (ErlangCons
                                                                                                   head_62
                                                                                                   (ErlangCons
                                                                                                      head_64
                                                                                                      (ErlangCons
                                                                                                         head_66
                                                                                                         (ErlangCons
                                                                                                            head_68
                                                                                                            (ErlangCons
                                                                                                               head_70
                                                                                                               (ErlangCons
                                                                                                                  head_72
                                                                                                                  (ErlangCons
                                                                                                                     head_74
                                                                                                                     (ErlangCons
                                                                                                                        head_76
                                                                                                                        (ErlangCons
                                                                                                                           head_78
                                                                                                                           (ErlangCons
                                                                                                                              head_80
                                                                                                                              (ErlangCons
                                                                                                                                 head_82
                                                                                                                                 (ErlangCons
                                                                                                                                    head_84
                                                                                                                                    (ErlangCons
                                                                                                                                       head_86
                                                                                                                                       (ErlangCons
                                                                                                                                          head_88
                                                                                                                                          (ErlangCons
                                                                                                                                             head_90
                                                                                                                                             (ErlangCons
                                                                                                                                                head_92
                                                                                                                                                (ErlangCons
                                                                                                                                                   head_94
                                                                                                                                                   (ErlangCons
                                                                                                                                                      head_96
                                                                                                                                                      (ErlangCons
                                                                                                                                                         head_98
                                                                                                                                                         (ErlangCons
                                                                                                                                                            head_100
                                                                                                                                                            (ErlangCons
                                                                                                                                                               head_102
                                                                                                                                                               (ErlangCons
                                                                                                                                                                  head_104
                                                                                                                                                                  (ErlangCons
                                                                                                                                                                     head_106
                                                                                                                                                                     (ErlangCons
                                                                                                                                                                        head_108
                                                                                                                                                                        (ErlangCons
                                                                                                                                                                           head_110
                                                                                                                                                                           (ErlangCons
                                                                                                                                                                              head_112
                                                                                                                                                                              ErlangEmptyList))))))))))))))))))))))))))))))))))))))))))))))))))))))))
erlps__compilable_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__compilable_contracts__0) args

erlps__not_compilable_on__1 :: ErlangFun
erlps__not_compilable_on__1 [(ErlangAtom "fate")] =
  ErlangEmptyList
erlps__not_compilable_on__1 [(ErlangAtom "aevm")] =
  erlps__compilable_contracts__0 []
erlps__not_compilable_on__1 [arg_0] = EXC.function_clause unit
erlps__not_compilable_on__1 args =
  EXC.badarity (ErlangFun 1 erlps__not_compilable_on__1) args

erlps__debug_mode_contracts__0 :: ErlangFun
erlps__debug_mode_contracts__0 [] =
  let head_0 = toErl "hermetization_turnoff"
  in ErlangCons head_0 ErlangEmptyList
erlps__debug_mode_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__debug_mode_contracts__0) args

erlps__failing_contracts__0 :: ErlangFun
erlps__failing_contracts__0 [] =
  let
    matchExpr_1 =
      BIF.do_remote_fun_call "Aeso.Compiler"
        "erlps__numeric_version__0" []
  in
    case matchExpr_1 of
      (ErlangTuple [(ErlangAtom "ok"), v_0]) ->
        let   
          arg_3 =
            flmap
              (\ lc_6 ->
                 let lcRet_7 = BIF.erlang__integer_to_list__1 [lc_6]
                 in ErlangCons lcRet_7 ErlangEmptyList)
              v_0
        in let arg_9 = toErl "."
        in let
          arg_2 =
            BIF.do_remote_fun_call "String" "erlps__join__2" [arg_3, arg_9]
        in let version_10 = BIF.erlang__list_to_binary__1 [arg_2]
        in let
          fun_12 =
            ErlangFun 0
              (let
                 lambda_13 [] =
                   let    __kind_14 = toErl "Parse"
                   in let __file_15 = toErl "field_parse_error"
                   in let bin_el_19 = BIF.erlang__list_to_binary__1 [__kind_14]
                   in let bin_el_21 = BIF.erlang__list_to_binary__1 [__file_15]
                   in let
                     head_18 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_19 (BIN.packedSize bin_el_19)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_21 (BIN.packedSize bin_el_21)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 26:\nCannot use nested fields or keys in record construction: p.x")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_15, ErlangCons head_18 ErlangEmptyList]
                 lambda_13 [] = EXC.function_clause unit
                 lambda_13 args = EXC.badarity (ErlangFun 0 lambda_13) args
               in lambda_13)
        in let head_11 = BIF.erlang__apply__2 [fun_12, ErlangEmptyList]
        in let
          fun_26 =
            ErlangFun 0
              (let
                 lambda_27 [] =
                   let    __kind_28 = toErl "Parse"
                   in let __file_29 = toErl "vsemi"
                   in let bin_el_33 = BIF.erlang__list_to_binary__1 [__kind_28]
                   in let bin_el_35 = BIF.erlang__list_to_binary__1 [__file_29]
                   in let
                     head_32 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_33 (BIN.packedSize bin_el_33)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_35 (BIN.packedSize bin_el_35)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 3:\nUnexpected indentation. Did you forget a \'}\'?")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_29, ErlangCons head_32 ErlangEmptyList]
                 lambda_27 [] = EXC.function_clause unit
                 lambda_27 args = EXC.badarity (ErlangFun 0 lambda_27) args
               in lambda_27)
        in let head_25 = BIF.erlang__apply__2 [fun_26, ErlangEmptyList]
        in let
          fun_40 =
            ErlangFun 0
              (let
                 lambda_41 [] =
                   let    __kind_42 = toErl "Parse"
                   in let __file_43 = toErl "vclose"
                   in let bin_el_47 = BIF.erlang__list_to_binary__1 [__kind_42]
                   in let bin_el_49 = BIF.erlang__list_to_binary__1 [__file_43]
                   in let
                     head_46 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_47 (BIN.packedSize bin_el_47)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_49 (BIN.packedSize bin_el_49)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 3:\nUnexpected indentation. Did you forget a \']\'?")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_43, ErlangCons head_46 ErlangEmptyList]
                 lambda_41 [] = EXC.function_clause unit
                 lambda_41 args = EXC.badarity (ErlangFun 0 lambda_41) args
               in lambda_41)
        in let head_39 = BIF.erlang__apply__2 [fun_40, ErlangEmptyList]
        in let
          fun_54 =
            ErlangFun 0
              (let
                 lambda_55 [] =
                   let    __kind_56 = toErl "Parse"
                   in let __file_57 = toErl "indent_fail"
                   in let bin_el_61 = BIF.erlang__list_to_binary__1 [__kind_56]
                   in let bin_el_63 = BIF.erlang__list_to_binary__1 [__file_57]
                   in let
                     head_60 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_61 (BIN.packedSize bin_el_61)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_63 (BIN.packedSize bin_el_63)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 2:\nUnexpected token \'entrypoint\'.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple [__file_57, ErlangCons head_60 ErlangEmptyList]
                 lambda_55 [] = EXC.function_clause unit
                 lambda_55 args = EXC.badarity (ErlangFun 0 lambda_55) args
               in lambda_55)
        in let head_53 = BIF.erlang__apply__2 [fun_54, ErlangEmptyList]
        in let
          fun_68 =
            ErlangFun 0
              (let
                 lambda_69 [] =
                   let    __kind_70 = toErl "Type"
                   in let __file_71 = toErl "name_clash"
                   in let bin_el_75 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_77 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_74 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_75 (BIN.packedSize bin_el_75)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_77 (BIN.packedSize bin_el_77)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 3:\nDuplicate definitions of abort at\n  - (builtin location)\n  - line 14, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_81 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_83 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_80 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_81 (BIN.packedSize bin_el_81)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_83 (BIN.packedSize bin_el_83)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 3:\nDuplicate definitions of require at\n  - (builtin location)\n  - line 15, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_87 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_89 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_86 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_87 (BIN.packedSize bin_el_87)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_89 (BIN.packedSize bin_el_89)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 3:\nDuplicate definitions of double_def at\n  - line 10, column 3\n  - line 11, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_93 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_95 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_92 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_93 (BIN.packedSize bin_el_93)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_95 (BIN.packedSize bin_el_95)
                               8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 3:\nDuplicate definitions of double_proto at\n  - line 4, column 3\n  - line 5, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_99 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_101 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_98 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_99 (BIN.packedSize bin_el_99)
                               8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_101
                               (BIN.packedSize bin_el_101) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 8, col 3:\nDuplicate definitions of proto_and_def at\n  - line 7, column 3\n  - line 8, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_105 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_107 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_104 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_105
                               (BIN.packedSize bin_el_105) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_107
                               (BIN.packedSize bin_el_107) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 3:\nDuplicate definitions of put at\n  - (builtin location)\n  - line 16, column 3")
                               (toErl 8) 1 BIN.Big])
                   in let bin_el_111 = BIF.erlang__list_to_binary__1 [__kind_70]
                   in let bin_el_113 = BIF.erlang__list_to_binary__1 [__file_71]
                   in let
                     head_110 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_111
                               (BIN.packedSize bin_el_111) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_113
                               (BIN.packedSize bin_el_113) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 17, col 3:\nDuplicate definitions of state at\n  - (builtin location)\n  - line 17, column 3")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_71,
                        ErlangCons head_74
                          (ErlangCons head_80
                             (ErlangCons head_86
                                (ErlangCons head_92
                                   (ErlangCons head_98
                                      (ErlangCons head_104
                                         (ErlangCons head_110
                                            ErlangEmptyList))))))]
                 lambda_69 [] = EXC.function_clause unit
                 lambda_69 args = EXC.badarity (ErlangFun 0 lambda_69) args
               in lambda_69)
        in let head_67 = BIF.erlang__apply__2 [fun_68, ErlangEmptyList]
        in let
          fun_118 =
            ErlangFun 0
              (let
                 lambda_119 [] =
                   let    __kind_120 = toErl "Type"
                   in let __file_121 = toErl "type_errors"
                   in let
                     bin_el_125 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_127 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_124 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_125
                               (BIN.packedSize bin_el_125) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_127
                               (BIN.packedSize bin_el_127) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 17, col 23:\nUnbound variable zz at line 17, column 23")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_131 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_133 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_130 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_131
                               (BIN.packedSize bin_el_131) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_133
                               (BIN.packedSize bin_el_133) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 26, col 9:\nCannot unify int\n         and list(int)\nwhen checking the application at line 26, column 9 of\n  (::) : (int, list(int)) => list(int)\nto arguments\n  x : int\n  x : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_137 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_139 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_136 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_137
                               (BIN.packedSize bin_el_137) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_139
                               (BIN.packedSize bin_el_139) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 48:\nCannot unify string\n         and int\nwhen checking the assignment of the field\n  x : map(string, string) (at line 9, column 48)\nto the old value __x and the new value\n  __x {[\"foo\"] @ x = x + 1} : map(string, int)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_143 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_145 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_142 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_143
                               (BIN.packedSize bin_el_143) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_145
                               (BIN.packedSize bin_el_145) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 34, col 47:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 34, column 47\n  1 : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_149 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_151 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_148 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_149
                               (BIN.packedSize bin_el_149) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_151
                               (BIN.packedSize bin_el_151) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 34, col 52:\nCannot unify string\n         and int\nwhen checking the type of the expression at line 34, column 52\n  \"bla\" : string\nagainst the expected type\n  int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_155 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_157 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_154 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_155
                               (BIN.packedSize bin_el_155) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_157
                               (BIN.packedSize bin_el_157) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 32, col 18:\nCannot unify string\n         and int\nwhen checking the type of the expression at line 32, column 18\n  \"x\" : string\nagainst the expected type\n  int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_161 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_163 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_160 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_161
                               (BIN.packedSize bin_el_161) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_163
                               (BIN.packedSize bin_el_163) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 58:\nCannot unify string\n         and int\nwhen checking the type of the expression at line 11, column 58\n  \"foo\" : string\nagainst the expected type\n  int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_167 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_169 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_166 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_167
                               (BIN.packedSize bin_el_167) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_169
                               (BIN.packedSize bin_el_169) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 38, col 13:\nCannot unify int\n         and string\nwhen comparing the types of the if-branches\n  - w : int (at line 38, column 13)\n  - z : string (at line 39, column 10)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_173 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_175 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_172 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_173
                               (BIN.packedSize bin_el_173) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_175
                               (BIN.packedSize bin_el_175) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 22, col 40:\nNot a record type: string\narising from the projection of the field y (at line 22, column 40)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_179 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_181 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_178 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_179
                               (BIN.packedSize bin_el_179) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_181
                               (BIN.packedSize bin_el_181) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 21, col 44:\nNot a record type: string\narising from an assignment of the field y (at line 21, column 44)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_185 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_187 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_184 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_185
                               (BIN.packedSize bin_el_185) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_187
                               (BIN.packedSize bin_el_187) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 20, col 40:\nNot a record type: string\narising from an assignment of the field y (at line 20, column 40)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_191 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_193 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_190 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_191
                               (BIN.packedSize bin_el_191) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_193
                               (BIN.packedSize bin_el_193) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 19, col 37:\nNot a record type: string\narising from an assignment of the field y (at line 19, column 37)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_197 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_199 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_196 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_197
                               (BIN.packedSize bin_el_197) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_199
                               (BIN.packedSize bin_el_199) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 27:\nAmbiguous record type with field y (at line 13, column 27) could be one of\n  - r (at line 4, column 10)\n  - r\' (at line 5, column 10)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_203 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_205 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_202 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_203
                               (BIN.packedSize bin_el_203) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_205
                               (BIN.packedSize bin_el_205) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 26, col 7:\nRepeated name x in pattern\n  x :: x (at line 26, column 7)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_209 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_211 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_208 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_209
                               (BIN.packedSize bin_el_209) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_211
                               (BIN.packedSize bin_el_211) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 44, col 14:\nRepeated names x, y in pattern\n  (x : int, y, x : string, y : bool) (at line 44, column 14)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_215 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_217 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_214 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_215
                               (BIN.packedSize bin_el_215) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_217
                               (BIN.packedSize bin_el_217) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 44, col 39:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 44, column 39\n  x : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_221 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_223 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_220 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_221
                               (BIN.packedSize bin_el_221) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_223
                               (BIN.packedSize bin_el_223) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 44, col 72:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 44, column 72\n  x : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_227 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_229 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_226 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_227
                               (BIN.packedSize bin_el_227) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_229
                               (BIN.packedSize bin_el_229) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 24:\nNo record type with fields y, z (at line 14, column 24)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_233 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_235 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_232 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_233
                               (BIN.packedSize bin_el_233) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_235
                               (BIN.packedSize bin_el_235) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 26:\nThe field z is missing when constructing an element of type r2 (at line 15, column 26)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_239 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_241 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_238 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_239
                               (BIN.packedSize bin_el_239) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_241
                               (BIN.packedSize bin_el_241) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 24:\nRecord type r2 does not have field y (at line 15, column 24)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_245 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_247 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_244 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_245
                               (BIN.packedSize bin_el_245) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_247
                               (BIN.packedSize bin_el_247) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 47, col 5:\nLet binding at line 47, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_251 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_253 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_250 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_251
                               (BIN.packedSize bin_el_251) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_253
                               (BIN.packedSize bin_el_253) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 50, col 5:\nLet binding at line 50, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_257 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_259 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_256 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_257
                               (BIN.packedSize bin_el_257) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_259
                               (BIN.packedSize bin_el_259) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 54, col 5:\nLet binding at line 54, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_263 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_265 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_262 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_263
                               (BIN.packedSize bin_el_263) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_265
                               (BIN.packedSize bin_el_265) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 58, col 5:\nLet binding at line 58, column 5 must be followed by an expression")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_269 = BIF.erlang__list_to_binary__1 [__kind_120]
                   in let
                     bin_el_271 = BIF.erlang__list_to_binary__1 [__file_121]
                   in let
                     head_268 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_269
                               (BIN.packedSize bin_el_269) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_271
                               (BIN.packedSize bin_el_271) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 63, col 5:\nCannot unify int\n         and bool\nwhen checking the type of the expression at line 63, column 5\n  id(n) : int\nagainst the expected type\n  bool")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_121,
                        ErlangCons head_124
                          (ErlangCons head_130
                             (ErlangCons head_136
                                (ErlangCons head_142
                                   (ErlangCons head_148
                                      (ErlangCons head_154
                                         (ErlangCons head_160
                                            (ErlangCons head_166
                                               (ErlangCons head_172
                                                  (ErlangCons head_178
                                                     (ErlangCons head_184
                                                        (ErlangCons head_190
                                                           (ErlangCons head_196
                                                              (ErlangCons
                                                                 head_202
                                                                 (ErlangCons
                                                                    head_208
                                                                    (ErlangCons
                                                                       head_214
                                                                       (ErlangCons
                                                                          head_220
                                                                          (ErlangCons
                                                                             head_226
                                                                             (ErlangCons
                                                                                head_232
                                                                                (ErlangCons
                                                                                   head_238
                                                                                   (ErlangCons
                                                                                      head_244
                                                                                      (ErlangCons
                                                                                         head_250
                                                                                         (ErlangCons
                                                                                            head_256
                                                                                            (ErlangCons
                                                                                               head_262
                                                                                               (ErlangCons
                                                                                                  head_268
                                                                                                  ErlangEmptyList))))))))))))))))))))))))]
                 lambda_119 [] = EXC.function_clause unit
                 lambda_119 args = EXC.badarity (ErlangFun 0 lambda_119) args
               in lambda_119)
        in let head_117 = BIF.erlang__apply__2 [fun_118, ErlangEmptyList]
        in let
          fun_276 =
            ErlangFun 0
              (let
                 lambda_277 [] =
                   let    __kind_278 = toErl "Type"
                   in let __file_279 = toErl "init_type_error"
                   in let
                     bin_el_283 = BIF.erlang__list_to_binary__1 [__kind_278]
                   in let
                     bin_el_285 = BIF.erlang__list_to_binary__1 [__file_279]
                   in let
                     head_282 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_283
                               (BIN.packedSize bin_el_283) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_285
                               (BIN.packedSize bin_el_285) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 3:\nCannot unify string\n         and map(int, int)\nwhen checking that \'init\' returns a value of type \'state\' at line 7, column 3")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_279, ErlangCons head_282 ErlangEmptyList]
                 lambda_277 [] = EXC.function_clause unit
                 lambda_277 args = EXC.badarity (ErlangFun 0 lambda_277) args
               in lambda_277)
        in let head_275 = BIF.erlang__apply__2 [fun_276, ErlangEmptyList]
        in let
          fun_290 =
            ErlangFun 0
              (let
                 lambda_291 [] =
                   let    __kind_292 = toErl "Type"
                   in let __file_293 = toErl "missing_state_type"
                   in let
                     bin_el_297 = BIF.erlang__list_to_binary__1 [__kind_292]
                   in let
                     bin_el_299 = BIF.erlang__list_to_binary__1 [__file_293]
                   in let
                     head_296 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_297
                               (BIN.packedSize bin_el_297) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_299
                               (BIN.packedSize bin_el_299) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 3:\nCannot unify string\n         and unit\nwhen checking that \'init\' returns a value of type \'state\' at line 5, column 3")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_293, ErlangCons head_296 ErlangEmptyList]
                 lambda_291 [] = EXC.function_clause unit
                 lambda_291 args = EXC.badarity (ErlangFun 0 lambda_291) args
               in lambda_291)
        in let head_289 = BIF.erlang__apply__2 [fun_290, ErlangEmptyList]
        in let
          fun_304 =
            ErlangFun 0
              (let
                 lambda_305 [] =
                   let    __kind_306 = toErl "Type"
                   in let
                     __file_307 = toErl "missing_fields_in_record_expression"
                   in let
                     bin_el_311 = BIF.erlang__list_to_binary__1 [__kind_306]
                   in let
                     bin_el_313 = BIF.erlang__list_to_binary__1 [__file_307]
                   in let
                     head_310 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_311
                               (BIN.packedSize bin_el_311) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_313
                               (BIN.packedSize bin_el_313) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 42:\nThe field x is missing when constructing an element of type r(\'a) (at line 7, column 42)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_317 = BIF.erlang__list_to_binary__1 [__kind_306]
                   in let
                     bin_el_319 = BIF.erlang__list_to_binary__1 [__file_307]
                   in let
                     head_316 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_317
                               (BIN.packedSize bin_el_317) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_319
                               (BIN.packedSize bin_el_319) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 8, col 42:\nThe field y is missing when constructing an element of type r(int) (at line 8, column 42)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_323 = BIF.erlang__list_to_binary__1 [__kind_306]
                   in let
                     bin_el_325 = BIF.erlang__list_to_binary__1 [__file_307]
                   in let
                     head_322 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_323
                               (BIN.packedSize bin_el_323) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_325
                               (BIN.packedSize bin_el_325) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 42:\nThe fields y, z are missing when constructing an element of type r(\'a) (at line 6, column 42)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_307,
                        ErlangCons head_310
                          (ErlangCons head_316
                             (ErlangCons head_322 ErlangEmptyList))]
                 lambda_305 [] = EXC.function_clause unit
                 lambda_305 args = EXC.badarity (ErlangFun 0 lambda_305) args
               in lambda_305)
        in let head_303 = BIF.erlang__apply__2 [fun_304, ErlangEmptyList]
        in let
          fun_330 =
            ErlangFun 0
              (let
                 lambda_331 [] =
                   let    __kind_332 = toErl "Type"
                   in let __file_333 = toErl "namespace_clash"
                   in let
                     bin_el_337 = BIF.erlang__list_to_binary__1 [__kind_332]
                   in let
                     bin_el_339 = BIF.erlang__list_to_binary__1 [__file_333]
                   in let
                     head_336 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_337
                               (BIN.packedSize bin_el_337) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_339
                               (BIN.packedSize bin_el_339) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 10:\nThe contract Call (at line 4, column 10) has the same name as a namespace at (builtin location)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_333, ErlangCons head_336 ErlangEmptyList]
                 lambda_331 [] = EXC.function_clause unit
                 lambda_331 args = EXC.badarity (ErlangFun 0 lambda_331) args
               in lambda_331)
        in let head_329 = BIF.erlang__apply__2 [fun_330, ErlangEmptyList]
        in let
          fun_344 =
            ErlangFun 0
              (let
                 lambda_345 [] =
                   let    __kind_346 = toErl "Type"
                   in let __file_347 = toErl "bad_events"
                   in let
                     bin_el_351 = BIF.erlang__list_to_binary__1 [__kind_346]
                   in let
                     bin_el_353 = BIF.erlang__list_to_binary__1 [__file_347]
                   in let
                     head_350 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_351
                               (BIN.packedSize bin_el_351) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_353
                               (BIN.packedSize bin_el_353) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 25:\nThe indexed type string (at line 9, column 25) is not a word type")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_357 = BIF.erlang__list_to_binary__1 [__kind_346]
                   in let
                     bin_el_359 = BIF.erlang__list_to_binary__1 [__file_347]
                   in let
                     head_356 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_357
                               (BIN.packedSize bin_el_357) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_359
                               (BIN.packedSize bin_el_359) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 25:\nThe indexed type alias_string (at line 10, column 25) equals string which is not a word type")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_347,
                        ErlangCons head_350
                          (ErlangCons head_356 ErlangEmptyList)]
                 lambda_345 [] = EXC.function_clause unit
                 lambda_345 args = EXC.badarity (ErlangFun 0 lambda_345) args
               in lambda_345)
        in let head_343 = BIF.erlang__apply__2 [fun_344, ErlangEmptyList]
        in let
          fun_364 =
            ErlangFun 0
              (let
                 lambda_365 [] =
                   let    __kind_366 = toErl "Type"
                   in let __file_367 = toErl "bad_events2"
                   in let
                     bin_el_371 = BIF.erlang__list_to_binary__1 [__kind_366]
                   in let
                     bin_el_373 = BIF.erlang__list_to_binary__1 [__file_367]
                   in let
                     head_370 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_371
                               (BIN.packedSize bin_el_371) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_373
                               (BIN.packedSize bin_el_373) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 7:\nThe event constructor BadEvent1 (at line 9, column 7) has too many non-indexed values (max 1)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_377 = BIF.erlang__list_to_binary__1 [__kind_366]
                   in let
                     bin_el_379 = BIF.erlang__list_to_binary__1 [__file_367]
                   in let
                     head_376 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_377
                               (BIN.packedSize bin_el_377) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_379
                               (BIN.packedSize bin_el_379) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 7:\nThe event constructor BadEvent2 (at line 10, column 7) has too many indexed values (max 3)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_367,
                        ErlangCons head_370
                          (ErlangCons head_376 ErlangEmptyList)]
                 lambda_365 [] = EXC.function_clause unit
                 lambda_365 args = EXC.badarity (ErlangFun 0 lambda_365) args
               in lambda_365)
        in let head_363 = BIF.erlang__apply__2 [fun_364, ErlangEmptyList]
        in let
          fun_384 =
            ErlangFun 0
              (let
                 lambda_385 [] =
                   let    __kind_386 = toErl "Type"
                   in let __file_387 = toErl "type_clash"
                   in let
                     bin_el_391 = BIF.erlang__list_to_binary__1 [__kind_386]
                   in let
                     bin_el_393 = BIF.erlang__list_to_binary__1 [__file_387]
                   in let
                     head_390 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_391
                               (BIN.packedSize bin_el_391) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_393
                               (BIN.packedSize bin_el_393) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 42:\nCannot unify int\n         and string\nwhen checking the type of the expression at line 12, column 42\n  r.foo() : map(int, string)\nagainst the expected type\n  map(string, int)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_387, ErlangCons head_390 ErlangEmptyList]
                 lambda_385 [] = EXC.function_clause unit
                 lambda_385 args = EXC.badarity (ErlangFun 0 lambda_385) args
               in lambda_385)
        in let head_383 = BIF.erlang__apply__2 [fun_384, ErlangEmptyList]
        in let
          fun_398 =
            ErlangFun 0
              (let
                 lambda_399 [] =
                   let    __kind_400 = toErl "Type"
                   in let __file_401 = toErl "not_toplevel_include"
                   in let
                     bin_el_405 = BIF.erlang__list_to_binary__1 [__kind_400]
                   in let
                     bin_el_407 = BIF.erlang__list_to_binary__1 [__file_401]
                   in let
                     head_404 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_405
                               (BIN.packedSize bin_el_405) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_407
                               (BIN.packedSize bin_el_407) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 11:\nInclude of \'included.aes\' at line 2, column 11\nnot allowed, include only allowed at top level.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_401, ErlangCons head_404 ErlangEmptyList]
                 lambda_399 [] = EXC.function_clause unit
                 lambda_399 args = EXC.badarity (ErlangFun 0 lambda_399) args
               in lambda_399)
        in let head_397 = BIF.erlang__apply__2 [fun_398, ErlangEmptyList]
        in let
          fun_412 =
            ErlangFun 0
              (let
                 lambda_413 [] =
                   let    __kind_414 = toErl "Type"
                   in let __file_415 = toErl "not_toplevel_namespace"
                   in let
                     bin_el_419 = BIF.erlang__list_to_binary__1 [__kind_414]
                   in let
                     bin_el_421 = BIF.erlang__list_to_binary__1 [__file_415]
                   in let
                     head_418 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_419
                               (BIN.packedSize bin_el_419) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_421
                               (BIN.packedSize bin_el_421) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 13:\nNested namespaces are not allowed\nNamespace \'Foo\' at line 2, column 13 not defined at top level.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_415, ErlangCons head_418 ErlangEmptyList]
                 lambda_413 [] = EXC.function_clause unit
                 lambda_413 args = EXC.badarity (ErlangFun 0 lambda_413) args
               in lambda_413)
        in let head_411 = BIF.erlang__apply__2 [fun_412, ErlangEmptyList]
        in let
          fun_426 =
            ErlangFun 0
              (let
                 lambda_427 [] =
                   let    __kind_428 = toErl "Type"
                   in let __file_429 = toErl "not_toplevel_contract"
                   in let
                     bin_el_433 = BIF.erlang__list_to_binary__1 [__kind_428]
                   in let
                     bin_el_435 = BIF.erlang__list_to_binary__1 [__file_429]
                   in let
                     head_432 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_433
                               (BIN.packedSize bin_el_433) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_435
                               (BIN.packedSize bin_el_435) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 12:\nNested contracts are not allowed\nContract \'Con\' at line 2, column 12 not defined at top level.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_429, ErlangCons head_432 ErlangEmptyList]
                 lambda_427 [] = EXC.function_clause unit
                 lambda_427 args = EXC.badarity (ErlangFun 0 lambda_427) args
               in lambda_427)
        in let head_425 = BIF.erlang__apply__2 [fun_426, ErlangEmptyList]
        in let
          fun_440 =
            ErlangFun 0
              (let
                 lambda_441 [] =
                   let    __kind_442 = toErl "Type"
                   in let __file_443 = toErl "bad_address_literals"
                   in let
                     bin_el_447 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_449 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_446 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_447
                               (BIN.packedSize bin_el_447) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_449
                               (BIN.packedSize bin_el_449) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 5:\nCannot unify address\n         and oracle(int, bool)\nwhen checking the type of the expression at line 11, column 5\n  ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt : address\nagainst the expected type\n  oracle(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_453 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_455 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_452 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_453
                               (BIN.packedSize bin_el_453) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_455
                               (BIN.packedSize bin_el_455) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 9, col 5:\nCannot unify address\n         and Remote\nwhen checking the type of the expression at line 9, column 5\n  ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt : address\nagainst the expected type\n  Remote")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_459 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_461 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_458 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_459
                               (BIN.packedSize bin_el_459) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_461
                               (BIN.packedSize bin_el_461) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 5:\nCannot unify address\n         and bytes(32)\nwhen checking the type of the expression at line 7, column 5\n  ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt : address\nagainst the expected type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_465 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_467 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_464 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_465
                               (BIN.packedSize bin_el_465) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_467
                               (BIN.packedSize bin_el_467) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 5:\nCannot unify oracle(\'a, \'b)\n         and oracle_query(int, bool)\nwhen checking the type of the expression at line 14, column 5\n  ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 :\n    oracle(\'a, \'b)\nagainst the expected type\n  oracle_query(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_471 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_473 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_470 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_471
                               (BIN.packedSize bin_el_471) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_473
                               (BIN.packedSize bin_el_473) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 5:\nCannot unify oracle(\'c, \'d)\n         and bytes(32)\nwhen checking the type of the expression at line 16, column 5\n  ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 :\n    oracle(\'c, \'d)\nagainst the expected type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_477 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_479 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_476 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_477
                               (BIN.packedSize bin_el_477) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_479
                               (BIN.packedSize bin_el_479) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 18, col 5:\nCannot unify oracle(\'e, \'f)\n         and Remote\nwhen checking the type of the expression at line 18, column 5\n  ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 :\n    oracle(\'e, \'f)\nagainst the expected type\n  Remote")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_483 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_485 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_482 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_483
                               (BIN.packedSize bin_el_483) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_485
                               (BIN.packedSize bin_el_485) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 21, col 5:\nCannot unify oracle_query(\'g, \'h)\n         and oracle(int, bool)\nwhen checking the type of the expression at line 21, column 5\n  oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY :\n    oracle_query(\'g, \'h)\nagainst the expected type\n  oracle(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_489 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_491 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_488 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_489
                               (BIN.packedSize bin_el_489) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_491
                               (BIN.packedSize bin_el_491) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 23, col 5:\nCannot unify oracle_query(\'i, \'j)\n         and bytes(32)\nwhen checking the type of the expression at line 23, column 5\n  oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY :\n    oracle_query(\'i, \'j)\nagainst the expected type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_495 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_497 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_494 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_495
                               (BIN.packedSize bin_el_495) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_497
                               (BIN.packedSize bin_el_497) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 25, col 5:\nCannot unify oracle_query(\'k, \'l)\n         and Remote\nwhen checking the type of the expression at line 25, column 5\n  oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY :\n    oracle_query(\'k, \'l)\nagainst the expected type\n  Remote")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_501 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_503 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_500 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_501
                               (BIN.packedSize bin_el_501) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_503
                               (BIN.packedSize bin_el_503) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 28, col 5:\nThe type address is not a contract type\nwhen checking that the contract literal\n  ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\nhas the type\n  address")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_507 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_509 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_506 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_507
                               (BIN.packedSize bin_el_507) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_509
                               (BIN.packedSize bin_el_509) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 30, col 5:\nThe type oracle(int, bool) is not a contract type\nwhen checking that the contract literal\n  ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\nhas the type\n  oracle(int, bool)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_513 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_515 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_512 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_513
                               (BIN.packedSize bin_el_513) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_515
                               (BIN.packedSize bin_el_515) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 32, col 5:\nThe type bytes(32) is not a contract type\nwhen checking that the contract literal\n  ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\nhas the type\n  bytes(32)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_519 = BIF.erlang__list_to_binary__1 [__kind_442]
                   in let
                     bin_el_521 = BIF.erlang__list_to_binary__1 [__file_443]
                   in let
                     head_518 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_519
                               (BIN.packedSize bin_el_519) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_521
                               (BIN.packedSize bin_el_521) 8,
                             BIN.fromInts (toErl ".aes\' at line 34, col 5:\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "The type address is not a contract type\nwhen checking that the call to\n  Address.to_contract\nhas the type\n  address")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_443,
                        ErlangCons head_446
                          (ErlangCons head_452
                             (ErlangCons head_458
                                (ErlangCons head_464
                                   (ErlangCons head_470
                                      (ErlangCons head_476
                                         (ErlangCons head_482
                                            (ErlangCons head_488
                                               (ErlangCons head_494
                                                  (ErlangCons head_500
                                                     (ErlangCons head_506
                                                        (ErlangCons head_512
                                                           (ErlangCons head_518
                                                              ErlangEmptyList))))))))))))]
                 lambda_441 [] = EXC.function_clause unit
                 lambda_441 args = EXC.badarity (ErlangFun 0 lambda_441) args
               in lambda_441)
        in let head_439 = BIF.erlang__apply__2 [fun_440, ErlangEmptyList]
        in let
          fun_526 =
            ErlangFun 0
              (let
                 lambda_527 [] =
                   let    __kind_528 = toErl "Type"
                   in let __file_529 = toErl "stateful"
                   in let
                     bin_el_533 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_535 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_532 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_533
                               (BIN.packedSize bin_el_533) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_535
                               (BIN.packedSize bin_el_535) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 35:\nCannot reference stateful function Chain.spend (at line 13, column 35)\nin the definition of non-stateful function fail1.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_539 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_541 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_538 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_539
                               (BIN.packedSize bin_el_539) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_541
                               (BIN.packedSize bin_el_541) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 14, col 35:\nCannot reference stateful function local_spend (at line 14, column 35)\nin the definition of non-stateful function fail2.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_545 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_547 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_544 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_545
                               (BIN.packedSize bin_el_545) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_547
                               (BIN.packedSize bin_el_547) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 15:\nCannot reference stateful function Chain.spend (at line 16, column 15)\nin the definition of non-stateful function fail3.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_551 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_553 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_550 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_551
                               (BIN.packedSize bin_el_551) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_553
                               (BIN.packedSize bin_el_553) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 20, col 31:\nCannot reference stateful function Chain.spend (at line 20, column 31)\nin the definition of non-stateful function fail4.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_557 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_559 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_556 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_557
                               (BIN.packedSize bin_el_557) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_559
                               (BIN.packedSize bin_el_559) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 35, col 47:\nCannot reference stateful function Chain.spend (at line 35, column 47)\nin the definition of non-stateful function fail5.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_563 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_565 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_562 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_563
                               (BIN.packedSize bin_el_563) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_565
                               (BIN.packedSize bin_el_565) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 48, col 57:\nCannot pass non-zero value argument 1000 (at line 48, column 57)\nin the definition of non-stateful function fail6.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_569 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_571 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_568 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_569
                               (BIN.packedSize bin_el_569) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_571
                               (BIN.packedSize bin_el_571) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 49, col 56:\nCannot pass non-zero value argument 1000 (at line 49, column 56)\nin the definition of non-stateful function fail7.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_575 = BIF.erlang__list_to_binary__1 [__kind_528]
                   in let
                     bin_el_577 = BIF.erlang__list_to_binary__1 [__file_529]
                   in let
                     head_574 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_575
                               (BIN.packedSize bin_el_575) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_577
                               (BIN.packedSize bin_el_577) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 52, col 17:\nCannot pass non-zero value argument 1000 (at line 52, column 17)\nin the definition of non-stateful function fail8.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_529,
                        ErlangCons head_532
                          (ErlangCons head_538
                             (ErlangCons head_544
                                (ErlangCons head_550
                                   (ErlangCons head_556
                                      (ErlangCons head_562
                                         (ErlangCons head_568
                                            (ErlangCons head_574
                                               ErlangEmptyList)))))))]
                 lambda_527 [] = EXC.function_clause unit
                 lambda_527 args = EXC.badarity (ErlangFun 0 lambda_527) args
               in lambda_527)
        in let head_525 = BIF.erlang__apply__2 [fun_526, ErlangEmptyList]
        in let
          fun_582 =
            ErlangFun 0
              (let
                 lambda_583 [] =
                   let    __kind_584 = toErl "Type"
                   in let __file_585 = toErl "bad_init_state_access"
                   in let
                     bin_el_589 = BIF.erlang__list_to_binary__1 [__kind_584]
                   in let
                     bin_el_591 = BIF.erlang__list_to_binary__1 [__file_585]
                   in let
                     head_588 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_589
                               (BIN.packedSize bin_el_589) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_591
                               (BIN.packedSize bin_el_591) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 5:\nThe init function should return the initial state as its result and cannot write the state,\nbut it calls\n  - set_state (at line 11, column 5), which calls\n  - roundabout (at line 8, column 38), which calls\n  - put (at line 7, column 39)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_595 = BIF.erlang__list_to_binary__1 [__kind_584]
                   in let
                     bin_el_597 = BIF.erlang__list_to_binary__1 [__file_585]
                   in let
                     head_594 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_595
                               (BIN.packedSize bin_el_595) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_597
                               (BIN.packedSize bin_el_597) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 5:\nThe init function should return the initial state as its result and cannot read the state,\nbut it calls\n  - new_state (at line 12, column 5), which calls\n  - state (at line 5, column 29)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_601 = BIF.erlang__list_to_binary__1 [__kind_584]
                   in let
                     bin_el_603 = BIF.erlang__list_to_binary__1 [__file_585]
                   in let
                     head_600 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_601
                               (BIN.packedSize bin_el_601) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_603
                               (BIN.packedSize bin_el_603) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 13:\nThe init function should return the initial state as its result and cannot read the state,\nbut it calls\n  - state (at line 13, column 13)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_585,
                        ErlangCons head_588
                          (ErlangCons head_594
                             (ErlangCons head_600 ErlangEmptyList))]
                 lambda_583 [] = EXC.function_clause unit
                 lambda_583 args = EXC.badarity (ErlangFun 0 lambda_583) args
               in lambda_583)
        in let head_581 = BIF.erlang__apply__2 [fun_582, ErlangEmptyList]
        in let
          fun_608 =
            ErlangFun 0
              (let
                 lambda_609 [] =
                   let    __kind_610 = toErl "Type"
                   in let __file_611 = toErl "modifier_checks"
                   in let
                     bin_el_615 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_617 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_614 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_615
                               (BIN.packedSize bin_el_615) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_617
                               (BIN.packedSize bin_el_617) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 3:\nThe function all_the_things (at line 11, column 3) cannot be both public and private.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_621 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_623 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_620 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_621
                               (BIN.packedSize bin_el_621) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_623
                               (BIN.packedSize bin_el_623) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 3:\nNamespaces cannot contain entrypoints (at line 3, column 3). Use \'function\' instead.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_627 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_629 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_626 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_627
                               (BIN.packedSize bin_el_627) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_629
                               (BIN.packedSize bin_el_629) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 10:\nThe contract Remote (at line 5, column 10) has no entrypoints. Since Sophia version 3.2, public\ncontract functions must be declared with the \'entrypoint\' keyword instead of\n\'function\'.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_633 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_635 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_632 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_633
                               (BIN.packedSize bin_el_633) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_635
                               (BIN.packedSize bin_el_635) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 3:\nThe entrypoint wha (at line 12, column 3) cannot be private. Use \'function\' instead.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_639 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_641 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_638 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_639
                               (BIN.packedSize bin_el_639) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_641
                               (BIN.packedSize bin_el_641) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 3:\nUse \'entrypoint\' for declaration of foo (at line 6, column 3):\n  entrypoint foo : () => unit")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_645 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_647 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_644 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_645
                               (BIN.packedSize bin_el_645) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_647
                               (BIN.packedSize bin_el_647) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 3:\nUse \'entrypoint\' instead of \'function\' for public function foo (at line 10, column 3):\n  entrypoint foo() = ()")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_651 = BIF.erlang__list_to_binary__1 [__kind_610]
                   in let
                     bin_el_653 = BIF.erlang__list_to_binary__1 [__file_611]
                   in let
                     head_650 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_651
                               (BIN.packedSize bin_el_651) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_653
                               (BIN.packedSize bin_el_653) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 3:\nUse \'entrypoint\' instead of \'function\' for public function foo (at line 6, column 3):\n  entrypoint foo : () => unit")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_611,
                        ErlangCons head_614
                          (ErlangCons head_620
                             (ErlangCons head_626
                                (ErlangCons head_632
                                   (ErlangCons head_638
                                      (ErlangCons head_644
                                         (ErlangCons head_650
                                            ErlangEmptyList))))))]
                 lambda_609 [] = EXC.function_clause unit
                 lambda_609 args = EXC.badarity (ErlangFun 0 lambda_609) args
               in lambda_609)
        in let head_607 = BIF.erlang__apply__2 [fun_608, ErlangEmptyList]
        in let
          fun_658 =
            ErlangFun 0
              (let
                 lambda_659 [] =
                   let    __kind_660 = toErl "Type"
                   in let __file_661 = toErl "list_comp_not_a_list"
                   in let
                     bin_el_665 = BIF.erlang__list_to_binary__1 [__kind_660]
                   in let
                     bin_el_667 = BIF.erlang__list_to_binary__1 [__file_661]
                   in let
                     head_664 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_665
                               (BIN.packedSize bin_el_665) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_667
                               (BIN.packedSize bin_el_667) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 36:\nCannot unify int\n         and list(\'a)\nwhen checking rvalue of list comprehension binding at line 2, column 36\n  1 : int\nagainst type \n  list(\'a)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_661, ErlangCons head_664 ErlangEmptyList]
                 lambda_659 [] = EXC.function_clause unit
                 lambda_659 args = EXC.badarity (ErlangFun 0 lambda_659) args
               in lambda_659)
        in let head_657 = BIF.erlang__apply__2 [fun_658, ErlangEmptyList]
        in let
          fun_672 =
            ErlangFun 0
              (let
                 lambda_673 [] =
                   let    __kind_674 = toErl "Type"
                   in let __file_675 = toErl "list_comp_if_not_bool"
                   in let
                     bin_el_679 = BIF.erlang__list_to_binary__1 [__kind_674]
                   in let
                     bin_el_681 = BIF.erlang__list_to_binary__1 [__file_675]
                   in let
                     head_678 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_679
                               (BIN.packedSize bin_el_679) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_681
                               (BIN.packedSize bin_el_681) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 44:\nCannot unify int\n         and bool\nwhen checking the type of the expression at line 2, column 44\n  3 : int\nagainst the expected type\n  bool")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_675, ErlangCons head_678 ErlangEmptyList]
                 lambda_673 [] = EXC.function_clause unit
                 lambda_673 args = EXC.badarity (ErlangFun 0 lambda_673) args
               in lambda_673)
        in let head_671 = BIF.erlang__apply__2 [fun_672, ErlangEmptyList]
        in let
          fun_686 =
            ErlangFun 0
              (let
                 lambda_687 [] =
                   let    __kind_688 = toErl "Type"
                   in let __file_689 = toErl "list_comp_bad_shadow"
                   in let
                     bin_el_693 = BIF.erlang__list_to_binary__1 [__kind_688]
                   in let
                     bin_el_695 = BIF.erlang__list_to_binary__1 [__file_689]
                   in let
                     head_692 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_693
                               (BIN.packedSize bin_el_693) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_695
                               (BIN.packedSize bin_el_695) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 53:\nCannot unify int\n         and string\nwhen checking the type of the pattern at line 2, column 53\n  x : int\nagainst the expected type\n  string")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_689, ErlangCons head_692 ErlangEmptyList]
                 lambda_687 [] = EXC.function_clause unit
                 lambda_687 args = EXC.badarity (ErlangFun 0 lambda_687) args
               in lambda_687)
        in let head_685 = BIF.erlang__apply__2 [fun_686, ErlangEmptyList]
        in let
          fun_700 =
            ErlangFun 0
              (let
                 lambda_701 [] =
                   let    __kind_702 = toErl "Type"
                   in let __file_703 = toErl "map_as_map_key"
                   in let
                     bin_el_707 = BIF.erlang__list_to_binary__1 [__kind_702]
                   in let
                     bin_el_709 = BIF.erlang__list_to_binary__1 [__file_703]
                   in let
                     head_706 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_707
                               (BIN.packedSize bin_el_707) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_709
                               (BIN.packedSize bin_el_709) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 47:\nInvalid key type\n  map(int, int)\nMap keys cannot contain other maps.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_713 = BIF.erlang__list_to_binary__1 [__kind_702]
                   in let
                     bin_el_715 = BIF.erlang__list_to_binary__1 [__file_703]
                   in let
                     head_712 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_713
                               (BIN.packedSize bin_el_713) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_715
                               (BIN.packedSize bin_el_715) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 31:\nInvalid key type\n  list(map(int, int))\nMap keys cannot contain other maps.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_719 = BIF.erlang__list_to_binary__1 [__kind_702]
                   in let
                     bin_el_721 = BIF.erlang__list_to_binary__1 [__file_703]
                   in let
                     head_718 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_719
                               (BIN.packedSize bin_el_719) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_721
                               (BIN.packedSize bin_el_721) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 31:\nInvalid key type\n  lm\nMap keys cannot contain other maps.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_703,
                        ErlangCons head_706
                          (ErlangCons head_712
                             (ErlangCons head_718 ErlangEmptyList))]
                 lambda_701 [] = EXC.function_clause unit
                 lambda_701 args = EXC.badarity (ErlangFun 0 lambda_701) args
               in lambda_701)
        in let head_699 = BIF.erlang__apply__2 [fun_700, ErlangEmptyList]
        in let
          fun_726 =
            ErlangFun 0
              (let
                 lambda_727 [] =
                   let    __kind_728 = toErl "Type"
                   in let __file_729 = toErl "calling_init_function"
                   in let
                     bin_el_733 = BIF.erlang__list_to_binary__1 [__kind_728]
                   in let
                     bin_el_735 = BIF.erlang__list_to_binary__1 [__file_729]
                   in let
                     head_732 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_733
                               (BIN.packedSize bin_el_733) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_735
                               (BIN.packedSize bin_el_735) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 7, col 28:\nThe \'init\' function is called exclusively by the create contract transaction\nand cannot be called from the contract code.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_729, ErlangCons head_732 ErlangEmptyList]
                 lambda_727 [] = EXC.function_clause unit
                 lambda_727 args = EXC.badarity (ErlangFun 0 lambda_727) args
               in lambda_727)
        in let head_725 = BIF.erlang__apply__2 [fun_726, ErlangEmptyList]
        in let
          fun_740 =
            ErlangFun 0
              (let
                 lambda_741 [] =
                   let    __kind_742 = toErl "Type"
                   in let __file_743 = toErl "bad_top_level_decl"
                   in let
                     bin_el_747 = BIF.erlang__list_to_binary__1 [__kind_742]
                   in let
                     bin_el_749 = BIF.erlang__list_to_binary__1 [__file_743]
                   in let
                     head_746 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_747
                               (BIN.packedSize bin_el_747) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_749
                               (BIN.packedSize bin_el_749) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 1, col 1:\nThe definition of \'square\' must appear inside a contract or namespace.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_743, ErlangCons head_746 ErlangEmptyList]
                 lambda_741 [] = EXC.function_clause unit
                 lambda_741 args = EXC.badarity (ErlangFun 0 lambda_741) args
               in lambda_741)
        in let head_739 = BIF.erlang__apply__2 [fun_740, ErlangEmptyList]
        in let
          fun_754 =
            ErlangFun 0
              (let
                 lambda_755 [] =
                   let    __kind_756 = toErl "Type"
                   in let __file_757 = toErl "missing_event_type"
                   in let
                     bin_el_761 = BIF.erlang__list_to_binary__1 [__kind_756]
                   in let
                     bin_el_763 = BIF.erlang__list_to_binary__1 [__file_757]
                   in let
                     head_760 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_761
                               (BIN.packedSize bin_el_761) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_763
                               (BIN.packedSize bin_el_763) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 5:\nUnbound variable Chain.event at line 3, column 5\nDid you forget to define the event type?")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_757, ErlangCons head_760 ErlangEmptyList]
                 lambda_755 [] = EXC.function_clause unit
                 lambda_755 args = EXC.badarity (ErlangFun 0 lambda_755) args
               in lambda_755)
        in let head_753 = BIF.erlang__apply__2 [fun_754, ErlangEmptyList]
        in let
          fun_768 =
            ErlangFun 0
              (let
                 lambda_769 [] =
                   let    __kind_770 = toErl "Type"
                   in let __file_771 = toErl "bad_bytes_concat"
                   in let
                     bin_el_775 = BIF.erlang__list_to_binary__1 [__kind_770]
                   in let
                     bin_el_777 = BIF.erlang__list_to_binary__1 [__file_771]
                   in let
                     head_774 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_775
                               (BIN.packedSize bin_el_775) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_777
                               (BIN.packedSize bin_el_777) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 40:\nFailed to resolve byte array lengths in call to Bytes.concat with arguments of type\n  - \'g  (at line 12, column 20)\n  - \'h  (at line 12, column 23)\nand result type\n  - bytes(10)  (at line 12, column 28)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_781 = BIF.erlang__list_to_binary__1 [__kind_770]
                   in let
                     bin_el_783 = BIF.erlang__list_to_binary__1 [__file_771]
                   in let
                     head_780 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_781
                               (BIN.packedSize bin_el_781) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_783
                               (BIN.packedSize bin_el_783) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 28:\nFailed to resolve byte array lengths in call to Bytes.concat with arguments of type\n  - \'d  (at line 13, column 20)\n  - \'e  (at line 13, column 23)\nand result type\n  - \'f  (at line 13, column 14)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_787 = BIF.erlang__list_to_binary__1 [__kind_770]
                   in let
                     bin_el_789 = BIF.erlang__list_to_binary__1 [__file_771]
                   in let
                     head_786 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_787
                               (BIN.packedSize bin_el_787) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_789
                               (BIN.packedSize bin_el_789) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 15, col 5:\nCannot unify bytes(26)\n         and bytes(25)\nat line 15, column 5")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_793 = BIF.erlang__list_to_binary__1 [__kind_770]
                   in let
                     bin_el_795 = BIF.erlang__list_to_binary__1 [__file_771]
                   in let
                     head_792 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_793
                               (BIN.packedSize bin_el_793) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_795
                               (BIN.packedSize bin_el_795) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 17, col 5:\nFailed to resolve byte array lengths in call to Bytes.concat with arguments of type\n  - bytes(6)  (at line 16, column 24)\n  - \'b  (at line 16, column 34)\nand result type\n  - \'c  (at line 16, column 39)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_799 = BIF.erlang__list_to_binary__1 [__kind_770]
                   in let
                     bin_el_801 = BIF.erlang__list_to_binary__1 [__file_771]
                   in let
                     head_798 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_799
                               (BIN.packedSize bin_el_799) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_801
                               (BIN.packedSize bin_el_801) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 19, col 25:\nCannot resolve length of byte array.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_771,
                        ErlangCons head_774
                          (ErlangCons head_780
                             (ErlangCons head_786
                                (ErlangCons head_792
                                   (ErlangCons head_798 ErlangEmptyList))))]
                 lambda_769 [] = EXC.function_clause unit
                 lambda_769 args = EXC.badarity (ErlangFun 0 lambda_769) args
               in lambda_769)
        in let head_767 = BIF.erlang__apply__2 [fun_768, ErlangEmptyList]
        in let
          fun_806 =
            ErlangFun 0
              (let
                 lambda_807 [] =
                   let    __kind_808 = toErl "Type"
                   in let __file_809 = toErl "bad_bytes_split"
                   in let
                     bin_el_813 = BIF.erlang__list_to_binary__1 [__kind_808]
                   in let
                     bin_el_815 = BIF.erlang__list_to_binary__1 [__file_809]
                   in let
                     head_812 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_813
                               (BIN.packedSize bin_el_813) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_815
                               (BIN.packedSize bin_el_815) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 13, col 5:\nFailed to resolve byte array lengths in call to Bytes.split with argument of type\n  - \'f  (at line 12, column 20)\nand result types\n  - \'e  (at line 12, column 25)\n  - bytes(20)  (at line 12, column 29)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_819 = BIF.erlang__list_to_binary__1 [__kind_808]
                   in let
                     bin_el_821 = BIF.erlang__list_to_binary__1 [__file_809]
                   in let
                     head_818 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_819
                               (BIN.packedSize bin_el_819) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_821
                               (BIN.packedSize bin_el_821) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 16, col 5:\nFailed to resolve byte array lengths in call to Bytes.split with argument of type\n  - bytes(15)  (at line 15, column 24)\nand result types\n  - \'c  (at line 16, column 5)\n  - \'d  (at line 16, column 5)")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_825 = BIF.erlang__list_to_binary__1 [__kind_808]
                   in let
                     bin_el_827 = BIF.erlang__list_to_binary__1 [__file_809]
                   in let
                     head_824 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_825
                               (BIN.packedSize bin_el_825) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_827
                               (BIN.packedSize bin_el_827) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 19, col 5:\nFailed to resolve byte array lengths in call to Bytes.split with argument of type\n  - \'b  (at line 18, column 20)\nand result types\n  - bytes(20)  (at line 18, column 25)\n  - \'a  (at line 18, column 37)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_809,
                        ErlangCons head_812
                          (ErlangCons head_818
                             (ErlangCons head_824 ErlangEmptyList))]
                 lambda_807 [] = EXC.function_clause unit
                 lambda_807 args = EXC.badarity (ErlangFun 0 lambda_807) args
               in lambda_807)
        in let head_805 = BIF.erlang__apply__2 [fun_806, ErlangEmptyList]
        in let
          fun_832 =
            ErlangFun 0
              (let
                 lambda_833 [] =
                   let    __kind_834 = toErl "Type"
                   in let __file_835 = toErl "wrong_compiler_version"
                   in let
                     bin_el_839 = BIF.erlang__list_to_binary__1 [__kind_834]
                   in let
                     bin_el_841 = BIF.erlang__list_to_binary__1 [__file_835]
                   in let
                     head_838 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_839
                               (BIN.packedSize bin_el_839) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_841
                               (BIN.packedSize bin_el_841) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 1, col 1:\nCannot compile with this version of the compiler,\nbecause it does not satisfy the constraint ")
                               (toErl 8) 1 BIN.Big,
                             BIN.binPrefix version_10
                               (BIN.packedSize version_10) 8,
                             BIN.fromInts (toErl " < 1.0") (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_846 = BIF.erlang__list_to_binary__1 [__kind_834]
                   in let
                     bin_el_848 = BIF.erlang__list_to_binary__1 [__file_835]
                   in let
                     head_845 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_846
                               (BIN.packedSize bin_el_846) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_848
                               (BIN.packedSize bin_el_848) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 1:\nCannot compile with this version of the compiler,\nbecause it does not satisfy the constraint ")
                               (toErl 8) 1 BIN.Big,
                             BIN.binPrefix version_10
                               (BIN.packedSize version_10) 8,
                             BIN.fromInts (toErl " == 9.9.9") (toErl 8) 1
                               BIN.Big])
                   in
                     ErlangTuple
                       [__file_835,
                        ErlangCons head_838
                          (ErlangCons head_845 ErlangEmptyList)]
                 lambda_833 [] = EXC.function_clause unit
                 lambda_833 args = EXC.badarity (ErlangFun 0 lambda_833) args
               in lambda_833)
        in let head_831 = BIF.erlang__apply__2 [fun_832, ErlangEmptyList]
        in let
          fun_854 =
            ErlangFun 0
              (let
                 lambda_855 [] =
                   let    __kind_856 = toErl "Type"
                   in let __file_857 = toErl "interface_with_defs"
                   in let
                     bin_el_861 = BIF.erlang__list_to_binary__1 [__kind_856]
                   in let
                     bin_el_863 = BIF.erlang__list_to_binary__1 [__file_857]
                   in let
                     head_860 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_861
                               (BIN.packedSize bin_el_861) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_863
                               (BIN.packedSize bin_el_863) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 3:\nContract interfaces cannot contain defined functions or entrypoints.\nFix: replace the definition of \'foo\' by a type signature.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_857, ErlangCons head_860 ErlangEmptyList]
                 lambda_855 [] = EXC.function_clause unit
                 lambda_855 args = EXC.badarity (ErlangFun 0 lambda_855) args
               in lambda_855)
        in let head_853 = BIF.erlang__apply__2 [fun_854, ErlangEmptyList]
        in let
          fun_868 =
            ErlangFun 0
              (let
                 lambda_869 [] =
                   let    __kind_870 = toErl "Type"
                   in let __file_871 = toErl "contract_as_namespace"
                   in let
                     bin_el_875 = BIF.erlang__list_to_binary__1 [__kind_870]
                   in let
                     bin_el_877 = BIF.erlang__list_to_binary__1 [__file_871]
                   in let
                     head_874 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_875
                               (BIN.packedSize bin_el_875) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_877
                               (BIN.packedSize bin_el_877) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 28:\nInvalid call to contract entrypoint \'Foo.foo\'.\nIt must be called as \'c.foo\' for some c : Foo.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_871, ErlangCons head_874 ErlangEmptyList]
                 lambda_869 [] = EXC.function_clause unit
                 lambda_869 args = EXC.badarity (ErlangFun 0 lambda_869) args
               in lambda_869)
        in let head_867 = BIF.erlang__apply__2 [fun_868, ErlangEmptyList]
        in let
          fun_882 =
            ErlangFun 0
              (let
                 lambda_883 [] =
                   let    __kind_884 = toErl "Type"
                   in let __file_885 = toErl "toplevel_let"
                   in let
                     bin_el_889 = BIF.erlang__list_to_binary__1 [__kind_884]
                   in let
                     bin_el_891 = BIF.erlang__list_to_binary__1 [__file_885]
                   in let
                     head_888 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_889
                               (BIN.packedSize bin_el_889) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_891
                               (BIN.packedSize bin_el_891) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 7:\nToplevel \"let\" definitions are not supported\nValue this_is_illegal at line 2, column 7 could be replaced by 0-argument function")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_885, ErlangCons head_888 ErlangEmptyList]
                 lambda_883 [] = EXC.function_clause unit
                 lambda_883 args = EXC.badarity (ErlangFun 0 lambda_883) args
               in lambda_883)
        in let head_881 = BIF.erlang__apply__2 [fun_882, ErlangEmptyList]
        in let
          fun_896 =
            ErlangFun 0
              (let
                 lambda_897 [] =
                   let    __kind_898 = toErl "Type"
                   in let __file_899 = toErl "empty_typedecl"
                   in let
                     bin_el_903 = BIF.erlang__list_to_binary__1 [__kind_898]
                   in let
                     bin_el_905 = BIF.erlang__list_to_binary__1 [__file_899]
                   in let
                     head_902 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_903
                               (BIN.packedSize bin_el_903) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_905
                               (BIN.packedSize bin_el_905) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 8:\nEmpty type declarations are not supported\nType t at line 2, column 8 lacks a definition")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_899, ErlangCons head_902 ErlangEmptyList]
                 lambda_897 [] = EXC.function_clause unit
                 lambda_897 args = EXC.badarity (ErlangFun 0 lambda_897) args
               in lambda_897)
        in let head_895 = BIF.erlang__apply__2 [fun_896, ErlangEmptyList]
        in let
          fun_910 =
            ErlangFun 0
              (let
                 lambda_911 [] =
                   let    __kind_912 = toErl "Type"
                   in let __file_913 = toErl "higher_kinded_type"
                   in let
                     bin_el_917 = BIF.erlang__list_to_binary__1 [__kind_912]
                   in let
                     bin_el_919 = BIF.erlang__list_to_binary__1 [__file_913]
                   in let
                     head_916 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_917
                               (BIN.packedSize bin_el_917) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_919
                               (BIN.packedSize bin_el_919) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 35:\nType \'m is a higher kinded type variable\n(takes another type as an argument)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_913, ErlangCons head_916 ErlangEmptyList]
                 lambda_911 [] = EXC.function_clause unit
                 lambda_911 args = EXC.badarity (ErlangFun 0 lambda_911) args
               in lambda_911)
        in let head_909 = BIF.erlang__apply__2 [fun_910, ErlangEmptyList]
        in let
          fun_924 =
            ErlangFun 0
              (let
                 lambda_925 [] =
                   let    __kind_926 = toErl "Type"
                   in let __file_927 = toErl "bad_arity"
                   in let
                     bin_el_931 = BIF.erlang__list_to_binary__1 [__kind_926]
                   in let
                     bin_el_933 = BIF.erlang__list_to_binary__1 [__file_927]
                   in let
                     head_930 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_931
                               (BIN.packedSize bin_el_931) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_933
                               (BIN.packedSize bin_el_933) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 20:\nArity for id doesn\'t match. Expected 1, got 0")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_937 = BIF.erlang__list_to_binary__1 [__kind_926]
                   in let
                     bin_el_939 = BIF.erlang__list_to_binary__1 [__file_927]
                   in let
                     head_936 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_937
                               (BIN.packedSize bin_el_937) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_939
                               (BIN.packedSize bin_el_939) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 25:\nCannot unify int\n         and id\nwhen checking the type of the expression at line 3, column 25\n  123 : int\nagainst the expected type\n  id")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_943 = BIF.erlang__list_to_binary__1 [__kind_926]
                   in let
                     bin_el_945 = BIF.erlang__list_to_binary__1 [__file_927]
                   in let
                     head_942 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_943
                               (BIN.packedSize bin_el_943) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_945
                               (BIN.packedSize bin_el_945) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 20:\nArity for id doesn\'t match. Expected 1, got 2")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_949 = BIF.erlang__list_to_binary__1 [__kind_926]
                   in let
                     bin_el_951 = BIF.erlang__list_to_binary__1 [__file_927]
                   in let
                     head_948 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_949
                               (BIN.packedSize bin_el_949) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_951
                               (BIN.packedSize bin_el_951) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 35:\nCannot unify int\n         and id(int, int)\nwhen checking the type of the expression at line 4, column 35\n  123 : int\nagainst the expected type\n  id(int, int)")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_927,
                        ErlangCons head_930
                          (ErlangCons head_936
                             (ErlangCons head_942
                                (ErlangCons head_948 ErlangEmptyList)))]
                 lambda_925 [] = EXC.function_clause unit
                 lambda_925 args = EXC.badarity (ErlangFun 0 lambda_925) args
               in lambda_925)
        in let head_923 = BIF.erlang__apply__2 [fun_924, ErlangEmptyList]
        in let
          fun_956 =
            ErlangFun 0
              (let
                 lambda_957 [] =
                   let    __kind_958 = toErl "Type"
                   in let __file_959 = toErl "bad_unnamed_map_update_default"
                   in let
                     bin_el_963 = BIF.erlang__list_to_binary__1 [__kind_958]
                   in let
                     bin_el_965 = BIF.erlang__list_to_binary__1 [__file_959]
                   in let
                     head_962 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_963
                               (BIN.packedSize bin_el_963) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_965
                               (BIN.packedSize bin_el_965) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 17:\nInvalid map update with default")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_959, ErlangCons head_962 ErlangEmptyList]
                 lambda_957 [] = EXC.function_clause unit
                 lambda_957 args = EXC.badarity (ErlangFun 0 lambda_957) args
               in lambda_957)
        in let head_955 = BIF.erlang__apply__2 [fun_956, ErlangEmptyList]
        in let
          fun_970 =
            ErlangFun 0
              (let
                 lambda_971 [] =
                   let    __kind_972 = toErl "Type"
                   in let __file_973 = toErl "non_functional_entrypoint"
                   in let
                     bin_el_977 = BIF.erlang__list_to_binary__1 [__kind_972]
                   in let
                     bin_el_979 = BIF.erlang__list_to_binary__1 [__file_973]
                   in let
                     head_976 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_977
                               (BIN.packedSize bin_el_977) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_979
                               (BIN.packedSize bin_el_979) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 2, col 14:\nf at line 2, column 14 was declared with an invalid type int.\nEntrypoints and functions must have functional types")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_973, ErlangCons head_976 ErlangEmptyList]
                 lambda_971 [] = EXC.function_clause unit
                 lambda_971 args = EXC.badarity (ErlangFun 0 lambda_971) args
               in lambda_971)
        in let head_969 = BIF.erlang__apply__2 [fun_970, ErlangEmptyList]
        in let
          fun_984 =
            ErlangFun 0
              (let
                 lambda_985 [] =
                   let    __kind_986 = toErl "Type"
                   in let __file_987 = toErl "bad_records"
                   in let
                     bin_el_991 = BIF.erlang__list_to_binary__1 [__kind_986]
                   in let
                     bin_el_993 = BIF.erlang__list_to_binary__1 [__file_987]
                   in let
                     head_990 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_991
                               (BIN.packedSize bin_el_991) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_993
                               (BIN.packedSize bin_el_993) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 16:\nMixed record fields and map keys in\n  {x = 0, [0] = 1}")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_997 = BIF.erlang__list_to_binary__1 [__kind_986]
                   in let
                     bin_el_999 = BIF.erlang__list_to_binary__1 [__file_987]
                   in let
                     head_996 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_997
                               (BIN.packedSize bin_el_997) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_999
                               (BIN.packedSize bin_el_999) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 6:\nMixed record fields and map keys in\n  r {x = 0, [0] = 1}")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1003 = BIF.erlang__list_to_binary__1 [__kind_986]
                   in let
                     bin_el_1005 = BIF.erlang__list_to_binary__1 [__file_987]
                   in let
                     head_1002 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1003
                               (BIN.packedSize bin_el_1003) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1005
                               (BIN.packedSize bin_el_1005) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 6:\nEmpty record/map update\n  r {}")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_987,
                        ErlangCons head_990
                          (ErlangCons head_996
                             (ErlangCons head_1002 ErlangEmptyList))]
                 lambda_985 [] = EXC.function_clause unit
                 lambda_985 args = EXC.badarity (ErlangFun 0 lambda_985) args
               in lambda_985)
        in let head_983 = BIF.erlang__apply__2 [fun_984, ErlangEmptyList]
        in let
          fun_1010 =
            ErlangFun 0
              (let
                 lambda_1011 [] =
                   let    __kind_1012 = toErl "Type"
                   in let __file_1013 = toErl "bad_protected_call"
                   in let
                     bin_el_1017 = BIF.erlang__list_to_binary__1 [__kind_1012]
                   in let
                     bin_el_1019 = BIF.erlang__list_to_binary__1 [__file_1013]
                   in let
                     head_1016 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1017
                               (BIN.packedSize bin_el_1017) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1019
                               (BIN.packedSize bin_el_1019) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 6, col 22:\nInvalid \'protected\' argument\n  (0 : int) == (1 : int) : bool\nIt must be either \'true\' or \'false\'.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1013, ErlangCons head_1016 ErlangEmptyList]
                 lambda_1011 [] = EXC.function_clause unit
                 lambda_1011 args = EXC.badarity (ErlangFun 0 lambda_1011) args
               in lambda_1011)
        in let
          head_1009 = BIF.erlang__apply__2 [fun_1010, ErlangEmptyList]
        in let
          fun_1024 =
            ErlangFun 0
              (let
                 lambda_1025 [] =
                   let    __kind_1026 = toErl "Type"
                   in let __file_1027 = toErl "bad_function_block"
                   in let
                     bin_el_1031 = BIF.erlang__list_to_binary__1 [__kind_1026]
                   in let
                     bin_el_1033 = BIF.erlang__list_to_binary__1 [__file_1027]
                   in let
                     head_1030 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1031
                               (BIN.packedSize bin_el_1031) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1033
                               (BIN.packedSize bin_el_1033) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 5:\nMismatch in the function block. Expected implementation/type declaration of g function")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1037 = BIF.erlang__list_to_binary__1 [__kind_1026]
                   in let
                     bin_el_1039 = BIF.erlang__list_to_binary__1 [__file_1027]
                   in let
                     head_1036 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1037
                               (BIN.packedSize bin_el_1037) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1039
                               (BIN.packedSize bin_el_1039) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 5:\nMismatch in the function block. Expected implementation/type declaration of g function")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1027,
                        ErlangCons head_1030
                          (ErlangCons head_1036 ErlangEmptyList)]
                 lambda_1025 [] = EXC.function_clause unit
                 lambda_1025 args = EXC.badarity (ErlangFun 0 lambda_1025) args
               in lambda_1025)
        in let
          head_1023 = BIF.erlang__apply__2 [fun_1024, ErlangEmptyList]
        in let
          fun_1044 =
            ErlangFun 0
              (let
                 lambda_1045 [] =
                   let    __kind_1046 = toErl "Type"
                   in let __file_1047 = toErl "just_an_empty_file"
                   in let
                     bin_el_1051 = BIF.erlang__list_to_binary__1 [__kind_1046]
                   in let
                     bin_el_1053 = BIF.erlang__list_to_binary__1 [__file_1047]
                   in let
                     head_1050 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1051
                               (BIN.packedSize bin_el_1051) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1053
                               (BIN.packedSize bin_el_1053) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 0, col 0:\nEmpty contract")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1047, ErlangCons head_1050 ErlangEmptyList]
                 lambda_1045 [] = EXC.function_clause unit
                 lambda_1045 args = EXC.badarity (ErlangFun 0 lambda_1045) args
               in lambda_1045)
        in let
          head_1043 = BIF.erlang__apply__2 [fun_1044, ErlangEmptyList]
        in let
          fun_1058 =
            ErlangFun 0
              (let
                 lambda_1059 [] =
                   let    __kind_1060 = toErl "Type"
                   in let __file_1061 = toErl "bad_number_of_args"
                   in let
                     bin_el_1065 = BIF.erlang__list_to_binary__1 [__kind_1060]
                   in let
                     bin_el_1067 = BIF.erlang__list_to_binary__1 [__file_1061]
                   in let
                     head_1064 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1065
                               (BIN.packedSize bin_el_1065) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1067
                               (BIN.packedSize bin_el_1067) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 3, col 39:\nCannot unify () => unit\n         and (int) => \'a\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "when checking the application at line 3, column 39 of\n  f : () => unit\nto arguments\n  1 : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1071 = BIF.erlang__list_to_binary__1 [__kind_1060]
                   in let
                     bin_el_1073 = BIF.erlang__list_to_binary__1 [__file_1061]
                   in let
                     head_1070 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1071
                               (BIN.packedSize bin_el_1071) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1073
                               (BIN.packedSize bin_el_1073) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 20:\nCannot unify (int, string) => \'e\n         and (int) => \'d\nwhen checking the application at line 4, column 20 of\n  g : (int, string) => \'e\nto arguments\n  1 : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1077 = BIF.erlang__list_to_binary__1 [__kind_1060]
                   in let
                     bin_el_1079 = BIF.erlang__list_to_binary__1 [__file_1061]
                   in let
                     head_1076 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1077
                               (BIN.packedSize bin_el_1077) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1079
                               (BIN.packedSize bin_el_1079) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 5, col 20:\nCannot unify (int, string) => \'c\n         and (string) => \'b\nwhen checking the application at line 5, column 20 of\n  g : (int, string) => \'c\nto arguments\n  \"Litwo, ojczyzno moja\" : string")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1061,
                        ErlangCons head_1064
                          (ErlangCons head_1070
                             (ErlangCons head_1076 ErlangEmptyList))]
                 lambda_1059 [] = EXC.function_clause unit
                 lambda_1059 args = EXC.badarity (ErlangFun 0 lambda_1059) args
               in lambda_1059)
        in let
          head_1057 = BIF.erlang__apply__2 [fun_1058, ErlangEmptyList]
        in let
          fun_1084 =
            ErlangFun 0
              (let
                 lambda_1085 [] =
                   let    __kind_1086 = toErl "Type"
                   in let __file_1087 = toErl "bad_state"
                   in let
                     bin_el_1091 = BIF.erlang__list_to_binary__1 [__kind_1086]
                   in let
                     bin_el_1093 = BIF.erlang__list_to_binary__1 [__file_1087]
                   in let
                     head_1090 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1091
                               (BIN.packedSize bin_el_1091) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1093
                               (BIN.packedSize bin_el_1093) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 4, col 16:\nConflicting updates for field \'foo\'")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1087, ErlangCons head_1090 ErlangEmptyList]
                 lambda_1085 [] = EXC.function_clause unit
                 lambda_1085 args = EXC.badarity (ErlangFun 0 lambda_1085) args
               in lambda_1085)
        in let
          head_1083 = BIF.erlang__apply__2 [fun_1084, ErlangEmptyList]
        in let
          fun_1098 =
            ErlangFun 0
              (let
                 lambda_1099 [] =
                   let    __kind_1100 = toErl "Type"
                   in let __file_1101 = toErl "factories_type_errors"
                   in let
                     bin_el_1105 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1107 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1104 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1105
                               (BIN.packedSize bin_el_1105) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1107
                               (BIN.packedSize bin_el_1107) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 10, col 18:\nChain.clone requires `ref` named argument of contract type.")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1111 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1113 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1110 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1111
                               (BIN.packedSize bin_el_1111) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1113
                               (BIN.packedSize bin_el_1113) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 11, col 18:\nCannot unify (gas : int, value : int, protected : bool) => if(protected, option(void), void)\n         and (gas : int, value : int, protected : bool, int, bool) => \'b\nwhen checking contract construction of type\n  (gas : int, value : int, protected : bool) =>\n    if(protected, option(void), void) (at line 11, column 18)\nagainst the expected type\n  (gas : int, value : int, protected : bool, int, bool) => \'b")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1117 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1119 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1116 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1117
                               (BIN.packedSize bin_el_1117) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1119
                               (BIN.packedSize bin_el_1119) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 12, col 37:\nCannot unify int\n         and bool\nwhen checking named argument\n  gas : int\nagainst inferred type\n  bool")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1123 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1125 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1122 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1123
                               (BIN.packedSize bin_el_1123) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1125
                               (BIN.packedSize bin_el_1125) 8,
                             BIN.fromInts (toErl ".aes\' at line 13, col 18:\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "Kaboom is not implemented.\nwhen resolving arguments of variadic function\n  Chain.create")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1129 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1131 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1128 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1129
                               (BIN.packedSize bin_el_1129) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1131
                               (BIN.packedSize bin_el_1131) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 18, col 18:\nCannot unify (gas : int, value : int, protected : bool, int, bool) => if(protected, option(void), void)\n         and (gas : int, value : int, protected : bool) => \'a\nwhen checking contract construction of type\n  (gas : int, value : int, protected : bool, int, bool) =>\n    if(protected, option(void), void) (at line 18, column 18)\nagainst the expected type\n  (gas : int, value : int, protected : bool) => \'a")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1135 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1137 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1134 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1135
                               (BIN.packedSize bin_el_1135) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1137
                               (BIN.packedSize bin_el_1137) 8,
                             BIN.fromInts (toErl ".aes\' at line 19, col 42:\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "Named argument protected (at line 19, column 42) is not one of the expected named arguments\n  - value : int")
                               (toErl 8) 1 BIN.Big])
                   in let
                     bin_el_1141 = BIF.erlang__list_to_binary__1 [__kind_1100]
                   in let
                     bin_el_1143 = BIF.erlang__list_to_binary__1 [__file_1101]
                   in let
                     head_1140 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1141
                               (BIN.packedSize bin_el_1141) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1143
                               (BIN.packedSize bin_el_1143) 8,
                             BIN.fromInts (toErl ".aes\' at line 20, col 42:\n")
                               (toErl 8) 1 BIN.Big,
                             BIN.fromInts
                               (toErl
                                  "Cannot unify int\n         and bool\nwhen checking named argument\n  value : int\nagainst inferred type\n  bool")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1101,
                        ErlangCons head_1104
                          (ErlangCons head_1110
                             (ErlangCons head_1116
                                (ErlangCons head_1122
                                   (ErlangCons head_1128
                                      (ErlangCons head_1134
                                         (ErlangCons head_1140
                                            ErlangEmptyList))))))]
                 lambda_1099 [] = EXC.function_clause unit
                 lambda_1099 args = EXC.badarity (ErlangFun 0 lambda_1099) args
               in lambda_1099)
        in let
          head_1097 = BIF.erlang__apply__2 [fun_1098, ErlangEmptyList]
        in let
          fun_1148 =
            ErlangFun 0
              (let
                 lambda_1149 [] =
                   let    __kind_1150 = toErl "Type"
                   in let __file_1151 = toErl "ambiguous_main"
                   in let
                     bin_el_1155 = BIF.erlang__list_to_binary__1 [__kind_1150]
                   in let
                     bin_el_1157 = BIF.erlang__list_to_binary__1 [__file_1151]
                   in let
                     head_1154 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1155
                               (BIN.packedSize bin_el_1155) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1157
                               (BIN.packedSize bin_el_1157) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 1, col 1:\nCould not deduce the main contract. You can point it out manually with the `main` keyword.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1151, ErlangCons head_1154 ErlangEmptyList]
                 lambda_1149 [] = EXC.function_clause unit
                 lambda_1149 args = EXC.badarity (ErlangFun 0 lambda_1149) args
               in lambda_1149)
        in let
          head_1147 = BIF.erlang__apply__2 [fun_1148, ErlangEmptyList]
        in let
          fun_1162 =
            ErlangFun 0
              (let
                 lambda_1163 [] =
                   let    __kind_1164 = toErl "Type"
                   in let __file_1165 = toErl "no_main_contract"
                   in let
                     bin_el_1169 = BIF.erlang__list_to_binary__1 [__kind_1164]
                   in let
                     bin_el_1171 = BIF.erlang__list_to_binary__1 [__file_1165]
                   in let
                     head_1168 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1169
                               (BIN.packedSize bin_el_1169) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1171
                               (BIN.packedSize bin_el_1171) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 0, col 0:\nNo contract defined.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1165, ErlangCons head_1168 ErlangEmptyList]
                 lambda_1163 [] = EXC.function_clause unit
                 lambda_1163 args = EXC.badarity (ErlangFun 0 lambda_1163) args
               in lambda_1163)
        in let
          head_1161 = BIF.erlang__apply__2 [fun_1162, ErlangEmptyList]
        in let
          fun_1176 =
            ErlangFun 0
              (let
                 lambda_1177 [] =
                   let    __kind_1178 = toErl "Type"
                   in let __file_1179 = toErl "multiple_main_contracts"
                   in let
                     bin_el_1183 = BIF.erlang__list_to_binary__1 [__kind_1178]
                   in let
                     bin_el_1185 = BIF.erlang__list_to_binary__1 [__file_1179]
                   in let
                     head_1182 =
                       ErlangBinary
                         (BIN.concat
                            [BIN.binPrefix bin_el_1183
                               (BIN.packedSize bin_el_1183) 8,
                             BIN.fromInts (toErl " error in \'") (toErl 8) 1
                               BIN.Big,
                             BIN.binPrefix bin_el_1185
                               (BIN.packedSize bin_el_1185) 8,
                             BIN.fromInts
                               (toErl
                                  ".aes\' at line 1, col 6:\nOnly one main contract can be defined.")
                               (toErl 8) 1 BIN.Big])
                   in
                     ErlangTuple
                       [__file_1179, ErlangCons head_1182 ErlangEmptyList]
                 lambda_1177 [] = EXC.function_clause unit
                 lambda_1177 args = EXC.badarity (ErlangFun 0 lambda_1177) args
               in lambda_1177)
        in let
          head_1175 = BIF.erlang__apply__2 [fun_1176, ErlangEmptyList]
        in
          ErlangCons head_11
            (ErlangCons head_25
               (ErlangCons head_39
                  (ErlangCons head_53
                     (ErlangCons head_67
                        (ErlangCons head_117
                           (ErlangCons head_275
                              (ErlangCons head_289
                                 (ErlangCons head_303
                                    (ErlangCons head_329
                                       (ErlangCons head_343
                                          (ErlangCons head_363
                                             (ErlangCons head_383
                                                (ErlangCons head_397
                                                   (ErlangCons head_411
                                                      (ErlangCons head_425
                                                         (ErlangCons head_439
                                                            (ErlangCons head_525
                                                               (ErlangCons
                                                                  head_581
                                                                  (ErlangCons
                                                                     head_607
                                                                     (ErlangCons
                                                                        head_657
                                                                        (ErlangCons
                                                                           head_671
                                                                           (ErlangCons
                                                                              head_685
                                                                              (ErlangCons
                                                                                 head_699
                                                                                 (ErlangCons
                                                                                    head_725
                                                                                    (ErlangCons
                                                                                       head_739
                                                                                       (ErlangCons
                                                                                          head_753
                                                                                          (ErlangCons
                                                                                             head_767
                                                                                             (ErlangCons
                                                                                                head_805
                                                                                                (ErlangCons
                                                                                                   head_831
                                                                                                   (ErlangCons
                                                                                                      head_853
                                                                                                      (ErlangCons
                                                                                                         head_867
                                                                                                         (ErlangCons
                                                                                                            head_881
                                                                                                            (ErlangCons
                                                                                                               head_895
                                                                                                               (ErlangCons
                                                                                                                  head_909
                                                                                                                  (ErlangCons
                                                                                                                     head_923
                                                                                                                     (ErlangCons
                                                                                                                        head_955
                                                                                                                        (ErlangCons
                                                                                                                           head_969
                                                                                                                           (ErlangCons
                                                                                                                              head_983
                                                                                                                              (ErlangCons
                                                                                                                                 head_1009
                                                                                                                                 (ErlangCons
                                                                                                                                    head_1023
                                                                                                                                    (ErlangCons
                                                                                                                                       head_1043
                                                                                                                                       (ErlangCons
                                                                                                                                          head_1057
                                                                                                                                          (ErlangCons
                                                                                                                                             head_1083
                                                                                                                                             (ErlangCons
                                                                                                                                                head_1097
                                                                                                                                                (ErlangCons
                                                                                                                                                   head_1147
                                                                                                                                                   (ErlangCons
                                                                                                                                                      head_1161
                                                                                                                                                      (ErlangCons
                                                                                                                                                         head_1175
                                                                                                                                                         ErlangEmptyList)))))))))))))))))))))))))))))))))))))))))))))))
      _ -> EXC.badmatch matchExpr_1
erlps__failing_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__failing_contracts__0) args

erlps__failing_code_gen_contracts__0 :: ErlangFun
erlps__failing_code_gen_contracts__0 [] =
  let    tup_el_1 = toErl "code_errors/missing_definition"
  in let arg_4 = toErl "Code generation"
  in let bin_el_3 = BIF.erlang__list_to_binary__1 [arg_4]
  in let arg_6 = toErl "code_errors/missing_definition"
  in let bin_el_5 = BIF.erlang__list_to_binary__1 [arg_6]
  in let
    tup_el_2 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_3 (BIN.packedSize bin_el_3) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_5 (BIN.packedSize bin_el_5) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 14:\nMissing definition of function \'foo\'.")
              (toErl 8) 1 BIN.Big])
  in let head_0 = ErlangTuple [tup_el_1, tup_el_2]
  in let tup_el_9 = toErl "code_errors/polymorphic_entrypoint"
  in let arg_15 = toErl "Code generation"
  in let bin_el_14 = BIF.erlang__list_to_binary__1 [arg_15]
  in let arg_17 = toErl "code_errors/polymorphic_entrypoint"
  in let bin_el_16 = BIF.erlang__list_to_binary__1 [arg_17]
  in let
    tup_el_13 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_14 (BIN.packedSize bin_el_14) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_16 (BIN.packedSize bin_el_16) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 17:\nThe argument\n  x : \'a\nof entrypoint \'id\' has a polymorphic (contains type variables) type.\nUse the FATE backend if you want polymorphic entrypoints.")
              (toErl 8) 1 BIN.Big])
  in let head_11 = ErlangTuple [ErlangAtom "aevm", tup_el_13]
  in let
    head_8 =
      ErlangTuple [tup_el_9, ErlangCons head_11 ErlangEmptyList]
  in let
    tup_el_21 = toErl "code_errors/polymorphic_entrypoint_return"
  in let arg_27 = toErl "Code generation"
  in let bin_el_26 = BIF.erlang__list_to_binary__1 [arg_27]
  in let arg_29 = toErl "code_errors/polymorphic_entrypoint_return"
  in let bin_el_28 = BIF.erlang__list_to_binary__1 [arg_29]
  in let
    tup_el_25 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_26 (BIN.packedSize bin_el_26) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_28 (BIN.packedSize bin_el_28) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 3:\nThe return type\n  \'a\nof entrypoint \'fail\' is polymorphic (contains type variables).\nUse the FATE backend if you want polymorphic entrypoints.")
              (toErl 8) 1 BIN.Big])
  in let head_23 = ErlangTuple [ErlangAtom "aevm", tup_el_25]
  in let
    head_20 =
      ErlangTuple [tup_el_21, ErlangCons head_23 ErlangEmptyList]
  in let tup_el_33 = toErl "code_errors/higher_order_entrypoint"
  in let arg_36 = toErl "Code generation"
  in let bin_el_35 = BIF.erlang__list_to_binary__1 [arg_36]
  in let arg_38 = toErl "code_errors/higher_order_entrypoint"
  in let bin_el_37 = BIF.erlang__list_to_binary__1 [arg_38]
  in let
    tup_el_34 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_35 (BIN.packedSize bin_el_35) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_37 (BIN.packedSize bin_el_37) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 20:\nThe argument\n  f : (int) => int\nof entrypoint \'apply\' has a higher-order (contains function types) type.")
              (toErl 8) 1 BIN.Big])
  in let head_32 = ErlangTuple [tup_el_33, tup_el_34]
  in let
    tup_el_41 = toErl "code_errors/higher_order_entrypoint_return"
  in let arg_44 = toErl "Code generation"
  in let bin_el_43 = BIF.erlang__list_to_binary__1 [arg_44]
  in let
    arg_46 = toErl "code_errors/higher_order_entrypoint_return"
  in let bin_el_45 = BIF.erlang__list_to_binary__1 [arg_46]
  in let
    tup_el_42 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_43 (BIN.packedSize bin_el_43) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_45 (BIN.packedSize bin_el_45) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 3:\nThe return type\n  (int) => int\nof entrypoint \'add\' is higher-order (contains function types).")
              (toErl 8) 1 BIN.Big])
  in let head_40 = ErlangTuple [tup_el_41, tup_el_42]
  in let tup_el_49 = toErl "code_errors/missing_init_function"
  in let arg_52 = toErl "Code generation"
  in let bin_el_51 = BIF.erlang__list_to_binary__1 [arg_52]
  in let arg_54 = toErl "code_errors/missing_init_function"
  in let bin_el_53 = BIF.erlang__list_to_binary__1 [arg_54]
  in let
    tup_el_50 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_51 (BIN.packedSize bin_el_51) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_53 (BIN.packedSize bin_el_53) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 1, col 10:\nMissing init function for the contract \'MissingInitFunction\'.\nThe \'init\' function can only be omitted if the state type is \'unit\'.")
              (toErl 8) 1 BIN.Big])
  in let head_48 = ErlangTuple [tup_el_49, tup_el_50]
  in let tup_el_57 = toErl "code_errors/parameterised_state"
  in let arg_60 = toErl "Code generation"
  in let bin_el_59 = BIF.erlang__list_to_binary__1 [arg_60]
  in let arg_62 = toErl "code_errors/parameterised_state"
  in let bin_el_61 = BIF.erlang__list_to_binary__1 [arg_62]
  in let
    tup_el_58 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_59 (BIN.packedSize bin_el_59) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_61 (BIN.packedSize bin_el_61) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 8:\nThe state type cannot be parameterized.")
              (toErl 8) 1 BIN.Big])
  in let head_56 = ErlangTuple [tup_el_57, tup_el_58]
  in let tup_el_65 = toErl "code_errors/parameterised_event"
  in let arg_68 = toErl "Code generation"
  in let bin_el_67 = BIF.erlang__list_to_binary__1 [arg_68]
  in let arg_70 = toErl "code_errors/parameterised_event"
  in let bin_el_69 = BIF.erlang__list_to_binary__1 [arg_70]
  in let
    tup_el_66 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_67 (BIN.packedSize bin_el_67) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_69 (BIN.packedSize bin_el_69) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 12:\nThe event type cannot be parameterized.")
              (toErl 8) 1 BIN.Big])
  in let head_64 = ErlangTuple [tup_el_65, tup_el_66]
  in let tup_el_73 = toErl "code_errors/polymorphic_aens_resolve"
  in let arg_76 = toErl "Code generation"
  in let bin_el_75 = BIF.erlang__list_to_binary__1 [arg_76]
  in let arg_78 = toErl "code_errors/polymorphic_aens_resolve"
  in let bin_el_77 = BIF.erlang__list_to_binary__1 [arg_78]
  in let
    tup_el_74 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_75 (BIN.packedSize bin_el_75) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_77 (BIN.packedSize bin_el_77) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nInvalid return type of AENS.resolve:\n  \'a\nIt must be a string or a pubkey type (address, oracle, etc).")
              (toErl 8) 1 BIN.Big])
  in let head_72 = ErlangTuple [tup_el_73, tup_el_74]
  in let tup_el_81 = toErl "code_errors/bad_aens_resolve"
  in let arg_84 = toErl "Code generation"
  in let bin_el_83 = BIF.erlang__list_to_binary__1 [arg_84]
  in let arg_86 = toErl "code_errors/bad_aens_resolve"
  in let bin_el_85 = BIF.erlang__list_to_binary__1 [arg_86]
  in let
    tup_el_82 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_83 (BIN.packedSize bin_el_83) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_85 (BIN.packedSize bin_el_85) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 6, col 5:\nInvalid return type of AENS.resolve:\n  list(int)\nIt must be a string or a pubkey type (address, oracle, etc).")
              (toErl 8) 1 BIN.Big])
  in let head_80 = ErlangTuple [tup_el_81, tup_el_82]
  in let tup_el_89 = toErl "code_errors/polymorphic_compare"
  in let arg_95 = toErl "Code generation"
  in let bin_el_94 = BIF.erlang__list_to_binary__1 [arg_95]
  in let arg_97 = toErl "code_errors/polymorphic_compare"
  in let bin_el_96 = BIF.erlang__list_to_binary__1 [arg_97]
  in let
    tup_el_93 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_94 (BIN.packedSize bin_el_94) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_96 (BIN.packedSize bin_el_96) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  \'a\nThe AEVM only supports \'==\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\n- type string\n- tuple or record of word type\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_91 = ErlangTuple [ErlangAtom "aevm", tup_el_93]
  in let
    head_88 =
      ErlangTuple [tup_el_89, ErlangCons head_91 ErlangEmptyList]
  in let tup_el_101 = toErl "code_errors/complex_compare"
  in let arg_107 = toErl "Code generation"
  in let bin_el_106 = BIF.erlang__list_to_binary__1 [arg_107]
  in let arg_109 = toErl "code_errors/complex_compare"
  in let bin_el_108 = BIF.erlang__list_to_binary__1 [arg_109]
  in let
    tup_el_105 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_106 (BIN.packedSize bin_el_106) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_108 (BIN.packedSize bin_el_108) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  (string * int)\nThe AEVM only supports \'!=\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\n- type string\n- tuple or record of word type\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_103 = ErlangTuple [ErlangAtom "aevm", tup_el_105]
  in let
    head_100 =
      ErlangTuple [tup_el_101, ErlangCons head_103 ErlangEmptyList]
  in let tup_el_113 = toErl "code_errors/complex_compare_leq"
  in let arg_119 = toErl "Code generation"
  in let bin_el_118 = BIF.erlang__list_to_binary__1 [arg_119]
  in let arg_121 = toErl "code_errors/complex_compare_leq"
  in let bin_el_120 = BIF.erlang__list_to_binary__1 [arg_121]
  in let
    tup_el_117 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_118 (BIN.packedSize bin_el_118) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_120 (BIN.packedSize bin_el_120) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  (int * int)\nThe AEVM only supports \'=<\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_115 = ErlangTuple [ErlangAtom "aevm", tup_el_117]
  in let
    head_112 =
      ErlangTuple [tup_el_113, ErlangCons head_115 ErlangEmptyList]
  in let tup_el_125 = toErl "code_errors/higher_order_compare"
  in let arg_131 = toErl "Code generation"
  in let bin_el_130 = BIF.erlang__list_to_binary__1 [arg_131]
  in let arg_133 = toErl "code_errors/higher_order_compare"
  in let bin_el_132 = BIF.erlang__list_to_binary__1 [arg_133]
  in let
    tup_el_129 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_130 (BIN.packedSize bin_el_130) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_132 (BIN.packedSize bin_el_132) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 5:\nCannot compare values of type\n  (int) => int\nThe AEVM only supports \'<\' on values of\n- word type (int, bool, bits, address, oracle(_, _), etc)\nUse FATE if you need to compare arbitrary types.")
              (toErl 8) 1 BIN.Big])
  in let head_127 = ErlangTuple [ErlangAtom "aevm", tup_el_129]
  in let
    head_124 =
      ErlangTuple [tup_el_125, ErlangCons head_127 ErlangEmptyList]
  in let tup_el_137 = toErl "code_errors/unapplied_contract_call"
  in let arg_143 = toErl "Code generation"
  in let bin_el_142 = BIF.erlang__list_to_binary__1 [arg_143]
  in let arg_145 = toErl "code_errors/unapplied_contract_call"
  in let bin_el_144 = BIF.erlang__list_to_binary__1 [arg_145]
  in let
    tup_el_141 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_142 (BIN.packedSize bin_el_142) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_144 (BIN.packedSize bin_el_144) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 6, col 19:\nThe AEVM does not support unapplied contract call to\n  r : Remote\nUse FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_139 = ErlangTuple [ErlangAtom "aevm", tup_el_141]
  in let
    head_136 =
      ErlangTuple [tup_el_137, ErlangCons head_139 ErlangEmptyList]
  in let
    tup_el_149 = toErl "code_errors/unapplied_named_arg_builtin"
  in let arg_155 = toErl "Code generation"
  in let bin_el_154 = BIF.erlang__list_to_binary__1 [arg_155]
  in let arg_157 = toErl "code_errors/unapplied_named_arg_builtin"
  in let bin_el_156 = BIF.erlang__list_to_binary__1 [arg_157]
  in let
    tup_el_153 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_154 (BIN.packedSize bin_el_154) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_156 (BIN.packedSize bin_el_156) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 15:\nThe AEVM does not support unapplied use of Oracle.register.\nUse FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_151 = ErlangTuple [ErlangAtom "aevm", tup_el_153]
  in let
    head_148 =
      ErlangTuple [tup_el_149, ErlangCons head_151 ErlangEmptyList]
  in let tup_el_161 = toErl "code_errors/polymorphic_map_keys"
  in let arg_167 = toErl "Code generation"
  in let bin_el_166 = BIF.erlang__list_to_binary__1 [arg_167]
  in let arg_169 = toErl "code_errors/polymorphic_map_keys"
  in let bin_el_168 = BIF.erlang__list_to_binary__1 [arg_169]
  in let
    tup_el_165 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_166 (BIN.packedSize bin_el_166) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_168 (BIN.packedSize bin_el_168) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 34:\nInvalid map key type\n  \'a\nMap keys cannot be polymorphic in the AEVM. Use FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_163 = ErlangTuple [ErlangAtom "aevm", tup_el_165]
  in let
    head_160 =
      ErlangTuple [tup_el_161, ErlangCons head_163 ErlangEmptyList]
  in let tup_el_173 = toErl "code_errors/higher_order_map_keys"
  in let arg_179 = toErl "Code generation"
  in let bin_el_178 = BIF.erlang__list_to_binary__1 [arg_179]
  in let arg_181 = toErl "code_errors/higher_order_map_keys"
  in let bin_el_180 = BIF.erlang__list_to_binary__1 [arg_181]
  in let
    tup_el_177 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_178 (BIN.packedSize bin_el_178) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_180 (BIN.packedSize bin_el_180) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 4, col 42:\nInvalid map key type\n  (int) => int\nMap keys cannot be higher-order.")
              (toErl 8) 1 BIN.Big])
  in let head_175 = ErlangTuple [ErlangAtom "aevm", tup_el_177]
  in let
    head_172 =
      ErlangTuple [tup_el_173, ErlangCons head_175 ErlangEmptyList]
  in let tup_el_185 = toErl "code_errors/polymorphic_query_type"
  in let arg_188 = toErl "Code generation"
  in let bin_el_187 = BIF.erlang__list_to_binary__1 [arg_188]
  in let arg_190 = toErl "code_errors/polymorphic_query_type"
  in let bin_el_189 = BIF.erlang__list_to_binary__1 [arg_190]
  in let
    tup_el_186 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_187 (BIN.packedSize bin_el_187) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_189 (BIN.packedSize bin_el_189) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle(\'a, \'b)\nThe query type must not be polymorphic (contain type variables).")
              (toErl 8) 1 BIN.Big])
  in let head_184 = ErlangTuple [tup_el_185, tup_el_186]
  in let tup_el_193 = toErl "code_errors/polymorphic_response_type"
  in let arg_196 = toErl "Code generation"
  in let bin_el_195 = BIF.erlang__list_to_binary__1 [arg_196]
  in let arg_198 = toErl "code_errors/polymorphic_response_type"
  in let bin_el_197 = BIF.erlang__list_to_binary__1 [arg_198]
  in let
    tup_el_194 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_195 (BIN.packedSize bin_el_195) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_197 (BIN.packedSize bin_el_197) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle(string, \'r)\nThe response type must not be polymorphic (contain type variables).")
              (toErl 8) 1 BIN.Big])
  in let head_192 = ErlangTuple [tup_el_193, tup_el_194]
  in let tup_el_201 = toErl "code_errors/higher_order_query_type"
  in let arg_204 = toErl "Code generation"
  in let bin_el_203 = BIF.erlang__list_to_binary__1 [arg_204]
  in let arg_206 = toErl "code_errors/higher_order_query_type"
  in let bin_el_205 = BIF.erlang__list_to_binary__1 [arg_206]
  in let
    tup_el_202 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_203 (BIN.packedSize bin_el_203) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_205 (BIN.packedSize bin_el_205) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle((int) => int, string)\nThe query type must not be higher-order (contain function types).")
              (toErl 8) 1 BIN.Big])
  in let head_200 = ErlangTuple [tup_el_201, tup_el_202]
  in let
    tup_el_209 = toErl "code_errors/higher_order_response_type"
  in let arg_212 = toErl "Code generation"
  in let bin_el_211 = BIF.erlang__list_to_binary__1 [arg_212]
  in let arg_214 = toErl "code_errors/higher_order_response_type"
  in let bin_el_213 = BIF.erlang__list_to_binary__1 [arg_214]
  in let
    tup_el_210 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_211 (BIN.packedSize bin_el_211) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_213 (BIN.packedSize bin_el_213) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 5:\nInvalid oracle type\n  oracle(string, (int) => int)\nThe response type must not be higher-order (contain function types).")
              (toErl 8) 1 BIN.Big])
  in let head_208 = ErlangTuple [tup_el_209, tup_el_210]
  in let tup_el_217 = toErl "code_errors/higher_order_state"
  in let arg_223 = toErl "Code generation"
  in let bin_el_222 = BIF.erlang__list_to_binary__1 [arg_223]
  in let arg_225 = toErl "code_errors/higher_order_state"
  in let bin_el_224 = BIF.erlang__list_to_binary__1 [arg_225]
  in let
    tup_el_221 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_222 (BIN.packedSize bin_el_222) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_224 (BIN.packedSize bin_el_224) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 3, col 3:\nInvalid state type\n  {f : (int) => int}\nThe state cannot contain functions in the AEVM. Use FATE if you need this.")
              (toErl 8) 1 BIN.Big])
  in let head_219 = ErlangTuple [ErlangAtom "aevm", tup_el_221]
  in let
    head_216 =
      ErlangTuple [tup_el_217, ErlangCons head_219 ErlangEmptyList]
  in let tup_el_229 = toErl "code_errors/child_with_decls"
  in let arg_235 = toErl "Code generation"
  in let bin_el_234 = BIF.erlang__list_to_binary__1 [arg_235]
  in let arg_237 = toErl "code_errors/child_with_decls"
  in let bin_el_236 = BIF.erlang__list_to_binary__1 [arg_237]
  in let
    tup_el_233 =
      ErlangBinary
        (BIN.concat
           [BIN.binPrefix bin_el_234 (BIN.packedSize bin_el_234) 8,
            BIN.fromInts (toErl " error in \'") (toErl 8) 1 BIN.Big,
            BIN.binPrefix bin_el_236 (BIN.packedSize bin_el_236) 8,
            BIN.fromInts
              (toErl
                 ".aes\' at line 2, col 14:\nMissing definition of function \'f\'.")
              (toErl 8) 1 BIN.Big])
  in let head_231 = ErlangTuple [ErlangAtom "fate", tup_el_233]
  in let
    head_228 =
      ErlangTuple [tup_el_229, ErlangCons head_231 ErlangEmptyList]
  in
    ErlangCons head_0
      (ErlangCons head_8
         (ErlangCons head_20
            (ErlangCons head_32
               (ErlangCons head_40
                  (ErlangCons head_48
                     (ErlangCons head_56
                        (ErlangCons head_64
                           (ErlangCons head_72
                              (ErlangCons head_80
                                 (ErlangCons head_88
                                    (ErlangCons head_100
                                       (ErlangCons head_112
                                          (ErlangCons head_124
                                             (ErlangCons head_136
                                                (ErlangCons head_148
                                                   (ErlangCons head_160
                                                      (ErlangCons head_172
                                                         (ErlangCons head_184
                                                            (ErlangCons head_192
                                                               (ErlangCons
                                                                  head_200
                                                                  (ErlangCons
                                                                     head_208
                                                                     (ErlangCons
                                                                        head_216
                                                                        (ErlangCons
                                                                           head_228
                                                                           ErlangEmptyList)))))))))))))))))))))))
erlps__failing_code_gen_contracts__0 args =
  EXC.badarity (ErlangFun 0 erlps__failing_code_gen_contracts__0)
    args

erlps__validation_test___0 :: ErlangFun
erlps__validation_test___0 [] =
  let    lcSrc_1 = erlps__validation_fails__0 []
  in let
    lop_0 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             (ErlangTuple [c1_2, c2_3, expect_4]) ->
               let    lop_8 = toErl "Validation fail: "
               in let lop_12 = toErl " /= "
               in let rop_11 = BIF.erlang__op_append [lop_12, c2_3]
               in let rop_9 = BIF.erlang__op_append [c1_2, rop_11]
               in let tup_el_7 = BIF.erlang__op_append [lop_8, rop_9]
               in let
                 tup_el_14 =
                   ErlangFun 0
                     (let
                        lambda_15 [] =
                          let    case_16 = erlps__validate__2 [c1_2, c2_3]
                          in let
                            actual_20 =
                              case case_16 of
                                (ErlangTuple [(ErlangAtom "error"), errs_19]) ->
                                  errs_19
                                (ErlangAtom "ok") -> ErlangMap Map.empty
                                something_else -> EXC.case_clause something_else
                          in erlps__check_errors__2 [expect_4, actual_20]
                        lambda_15 [] = EXC.function_clause unit
                        lambda_15 args =
                          EXC.badarity (ErlangFun 0 lambda_15) args
                      in lambda_15)
               in let lcRet_6 = ErlangTuple [tup_el_7, tup_el_14]
               in ErlangCons lcRet_6 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_1
  in let lcSrc_24 = erlps__compilable_contracts__0 []
  in let
    rop_23 =
      flmap
        (\ lc_26 ->
           let    lop_29 = toErl "Validation of "
           in let tup_el_28 = BIF.erlang__op_append [lop_29, lc_26]
           in let
             tup_el_31 =
               ErlangFun 0
                 (let
                    lambda_32 [] =
                      let
                        fun_33 =
                          ErlangFun 0
                            (let
                               lambda_34 [] =
                                 let case_36 = erlps__validate__2 [lc_26, lc_26]
                                 in
                                   case case_36 of
                                     __x_39 | __x_39 == (ErlangAtom "ok") ->
                                       ErlangAtom "ok"
                                     __v_40 ->
                                       let   
                                         head_44 =
                                           ErlangTuple
                                             [ErlangAtom "module",
                                              ErlangAtom "aeso_compiler_tests"]
                                       in let tup_el_50 = toErl 892
                                       in let
                                         head_48 =
                                           ErlangTuple
                                             [ErlangAtom "line", tup_el_50]
                                       in let
                                         tup_el_54 = toErl "validate ( C , C )"
                                       in let
                                         head_52 =
                                           ErlangTuple
                                             [ErlangAtom "expression",
                                              tup_el_54]
                                       in let
                                         head_56 =
                                           ErlangTuple
                                             [ErlangAtom "expected",
                                              ErlangAtom "ok"]
                                       in let
                                         head_60 =
                                           ErlangTuple
                                             [ErlangAtom "value", __v_40]
                                       in let
                                         arg_41 =
                                           ErlangTuple
                                             [ErlangAtom "assertEqual",
                                              ErlangCons head_44
                                                (ErlangCons head_48
                                                   (ErlangCons head_52
                                                      (ErlangCons head_56
                                                         (ErlangCons head_60
                                                            ErlangEmptyList))))]
                                       in BIF.erlang__error__1 [arg_41]
                               lambda_34 [] = EXC.function_clause unit
                               lambda_34 args =
                                 EXC.badarity (ErlangFun 0 lambda_34) args
                             in lambda_34)
                      in BIF.erlang__apply__2 [fun_33, ErlangEmptyList]
                    lambda_32 [] = EXC.function_clause unit
                    lambda_32 args = EXC.badarity (ErlangFun 0 lambda_32) args
                  in lambda_32)
           in let lcRet_27 = ErlangTuple [tup_el_28, tup_el_31]
           in ErlangCons lcRet_27 ErlangEmptyList)
        lcSrc_24
  in BIF.erlang__op_append [lop_0, rop_23]
erlps__validation_test___0 args =
  EXC.badarity (ErlangFun 0 erlps__validation_test___0) args

erlps__validation_fails__0 :: ErlangFun
erlps__validation_fails__0 [] =
  let    tup_el_1 = toErl "deadcode"
  in let tup_el_2 = toErl "nodeadcode"
  in let
    head_4 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "Data error:\nByte code does not match source code.\n- Functions in the source code but not in the byte code:\n    .MyList.map2")
           (toErl 8) 1 BIN.Big)
  in let
    head_0 =
      ErlangTuple
        [tup_el_1, tup_el_2, ErlangCons head_4 ErlangEmptyList]
  in let tup_el_8 = toErl "validation_test1"
  in let tup_el_9 = toErl "validation_test2"
  in let
    head_11 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "Data error:\nByte code does not match source code.\n- The implementation of the function code_fail is different.\n- The attributes of the function attr_fail differ:\n    Byte code:   payable\n    Source code: \n- The type of the function type_fail differs:\n    Byte code:   integer => integer\n    Source code: {tvar,0} => {tvar,0}")
           (toErl 8) 1 BIN.Big)
  in let
    head_7 =
      ErlangTuple
        [tup_el_8, tup_el_9, ErlangCons head_11 ErlangEmptyList]
  in let tup_el_15 = toErl "validation_test1"
  in let tup_el_16 = toErl "validation_test3"
  in let
    head_18 =
      ErlangBinary
        (BIN.fromInts
           (toErl
              "Data error:\nByte code contract is not payable, but source code contract is.")
           (toErl 8) 1 BIN.Big)
  in let
    head_14 =
      ErlangTuple
        [tup_el_15, tup_el_16, ErlangCons head_18 ErlangEmptyList]
  in
    ErlangCons head_0
      (ErlangCons head_7 (ErlangCons head_14 ErlangEmptyList))
erlps__validation_fails__0 args =
  EXC.badarity (ErlangFun 0 erlps__validation_fails__0) args

erlps__validate__2 :: ErlangFun
erlps__validate__2 [contract1_0, contract2_1] =
  let case_2 = erlps__compile__2 [ErlangAtom "fate", contract1_0]
  in
    case case_2 of
      bytecode_7@(ErlangMap map_5) | (DM.Just fcode_6) <-
                                       (Map.lookup (ErlangAtom "fate_code")
                                          map_5) ->
        let   
          arg_8 =
            BIF.do_remote_fun_call "Aeb.Fate.Code"
              "erlps__strip_init_function__1" [fcode_6]
        in let
          fcode1_10 =
            BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__serialize__1"
              [arg_8]
        in let
          source_12 =
            BIF.do_remote_fun_call "Aeso.Test.Utils"
              "erlps__read_contract__1" [contract2_1]
        in let
          mapExt_17 =
            ErlangMap (Map.singleton (ErlangAtom "byte_code") fcode1_10)
        in let
          arg_13 =
            case findMissingKey bytecode_7 [ErlangAtom "byte_code"] of
              (DM.Nothing) -> BIF.maps__merge__2 [bytecode_7, mapExt_17]
              (DM.Just missing_19) -> EXC.badkey missing_19
        in let arg_25 = erlps__debug_mode_contracts__0 []
        in let case_23 = BIF.lists__member__2 [contract2_1, arg_25]
        in let
          lop_22 =
            case case_23 of
              (ErlangAtom "true") ->
                ErlangCons (ErlangAtom "debug_mode") ErlangEmptyList
              (ErlangAtom "false") -> ErlangEmptyList
              something_else -> EXC.case_clause something_else
        in let
          head_29 = ErlangTuple [ErlangAtom "backend", ErlangAtom "fate"]
        in let
          head_38 =
            BIF.do_remote_fun_call "Aeso.Test.Utils"
              "erlps__contract_path__0" []
        in let
          tup_el_35 =
            ErlangTuple
              [ErlangAtom "file_system", ErlangCons head_38 ErlangEmptyList]
        in let head_33 = ErlangTuple [ErlangAtom "include", tup_el_35]
        in let
          arg_21 =
            BIF.erlang__op_append
              [lop_22, ErlangCons head_29 (ErlangCons head_33 ErlangEmptyList)]
        in
          BIF.do_remote_fun_call "Aeso.Compiler"
            "erlps__validate_byte_code__3" [arg_13, source_12, arg_21]
      error_41 -> erlps__print_and_throw__1 [error_41]
erlps__validate__2 [arg_43, arg_44] = EXC.function_clause unit
erlps__validate__2 args =
  EXC.badarity (ErlangFun 2 erlps__validate__2) args

erlps__print_and_throw__1 :: ErlangFun
erlps__print_and_throw__1 [err_0] =
  case err_0 of
    errbin_2 | isEBinary errbin_2 ->
      let    arg_3 = toErl "\n~s"
      in let
        _ =
          BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
            [arg_3, ErlangCons errbin_2 ErlangEmptyList]
      in BIF.erlang__error__1 [errbin_2]
    errors_8 ->
      let    arg_9 = toErl "Compilation error:\n~s"
      in let
        arg_12 =
          flmap
            (\ lc_15 ->
               let
                 lcRet_16 =
                   BIF.do_remote_fun_call "Aeso.Errors" "erlps__pp__1" [lc_15]
               in ErlangCons lcRet_16 ErlangEmptyList)
            errors_8
      in let arg_18 = toErl "\n\n"
      in let
        head_11 =
          BIF.do_remote_fun_call "String" "erlps__join__2" [arg_12, arg_18]
      in let
        _ =
          BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
            [arg_9, ErlangCons head_11 ErlangEmptyList]
      in BIF.erlang__error__1 [ErlangAtom "compilation_error"]
erlps__print_and_throw__1 [arg_21] = EXC.function_clause unit
erlps__print_and_throw__1 args =
  EXC.badarity (ErlangFun 1 erlps__print_and_throw__1) args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeso_compiler_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 erlps__test__0) args