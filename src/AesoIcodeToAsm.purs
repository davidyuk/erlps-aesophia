module Aeso.Icode.To.Asm(erlps__convert__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__i__1 :: ErlangFun
erlps__i__1 [code_0] =
  BIF.do_remote_fun_call "Aeb.Opcodes" "erlps__mnemonic__1"
    [code_0]
erlps__i__1 [arg_2] = EXC.function_clause unit
erlps__i__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_stateful__1 :: ErlangFun
erlps__is_stateful__1 [(ErlangTuple [fname_0, _, _, _, _])] =
  let   
    lop_1 = BIF.do_remote_fun_call "Lists" "erlps__last__1" [fname_0]
  in let rop_3 = toErl "init"
  in BIF.erlang__op_neq [lop_1, rop_3]
erlps__is_stateful__1 [arg_4] = EXC.function_clause unit
erlps__is_stateful__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_public__1 :: ErlangFun
erlps__is_public__1 [(ErlangTuple [_name_0, attrs_1, _args_2,
                                   _body_3, _type_4])]
  =
  let
    op_arg_5 = BIF.lists__member__2 [ErlangAtom "private", attrs_1]
  in BIF.erlang__not__1 [op_arg_5]
erlps__is_public__1 [arg_8] = EXC.function_clause unit
erlps__is_public__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__convert__2 :: ErlangFun
erlps__convert__2 [(ErlangMap map_0), _options_4]
  | (DM.Just functions_3) <-
      (Map.lookup (ErlangAtom "functions") map_0)
  , (DM.Just statetype_2) <-
      (Map.lookup (ErlangAtom "state_type") map_0)
  , (DM.Just _contractname_1) <-
      (Map.lookup (ErlangAtom "contract_name") map_0) =
  let    tup_el_5 = toErl "%main"
  in let tup_el_9 = toErl "arg"
  in let tup_el_10 = toErl "_"
  in let head_8 = ErlangTuple [tup_el_9, tup_el_10]
  in let tup_el_16 = toErl "arg"
  in let tup_el_14 = ErlangTuple [ErlangAtom "var_ref", tup_el_16]
  in let
    tup_el_17 =
      flmap
        (\ lc_23 ->
           case lc_23 of
             fun_22@(ErlangTuple [fname_19, _, args_20, _, _typerep_21]) ->
               let cond_24 = erlps__is_public__1 [fun_22]
               in
                 case cond_24 of
                   (ErlangAtom "true") ->
                     let    head_30 = erlps__fun_hash__1 [fun_22]
                     in let tup_el_35 = erlps__make_args__1 [args_20]
                     in let
                       head_33 = ErlangTuple [ErlangAtom "tuple", tup_el_35]
                     in let
                       tup_el_27 =
                         ErlangTuple
                           [ErlangAtom "tuple",
                            ErlangCons head_30
                              (ErlangCons head_33 ErlangEmptyList)]
                     in let lop_44 = BIF.erlang__length__1 [args_20]
                     in let rop_46 = toErl 1
                     in let arg_43 = BIF.erlang__op_plus [lop_44, rop_46]
                     in let
                       head_41 = erlps__hack_return_address__2 [fun_22, arg_43]
                     in let
                       tup_el_51 = ErlangTuple [ErlangAtom "var_ref", fname_19]
                     in let tup_el_54 = erlps__make_args__1 [args_20]
                     in let
                       head_49 =
                         ErlangTuple
                           [ErlangAtom "funcall", tup_el_51, tup_el_54]
                     in let
                       arg_39 =
                         BIF.erlang__op_append
                           [ErlangCons head_41 ErlangEmptyList,
                            ErlangCons head_49 ErlangEmptyList]
                     in let tup_el_38 = erlps__icode_seq__1 [arg_39]
                     in let lcRet_26 = ErlangTuple [tup_el_27, tup_el_38]
                     in ErlangCons lcRet_26 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        functions_3
  in let
    tup_el_12 =
      ErlangTuple [ErlangAtom "switch", tup_el_14, tup_el_17]
  in let
    dispatchfun_58 =
      ErlangTuple
        [tup_el_5, ErlangEmptyList, ErlangCons head_8 ErlangEmptyList,
         tup_el_12, ErlangAtom "word"]
  in let
    newfunctions_63 =
      BIF.erlang__op_append
        [functions_3, ErlangCons dispatchfun_58 ErlangEmptyList]
  in let
    funs_76 =
      flmap
        (\ lc_70 ->
           case lc_70 of
             (ErlangTuple [name_65, _attrs_66, args_67, _body_68,
                           _type_69]) ->
               let    tup_el_73 = BIF.erlang__length__1 [args_67]
               in let tup_el_75 = BIF.erlang__make_ref__0 []
               in let lcRet_71 = ErlangTuple [name_65, tup_el_73, tup_el_75]
               in ErlangCons lcRet_71 ErlangEmptyList
             _ -> ErlangEmptyList)
        newfunctions_63
  in let stoplabel_77 = BIF.erlang__make_ref__0 []
  in let statefulstoplabel_78 = BIF.erlang__make_ref__0 []
  in let arg_80 = toErl "%main"
  in let mainfunction_81 = erlps__lookup_fun__2 [funs_76, arg_80]
  in let
    statetypevalue_83 =
      BIF.do_remote_fun_call "Aeso.Ast.To.Icode" "erlps__type_value__1"
        [statetype_2]
  in let head_84 = erlps__push_label__1 [statefulstoplabel_78]
  in let head_87 = erlps__push_label__1 [stoplabel_77]
  in let arg_91 = toErl 2
  in let head_90 = erlps__swap__1 [arg_91]
  in let head_93 = erlps__jump__1 [mainfunction_81]
  in let head_96 = erlps__jumpdest__1 [statefulstoplabel_78]
  in let
    head_99 =
      erlps__assemble_expr__4
        [funs_76, ErlangEmptyList, ErlangAtom "nontail",
         statetypevalue_83]
  in let arg_106 = toErl 1
  in let head_105 = erlps__swap__1 [arg_106]
  in let arg_109 = toErl 89
  in let head_108 = erlps__i__1 [arg_109]
  in let arg_112 = toErl 0
  in let head_111 = erlps__push__1 [arg_112]
  in let arg_115 = toErl 81
  in let head_114 = erlps__i__1 [arg_115]
  in let arg_118 = toErl 89
  in let head_117 = erlps__i__1 [arg_118]
  in let arg_121 = toErl 82
  in let head_120 = erlps__i__1 [arg_121]
  in let arg_124 = toErl 0
  in let head_123 = erlps__push__1 [arg_124]
  in let arg_127 = toErl 82
  in let head_126 = erlps__i__1 [arg_127]
  in let arg_130 = toErl 0
  in let head_129 = erlps__push__1 [arg_130]
  in let arg_133 = toErl 243
  in let head_132 = erlps__i__1 [arg_133]
  in let head_135 = erlps__jumpdest__1 [stoplabel_77]
  in let arg_139 = toErl 0
  in let head_138 = erlps__push__1 [arg_139]
  in let arg_142 = toErl 1
  in let head_141 = erlps__dup__1 [arg_142]
  in let arg_145 = toErl 82
  in let head_144 = erlps__i__1 [arg_145]
  in let arg_148 = toErl 0
  in let head_147 = erlps__push__1 [arg_148]
  in let arg_151 = toErl 243
  in let head_150 = erlps__i__1 [arg_151]
  in let
    code_165 =
      flmap
        (\ lc_159 ->
           case lc_159 of
             (ErlangTuple [name_155, _, args_156, body_157, _type_158]) ->
               let
                 lcRet_160 =
                   erlps__assemble_function__4
                     [funs_76, name_155, args_156, body_157]
               in ErlangCons lcRet_160 ErlangEmptyList
             _ -> ErlangEmptyList)
        newfunctions_63
  in
    erlps__resolve_references__1
      [ErlangCons
         (ErlangCons head_84
            (ErlangCons head_87
               (ErlangCons head_90
                  (ErlangCons head_93
                     (ErlangCons head_96
                        (ErlangCons head_99
                           (ErlangCons head_105
                              (ErlangCons head_108
                                 (ErlangCons head_111
                                    (ErlangCons head_114
                                       (ErlangCons head_117
                                          (ErlangCons head_120
                                             (ErlangCons head_123
                                                (ErlangCons head_126
                                                   (ErlangCons head_129
                                                      (ErlangCons head_132
                                                         (ErlangCons head_135
                                                            (ErlangCons head_138
                                                               (ErlangCons
                                                                  head_141
                                                                  (ErlangCons
                                                                     head_144
                                                                     (ErlangCons
                                                                        head_147
                                                                        (ErlangCons
                                                                           head_150
                                                                           ErlangEmptyList))))))))))))))))))))))
         (ErlangCons code_165 ErlangEmptyList)]
erlps__convert__2 [arg_171, arg_172] = EXC.function_clause unit
erlps__convert__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__gen_error__1 :: ErlangFun
erlps__gen_error__1 [error_0] =
  let
    arg_1 =
      ErlangTuple
        [ErlangAtom "code_errors", ErlangCons error_0 ErlangEmptyList]
  in BIF.erlang__error__1 [arg_1]
erlps__gen_error__1 [arg_6] = EXC.function_clause unit
erlps__gen_error__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_args__1 :: ErlangFun
erlps__make_args__1 [args_0] =
  let    arg_2 = toErl 1
  in let arg_3 = BIF.erlang__length__1 [args_0]
  in let
    lcSrc_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in
    flmap
      (\ lc_6 ->
         let    rop_13 = toErl 1
         in let lop_11 = BIF.erlang__op_minus [lc_6, rop_13]
         in let rop_14 = toErl 97
         in let head_10 = BIF.erlang__op_plus [lop_11, rop_14]
         in let
           lcRet_7 =
             ErlangTuple
               [ErlangAtom "var_ref", ErlangCons head_10 ErlangEmptyList]
         in ErlangCons lcRet_7 ErlangEmptyList)
      lcSrc_1
erlps__make_args__1 [arg_16] = EXC.function_clause unit
erlps__make_args__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fun_hash__1 :: ErlangFun
erlps__fun_hash__1 [(ErlangTuple [fname_0, _, args_1, _,
                                  typerep_2])]
  =
  let   
    tup_el_4 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [_, t_6]) -> ErlangCons t_6 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_1
  in let argtype_9 = ErlangTuple [ErlangAtom "tuple", tup_el_4]
  in let
    arg_11 =
      BIF.do_remote_fun_call "Lists" "erlps__last__1" [fname_0]
  in let arg_10 = BIF.erlang__list_to_binary__1 [arg_11]
  in let
    matchExpr_19 =
      BIF.do_remote_fun_call "Aeb.Aevm.Abi"
        "erlps__function_type_hash__3" [arg_10, argtype_9, typerep_2]
  in
    case matchExpr_19 of
      (ErlangBinary binSeg_15) | (ErlangInt size_16) <- (toErl 256)
                               , (BIN.Ok hash_18 bin_17) <-
                                   (BIN.chopInt binSeg_15 size_16 1 BIN.Big
                                      BIN.Unsigned)
                               , BIN.empty bin_17 ->
        ErlangTuple [ErlangAtom "integer", hash_18]
      _ -> EXC.badmatch matchExpr_19
erlps__fun_hash__1 [arg_22] = EXC.function_clause unit
erlps__fun_hash__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__hack_return_address__2 :: ErlangFun
erlps__hack_return_address__2 [fun_0, n_1] =
  let case_2 = erlps__is_stateful__1 [fun_0]
  in
    case case_2 of
      (ErlangAtom "true") ->
        let    arg_7 = toErl 89
        in let head_6 = erlps__i__1 [arg_7]
        in
          ErlangTuple
            [ErlangAtom "inline_asm", ErlangCons head_6 ErlangEmptyList]
      (ErlangAtom "false") ->
        let    rop_14 = toErl 2
        in let arg_12 = BIF.erlang__op_plus [n_1, rop_14]
        in let head_11 = erlps__dup__1 [arg_12]
        in let rop_19 = toErl 1
        in let arg_17 = BIF.erlang__op_plus [n_1, rop_19]
        in let head_16 = erlps__swap__1 [arg_17]
        in
          ErlangTuple
            [ErlangAtom "inline_asm",
             ErlangCons head_11 (ErlangCons head_16 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__hack_return_address__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__hack_return_address__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_function__4 :: ErlangFun
erlps__assemble_function__4 [funs_0, name_1, args_2, body_3] =
  let    arg_5 = erlps__lookup_fun__2 [funs_0, name_1]
  in let head_4 = erlps__jumpdest__1 [arg_5]
  in let
    arg_11 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [args_2]
  in let
    head_9 =
      erlps__assemble_expr__4
        [funs_0, arg_11, ErlangAtom "tail", body_3]
  in let arg_17 = BIF.erlang__length__1 [args_2]
  in let head_16 = erlps__pop_args__1 [arg_17]
  in let arg_21 = toErl 1
  in let head_20 = erlps__swap__1 [arg_21]
  in let arg_24 = toErl 86
  in let head_23 = erlps__i__1 [arg_24]
  in
    ErlangCons head_4
      (ErlangCons head_9
         (ErlangCons head_16
            (ErlangCons head_20 (ErlangCons head_23 ErlangEmptyList))))
erlps__assemble_function__4 [arg_26, arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__assemble_function__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_expr__4 :: ErlangFun
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "seq"),
                                       (ErlangCons e_3 (ErlangEmptyList))])]
  =
  erlps__assemble_expr__4 [funs_0, stack_1, tail_2, e_3]
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "seq"),
                                       (ErlangCons e_3 es_4)])]
  =
  let   
    head_5 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", e_3]
  in let arg_15 = ErlangTuple [ErlangAtom "seq", es_4]
  in let
    head_11 =
      erlps__assemble_expr__4 [funs_0, stack_1, tail_2, arg_15]
  in ErlangCons head_5 (ErlangCons head_11 ErlangEmptyList)
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangTuple [(ErlangAtom "inline_asm"), code_3])]
  =
  code_3
erlps__assemble_expr__4 [funs_0, stack_1, _tailposition_2,
                         (ErlangTuple [(ErlangAtom "var_ref"), id_3])]
  =
  let    arg_6 = toErl 1
  in let case_4 = BIF.lists__keymember__3 [id_3, arg_6, stack_1]
  in
    case case_4 of
      (ErlangAtom "true") ->
        let arg_8 = erlps__lookup_var__2 [id_3, stack_1]
        in erlps__dup__1 [arg_8]
      (ErlangAtom "false") ->
        let    eta_11 = BIF.erlang__make_ref__0 []
        in let continue_12 = BIF.erlang__make_ref__0 []
        in let arg_14 = toErl 89
        in let head_13 = erlps__i__1 [arg_14]
        in let head_16 = erlps__push_label__1 [eta_11]
        in let arg_20 = toErl 2
        in let head_19 = erlps__dup__1 [arg_20]
        in let arg_23 = toErl 82
        in let head_22 = erlps__i__1 [arg_23]
        in let head_25 = erlps__jump__1 [continue_12]
        in let head_28 = erlps__jumpdest__1 [eta_11]
        in let arg_32 = toErl 1
        in let head_31 = erlps__pop__1 [arg_32]
        in let arg_35 = erlps__lookup_fun__2 [funs_0, id_3]
        in let head_34 = erlps__jump__1 [arg_35]
        in let head_39 = erlps__jumpdest__1 [continue_12]
        in
          ErlangCons head_13
            (ErlangCons head_16
               (ErlangCons head_19
                  (ErlangCons head_22
                     (ErlangCons head_25
                        (ErlangCons head_28
                           (ErlangCons head_31
                              (ErlangCons head_34
                                 (ErlangCons head_39 ErlangEmptyList))))))))
      something_else -> EXC.case_clause something_else
erlps__assemble_expr__4 [_, _, _,
                         (ErlangTuple [(ErlangAtom "missing_field"), format_0,
                                       args_1])]
  =
  let
    _ =
      BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
        [format_0, args_1]
  in erlps__gen_error__1 [ErlangAtom "missing_field"]
erlps__assemble_expr__4 [_funs_0, _stack_1, _,
                         (ErlangTuple [(ErlangAtom "integer"), n_2])]
  =
  erlps__push__1 [n_2]
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "tuple"), cpts_2])]
  =
  let
    case_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [cpts_2]
  in
    case case_3 of
      (ErlangEmptyList) ->
        let arg_5 = toErl 89
        in erlps__i__1 [arg_5]
      (ErlangCons last_6 rest_7) ->
        let   
          head_8 =
            erlps__assemble_expr__4
              [funs_0, stack_1, ErlangAtom "nontail", last_6]
        in let arg_15 = toErl 89
        in let head_14 = erlps__i__1 [arg_15]
        in let lop_19 = toErl 32
        in let lop_21 = BIF.erlang__length__1 [cpts_2]
        in let rop_23 = toErl 1
        in let rop_20 = BIF.erlang__op_minus [lop_21, rop_23]
        in let arg_18 = BIF.erlang__op_mult [lop_19, rop_20]
        in let head_17 = erlps__push__1 [arg_18]
        in let arg_26 = toErl 1
        in let head_25 = erlps__i__1 [arg_26]
        in let arg_29 = toErl 1
        in let head_28 = erlps__swap__1 [arg_29]
        in let arg_32 = toErl 2
        in let head_31 = erlps__dup__1 [arg_32]
        in let arg_35 = toErl 82
        in let head_34 = erlps__i__1 [arg_35]
        in let
          head_37 =
            flmap
              (\ lc_40 ->
                 let    arg_43 = toErl 32
                 in let head_42 = erlps__push__1 [arg_43]
                 in let arg_46 = toErl 1
                 in let head_45 = erlps__swap__1 [arg_46]
                 in let arg_49 = toErl 3
                 in let head_48 = erlps__i__1 [arg_49]
                 in let
                   head_51 =
                     erlps__assemble_expr__4
                       [funs_0, ErlangCons (ErlangAtom "pointer") stack_1,
                        ErlangAtom "nontail", lc_40]
                 in let arg_60 = toErl 2
                 in let head_59 = erlps__dup__1 [arg_60]
                 in let arg_63 = toErl 82
                 in let head_62 = erlps__i__1 [arg_63]
                 in
                   ErlangCons
                     (ErlangCons head_42
                        (ErlangCons head_45
                           (ErlangCons head_48
                              (ErlangCons head_51
                                 (ErlangCons head_59
                                    (ErlangCons head_62 ErlangEmptyList))))))
                     ErlangEmptyList)
              rest_7
        in
          ErlangCons head_8
            (ErlangCons head_14
               (ErlangCons head_17
                  (ErlangCons head_25
                     (ErlangCons head_28
                        (ErlangCons head_31
                           (ErlangCons head_34
                              (ErlangCons head_37 ErlangEmptyList)))))))
      something_else -> EXC.case_clause something_else
erlps__assemble_expr__4 [_funs_0, _stack_1, _,
                         (ErlangTuple [(ErlangAtom "list"), (ErlangEmptyList)])]
  =
  let    arg_3 = toErl 0
  in let head_2 = erlps__push__1 [arg_3]
  in let arg_6 = toErl 25
  in let head_5 = erlps__i__1 [arg_6]
  in ErlangCons head_2 (ErlangCons head_5 ErlangEmptyList)
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "list"),
                                       (ErlangCons a_2 b_3)])]
  =
  let    head_12 = ErlangTuple [ErlangAtom "list", b_3]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "tuple",
         ErlangCons a_2 (ErlangCons head_12 ErlangEmptyList)]
  in
    erlps__assemble_expr__4
      [funs_0, stack_1, ErlangAtom "nontail", arg_7]
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "unop"), (ErlangAtom "!"),
                                       a_2])]
  =
  case a_2 of
    (ErlangTuple [(ErlangAtom "binop"), logical_4, _,
                  _]) | ((ErlangAtom "true") ==
                           (falsifyErrors
                              (\ _ ->
                                 let
                                   lop_5 =
                                     BIF.erlang__op_eq
                                       [logical_4, ErlangAtom "&&"]
                                 in
                                   case lop_5 of
                                     (ErlangAtom "true") -> ErlangAtom "true"
                                     (ErlangAtom "false") ->
                                       BIF.erlang__op_eq
                                         [logical_4, ErlangAtom "||"]
                                     _ -> EXC.badarg1 lop_5))) ->
      let    tup_el_18 = toErl 0
      in let tup_el_16 = ErlangTuple [ErlangAtom "integer", tup_el_18]
      in let tup_el_21 = toErl 1
      in let tup_el_19 = ErlangTuple [ErlangAtom "integer", tup_el_21]
      in let
        arg_13 =
          ErlangTuple [ErlangAtom "ifte", a_2, tup_el_16, tup_el_19]
      in
        erlps__assemble_expr__4
          [funs_0, stack_1, ErlangAtom "nontail", arg_13]
    _ ->
      let   
        head_22 =
          erlps__assemble_expr__4
            [funs_0, stack_1, ErlangAtom "nontail", a_2]
      in let arg_29 = toErl 21
      in let head_28 = erlps__i__1 [arg_29]
      in ErlangCons head_22 (ErlangCons head_28 ErlangEmptyList)
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "event"), topics_2,
                                       payload_3])]
  =
  let   
    arg_7 =
      BIF.erlang__op_append
        [topics_2, ErlangCons payload_3 ErlangEmptyList]
  in let head_4 = erlps__assemble_exprs__3 [funs_0, stack_1, arg_7]
  in let case_14 = BIF.erlang__length__1 [topics_2]
  in let
    head_13 =
      case case_14 of
        (ErlangInt num_16) | ((ErlangInt num_16) == (toErl 0)) ->
          let arg_17 = toErl 160
          in erlps__i__1 [arg_17]
        (ErlangInt num_18) | ((ErlangInt num_18) == (toErl 1)) ->
          let arg_19 = toErl 161
          in erlps__i__1 [arg_19]
        (ErlangInt num_20) | ((ErlangInt num_20) == (toErl 2)) ->
          let arg_21 = toErl 162
          in erlps__i__1 [arg_21]
        (ErlangInt num_22) | ((ErlangInt num_22) == (toErl 3)) ->
          let arg_23 = toErl 163
          in erlps__i__1 [arg_23]
        (ErlangInt num_24) | ((ErlangInt num_24) == (toErl 4)) ->
          let arg_25 = toErl 164
          in erlps__i__1 [arg_25]
        something_else -> EXC.case_clause something_else
  in let arg_28 = toErl 89
  in let head_27 = erlps__i__1 [arg_28]
  in
    ErlangCons head_4
      (ErlangCons head_13 (ErlangCons head_27 ErlangEmptyList))
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "unop"), op_2, a_3])]
  =
  let   
    head_4 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", a_3]
  in let head_10 = erlps__assemble_prefix__1 [op_2]
  in ErlangCons head_4 (ErlangCons head_10 ErlangEmptyList)
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "binop"), (ErlangAtom "&&"),
                                       a_3, b_4])]
  =
  let    tup_el_14 = toErl 0
  in let tup_el_12 = ErlangTuple [ErlangAtom "integer", tup_el_14]
  in let
    arg_8 = ErlangTuple [ErlangAtom "ifte", a_3, b_4, tup_el_12]
  in erlps__assemble_expr__4 [funs_0, stack_1, tail_2, arg_8]
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "binop"), (ErlangAtom "||"),
                                       a_3, b_4])]
  =
  let    tup_el_13 = toErl 1
  in let tup_el_11 = ErlangTuple [ErlangAtom "integer", tup_el_13]
  in let
    arg_8 = ErlangTuple [ErlangAtom "ifte", a_3, tup_el_11, b_4]
  in erlps__assemble_expr__4 [funs_0, stack_1, tail_2, arg_8]
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "binop"), (ErlangAtom "::"),
                                       a_3, b_4])]
  =
  let
    arg_8 =
      ErlangTuple
        [ErlangAtom "tuple",
         ErlangCons a_3 (ErlangCons b_4 ErlangEmptyList)]
  in erlps__assemble_expr__4 [funs_0, stack_1, tail_2, arg_8]
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "binop"), op_2, a_3, b_4])]
  =
  let   
    head_5 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", b_4]
  in let
    head_11 =
      erlps__assemble_expr__4
        [funs_0, ErlangCons (ErlangAtom "dummy") stack_1,
         ErlangAtom "nontail", a_3]
  in let head_19 = erlps__assemble_infix__1 [op_2]
  in
    ErlangCons head_5
      (ErlangCons head_11 (ErlangCons head_19 ErlangEmptyList))
erlps__assemble_expr__4 [funs_0, stack_1, _,
                         (ErlangTuple [(ErlangAtom "lambda"), args_2, body_3])]
  =
  let    function_4 = BIF.erlang__make_ref__0 []
  in let funbody_5 = BIF.erlang__make_ref__0 []
  in let continue_6 = BIF.erlang__make_ref__0 []
  in let nomatch_7 = BIF.erlang__make_ref__0 []
  in let arg_8 = ErlangTuple [ErlangAtom "lambda", args_2, body_3]
  in let freevars_12 = erlps__free_vars__1 [arg_8]
  in let tup_el_20 = toErl "_"
  in let head_18 = ErlangTuple [ErlangAtom "var_ref", tup_el_20]
  in let
    arg_15 =
      ErlangTuple [ErlangAtom "tuple", ErlangCons head_18 freevars_12]
  in let
    matchExpr_24 =
      erlps__assemble_pattern__3 [funbody_5, nomatch_7, arg_15]
  in
    case matchExpr_24 of
      (ErlangTuple [newvars_22, matchingcode_23]) ->
        let   
          arg_29 =
            flmap
              (\ lc_32 ->
                 let   
                   tup_el_34 =
                     case lc_32 of
                       (ErlangTuple arr_37) | (DM.Just field_36) <-
                                                ((arr_37 DA.!! 1)) ->
                         field_36
                       _ -> EXC.badrecord (ErlangAtom "arg")
                 in let
                   tup_el_38 =
                     case lc_32 of
                       (ErlangTuple arr_41) | (DM.Just field_40) <-
                                                ((arr_41 DA.!! 2)) ->
                         field_40
                       _ -> EXC.badrecord (ErlangAtom "arg")
                 in let lcRet_33 = ErlangTuple [tup_el_34, tup_el_38]
                 in ErlangCons lcRet_33 ErlangEmptyList)
              args_2
        in let
          rop_28 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_29]
        in let arg_26 = BIF.erlang__op_append [newvars_22, rop_28]
        in let
          bodycode_44 =
            erlps__assemble_expr__4
              [funs_0, arg_26, ErlangAtom "tail", body_3]
        in let head_52 = ErlangTuple [ErlangAtom "label", function_4]
        in let
          arg_49 =
            ErlangTuple [ErlangAtom "tuple", ErlangCons head_52 freevars_12]
        in let
          head_45 =
            erlps__assemble_expr__4
              [funs_0, stack_1, ErlangAtom "nontail", arg_49]
        in let head_57 = erlps__jump__1 [continue_6]
        in let head_60 = erlps__jumpdest__1 [function_4]
        in let head_65 = erlps__jumpdest__1 [funbody_5]
        in let lop_72 = BIF.erlang__length__1 [args_2]
        in let rop_74 = BIF.erlang__length__1 [newvars_22]
        in let arg_71 = BIF.erlang__op_plus [lop_72, rop_74]
        in let head_70 = erlps__pop_args__1 [arg_71]
        in let arg_78 = toErl 1
        in let head_77 = erlps__swap__1 [arg_78]
        in let arg_81 = toErl 86
        in let head_80 = erlps__i__1 [arg_81]
        in let head_83 = erlps__jumpdest__1 [nomatch_7]
        in let arg_87 = toErl 0
        in let head_86 = erlps__push__1 [arg_87]
        in let arg_90 = toErl 25
        in let head_89 = erlps__i__1 [arg_90]
        in let arg_93 = toErl 81
        in let head_92 = erlps__i__1 [arg_93]
        in let arg_96 = toErl 0
        in let head_95 = erlps__i__1 [arg_96]
        in let head_98 = erlps__jumpdest__1 [continue_6]
        in
          ErlangCons head_45
            (ErlangCons head_57
               (ErlangCons head_60
                  (ErlangCons matchingcode_23
                     (ErlangCons head_65
                        (ErlangCons bodycode_44
                           (ErlangCons head_70
                              (ErlangCons head_77
                                 (ErlangCons head_80
                                    (ErlangCons head_83
                                       (ErlangCons head_86
                                          (ErlangCons head_89
                                             (ErlangCons head_92
                                                (ErlangCons head_95
                                                   (ErlangCons head_98
                                                      ErlangEmptyList))))))))))))))
      _ -> EXC.badmatch matchExpr_24
erlps__assemble_expr__4 [_, _, _,
                         (ErlangTuple [(ErlangAtom "label"), label_0])]
  =
  erlps__push_label__1 [label_0]
erlps__assemble_expr__4 [funs_0, stack_1, (ErlangAtom "nontail"),
                         (ErlangTuple [(ErlangAtom "funcall"), fun_2, args_3])]
  =
  let return_4 = BIF.erlang__make_ref__0 []
  in
    case args_3 of
      (ErlangEmptyList) ->
        let    head_6 = erlps__push_label__1 [return_4]
        in let
          head_9 =
            erlps__assemble_function__3
              [funs_0, ErlangCons (ErlangAtom "return_address") stack_1, fun_2]
        in let arg_17 = toErl 86
        in let head_16 = erlps__i__1 [arg_17]
        in let head_19 = erlps__jumpdest__1 [return_4]
        in
          ErlangCons head_6
            (ErlangCons head_9
               (ErlangCons head_16 (ErlangCons head_19 ErlangEmptyList)))
      _ ->
        let    lop_23 = BIF.erlang__length__1 [args_3]
        in let rop_25 = toErl 1
        in let arg_22 = BIF.erlang__op_minus [lop_23, rop_25]
        in let
          matchExpr_29 =
            BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_22, args_3]
        in
          case matchExpr_29 of
            (ErlangTuple [init_27,
                          (ErlangCons last_28 (ErlangEmptyList))]) ->
              let   
                head_30 =
                  erlps__assemble_exprs__3
                    [funs_0, stack_1, ErlangCons last_28 init_27]
              in let head_37 = erlps__push_label__1 [return_4]
              in let arg_41 = BIF.erlang__length__1 [args_3]
              in let head_40 = erlps__swap__1 [arg_41]
              in let
                lop_47 =
                  flmap
                    (\ lc_49 ->
                       case lc_49 of
                         _ -> ErlangCons (ErlangAtom "dummy") ErlangEmptyList)
                    args_3
              in let
                arg_46 =
                  BIF.erlang__op_append
                    [lop_47, ErlangCons (ErlangAtom "return_address") stack_1]
              in let
                head_44 = erlps__assemble_function__3 [funs_0, arg_46, fun_2]
              in let arg_57 = toErl 86
              in let head_56 = erlps__i__1 [arg_57]
              in let head_59 = erlps__jumpdest__1 [return_4]
              in
                ErlangCons head_30
                  (ErlangCons head_37
                     (ErlangCons head_40
                        (ErlangCons head_44
                           (ErlangCons head_56
                              (ErlangCons head_59 ErlangEmptyList)))))
            _ -> EXC.badmatch matchExpr_29
erlps__assemble_expr__4 [funs_0, stack_1, (ErlangAtom "tail"),
                         (ErlangTuple [(ErlangAtom "funcall"), fun_2, args_3])]
  =
  let    istoplevel_6 = erlps__is_top_level_fun__2 [stack_1, fun_2]
  in let cond_9 = BIF.erlang__not__1 [istoplevel_6]
  in let
    rop_8 =
      case cond_9 of
        (ErlangAtom "true") -> ErlangCons fun_2 ErlangEmptyList
        _ -> ErlangEmptyList
  in let argsandfun_12 = BIF.erlang__op_append [args_3, rop_8]
  in let
    computeargsandfun_16 =
      erlps__assemble_exprs__3 [funs_0, stack_1, argsandfun_12]
  in let arg_18 = BIF.erlang__length__1 [argsandfun_12]
  in let arg_20 = toErl 1
  in let op_arg_22 = toErl 1
  in let arg_21 = BIF.erlang__op_neg [op_arg_22]
  in let
    lop_17 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__3"
        [arg_18, arg_20, arg_21]
  in let
    rop_23 =
      flmap
        (\ lc_25 ->
           case lc_25 of
             _ -> ErlangCons (ErlangAtom "discard") ErlangEmptyList)
        stack_1
  in let shufflespec_27 = BIF.erlang__op_append [lop_17, rop_23]
  in let shuffle_29 = erlps__shuffle_stack__1 [shufflespec_27]
  in let
    head_34 =
      case ErlangAtom "true" of
        _ | ((ErlangAtom "true") ==
               (falsifyErrors (\ _ -> istoplevel_6))) ->
          erlps__assemble_function__3 [funs_0, ErlangEmptyList, fun_2]
        _ ->
          let    arg_39 = toErl 1
          in let head_38 = erlps__dup__1 [arg_39]
          in let arg_42 = toErl 81
          in let head_41 = erlps__i__1 [arg_42]
          in ErlangCons head_38 (ErlangCons head_41 ErlangEmptyList)
  in let arg_46 = toErl 86
  in let head_45 = erlps__i__1 [arg_46]
  in
    ErlangCons computeargsandfun_16
      (ErlangCons shuffle_29
         (ErlangCons head_34 (ErlangCons head_45 ErlangEmptyList)))
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "ifte"), decision_3, then_4,
                                       else_5])]
  =
  let    close_6 = BIF.erlang__make_ref__0 []
  in let thenl_7 = BIF.erlang__make_ref__0 []
  in let elsel_8 = BIF.erlang__make_ref__0 []
  in let
    head_9 =
      erlps__assemble_decision__5
        [funs_0, stack_1, decision_3, thenl_7, elsel_8]
  in let head_16 = erlps__jumpdest__1 [elsel_8]
  in let
    head_19 =
      erlps__assemble_expr__4 [funs_0, stack_1, tail_2, else_5]
  in let head_25 = erlps__jump__1 [close_6]
  in let head_28 = erlps__jumpdest__1 [thenl_7]
  in let
    head_31 =
      erlps__assemble_expr__4 [funs_0, stack_1, tail_2, then_4]
  in let head_37 = erlps__jumpdest__1 [close_6]
  in
    ErlangCons head_9
      (ErlangCons head_16
         (ErlangCons head_19
            (ErlangCons head_25
               (ErlangCons head_28
                  (ErlangCons head_31 (ErlangCons head_37 ErlangEmptyList))))))
erlps__assemble_expr__4 [funs_0, stack_1, tail_2,
                         (ErlangTuple [(ErlangAtom "switch"), a_3, cases_4])]
  =
  let    close_5 = BIF.erlang__make_ref__0 []
  in let
    head_6 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", a_3]
  in let
    head_12 =
      erlps__assemble_cases__5
        [funs_0, stack_1, tail_2, close_5, cases_4]
  in let head_19 = ErlangTuple [ErlangAtom "JUMPDEST", close_5]
  in
    ErlangCons head_6
      (ErlangCons head_12 (ErlangCons head_19 ErlangEmptyList))
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_state")]
  =
  let    arg_4 = toErl 0
  in let head_3 = erlps__push__1 [arg_4]
  in let arg_7 = toErl 81
  in let head_6 = erlps__i__1 [arg_7]
  in ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)
erlps__assemble_expr__4 [funs_0, stack_1, _tail_2,
                         (ErlangTuple [(ErlangAtom "prim_put"), state_3])]
  =
  let   
    head_4 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", state_3]
  in let arg_11 = toErl 0
  in let head_10 = erlps__push__1 [arg_11]
  in let arg_14 = toErl 82
  in let head_13 = erlps__i__1 [arg_14]
  in let arg_17 = toErl 89
  in let head_16 = erlps__i__1 [arg_17]
  in
    ErlangCons head_4
      (ErlangCons head_10
         (ErlangCons head_13 (ErlangCons head_16 ErlangEmptyList)))
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_contract_address")]
  =
  let    arg_4 = toErl 48
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_contract_creator")]
  =
  let    arg_4 = toErl 47
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_call_origin")]
  =
  let    arg_4 = toErl 50
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_caller")]
  =
  let    arg_4 = toErl 51
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_call_value")]
  =
  let    arg_4 = toErl 52
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_gas_price")]
  =
  let    arg_4 = toErl 58
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_gas_left")]
  =
  let    arg_4 = toErl 90
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_coinbase")]
  =
  let    arg_4 = toErl 65
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_timestamp")]
  =
  let    arg_4 = toErl 66
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_block_height")]
  =
  let    arg_4 = toErl 67
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_difficulty")]
  =
  let    arg_4 = toErl 68
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [_funs_0, _stack_1, _tail_2,
                         (ErlangAtom "prim_gas_limit")]
  =
  let    arg_4 = toErl 69
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__assemble_expr__4 [funs_0, stack_1, _tail_2,
                         (ErlangTuple [(ErlangAtom "prim_balance"), addr_3])]
  =
  let   
    head_4 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", addr_3]
  in let arg_11 = toErl 49
  in let head_10 = erlps__i__1 [arg_11]
  in ErlangCons head_4 (ErlangCons head_10 ErlangEmptyList)
erlps__assemble_expr__4 [funs_0, stack_1, _tail_2,
                         (ErlangTuple [(ErlangAtom "prim_block_hash"),
                                       height_3])]
  =
  let   
    head_4 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", height_3]
  in let arg_11 = toErl 64
  in let head_10 = erlps__i__1 [arg_11]
  in ErlangCons head_4 (ErlangCons head_10 ErlangEmptyList)
erlps__assemble_expr__4 [funs_0, stack_1, _tail_2,
                         (ErlangTuple [(ErlangAtom "prim_call_contract"), gas_3,
                                       to_4, value_5, arg_6, typehash_7])]
  =
  let    tup_el_14 = toErl 0
  in let head_12 = ErlangTuple [ErlangAtom "integer", tup_el_14]
  in let tup_el_18 = toErl 0
  in let head_16 = ErlangTuple [ErlangAtom "integer", tup_el_18]
  in let
    head_8 =
      erlps__assemble_exprs__3
        [funs_0, stack_1,
         ErlangCons head_12
           (ErlangCons head_16
              (ErlangCons typehash_7
                 (ErlangCons arg_6
                    (ErlangCons value_5
                       (ErlangCons to_4 (ErlangCons gas_3 ErlangEmptyList))))))]
  in let arg_32 = toErl 241
  in let head_31 = erlps__i__1 [arg_32]
  in ErlangCons head_8 (ErlangCons head_31 ErlangEmptyList)
erlps__assemble_expr__4 [arg_34, arg_35, arg_36, arg_37] =
  EXC.function_clause unit
erlps__assemble_expr__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_exprs__3 :: ErlangFun
erlps__assemble_exprs__3 [_funs_0, _stack_1, (ErlangEmptyList)] =
  ErlangEmptyList
erlps__assemble_exprs__3 [funs_0, stack_1, (ErlangCons e_2 es_3)]
  =
  let   
    head_4 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", e_2]
  in let
    head_10 =
      erlps__assemble_exprs__3
        [funs_0, ErlangCons (ErlangAtom "dummy") stack_1, es_3]
  in ErlangCons head_4 (ErlangCons head_10 ErlangEmptyList)
erlps__assemble_exprs__3 [arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__assemble_exprs__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_decision__5 :: ErlangFun
erlps__assemble_decision__5 [funs_0, stack_1,
                             (ErlangTuple [(ErlangAtom "binop"),
                                           (ErlangAtom "&&"), a_2, b_3]),
                             then_4, else_5]
  =
  let    label_6 = BIF.erlang__make_ref__0 []
  in let
    head_7 =
      erlps__assemble_decision__5
        [funs_0, stack_1, a_2, label_6, else_5]
  in let head_14 = erlps__jumpdest__1 [label_6]
  in let
    head_17 =
      erlps__assemble_decision__5
        [funs_0, stack_1, b_3, then_4, else_5]
  in
    ErlangCons head_7
      (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))
erlps__assemble_decision__5 [funs_0, stack_1,
                             (ErlangTuple [(ErlangAtom "binop"),
                                           (ErlangAtom "||"), a_2, b_3]),
                             then_4, else_5]
  =
  let    label_6 = BIF.erlang__make_ref__0 []
  in let
    head_7 =
      erlps__assemble_decision__5
        [funs_0, stack_1, a_2, then_4, label_6]
  in let head_14 = erlps__jumpdest__1 [label_6]
  in let
    head_17 =
      erlps__assemble_decision__5
        [funs_0, stack_1, b_3, then_4, else_5]
  in
    ErlangCons head_7
      (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))
erlps__assemble_decision__5 [funs_0, stack_1,
                             (ErlangTuple [(ErlangAtom "unop"),
                                           (ErlangAtom "!"), a_2]),
                             then_3, else_4]
  =
  erlps__assemble_decision__5
    [funs_0, stack_1, a_2, else_4, then_3]
erlps__assemble_decision__5 [funs_0, stack_1,
                             (ErlangTuple [(ErlangAtom "ifte"), a_2, b_3, c_4]),
                             then_5, else_6]
  =
  let    truel_7 = BIF.erlang__make_ref__0 []
  in let falsel_8 = BIF.erlang__make_ref__0 []
  in let
    head_9 =
      erlps__assemble_decision__5
        [funs_0, stack_1, a_2, truel_7, falsel_8]
  in let head_16 = erlps__jumpdest__1 [truel_7]
  in let
    head_19 =
      erlps__assemble_decision__5
        [funs_0, stack_1, b_3, then_5, else_6]
  in let head_26 = erlps__jumpdest__1 [falsel_8]
  in let
    head_29 =
      erlps__assemble_decision__5
        [funs_0, stack_1, c_4, then_5, else_6]
  in
    ErlangCons head_9
      (ErlangCons head_16
         (ErlangCons head_19
            (ErlangCons head_26 (ErlangCons head_29 ErlangEmptyList))))
erlps__assemble_decision__5 [funs_0, stack_1, decision_2, then_3,
                             else_4]
  =
  let   
    head_5 =
      erlps__assemble_expr__4
        [funs_0, stack_1, ErlangAtom "nontail", decision_2]
  in let head_11 = erlps__jump_if__1 [then_3]
  in let head_14 = erlps__jump__1 [else_4]
  in
    ErlangCons head_5
      (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))
erlps__assemble_decision__5 [arg_17, arg_18, arg_19, arg_20,
                             arg_21]
  =
  EXC.function_clause unit
erlps__assemble_decision__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_cases__5 :: ErlangFun
erlps__assemble_cases__5 [_funs_0, _stack_1, _tail_2, _close_3,
                          (ErlangEmptyList)]
  =
  let    arg_5 = toErl 1
  in let head_4 = erlps__push__1 [arg_5]
  in let arg_8 = toErl 25
  in let head_7 = erlps__i__1 [arg_8]
  in let arg_11 = toErl 81
  in let head_10 = erlps__i__1 [arg_11]
  in let arg_14 = toErl 0
  in let head_13 = erlps__i__1 [arg_14]
  in
    ErlangCons head_4
      (ErlangCons head_7
         (ErlangCons head_10 (ErlangCons head_13 ErlangEmptyList)))
erlps__assemble_cases__5 [funs_0, stack_1, tail_2, close_3,
                          (ErlangCons (ErlangTuple [pattern_4,
                                                    body_5]) cases_6)]
  =
  let    succeed_7 = BIF.erlang__make_ref__0 []
  in let fail_8 = BIF.erlang__make_ref__0 []
  in let
    matchExpr_14 =
      erlps__assemble_pattern__3 [succeed_7, fail_8, pattern_4]
  in
    case matchExpr_14 of
      (ErlangTuple [newvars_12, matchingcode_13]) ->
        let    cond_16 = BIF.erlang__op_neq [cases_6, ErlangEmptyList]
        in let
          head_15 =
            case cond_16 of
              (ErlangAtom "true") ->
                let    arg_20 = toErl 1
                in let lcRet_19 = erlps__dup__1 [arg_20]
                in ErlangCons lcRet_19 ErlangEmptyList
              _ -> ErlangEmptyList
        in let head_24 = erlps__jumpdest__1 [succeed_7]
        in let cond_28 = BIF.erlang__op_neq [cases_6, ErlangEmptyList]
        in let
          head_27 =
            case cond_28 of
              (ErlangAtom "true") ->
                let
                  lcRet_31 =
                    case newvars_12 of
                      (ErlangEmptyList) ->
                        let arg_33 = toErl 1
                        in erlps__pop__1 [arg_33]
                      (ErlangCons _ (ErlangEmptyList)) ->
                        let arg_34 = toErl 1
                        in erlps__pop_args__1 [arg_34]
                      _ ->
                        let    arg_36 = BIF.erlang__length__1 [newvars_12]
                        in let head_35 = erlps__swap__1 [arg_36]
                        in let arg_40 = toErl 1
                        in let head_39 = erlps__pop__1 [arg_40]
                        in
                          ErlangCons head_35
                            (ErlangCons head_39 ErlangEmptyList)
                in ErlangCons lcRet_31 ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          lop_46 =
            case cases_6 of
              (ErlangEmptyList) -> newvars_12
              _ -> erlps__reorder_vars__1 [newvars_12]
        in let arg_45 = BIF.erlang__op_append [lop_46, stack_1]
        in let
          head_43 =
            erlps__assemble_expr__4 [funs_0, arg_45, tail_2, body_5]
        in let arg_54 = BIF.erlang__length__1 [newvars_12]
        in let head_53 = erlps__pop_args__1 [arg_54]
        in let head_57 = erlps__jump__1 [close_3]
        in let head_60 = erlps__jumpdest__1 [fail_8]
        in let
          head_63 =
            erlps__assemble_cases__5
              [funs_0, stack_1, tail_2, close_3, cases_6]
        in
          ErlangCons head_15
            (ErlangCons matchingcode_13
               (ErlangCons head_24
                  (ErlangCons head_27
                     (ErlangCons head_43
                        (ErlangCons head_53
                           (ErlangCons head_57
                              (ErlangCons head_60
                                 (ErlangCons head_63 ErlangEmptyList))))))))
      _ -> EXC.badmatch matchExpr_14
erlps__assemble_cases__5 [arg_70, arg_71, arg_72, arg_73, arg_74]
  =
  EXC.function_clause unit
erlps__assemble_cases__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_pattern__3 :: ErlangFun
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "integer"), n_2])]
  =
  let    head_5 = erlps__push__1 [n_2]
  in let arg_9 = toErl 20
  in let head_8 = erlps__i__1 [arg_9]
  in let head_11 = erlps__jump_if__1 [succeed_0]
  in let head_14 = erlps__jump__1 [fail_1]
  in
    ErlangTuple
      [ErlangEmptyList,
       ErlangCons head_5
         (ErlangCons head_8
            (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList)))]
erlps__assemble_pattern__3 [succeed_0, _fail_1,
                            (ErlangTuple [(ErlangAtom "var_ref"),
                                          (ErlangCons (ErlangInt num_2) (ErlangEmptyList))])]
  | ((ErlangInt num_2) == (toErl 95)) =
  let    arg_6 = toErl 80
  in let head_5 = erlps__i__1 [arg_6]
  in let head_8 = erlps__jump__1 [succeed_0]
  in
    ErlangTuple
      [ErlangEmptyList,
       ErlangCons head_5 (ErlangCons head_8 ErlangEmptyList)]
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "missing_field"), _, _])]
  =
  let    tup_el_6 = toErl "_"
  in let arg_4 = ErlangTuple [ErlangAtom "var_ref", tup_el_6]
  in erlps__assemble_pattern__3 [succeed_0, fail_1, arg_4]
erlps__assemble_pattern__3 [succeed_0, _fail_1,
                            (ErlangTuple [(ErlangAtom "var_ref"), id_2])]
  =
  let    tup_el_6 = toErl "_"
  in let head_4 = ErlangTuple [id_2, tup_el_6]
  in let tup_el_8 = erlps__jump__1 [succeed_0]
  in ErlangTuple [ErlangCons head_4 ErlangEmptyList, tup_el_8]
erlps__assemble_pattern__3 [succeed_0, _fail_1,
                            (ErlangTuple [(ErlangAtom "tuple"),
                                          (ErlangEmptyList)])]
  =
  let    arg_5 = toErl 1
  in let head_4 = erlps__pop__1 [arg_5]
  in let head_7 = erlps__jump__1 [succeed_0]
  in
    ErlangTuple
      [ErlangEmptyList,
       ErlangCons head_4 (ErlangCons head_7 ErlangEmptyList)]
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "tuple"),
                                          (ErlangCons a_2 (ErlangEmptyList))])]
  =
  let
    matchExpr_8 = erlps__assemble_pattern__3 [succeed_0, fail_1, a_2]
  in
    case matchExpr_8 of
      (ErlangTuple [avars_6, acode_7]) ->
        let    arg_12 = toErl 81
        in let head_11 = erlps__i__1 [arg_12]
        in
          ErlangTuple
            [avars_6,
             ErlangCons head_11 (ErlangCons acode_7 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_8
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "tuple"),
                                          (ErlangCons a_2 b_3)])]
  =
  let    continue_4 = BIF.erlang__make_ref__0 []
  in let pop1fail_5 = BIF.erlang__make_ref__0 []
  in let popnfail_6 = BIF.erlang__make_ref__0 []
  in let
    matchExpr_12 =
      erlps__assemble_pattern__3 [continue_4, pop1fail_5, a_2]
  in
    case matchExpr_12 of
      (ErlangTuple [avars_10, acode_11]) ->
        let    arg_15 = ErlangTuple [ErlangAtom "tuple", b_3]
        in let
          matchExpr_20 =
            erlps__assemble_pattern__3 [succeed_0, popnfail_6, arg_15]
        in
          case matchExpr_20 of
            (ErlangTuple [bvars_18, bcode_19]) ->
              let    rop_23 = erlps__reorder_vars__1 [avars_10]
              in let tup_el_21 = BIF.erlang__op_append [bvars_18, rop_23]
              in let arg_27 = toErl 1
              in let head_26 = erlps__dup__1 [arg_27]
              in let arg_30 = toErl 81
              in let head_29 = erlps__i__1 [arg_30]
              in let head_34 = erlps__jumpdest__1 [continue_4]
              in let arg_38 = BIF.erlang__length__1 [avars_10]
              in let head_37 = erlps__swap__1 [arg_38]
              in let arg_42 = toErl 32
              in let head_41 = erlps__push__1 [arg_42]
              in let arg_45 = toErl 1
              in let head_44 = erlps__i__1 [arg_45]
              in let
                head_49 =
                  case avars_10 of
                    (ErlangEmptyList) ->
                      let    head_51 = erlps__jumpdest__1 [pop1fail_5]
                      in let arg_55 = toErl 1
                      in let head_54 = erlps__pop__1 [arg_55]
                      in let head_57 = erlps__jumpdest__1 [popnfail_6]
                      in let head_60 = erlps__jump__1 [fail_1]
                      in
                        ErlangCons head_51
                          (ErlangCons head_54
                             (ErlangCons head_57
                                (ErlangCons head_60 ErlangEmptyList)))
                    _ ->
                      let   
                        head_63 =
                          ErlangTuple [ErlangAtom "JUMPDEST", popnfail_6]
                      in let lop_69 = BIF.erlang__length__1 [avars_10]
                      in let rop_71 = toErl 1
                      in let arg_68 = BIF.erlang__op_minus [lop_69, rop_71]
                      in let head_67 = erlps__pop__1 [arg_68]
                      in let
                        head_73 =
                          ErlangTuple [ErlangAtom "JUMPDEST", pop1fail_5]
                      in let arg_78 = toErl 1
                      in let head_77 = erlps__pop__1 [arg_78]
                      in let
                        head_80 = ErlangTuple [ErlangAtom "push_label", fail_1]
                      in
                        ErlangCons head_63
                          (ErlangCons head_67
                             (ErlangCons head_73
                                (ErlangCons head_77
                                   (ErlangCons head_80
                                      (ErlangCons (ErlangAtom "JUMP")
                                         ErlangEmptyList)))))
              in
                ErlangTuple
                  [tup_el_21,
                   ErlangCons head_26
                     (ErlangCons head_29
                        (ErlangCons acode_11
                           (ErlangCons head_34
                              (ErlangCons head_37
                                 (ErlangCons head_41
                                    (ErlangCons head_44
                                       (ErlangCons bcode_19
                                          (ErlangCons head_49
                                             ErlangEmptyList))))))))]
            _ -> EXC.badmatch matchExpr_20
      _ -> EXC.badmatch matchExpr_12
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "list"),
                                          (ErlangEmptyList)])]
  =
  let    arg_5 = toErl 1
  in let head_4 = erlps__push__1 [arg_5]
  in let arg_8 = toErl 1
  in let head_7 = erlps__i__1 [arg_8]
  in let head_10 = erlps__jump_if__1 [fail_1]
  in let head_13 = erlps__jump__1 [succeed_0]
  in
    ErlangTuple
      [ErlangEmptyList,
       ErlangCons head_4
         (ErlangCons head_7
            (ErlangCons head_10 (ErlangCons head_13 ErlangEmptyList)))]
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "list"),
                                          (ErlangCons a_2 b_3)])]
  =
  let    tup_el_10 = ErlangTuple [ErlangAtom "list", b_3]
  in let
    arg_6 =
      ErlangTuple [ErlangAtom "binop", ErlangAtom "::", a_2, tup_el_10]
  in erlps__assemble_pattern__3 [succeed_0, fail_1, arg_6]
erlps__assemble_pattern__3 [succeed_0, fail_1,
                            (ErlangTuple [(ErlangAtom "binop"),
                                          (ErlangAtom "::"), a_2, b_3])]
  =
  let    notnil_4 = BIF.erlang__make_ref__0 []
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "tuple",
         ErlangCons a_2 (ErlangCons b_3 ErlangEmptyList)]
  in let
    matchExpr_16 =
      erlps__assemble_pattern__3 [succeed_0, fail_1, arg_7]
  in
    case matchExpr_16 of
      (ErlangTuple [vars_14, code_15]) ->
        let    arg_20 = toErl 1
        in let head_19 = erlps__dup__1 [arg_20]
        in let arg_23 = toErl 1
        in let head_22 = erlps__push__1 [arg_23]
        in let arg_26 = toErl 1
        in let head_25 = erlps__i__1 [arg_26]
        in let head_28 = erlps__jump_if__1 [notnil_4]
        in let arg_32 = toErl 1
        in let head_31 = erlps__pop__1 [arg_32]
        in let head_34 = erlps__jump__1 [fail_1]
        in let head_37 = erlps__jumpdest__1 [notnil_4]
        in
          ErlangTuple
            [vars_14,
             ErlangCons head_19
               (ErlangCons head_22
                  (ErlangCons head_25
                     (ErlangCons head_28
                        (ErlangCons head_31
                           (ErlangCons head_34
                              (ErlangCons head_37
                                 (ErlangCons code_15 ErlangEmptyList)))))))]
      _ -> EXC.badmatch matchExpr_16
erlps__assemble_pattern__3 [arg_42, arg_43, arg_44] =
  EXC.function_clause unit
erlps__assemble_pattern__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__reorder_vars__1 :: ErlangFun
erlps__reorder_vars__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__reorder_vars__1 [(ErlangCons v_0 vs_1)] =
  BIF.erlang__op_append [vs_1, ErlangCons v_0 ErlangEmptyList]
erlps__reorder_vars__1 [arg_6] = EXC.function_clause unit
erlps__reorder_vars__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_prefix__1 :: ErlangFun
erlps__assemble_prefix__1 [(ErlangAtom "sha3")] =
  let    arg_1 = toErl 128
  in let head_0 = erlps__i__1 [arg_1]
  in let arg_4 = toErl 81
  in let head_3 = erlps__i__1 [arg_4]
  in let arg_7 = toErl 144
  in let head_6 = erlps__i__1 [arg_7]
  in let arg_10 = toErl 32
  in let head_9 = erlps__push__1 [arg_10]
  in let arg_13 = toErl 1
  in let head_12 = erlps__i__1 [arg_13]
  in let arg_16 = toErl 32
  in let head_15 = erlps__i__1 [arg_16]
  in
    ErlangCons head_0
      (ErlangCons head_3
         (ErlangCons head_6
            (ErlangCons head_9
               (ErlangCons head_12 (ErlangCons head_15 ErlangEmptyList)))))
erlps__assemble_prefix__1 [(ErlangAtom "-")] =
  let    arg_1 = toErl 0
  in let head_0 = erlps__push__1 [arg_1]
  in let arg_4 = toErl 3
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_0 (ErlangCons head_3 ErlangEmptyList)
erlps__assemble_prefix__1 [(ErlangAtom "bnot")] =
  let arg_0 = toErl 25
  in erlps__i__1 [arg_0]
erlps__assemble_prefix__1 [arg_1] = EXC.function_clause unit
erlps__assemble_prefix__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_infix__1 :: ErlangFun
erlps__assemble_infix__1 [(ErlangAtom "+")] =
  let arg_0 = toErl 1
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "-")] =
  let arg_0 = toErl 3
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "*")] =
  let arg_0 = toErl 2
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "/")] =
  let arg_0 = toErl 5
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "div")] =
  let arg_0 = toErl 4
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "mod")] =
  let arg_0 = toErl 6
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "^")] =
  let arg_0 = toErl 10
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "bor")] =
  let arg_0 = toErl 23
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "band")] =
  let arg_0 = toErl 22
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "bxor")] =
  let arg_0 = toErl 24
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "bsl")] =
  let arg_0 = toErl 27
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "bsr")] =
  let arg_0 = toErl 28
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "<")] =
  let arg_0 = toErl 18
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom ">")] =
  let arg_0 = toErl 19
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "==")] =
  let arg_0 = toErl 20
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [(ErlangAtom "<=")] =
  let    arg_1 = toErl 19
  in let head_0 = erlps__i__1 [arg_1]
  in let arg_4 = toErl 21
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_0 (ErlangCons head_3 ErlangEmptyList)
erlps__assemble_infix__1 [(ErlangAtom "=<")] =
  let    arg_1 = toErl 19
  in let head_0 = erlps__i__1 [arg_1]
  in let arg_4 = toErl 21
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_0 (ErlangCons head_3 ErlangEmptyList)
erlps__assemble_infix__1 [(ErlangAtom ">=")] =
  let    arg_1 = toErl 18
  in let head_0 = erlps__i__1 [arg_1]
  in let arg_4 = toErl 21
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_0 (ErlangCons head_3 ErlangEmptyList)
erlps__assemble_infix__1 [(ErlangAtom "!=")] =
  let    arg_1 = toErl 20
  in let head_0 = erlps__i__1 [arg_1]
  in let arg_4 = toErl 21
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_0 (ErlangCons head_3 ErlangEmptyList)
erlps__assemble_infix__1 [(ErlangAtom "!")] =
  let    arg_1 = toErl 1
  in let head_0 = erlps__i__1 [arg_1]
  in let arg_4 = toErl 81
  in let head_3 = erlps__i__1 [arg_4]
  in ErlangCons head_0 (ErlangCons head_3 ErlangEmptyList)
erlps__assemble_infix__1 [(ErlangAtom "byte")] =
  let arg_0 = toErl 26
  in erlps__i__1 [arg_0]
erlps__assemble_infix__1 [arg_1] = EXC.function_clause unit
erlps__assemble_infix__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__assemble_function__3 :: ErlangFun
erlps__assemble_function__3 [funs_0, stack_1, fun_2] =
  let case_3 = erlps__is_top_level_fun__2 [stack_1, fun_2]
  in
    case case_3 of
      (ErlangAtom "true") ->
        case fun_2 of
          (ErlangTuple [(ErlangAtom "var_ref"), name_6]) ->
            let tup_el_9 = erlps__lookup_fun__2 [funs_0, name_6]
            in ErlangTuple [ErlangAtom "push_label", tup_el_9]
          _ -> EXC.badmatch fun_2
      (ErlangAtom "false") ->
        let   
          head_12 =
            erlps__assemble_expr__4
              [funs_0, stack_1, ErlangAtom "nontail", fun_2]
        in let arg_19 = toErl 1
        in let head_18 = erlps__dup__1 [arg_19]
        in let arg_22 = toErl 81
        in let head_21 = erlps__i__1 [arg_22]
        in
          ErlangCons head_12
            (ErlangCons head_18 (ErlangCons head_21 ErlangEmptyList))
      something_else -> EXC.case_clause something_else
erlps__assemble_function__3 [arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__assemble_function__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__free_vars__1 :: ErlangFun
erlps__free_vars__1 [v_0@(ErlangTuple [(ErlangAtom "var_ref"),
                                       _])]
  =
  ErlangCons v_0 ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "switch"), e_0,
                                   cases_1])]
  =
  let    arg_2 = erlps__free_vars__1 [e_0]
  in let
    arg_5 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [pattern_7, body_8]) ->
               let    lop_11 = erlps__free_vars__1 [body_8]
               in let rop_13 = erlps__free_vars__1 [pattern_7]
               in let lcRet_10 = BIF.erlang__op_unAppend [lop_11, rop_13]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        cases_1
  in let
    arg_4 = BIF.do_remote_fun_call "Lists" "erlps__umerge__1" [arg_5]
  in
    BIF.do_remote_fun_call "Lists" "erlps__umerge__2" [arg_2, arg_4]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "lambda"), args_0,
                                   body_1])]
  =
  let    lop_2 = erlps__free_vars__1 [body_1]
  in let
    rop_4 =
      flmap
        (\ lc_7 ->
           let   
             tup_el_10 =
               case lc_7 of
                 (ErlangTuple arr_13) | (DM.Just field_12) <-
                                          ((arr_13 DA.!! 1)) ->
                   field_12
                 _ -> EXC.badrecord (ErlangAtom "arg")
           in let lcRet_8 = ErlangTuple [ErlangAtom "var_ref", tup_el_10]
           in ErlangCons lcRet_8 ErlangEmptyList)
        args_0
  in BIF.erlang__op_unAppend [lop_2, rop_4]
erlps__free_vars__1 [t_0] | isETuple t_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [t_0]
  in erlps__free_vars__1 [arg_1]
erlps__free_vars__1 [(ErlangCons h_0 t_1)] =
  let    arg_2 = erlps__free_vars__1 [h_0]
  in let arg_4 = erlps__free_vars__1 [t_1]
  in
    BIF.do_remote_fun_call "Lists" "erlps__umerge__2" [arg_2, arg_4]
erlps__free_vars__1 [_] = ErlangEmptyList
erlps__free_vars__1 [arg_0] = EXC.function_clause unit
erlps__free_vars__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__shuffle_stack__1 :: ErlangFun
erlps__shuffle_stack__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__shuffle_stack__1 [(ErlangCons (ErlangAtom "discard") stack_0)]
  =
  let    arg_2 = toErl 80
  in let head_1 = erlps__i__1 [arg_2]
  in let tail_3 = erlps__shuffle_stack__1 [stack_0]
  in ErlangCons head_1 tail_3
erlps__shuffle_stack__1 [(ErlangCons n_0 stack_1)] =
  let    lop_4 = BIF.erlang__length__1 [stack_1]
  in let rop_6 = toErl 1
  in let lop_3 = BIF.erlang__op_plus [lop_4, rop_6]
  in let case_2 = BIF.erlang__op_minus [lop_3, n_0]
  in
    case case_2 of
      (ErlangInt num_8) | ((ErlangInt num_8) == (toErl 0)) ->
        let    rop_11 = toErl 1
        in let arg_9 = BIF.erlang__op_minus [n_0, rop_11]
        in let arg_12 = toErl 1
        in let op_arg_14 = toErl 1
        in let arg_13 = BIF.erlang__op_neg [op_arg_14]
        in let
          correctstack_15 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__3"
              [arg_9, arg_12, arg_13]
        in
          case stack_1 of
            correctstack_16 | (correctstack_16 == correctstack_15) ->
              ErlangEmptyList
            _ -> EXC.badmatch stack_1
      moveby_18 ->
        let    rop_21 = toErl 1
        in let arg_19 = BIF.erlang__op_minus [moveby_18, rop_21]
        in let
          matchExpr_25 =
            BIF.do_remote_fun_call "Lists" "erlps__split__2"
              [arg_19, stack_1]
        in
          case matchExpr_25 of
            (ErlangTuple [pref_23, (ErlangCons _ suff_24)]) ->
              let    head_26 = erlps__swap__1 [moveby_18]
              in let
                head_30 =
                  BIF.do_remote_fun_call "Lists" "erlps__nth__2"
                    [moveby_18, stack_1]
              in let
                tail_33 =
                  BIF.erlang__op_append [pref_23, ErlangCons n_0 suff_24]
              in let
                tail_28 = erlps__shuffle_stack__1 [ErlangCons head_30 tail_33]
              in ErlangCons head_26 tail_28
            _ -> EXC.badmatch matchExpr_25
erlps__shuffle_stack__1 [arg_38] = EXC.function_clause unit
erlps__shuffle_stack__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lookup_fun__2 :: ErlangFun
erlps__lookup_fun__2 [funs_0, name_1] =
  let
    case_2 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [name1_4, _, ref_5]) ->
               let cond_7 = BIF.erlang__op_eq [name_1, name1_4]
               in
                 case cond_7 of
                   (ErlangAtom "true") -> ErlangCons ref_5 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        funs_0
  in
    case case_2 of
      (ErlangCons ref_11 (ErlangEmptyList)) -> ref_11
      (ErlangEmptyList) ->
        let
          arg_12 = ErlangTuple [ErlangAtom "undefined_function", name_1]
        in erlps__gen_error__1 [arg_12]
      something_else -> EXC.case_clause something_else
erlps__lookup_fun__2 [arg_15, arg_16] = EXC.function_clause unit
erlps__lookup_fun__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_top_level_fun__2 :: ErlangFun
erlps__is_top_level_fun__2 [stack_0,
                            (ErlangTuple [(ErlangAtom "var_ref"), id_1])]
  =
  let    arg_4 = toErl 1
  in let op_arg_2 = BIF.lists__keymember__3 [id_1, arg_4, stack_0]
  in BIF.erlang__not__1 [op_arg_2]
erlps__is_top_level_fun__2 [_, _] = ErlangAtom "false"
erlps__is_top_level_fun__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__is_top_level_fun__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lookup_var__2 :: ErlangFun
erlps__lookup_var__2 [id_0, stack_1] =
  let arg_2 = toErl 1
  in erlps__lookup_var__3 [arg_2, id_0, stack_1]
erlps__lookup_var__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__lookup_var__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lookup_var__3 :: ErlangFun
erlps__lookup_var__3 [n_0, id_1,
                      (ErlangCons (ErlangTuple [id_2, _type_3]) _)]
  | (id_2 == id_1) =
  n_0
erlps__lookup_var__3 [n_0, id_1, (ErlangCons _ stack_2)] =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_plus [n_0, rop_5]
  in erlps__lookup_var__3 [arg_3, id_1, stack_2]
erlps__lookup_var__3 [_, id_0, (ErlangEmptyList)] =
  let arg_1 = ErlangTuple [ErlangAtom "var_not_in_scope", id_0]
  in erlps__gen_error__1 [arg_1]
erlps__lookup_var__3 [arg_4, arg_5, arg_6] =
  EXC.function_clause unit
erlps__lookup_var__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__dup__1 :: ErlangFun
erlps__dup__1 [n_0]
  | ((weakLeq (toErl 1) n_0) && (weakLeq n_0 (toErl 16))) =
  let    lop_3 = toErl 128
  in let lop_2 = BIF.erlang__op_plus [lop_3, n_0]
  in let rop_5 = toErl 1
  in let arg_1 = BIF.erlang__op_minus [lop_2, rop_5]
  in erlps__i__1 [arg_1]
erlps__dup__1 [arg_6] = EXC.function_clause unit
erlps__dup__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__push__1 :: ErlangFun
erlps__push__1 [n_0] =
  let    bytes_2 = BIF.binary__encode_unsigned__1 [n_0]
  in let lop_3 = BIF.erlang__size__1 [bytes_2]
  in let rop_5 = toErl 32
  in let matchExpr_6 = BIF.erlang__op_lesserEq [lop_3, rop_5]
  in
    case matchExpr_6 of
      (ErlangAtom "true") ->
        let    lop_10 = toErl 96
        in let rop_11 = BIF.erlang__size__1 [bytes_2]
        in let lop_9 = BIF.erlang__op_plus [lop_10, rop_11]
        in let rop_13 = toErl 1
        in let arg_8 = BIF.erlang__op_minus [lop_9, rop_13]
        in let head_7 = erlps__i__1 [arg_8]
        in let tail_14 = BIF.erlang__binary_to_list__1 [bytes_2]
        in ErlangCons head_7 tail_14
      _ -> EXC.badmatch matchExpr_6
erlps__push__1 [arg_16] = EXC.function_clause unit
erlps__push__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pop_args__1 :: ErlangFun
erlps__pop_args__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 0)) =
  ErlangEmptyList
erlps__pop_args__1 [n_0] =
  ErlangTuple [ErlangAtom "pop_args", n_0]
erlps__pop_args__1 [arg_3] = EXC.function_clause unit
erlps__pop_args__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pop__1 :: ErlangFun
erlps__pop__1 [n_0] =
  let    arg_2 = toErl 1
  in let
    lcSrc_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, n_0]
  in
    flmap
      (\ lc_4 ->
         case lc_4 of
           _ ->
             let    arg_6 = toErl 80
             in let lcRet_5 = erlps__i__1 [arg_6]
             in ErlangCons lcRet_5 ErlangEmptyList)
      lcSrc_1
erlps__pop__1 [arg_7] = EXC.function_clause unit
erlps__pop__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__swap__1 :: ErlangFun
erlps__swap__1 [(ErlangInt num_0)]
  | ((ErlangInt num_0) == (toErl 0)) =
  ErlangEmptyList
erlps__swap__1 [n_0]
  | ((weakLeq (toErl 1) n_0) && (weakLeq n_0 (toErl 16))) =
  let    lop_3 = toErl 144
  in let lop_2 = BIF.erlang__op_plus [lop_3, n_0]
  in let rop_5 = toErl 1
  in let arg_1 = BIF.erlang__op_minus [lop_2, rop_5]
  in erlps__i__1 [arg_1]
erlps__swap__1 [arg_6] = EXC.function_clause unit
erlps__swap__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__jumpdest__1 :: ErlangFun
erlps__jumpdest__1 [label_0] =
  let    arg_2 = toErl 91
  in let tup_el_1 = erlps__i__1 [arg_2]
  in ErlangTuple [tup_el_1, label_0]
erlps__jumpdest__1 [arg_4] = EXC.function_clause unit
erlps__jumpdest__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__push_label__1 :: ErlangFun
erlps__push_label__1 [label_0] =
  ErlangTuple [ErlangAtom "push_label", label_0]
erlps__push_label__1 [arg_3] = EXC.function_clause unit
erlps__push_label__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__jump__1 :: ErlangFun
erlps__jump__1 [label_0] =
  let    head_1 = erlps__push_label__1 [label_0]
  in let arg_5 = toErl 86
  in let head_4 = erlps__i__1 [arg_5]
  in ErlangCons head_1 (ErlangCons head_4 ErlangEmptyList)
erlps__jump__1 [arg_7] = EXC.function_clause unit
erlps__jump__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__jump_if__1 :: ErlangFun
erlps__jump_if__1 [label_0] =
  let    head_1 = erlps__push_label__1 [label_0]
  in let arg_5 = toErl 87
  in let head_4 = erlps__i__1 [arg_5]
  in ErlangCons head_1 (ErlangCons head_4 ErlangEmptyList)
erlps__jump_if__1 [arg_7] = EXC.function_clause unit
erlps__jump_if__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__icode_noname__0 :: ErlangFun
erlps__icode_noname__0 [] =
  let tup_el_1 = toErl "_"
  in ErlangTuple [ErlangAtom "var_ref", tup_el_1]
erlps__icode_noname__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__icode_seq__1 :: ErlangFun
erlps__icode_seq__1 [(ErlangCons a_0 (ErlangEmptyList))] = a_0
erlps__icode_seq__1 [(ErlangCons a_0 as_1)] =
  let arg_3 = erlps__icode_seq__1 [as_1]
  in erlps__icode_seq__2 [a_0, arg_3]
erlps__icode_seq__1 [arg_5] = EXC.function_clause unit
erlps__icode_seq__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__icode_seq__2 :: ErlangFun
erlps__icode_seq__2 [a_0, b_1] =
  let    tup_el_6 = erlps__icode_noname__0 []
  in let head_5 = ErlangTuple [tup_el_6, b_1]
  in
    ErlangTuple
      [ErlangAtom "switch", a_0, ErlangCons head_5 ErlangEmptyList]
erlps__icode_seq__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__icode_seq__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__resolve_references__1 :: ErlangFun
erlps__resolve_references__1 [code_0] =
  let   
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [code_0]
  in let peephole_3 = erlps__peep_hole__1 [arg_1]
  in let optimizedjumps_5 = erlps__optimize_jumps__1 [peephole_3]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [optimizedjumps_5]
  in let arg_6 = erlps__peep_hole_backwards__1 [arg_7]
  in let
    instrs_9 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_6]
  in let arg_10 = toErl 0
  in let labels_12 = erlps__define_labels__2 [arg_10, instrs_9]
  in let
    arg_13 =
      flmap
        (\ lc_16 ->
           let lcRet_17 = erlps__use_labels__2 [labels_12, lc_16]
           in ErlangCons lcRet_17 ErlangEmptyList)
        instrs_9
  in BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_13]
erlps__resolve_references__1 [arg_20] = EXC.function_clause unit
erlps__resolve_references__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__define_labels__2 :: ErlangFun
erlps__define_labels__2 [addr_0,
                         (ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                                   lab_1]) more_2)]
  =
  let    head_3 = ErlangTuple [lab_1, addr_0]
  in let rop_9 = toErl 1
  in let arg_7 = BIF.erlang__op_plus [addr_0, rop_9]
  in let tail_6 = erlps__define_labels__2 [arg_7, more_2]
  in ErlangCons head_3 tail_6
erlps__define_labels__2 [addr_0,
                         (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                   _]) more_1)]
  =
  let    rop_4 = toErl 4
  in let arg_2 = BIF.erlang__op_plus [addr_0, rop_4]
  in erlps__define_labels__2 [arg_2, more_1]
erlps__define_labels__2 [addr_0,
                         (ErlangCons (ErlangTuple [(ErlangAtom "pop_args"),
                                                   n_1]) more_2)]
  =
  let    lop_4 = BIF.erlang__op_plus [addr_0, n_1]
  in let rop_7 = toErl 1
  in let arg_3 = BIF.erlang__op_plus [lop_4, rop_7]
  in erlps__define_labels__2 [arg_3, more_2]
erlps__define_labels__2 [addr_0, (ErlangCons _ more_1)] =
  let    rop_4 = toErl 1
  in let arg_2 = BIF.erlang__op_plus [addr_0, rop_4]
  in erlps__define_labels__2 [arg_2, more_1]
erlps__define_labels__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__define_labels__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__define_labels__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__use_labels__2 :: ErlangFun
erlps__use_labels__2 [_,
                      (ErlangTuple [(ErlangAtom "JUMPDEST"), _])]
  =
  ErlangAtom "JUMPDEST"
erlps__use_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "push_label"), ref_1])]
  =
  let
    case_2 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [ref_1, labels_0]
  in
    case case_2 of
      (ErlangAtom "undefined") ->
        let arg_5 = ErlangTuple [ErlangAtom "undefined_label", ref_1]
        in erlps__gen_error__1 [arg_5]
      addr_8 | isEInt addr_8 ->
        let    arg_10 = toErl 98
        in let head_9 = erlps__i__1 [arg_10]
        in let rop_14 = toErl 65536
        in let head_12 = BIF.erlang__op_div_strict [addr_8, rop_14]
        in let rop_19 = toErl 256
        in let lop_17 = BIF.erlang__op_div_strict [addr_8, rop_19]
        in let rop_20 = toErl 256
        in let head_16 = BIF.erlang__op_rem_strict [lop_17, rop_20]
        in let rop_24 = toErl 256
        in let head_22 = BIF.erlang__op_rem_strict [addr_8, rop_24]
        in
          ErlangCons head_9
            (ErlangCons head_12
               (ErlangCons head_16 (ErlangCons head_22 ErlangEmptyList)))
      something_else -> EXC.case_clause something_else
erlps__use_labels__2 [_,
                      (ErlangTuple [(ErlangAtom "pop_args"), n_0])]
  =
  let    head_1 = erlps__swap__1 [n_0]
  in let head_4 = erlps__pop__1 [n_0]
  in ErlangCons head_1 (ErlangCons head_4 ErlangEmptyList)
erlps__use_labels__2 [_, i_0] = i_0
erlps__use_labels__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__use_labels__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__peep_hole__1 :: ErlangFun
erlps__peep_hole__1 [(ErlangCons (ErlangAtom "PUSH1") (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                                                                              _]) (ErlangCons (ErlangAtom "JUMPI") more_1))))]
  | ((ErlangInt num_0) == (toErl 0)) =
  erlps__peep_hole__1 [more_1]
erlps__peep_hole__1 [(ErlangCons (ErlangAtom "PUSH1") (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                                                                              lab_1]) (ErlangCons (ErlangAtom "JUMPI") more_2))))]
  | ((ErlangInt num_0) == (toErl 1)) =
  let    head_3 = ErlangTuple [ErlangAtom "push_label", lab_1]
  in let tail_8 = erlps__peep_hole__1 [more_2]
  in ErlangCons head_3 (ErlangCons (ErlangAtom "JUMP") tail_8)
erlps__peep_hole__1 [(ErlangCons (ErlangTuple [(ErlangAtom "pop_args"),
                                               m_0]) (ErlangCons (ErlangTuple [(ErlangAtom "pop_args"),
                                                                               n_1]) more_2))]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    lop_10 = BIF.erlang__op_plus [m_0, n_1]
             in let rop_13 = toErl 16
             in BIF.erlang__op_lesserEq [lop_10, rop_13]))) =
  let    tup_el_6 = BIF.erlang__op_plus [m_0, n_1]
  in let head_4 = ErlangTuple [ErlangAtom "pop_args", tup_el_6]
  in erlps__peep_hole__1 [ErlangCons head_4 more_2]
erlps__peep_hole__1 [(ErlangCons i_0 more_1)] =
  let tail_3 = erlps__peep_hole__1 [more_1]
  in ErlangCons i_0 tail_3
erlps__peep_hole__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__peep_hole__1 [arg_0] = EXC.function_clause unit
erlps__peep_hole__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__peep_hole_backwards__1 :: ErlangFun
erlps__peep_hole_backwards__1 [code_0] =
  let newcode_2 = erlps__peep_hole_backwards1__1 [code_0]
  in
    case ErlangAtom "true" of
      _ | weakEq code_0 newcode_2 -> code_0
      _ -> erlps__peep_hole_backwards__1 [newcode_2]
erlps__peep_hole_backwards__1 [arg_4] = EXC.function_clause unit
erlps__peep_hole_backwards__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__peep_hole_backwards1__1 :: ErlangFun
erlps__peep_hole_backwards1__1 [(ErlangCons (ErlangAtom "ADD") (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangAtom "PUSH1") code_1)))]
  | ((ErlangInt num_0) == (toErl 0)) =
  erlps__peep_hole_backwards1__1 [code_1]
erlps__peep_hole_backwards1__1 [(ErlangCons (ErlangAtom "POP") (ErlangCons unop_0 code_1))]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    lop_6 = BIF.erlang__op_eq [unop_0, ErlangAtom "MLOAD"]
             in let
               lop_5 =
                 case lop_6 of
                   (ErlangAtom "true") -> ErlangAtom "true"
                   (ErlangAtom "false") ->
                     BIF.erlang__op_eq [unop_0, ErlangAtom "ISZERO"]
                   _ -> EXC.badarg1 lop_6
             in
               case lop_5 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   BIF.erlang__op_eq [unop_0, ErlangAtom "NOT"]
                 _ -> EXC.badarg1 lop_5))) =
  erlps__peep_hole_backwards1__1
    [ErlangCons (ErlangAtom "POP") code_1]
erlps__peep_hole_backwards1__1 [(ErlangCons (ErlangAtom "POP") (ErlangCons binop_0 code_1))]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let    lop_9 = BIF.erlang__op_eq [binop_0, ErlangAtom "ADD"]
             in let
               lop_8 =
                 case lop_9 of
                   (ErlangAtom "true") -> ErlangAtom "true"
                   (ErlangAtom "false") ->
                     BIF.erlang__op_eq [binop_0, ErlangAtom "SUB"]
                   _ -> EXC.badarg1 lop_9
             in let
               lop_7 =
                 case lop_8 of
                   (ErlangAtom "true") -> ErlangAtom "true"
                   (ErlangAtom "false") ->
                     BIF.erlang__op_eq [binop_0, ErlangAtom "MUL"]
                   _ -> EXC.badarg1 lop_8
             in
               case lop_7 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   BIF.erlang__op_eq [binop_0, ErlangAtom "SDIV"]
                 _ -> EXC.badarg1 lop_7))) =
  erlps__peep_hole_backwards1__1
    [ErlangCons (ErlangAtom "POP")
       (ErlangCons (ErlangAtom "POP") code_1)]
erlps__peep_hole_backwards1__1 [(ErlangCons (ErlangAtom "POP") (ErlangCons _ (ErlangCons (ErlangAtom "PUSH1") code_0)))]
  =
  erlps__peep_hole_backwards1__1 [code_0]
erlps__peep_hole_backwards1__1 [(ErlangCons i_0 code_1)] =
  let tail_3 = erlps__peep_hole_backwards1__1 [code_1]
  in ErlangCons i_0 tail_3
erlps__peep_hole_backwards1__1 [(ErlangEmptyList)] =
  ErlangEmptyList
erlps__peep_hole_backwards1__1 [arg_0] = EXC.function_clause unit
erlps__peep_hole_backwards1__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__optimize_jumps__1 :: ErlangFun
erlps__optimize_jumps__1 [code_0] =
  let    jjs_2 = erlps__jumps_to_jumps__1 [code_0]
  in let
    shortcircuited_9 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = erlps__short_circuit_jumps__2 [jjs_2, lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        code_0
  in let
    nodeadcode_11 = erlps__eliminate_dead_code__1 [shortcircuited_9]
  in let arg_12 = erlps__moveable_blocks__1 [nodeadcode_11]
  in let movedcode_14 = erlps__merge_blocks__1 [arg_12]
  in erlps__eliminate_dead_code__1 [movedcode_14]
erlps__optimize_jumps__1 [arg_16] = EXC.function_clause unit
erlps__optimize_jumps__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__jumps_to_jumps__1 :: ErlangFun
erlps__jumps_to_jumps__1 [(ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                                    label_0]) (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                                                        target_1]) (ErlangCons (ErlangAtom "JUMP") more_2)))]
  =
  let    head_3 = ErlangTuple [label_0, target_1]
  in let tail_6 = erlps__jumps_to_jumps__1 [more_2]
  in ErlangCons head_3 tail_6
erlps__jumps_to_jumps__1 [(ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                                    label_0]) (ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                                                                        target_1]) more_2))]
  =
  let    head_3 = ErlangTuple [label_0, target_1]
  in let head_8 = ErlangTuple [ErlangAtom "JUMPDEST", target_1]
  in let
    tail_6 = erlps__jumps_to_jumps__1 [ErlangCons head_8 more_2]
  in ErlangCons head_3 tail_6
erlps__jumps_to_jumps__1 [(ErlangCons _ more_0)] =
  erlps__jumps_to_jumps__1 [more_0]
erlps__jumps_to_jumps__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__jumps_to_jumps__1 [arg_0] = EXC.function_clause unit
erlps__jumps_to_jumps__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__short_circuit_jumps__2 :: ErlangFun
erlps__short_circuit_jumps__2 [jjs_0,
                               (ErlangTuple [(ErlangAtom "push_label"), lab_1])]
  =
  let
    case_2 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [lab_1, jjs_0]
  in
    case case_2 of
      (ErlangAtom "undefined") ->
        ErlangTuple [ErlangAtom "push_label", lab_1]
      target_7 ->
        let arg_9 = ErlangTuple [ErlangAtom "push_label", target_7]
        in erlps__short_circuit_jumps__2 [jjs_0, arg_9]
erlps__short_circuit_jumps__2 [_jjs_0, instr_1] = instr_1
erlps__short_circuit_jumps__2 [arg_2, arg_3] =
  EXC.function_clause unit
erlps__short_circuit_jumps__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__eliminate_dead_code__1 :: ErlangFun
erlps__eliminate_dead_code__1 [code_0] =
  let   
    arg_1 =
      flmap
        (\ lc_4 ->
           case lc_4 of
             (ErlangTuple [(ErlangAtom "push_label"), lab_3]) ->
               ErlangCons lab_3 ErlangEmptyList
             _ -> ErlangEmptyList)
        code_0
  in let
    jumps_6 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_1]
  in let newcode_9 = erlps__live_code__2 [jumps_6, code_0]
  in
    case ErlangAtom "true" of
      _ | weakEq code_0 newcode_9 -> code_0
      _ -> erlps__eliminate_dead_code__1 [newcode_9]
erlps__eliminate_dead_code__1 [arg_11] = EXC.function_clause unit
erlps__eliminate_dead_code__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__live_code__2 :: ErlangFun
erlps__live_code__2 [jumps_0,
                     (ErlangCons (ErlangAtom "JUMP") more_1)]
  =
  let tail_3 = erlps__dead_code__2 [jumps_0, more_1]
  in ErlangCons (ErlangAtom "JUMP") tail_3
erlps__live_code__2 [jumps_0,
                     (ErlangCons (ErlangAtom "STOP") more_1)]
  =
  let tail_3 = erlps__dead_code__2 [jumps_0, more_1]
  in ErlangCons (ErlangAtom "STOP") tail_3
erlps__live_code__2 [jumps_0,
                     (ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                               lab_1]) more_2)]
  =
  let case_3 = BIF.lists__member__2 [lab_1, jumps_0]
  in
    case case_3 of
      (ErlangAtom "true") ->
        let    head_6 = ErlangTuple [ErlangAtom "JUMPDEST", lab_1]
        in let tail_9 = erlps__live_code__2 [jumps_0, more_2]
        in ErlangCons head_6 tail_9
      (ErlangAtom "false") -> erlps__live_code__2 [jumps_0, more_2]
      something_else -> EXC.case_clause something_else
erlps__live_code__2 [jumps_0, (ErlangCons i_1 more_2)] =
  let tail_4 = erlps__live_code__2 [jumps_0, more_2]
  in ErlangCons i_1 tail_4
erlps__live_code__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__live_code__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__live_code__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__dead_code__2 :: ErlangFun
erlps__dead_code__2 [jumps_0,
                     (ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                               lab_1]) more_2)]
  =
  let case_3 = BIF.lists__member__2 [lab_1, jumps_0]
  in
    case case_3 of
      (ErlangAtom "true") ->
        let    head_6 = ErlangTuple [ErlangAtom "JUMPDEST", lab_1]
        in let tail_9 = erlps__live_code__2 [jumps_0, more_2]
        in ErlangCons head_6 tail_9
      (ErlangAtom "false") -> erlps__dead_code__2 [jumps_0, more_2]
      something_else -> EXC.case_clause something_else
erlps__dead_code__2 [jumps_0, (ErlangCons _i_1 more_2)] =
  erlps__dead_code__2 [jumps_0, more_2]
erlps__dead_code__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__dead_code__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__dead_code__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__moveable_blocks__1 :: ErlangFun
erlps__moveable_blocks__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__moveable_blocks__1 [(ErlangCons i_0 (ErlangEmptyList))] =
  ErlangCons (ErlangCons i_0 ErlangEmptyList) ErlangEmptyList
erlps__moveable_blocks__1 [(ErlangCons jump_0 more_1)]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let lop_7 = BIF.erlang__op_eq [jump_0, ErlangAtom "JUMP"]
             in
               case lop_7 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   BIF.erlang__op_eq [jump_0, ErlangAtom "STOP"]
                 _ -> EXC.badarg1 lop_7))) =
  let tail_5 = erlps__moveable_blocks__1 [more_1]
  in ErlangCons (ErlangCons jump_0 ErlangEmptyList) tail_5
erlps__moveable_blocks__1 [(ErlangCons i_0 more_1)] =
  let matchExpr_5 = erlps__moveable_blocks__1 [more_1]
  in
    case matchExpr_5 of
      (ErlangCons block_3 moreblocks_4) ->
        ErlangCons (ErlangCons i_0 block_3) moreblocks_4
      _ -> EXC.badmatch matchExpr_5
erlps__moveable_blocks__1 [arg_10] = EXC.function_clause unit
erlps__moveable_blocks__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__merge_blocks__1 :: ErlangFun
erlps__merge_blocks__1 [blocks_0] =
  let   
    blocksandtargets_6 =
      flmap
        (\ lc_3 ->
           let lcRet_4 = erlps__label_and_jump__1 [lc_3]
           in ErlangCons lcRet_4 ErlangEmptyList)
        blocks_0
  in let lcSrc_7 = erlps__merge_after__1 [blocksandtargets_6]
  in
    flmap
      (\ lc_12 ->
         case lc_12 of
           (ErlangTuple [pref_9, body_10, suff_11]) ->
             let    rop_15 = BIF.erlang__op_append [body_10, suff_11]
             in let lcSrc_13 = BIF.erlang__op_append [pref_9, rop_15]
             in flmap (\ lc_19 -> ErlangCons lc_19 ErlangEmptyList) lcSrc_13
           _ -> ErlangEmptyList)
      lcSrc_7
erlps__merge_blocks__1 [arg_21] = EXC.function_clause unit
erlps__merge_blocks__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__merge_after__1 :: ErlangFun
erlps__merge_after__1 [all_4@(ErlangCons (ErlangTuple [label_0,
                                                       body_1,
                                                       (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                                                 target_2]) (ErlangCons (ErlangAtom "JUMP") (ErlangEmptyList)))]) blocksandtargets_3)]
  =
  let
    case_5 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                                     l_7]) (ErlangEmptyList)),
                           b_8, j_9]) ->
               let cond_11 = BIF.erlang__op_eq [l_7, target_2]
               in
                 case cond_11 of
                   (ErlangAtom "true") ->
                     let lcRet_14 = ErlangTuple [b_8, j_9]
                     in ErlangCons lcRet_14 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        blocksandtargets_3
  in
    case case_5 of
      (ErlangCons (ErlangTuple [b_17, j_18]) _) ->
        let    head_26 = ErlangTuple [ErlangAtom "JUMPDEST", target_2]
        in let
          rop_24 =
            BIF.erlang__op_append [ErlangCons head_26 ErlangEmptyList, b_17]
        in let tup_el_22 = BIF.erlang__op_append [body_1, rop_24]
        in let head_20 = ErlangTuple [label_0, tup_el_22, j_18]
        in let head_35 = ErlangTuple [ErlangAtom "JUMPDEST", target_2]
        in let
          arg_33 =
            ErlangTuple [ErlangCons head_35 ErlangEmptyList, b_17, j_18]
        in let
          tail_32 =
            BIF.do_remote_fun_call "Lists" "erlps__delete__2"
              [arg_33, blocksandtargets_3]
        in erlps__merge_after__1 [ErlangCons head_20 tail_32]
      (ErlangEmptyList) -> erlps__merge_before__1 [all_4]
      something_else -> EXC.case_clause something_else
erlps__merge_after__1 [all_0] = erlps__merge_before__1 [all_0]
erlps__merge_after__1 [arg_2] = EXC.function_clause unit
erlps__merge_after__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__merge_before__1 :: ErlangFun
erlps__merge_before__1 [(ErlangCons block_3@(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                                                                    label_0]) (ErlangEmptyList)),
                                                          body_1,
                                                          jump_2]) blocksandtargets_4)]
  =
  let
    case_5 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [l_7, b_8,
                           (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                     t_9]) (ErlangCons (ErlangAtom "JUMP") (ErlangEmptyList)))]) ->
               let cond_11 = BIF.erlang__op_eq [t_9, label_0]
               in
                 case cond_11 of
                   (ErlangAtom "true") ->
                     let lcRet_14 = ErlangTuple [l_7, b_8, t_9]
                     in ErlangCons lcRet_14 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        blocksandtargets_4
  in
    case case_5 of
      (ErlangCons (ErlangTuple [l_18, b_19, t_20]) _) ->
        let    head_28 = ErlangTuple [ErlangAtom "JUMPDEST", label_0]
        in let
          rop_26 =
            BIF.erlang__op_append
              [ErlangCons head_28 ErlangEmptyList, body_1]
        in let tup_el_24 = BIF.erlang__op_append [b_19, rop_26]
        in let head_22 = ErlangTuple [l_18, tup_el_24, jump_2]
        in let head_39 = ErlangTuple [ErlangAtom "push_label", t_20]
        in let
          arg_35 =
            ErlangTuple
              [l_18, b_19,
               ErlangCons head_39
                 (ErlangCons (ErlangAtom "JUMP") ErlangEmptyList)]
        in let
          tail_34 =
            BIF.do_remote_fun_call "Lists" "erlps__delete__2"
              [arg_35, blocksandtargets_4]
        in erlps__merge_before__1 [ErlangCons head_22 tail_34]
      _ ->
        let tail_47 = erlps__merge_after__1 [blocksandtargets_4]
        in ErlangCons block_3 tail_47
erlps__merge_before__1 [(ErlangCons block_0 blocksandtargets_1)]
  =
  let tail_3 = erlps__merge_after__1 [blocksandtargets_1]
  in ErlangCons block_0 tail_3
erlps__merge_before__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__merge_before__1 [arg_0] = EXC.function_clause unit
erlps__merge_before__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__label_and_jump__1 :: ErlangFun
erlps__label_and_jump__1 [b_0] =
  let
    matchExpr_14 =
      case b_0 of
        (ErlangCons (ErlangTuple [(ErlangAtom "JUMPDEST"),
                                  l_2]) more1_3) ->
          let head_5 = ErlangTuple [ErlangAtom "JUMPDEST", l_2]
          in ErlangTuple [ErlangCons head_5 ErlangEmptyList, more1_3]
        _ -> ErlangTuple [ErlangEmptyList, b_0]
  in
    case matchExpr_14 of
      (ErlangTuple [label_12, b1_13]) ->
        let   
          case_15 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [b1_13]
        in let
          matchExpr_32 =
            case case_15 of
              (ErlangCons (ErlangAtom "JUMP") (ErlangCons (ErlangTuple [(ErlangAtom "push_label"),
                                                                        t_17]) more2_18)) ->
                let    head_20 = ErlangTuple [ErlangAtom "push_label", t_17]
                in let
                  tup_el_26 =
                    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                      [more2_18]
                in
                  ErlangTuple
                    [ErlangCons head_20
                       (ErlangCons (ErlangAtom "JUMP") ErlangEmptyList),
                     tup_el_26]
              _ -> ErlangTuple [ErlangEmptyList, b1_13]
        in
          case matchExpr_32 of
            (ErlangTuple [target_30, b2_31]) ->
              ErlangTuple [label_12, b2_31, target_30]
            _ -> EXC.badmatch matchExpr_32
      _ -> EXC.badmatch matchExpr_14
erlps__label_and_jump__1 [arg_36] = EXC.function_clause unit
erlps__label_and_jump__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args