module Aeso.Ast.To.Fcode(erlps__ast_to_fcode__2,
                         erlps__format_fexpr__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__ast_to_fcode__2 :: ErlangFun
erlps__ast_to_fcode__2 [code_0, options_1] =
  let    _ = erlps__init_fresh_names__0 []
  in let arg_2 = erlps__init_env__1 [options_1]
  in let matchExpr_7 = erlps__to_fcode__2 [arg_2, code_0]
  in
    case matchExpr_7 of
      (ErlangTuple [env1_5, fcode1_6]) ->
        let    fcode2_10 = erlps__optimize__2 [fcode1_6, options_1]
        in let
          arg_14 =
            ErlangFun 2
              (let
                 lambda_15 [_, fc_18] = erlps__optimize__2 [fc_18, options_1]
                 lambda_15 [arg_16, arg_17] = EXC.function_clause unit
                 lambda_15 args = EXC.badarity (ErlangFun 2 lambda_15) args
               in lambda_15)
        in let
          arg_21 = BIF.maps__get__2 [ErlangAtom "child_con_env", env1_5]
        in let
          val_13 =
            BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_14, arg_21]
        in let
          mapExt_24 =
            ErlangMap (Map.singleton (ErlangAtom "child_con_env") val_13)
        in let
          env2_27 =
            case findMissingKey env1_5 [ErlangAtom "child_con_env"] of
              (DM.Nothing) -> BIF.maps__merge__2 [env1_5, mapExt_24]
              (DM.Just missing_26) -> EXC.badkey missing_26
        in let _ = erlps__clear_fresh_names__0 []
        in ErlangTuple [env2_27, fcode2_10]
      _ -> EXC.badmatch matchExpr_7
erlps__ast_to_fcode__2 [arg_30, arg_31] =
  EXC.function_clause unit
erlps__ast_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__ast_to_fcode__2) args

erlps__optimize__2 :: ErlangFun
erlps__optimize__2 [fcode1_0, options_1] =
  let   
    verbose_4 =
      BIF.lists__member__2 [ErlangAtom "pp_fcode", options_1]
  in let
    _ =
      case verbose_4 of
        (ErlangAtom "true") ->
          let    arg_7 = toErl "-- Before lambda lifting --\n~s\n\n"
          in let head_9 = erlps__format_fcode__1 [fcode1_0]
          in let
            lcRet_6 =
              BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                [arg_7, ErlangCons head_9 ErlangEmptyList]
          in ErlangCons lcRet_6 ErlangEmptyList
        _ -> ErlangEmptyList
  in let fcode2_13 = erlps__optimize_fcode__1 [fcode1_0]
  in let
    _ =
      case verbose_4 of
        (ErlangAtom "true") ->
          let cond_15 = BIF.erlang__op_neq [fcode2_13, fcode1_0]
          in
            case cond_15 of
              (ErlangAtom "true") ->
                let    arg_19 = toErl "-- After optimization --\n~s\n\n"
                in let head_21 = erlps__format_fcode__1 [fcode2_13]
                in let
                  lcRet_18 =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_19, ErlangCons head_21 ErlangEmptyList]
                in ErlangCons lcRet_18 ErlangEmptyList
              _ -> ErlangEmptyList
        _ -> ErlangEmptyList
  in let fcode3_25 = erlps__lambda_lift__1 [fcode2_13]
  in let
    _ =
      case verbose_4 of
        (ErlangAtom "true") ->
          let cond_27 = BIF.erlang__op_neq [fcode3_25, fcode2_13]
          in
            case cond_27 of
              (ErlangAtom "true") ->
                let    arg_31 = toErl "-- After lambda lifting --\n~s\n\n"
                in let head_33 = erlps__format_fcode__1 [fcode3_25]
                in let
                  lcRet_30 =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_31, ErlangCons head_33 ErlangEmptyList]
                in ErlangCons lcRet_30 ErlangEmptyList
              _ -> ErlangEmptyList
        _ -> ErlangEmptyList
  in fcode3_25
erlps__optimize__2 [arg_36, arg_37] = EXC.function_clause unit
erlps__optimize__2 args =
  EXC.badarity (ErlangFun 2 erlps__optimize__2) args

erlps__init_env__1 :: ErlangFun
erlps__init_env__1 [options_0] =
  let    head_1 = toErl 3
  in let head_3 = toErl 0
  in let head_5 = toErl 0
  in let head_7 = toErl 0
  in let head_9 = toErl 0
  in let head_11 = toErl 0
  in let head_13 = toErl 1
  in let head_15 = toErl 1
  in let head_17 = toErl 1
  in let head_19 = toErl 2
  in let head_21 = toErl 1
  in let head_23 = toErl 2
  in let head_25 = toErl 2
  in let head_27 = toErl 1
  in let head_29 = toErl 1
  in let head_31 = toErl 1
  in let head_33 = toErl 1
  in let head_35 = toErl 1
  in let head_37 = toErl 1
  in let head_39 = toErl 1
  in let head_41 = toErl 2
  in let head_43 = toErl 0
  in let val_53 = erlps__init_type_env__0 []
  in let val_54 = ErlangMap Map.empty
  in let val_55 = erlps__builtins__0 []
  in let val_56 = ErlangMap Map.empty
  in let head_59 = toErl "None"
  in let head_62 = toErl "Some"
  in let head_65 = toErl "RelativeTTL"
  in let head_68 = toErl "FixedTTL"
  in let head_71 = toErl "AENS"
  in let head_73 = toErl "AccountPt"
  in let head_76 = toErl "AENS"
  in let head_78 = toErl "OraclePt"
  in let head_81 = toErl "AENS"
  in let head_83 = toErl "ContractPt"
  in let head_86 = toErl "AENS"
  in let head_88 = toErl "ChannelPt"
  in let head_91 = toErl "AENS"
  in let head_93 = toErl "Name"
  in let head_96 = toErl "Chain"
  in let head_98 = toErl "GAMetaTx"
  in let head_101 = toErl "Chain"
  in let head_103 = toErl "PayingForTx"
  in let head_106 = toErl "Chain"
  in let head_108 = toErl "SpendTx"
  in let head_111 = toErl "Chain"
  in let head_113 = toErl "OracleRegisterTx"
  in let head_116 = toErl "Chain"
  in let head_118 = toErl "OracleQueryTx"
  in let head_121 = toErl "Chain"
  in let head_123 = toErl "OracleResponseTx"
  in let head_126 = toErl "Chain"
  in let head_128 = toErl "OracleExtendTx"
  in let head_131 = toErl "Chain"
  in let head_133 = toErl "NamePreclaimTx"
  in let head_136 = toErl "Chain"
  in let head_138 = toErl "NameClaimTx"
  in let head_141 = toErl "Chain"
  in let head_143 = toErl "NameUpdateTx"
  in let head_146 = toErl "Chain"
  in let head_148 = toErl "NameRevokeTx"
  in let head_151 = toErl "Chain"
  in let head_153 = toErl "NameTransferTx"
  in let head_156 = toErl "Chain"
  in let head_158 = toErl "ChannelCreateTx"
  in let head_161 = toErl "Chain"
  in let head_163 = toErl "ChannelDepositTx"
  in let head_166 = toErl "Chain"
  in let head_168 = toErl "ChannelWithdrawTx"
  in let head_171 = toErl "Chain"
  in let head_173 = toErl "ChannelForceProgressTx"
  in let head_176 = toErl "Chain"
  in let head_178 = toErl "ChannelCloseMutualTx"
  in let head_181 = toErl "Chain"
  in let head_183 = toErl "ChannelCloseSoloTx"
  in let head_186 = toErl "Chain"
  in let head_188 = toErl "ChannelSlashTx"
  in let head_191 = toErl "Chain"
  in let head_193 = toErl "ChannelSettleTx"
  in let head_196 = toErl "Chain"
  in let head_198 = toErl "ChannelSnapshotSoloTx"
  in let head_201 = toErl "Chain"
  in let head_203 = toErl "ContractCreateTx"
  in let head_206 = toErl "Chain"
  in let head_208 = toErl "ContractCallTx"
  in let head_211 = toErl "Chain"
  in let head_213 = toErl "GAAttachTx"
  in let tup_el_217 = toErl 0
  in let head_219 = toErl 0
  in let head_221 = toErl 1
  in let
    val_215 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_217,
         ErlangCons head_219 (ErlangCons head_221 ErlangEmptyList)]
  in let tup_el_225 = toErl 1
  in let head_227 = toErl 0
  in let head_229 = toErl 1
  in let
    val_223 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_225,
         ErlangCons head_227 (ErlangCons head_229 ErlangEmptyList)]
  in let tup_el_233 = toErl 0
  in let head_235 = toErl 1
  in let head_237 = toErl 1
  in let
    val_231 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_233,
         ErlangCons head_235 (ErlangCons head_237 ErlangEmptyList)]
  in let tup_el_241 = toErl 1
  in let head_243 = toErl 1
  in let head_245 = toErl 1
  in let
    val_239 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_241,
         ErlangCons head_243 (ErlangCons head_245 ErlangEmptyList)]
  in let tup_el_249 = toErl 0
  in let head_251 = toErl 1
  in let head_253 = toErl 1
  in let head_255 = toErl 1
  in let head_257 = toErl 1
  in let
    val_247 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_249,
         ErlangCons head_251
           (ErlangCons head_253
              (ErlangCons head_255 (ErlangCons head_257 ErlangEmptyList)))]
  in let tup_el_261 = toErl 1
  in let head_263 = toErl 1
  in let head_265 = toErl 1
  in let head_267 = toErl 1
  in let head_269 = toErl 1
  in let
    val_259 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_261,
         ErlangCons head_263
           (ErlangCons head_265
              (ErlangCons head_267 (ErlangCons head_269 ErlangEmptyList)))]
  in let tup_el_273 = toErl 2
  in let head_275 = toErl 1
  in let head_277 = toErl 1
  in let head_279 = toErl 1
  in let head_281 = toErl 1
  in let
    val_271 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_273,
         ErlangCons head_275
           (ErlangCons head_277
              (ErlangCons head_279 (ErlangCons head_281 ErlangEmptyList)))]
  in let tup_el_285 = toErl 3
  in let head_287 = toErl 1
  in let head_289 = toErl 1
  in let head_291 = toErl 1
  in let head_293 = toErl 1
  in let
    val_283 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_285,
         ErlangCons head_287
           (ErlangCons head_289
              (ErlangCons head_291 (ErlangCons head_293 ErlangEmptyList)))]
  in let tup_el_297 = toErl 0
  in let head_299 = toErl 3
  in let
    val_295 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_297,
         ErlangCons head_299 ErlangEmptyList]
  in let tup_el_303 = toErl 0
  in let head_305 = toErl 2
  in let
    val_301 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_303,
         ErlangCons head_305 ErlangEmptyList]
  in let tup_el_309 = toErl 0
  in let head_311 = toErl 2
  in let
    val_307 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_309,
         ErlangCons head_311 ErlangEmptyList]
  in let tup_el_315 = toErl 0
  in let
    val_313 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_315,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_319 = toErl 1
  in let
    val_317 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_319,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_323 = toErl 2
  in let
    val_321 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_323,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_327 = toErl 3
  in let
    val_325 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_327,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_331 = toErl 4
  in let
    val_329 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_331,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_335 = toErl 5
  in let
    val_333 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_335,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_339 = toErl 6
  in let
    val_337 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_339,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_343 = toErl 7
  in let
    val_341 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_343,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_347 = toErl 8
  in let
    val_345 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_347,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_351 = toErl 9
  in let
    val_349 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_351,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_355 = toErl 10
  in let
    val_353 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_355,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_359 = toErl 11
  in let
    val_357 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_359,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_363 = toErl 12
  in let
    val_361 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_363,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_367 = toErl 13
  in let
    val_365 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_367,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_371 = toErl 14
  in let
    val_369 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_371,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_375 = toErl 15
  in let
    val_373 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_375,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_379 = toErl 16
  in let
    val_377 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_379,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_383 = toErl 17
  in let
    val_381 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_383,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_387 = toErl 18
  in let
    val_385 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_387,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_391 = toErl 19
  in let
    val_389 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_391,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_395 = toErl 20
  in let
    val_393 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_395,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let tup_el_399 = toErl 21
  in let
    val_397 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_399,
         ErlangCons head_1
           (ErlangCons head_3
              (ErlangCons head_5
                 (ErlangCons head_7
                    (ErlangCons head_9
                       (ErlangCons head_11
                          (ErlangCons head_13
                             (ErlangCons head_15
                                (ErlangCons head_17
                                   (ErlangCons head_19
                                      (ErlangCons head_21
                                         (ErlangCons head_23
                                            (ErlangCons head_25
                                               (ErlangCons head_27
                                                  (ErlangCons head_29
                                                     (ErlangCons head_31
                                                        (ErlangCons head_33
                                                           (ErlangCons head_35
                                                              (ErlangCons
                                                                 head_37
                                                                 (ErlangCons
                                                                    head_39
                                                                    (ErlangCons
                                                                       head_41
                                                                       (ErlangCons
                                                                          head_43
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let
    val_57 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangCons head_59 ErlangEmptyList) val_215,
            DT.Tuple (ErlangCons head_62 ErlangEmptyList) val_223,
            DT.Tuple (ErlangCons head_65 ErlangEmptyList) val_231,
            DT.Tuple (ErlangCons head_68 ErlangEmptyList) val_239,
            DT.Tuple
              (ErlangCons head_71 (ErlangCons head_73 ErlangEmptyList))
              val_247,
            DT.Tuple
              (ErlangCons head_76 (ErlangCons head_78 ErlangEmptyList))
              val_259,
            DT.Tuple
              (ErlangCons head_81 (ErlangCons head_83 ErlangEmptyList))
              val_271,
            DT.Tuple
              (ErlangCons head_86 (ErlangCons head_88 ErlangEmptyList))
              val_283,
            DT.Tuple
              (ErlangCons head_91 (ErlangCons head_93 ErlangEmptyList))
              val_295,
            DT.Tuple
              (ErlangCons head_96 (ErlangCons head_98 ErlangEmptyList))
              val_301,
            DT.Tuple
              (ErlangCons head_101 (ErlangCons head_103 ErlangEmptyList))
              val_307,
            DT.Tuple
              (ErlangCons head_106 (ErlangCons head_108 ErlangEmptyList))
              val_313,
            DT.Tuple
              (ErlangCons head_111 (ErlangCons head_113 ErlangEmptyList))
              val_317,
            DT.Tuple
              (ErlangCons head_116 (ErlangCons head_118 ErlangEmptyList))
              val_321,
            DT.Tuple
              (ErlangCons head_121 (ErlangCons head_123 ErlangEmptyList))
              val_325,
            DT.Tuple
              (ErlangCons head_126 (ErlangCons head_128 ErlangEmptyList))
              val_329,
            DT.Tuple
              (ErlangCons head_131 (ErlangCons head_133 ErlangEmptyList))
              val_333,
            DT.Tuple
              (ErlangCons head_136 (ErlangCons head_138 ErlangEmptyList))
              val_337,
            DT.Tuple
              (ErlangCons head_141 (ErlangCons head_143 ErlangEmptyList))
              val_341,
            DT.Tuple
              (ErlangCons head_146 (ErlangCons head_148 ErlangEmptyList))
              val_345,
            DT.Tuple
              (ErlangCons head_151 (ErlangCons head_153 ErlangEmptyList))
              val_349,
            DT.Tuple
              (ErlangCons head_156 (ErlangCons head_158 ErlangEmptyList))
              val_353,
            DT.Tuple
              (ErlangCons head_161 (ErlangCons head_163 ErlangEmptyList))
              val_357,
            DT.Tuple
              (ErlangCons head_166 (ErlangCons head_168 ErlangEmptyList))
              val_361,
            DT.Tuple
              (ErlangCons head_171 (ErlangCons head_173 ErlangEmptyList))
              val_365,
            DT.Tuple
              (ErlangCons head_176 (ErlangCons head_178 ErlangEmptyList))
              val_369,
            DT.Tuple
              (ErlangCons head_181 (ErlangCons head_183 ErlangEmptyList))
              val_373,
            DT.Tuple
              (ErlangCons head_186 (ErlangCons head_188 ErlangEmptyList))
              val_377,
            DT.Tuple
              (ErlangCons head_191 (ErlangCons head_193 ErlangEmptyList))
              val_381,
            DT.Tuple
              (ErlangCons head_196 (ErlangCons head_198 ErlangEmptyList))
              val_385,
            DT.Tuple
              (ErlangCons head_201 (ErlangCons head_203 ErlangEmptyList))
              val_389,
            DT.Tuple
              (ErlangCons head_206 (ErlangCons head_208 ErlangEmptyList))
              val_393,
            DT.Tuple
              (ErlangCons head_211 (ErlangCons head_213 ErlangEmptyList))
              val_397])
  in let val_402 = ErlangMap Map.empty
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "type_env") val_53,
          DT.Tuple (ErlangAtom "fun_env") val_54,
          DT.Tuple (ErlangAtom "builtins") val_55,
          DT.Tuple (ErlangAtom "child_con_env") val_56,
          DT.Tuple (ErlangAtom "con_env") val_57,
          DT.Tuple (ErlangAtom "options") options_0,
          DT.Tuple (ErlangAtom "functions") val_402])
erlps__init_env__1 [arg_403] = EXC.function_clause unit
erlps__init_env__1 args =
  EXC.badarity (ErlangFun 1 erlps__init_env__1) args

erlps__builtins__0 :: ErlangFun
erlps__builtins__0 [] =
  let   
    mkname_13 =
      ErlangFun 2
        (let
           lambda_0 [ns_3, fun_4] =
             let   
               arg_7 =
                 BIF.erlang__op_append [ns_3, ErlangCons fun_4 ErlangEmptyList]
             in let arg_12 = toErl "_"
             in let
               arg_6 =
                 BIF.do_remote_fun_call "String" "erlps__join__2"
                   [arg_7, arg_12]
             in let
               arg_5 =
                 BIF.do_remote_fun_call "String" "erlps__to_lower__1" [arg_6]
             in BIF.erlang__list_to_atom__1 [arg_5]
           lambda_0 [arg_1, arg_2] = EXC.function_clause unit
           lambda_0 args = EXC.badarity (ErlangFun 2 lambda_0) args
         in lambda_0)
  in let tup_el_18 = toErl "abort"
  in let tup_el_19 = toErl 1
  in let head_17 = ErlangTuple [tup_el_18, tup_el_19]
  in let tup_el_22 = toErl "require"
  in let tup_el_23 = toErl 2
  in let head_21 = ErlangTuple [tup_el_22, tup_el_23]
  in let
    head_14 =
      ErlangTuple
        [ErlangEmptyList,
         ErlangCons head_17 (ErlangCons head_21 ErlangEmptyList)]
  in let head_28 = toErl "Chain"
  in let tup_el_32 = toErl "spend"
  in let tup_el_33 = toErl 2
  in let head_31 = ErlangTuple [tup_el_32, tup_el_33]
  in let tup_el_36 = toErl "balance"
  in let tup_el_37 = toErl 1
  in let head_35 = ErlangTuple [tup_el_36, tup_el_37]
  in let tup_el_40 = toErl "block_hash"
  in let tup_el_41 = toErl 1
  in let head_39 = ErlangTuple [tup_el_40, tup_el_41]
  in let tup_el_44 = toErl "coinbase"
  in let head_43 = ErlangTuple [tup_el_44, ErlangAtom "none"]
  in let tup_el_48 = toErl "timestamp"
  in let head_47 = ErlangTuple [tup_el_48, ErlangAtom "none"]
  in let tup_el_52 = toErl "block_height"
  in let head_51 = ErlangTuple [tup_el_52, ErlangAtom "none"]
  in let tup_el_56 = toErl "difficulty"
  in let head_55 = ErlangTuple [tup_el_56, ErlangAtom "none"]
  in let tup_el_60 = toErl "gas_limit"
  in let head_59 = ErlangTuple [tup_el_60, ErlangAtom "none"]
  in let tup_el_64 = toErl "bytecode_hash"
  in let tup_el_65 = toErl 1
  in let head_63 = ErlangTuple [tup_el_64, tup_el_65]
  in let tup_el_68 = toErl "create"
  in let head_67 = ErlangTuple [tup_el_68, ErlangAtom "variable"]
  in let tup_el_72 = toErl "clone"
  in let head_71 = ErlangTuple [tup_el_72, ErlangAtom "variable"]
  in let
    head_26 =
      ErlangTuple
        [ErlangCons head_28 ErlangEmptyList,
         ErlangCons head_31
           (ErlangCons head_35
              (ErlangCons head_39
                 (ErlangCons head_43
                    (ErlangCons head_47
                       (ErlangCons head_51
                          (ErlangCons head_55
                             (ErlangCons head_59
                                (ErlangCons head_63
                                   (ErlangCons head_67
                                      (ErlangCons head_71
                                         ErlangEmptyList))))))))))]
  in let head_78 = toErl "Contract"
  in let tup_el_82 = toErl "address"
  in let head_81 = ErlangTuple [tup_el_82, ErlangAtom "none"]
  in let tup_el_86 = toErl "balance"
  in let head_85 = ErlangTuple [tup_el_86, ErlangAtom "none"]
  in let tup_el_90 = toErl "creator"
  in let head_89 = ErlangTuple [tup_el_90, ErlangAtom "none"]
  in let
    head_76 =
      ErlangTuple
        [ErlangCons head_78 ErlangEmptyList,
         ErlangCons head_81
           (ErlangCons head_85 (ErlangCons head_89 ErlangEmptyList))]
  in let head_96 = toErl "Call"
  in let tup_el_100 = toErl "origin"
  in let head_99 = ErlangTuple [tup_el_100, ErlangAtom "none"]
  in let tup_el_104 = toErl "caller"
  in let head_103 = ErlangTuple [tup_el_104, ErlangAtom "none"]
  in let tup_el_108 = toErl "value"
  in let head_107 = ErlangTuple [tup_el_108, ErlangAtom "none"]
  in let tup_el_112 = toErl "gas_price"
  in let head_111 = ErlangTuple [tup_el_112, ErlangAtom "none"]
  in let tup_el_116 = toErl "fee"
  in let head_115 = ErlangTuple [tup_el_116, ErlangAtom "none"]
  in let tup_el_120 = toErl "gas_left"
  in let tup_el_121 = toErl 0
  in let head_119 = ErlangTuple [tup_el_120, tup_el_121]
  in let
    head_94 =
      ErlangTuple
        [ErlangCons head_96 ErlangEmptyList,
         ErlangCons head_99
           (ErlangCons head_103
              (ErlangCons head_107
                 (ErlangCons head_111
                    (ErlangCons head_115
                       (ErlangCons head_119 ErlangEmptyList)))))]
  in let head_126 = toErl "Oracle"
  in let tup_el_130 = toErl "register"
  in let tup_el_131 = toErl 4
  in let head_129 = ErlangTuple [tup_el_130, tup_el_131]
  in let tup_el_134 = toErl "expiry"
  in let tup_el_135 = toErl 1
  in let head_133 = ErlangTuple [tup_el_134, tup_el_135]
  in let tup_el_138 = toErl "query_fee"
  in let tup_el_139 = toErl 1
  in let head_137 = ErlangTuple [tup_el_138, tup_el_139]
  in let tup_el_142 = toErl "query"
  in let tup_el_143 = toErl 5
  in let head_141 = ErlangTuple [tup_el_142, tup_el_143]
  in let tup_el_146 = toErl "get_question"
  in let tup_el_147 = toErl 2
  in let head_145 = ErlangTuple [tup_el_146, tup_el_147]
  in let tup_el_150 = toErl "respond"
  in let tup_el_151 = toErl 4
  in let head_149 = ErlangTuple [tup_el_150, tup_el_151]
  in let tup_el_154 = toErl "extend"
  in let tup_el_155 = toErl 3
  in let head_153 = ErlangTuple [tup_el_154, tup_el_155]
  in let tup_el_158 = toErl "get_answer"
  in let tup_el_159 = toErl 2
  in let head_157 = ErlangTuple [tup_el_158, tup_el_159]
  in let tup_el_162 = toErl "check"
  in let tup_el_163 = toErl 1
  in let head_161 = ErlangTuple [tup_el_162, tup_el_163]
  in let tup_el_166 = toErl "check_query"
  in let tup_el_167 = toErl 2
  in let head_165 = ErlangTuple [tup_el_166, tup_el_167]
  in let
    head_124 =
      ErlangTuple
        [ErlangCons head_126 ErlangEmptyList,
         ErlangCons head_129
           (ErlangCons head_133
              (ErlangCons head_137
                 (ErlangCons head_141
                    (ErlangCons head_145
                       (ErlangCons head_149
                          (ErlangCons head_153
                             (ErlangCons head_157
                                (ErlangCons head_161
                                   (ErlangCons head_165
                                      ErlangEmptyList)))))))))]
  in let head_172 = toErl "AENS"
  in let tup_el_176 = toErl "resolve"
  in let tup_el_177 = toErl 2
  in let head_175 = ErlangTuple [tup_el_176, tup_el_177]
  in let tup_el_180 = toErl "preclaim"
  in let tup_el_181 = toErl 3
  in let head_179 = ErlangTuple [tup_el_180, tup_el_181]
  in let tup_el_184 = toErl "claim"
  in let tup_el_185 = toErl 5
  in let head_183 = ErlangTuple [tup_el_184, tup_el_185]
  in let tup_el_188 = toErl "transfer"
  in let tup_el_189 = toErl 4
  in let head_187 = ErlangTuple [tup_el_188, tup_el_189]
  in let tup_el_192 = toErl "revoke"
  in let tup_el_193 = toErl 3
  in let head_191 = ErlangTuple [tup_el_192, tup_el_193]
  in let tup_el_196 = toErl "update"
  in let tup_el_197 = toErl 6
  in let head_195 = ErlangTuple [tup_el_196, tup_el_197]
  in let tup_el_200 = toErl "lookup"
  in let tup_el_201 = toErl 1
  in let head_199 = ErlangTuple [tup_el_200, tup_el_201]
  in let
    head_170 =
      ErlangTuple
        [ErlangCons head_172 ErlangEmptyList,
         ErlangCons head_175
           (ErlangCons head_179
              (ErlangCons head_183
                 (ErlangCons head_187
                    (ErlangCons head_191
                       (ErlangCons head_195
                          (ErlangCons head_199 ErlangEmptyList))))))]
  in let head_206 = toErl "Map"
  in let tup_el_210 = toErl "from_list"
  in let tup_el_211 = toErl 1
  in let head_209 = ErlangTuple [tup_el_210, tup_el_211]
  in let tup_el_214 = toErl "to_list"
  in let tup_el_215 = toErl 1
  in let head_213 = ErlangTuple [tup_el_214, tup_el_215]
  in let tup_el_218 = toErl "lookup"
  in let tup_el_219 = toErl 2
  in let head_217 = ErlangTuple [tup_el_218, tup_el_219]
  in let tup_el_222 = toErl "lookup_default"
  in let tup_el_223 = toErl 3
  in let head_221 = ErlangTuple [tup_el_222, tup_el_223]
  in let tup_el_226 = toErl "delete"
  in let tup_el_227 = toErl 2
  in let head_225 = ErlangTuple [tup_el_226, tup_el_227]
  in let tup_el_230 = toErl "member"
  in let tup_el_231 = toErl 2
  in let head_229 = ErlangTuple [tup_el_230, tup_el_231]
  in let tup_el_234 = toErl "size"
  in let tup_el_235 = toErl 1
  in let head_233 = ErlangTuple [tup_el_234, tup_el_235]
  in let
    head_204 =
      ErlangTuple
        [ErlangCons head_206 ErlangEmptyList,
         ErlangCons head_209
           (ErlangCons head_213
              (ErlangCons head_217
                 (ErlangCons head_221
                    (ErlangCons head_225
                       (ErlangCons head_229
                          (ErlangCons head_233 ErlangEmptyList))))))]
  in let head_240 = toErl "Crypto"
  in let tup_el_244 = toErl "verify_sig"
  in let tup_el_245 = toErl 3
  in let head_243 = ErlangTuple [tup_el_244, tup_el_245]
  in let tup_el_248 = toErl "verify_sig_secp256k1"
  in let tup_el_249 = toErl 3
  in let head_247 = ErlangTuple [tup_el_248, tup_el_249]
  in let tup_el_252 = toErl "ecverify_secp256k1"
  in let tup_el_253 = toErl 3
  in let head_251 = ErlangTuple [tup_el_252, tup_el_253]
  in let tup_el_256 = toErl "ecrecover_secp256k1"
  in let tup_el_257 = toErl 2
  in let head_255 = ErlangTuple [tup_el_256, tup_el_257]
  in let tup_el_260 = toErl "sha3"
  in let tup_el_261 = toErl 1
  in let head_259 = ErlangTuple [tup_el_260, tup_el_261]
  in let tup_el_264 = toErl "sha256"
  in let tup_el_265 = toErl 1
  in let head_263 = ErlangTuple [tup_el_264, tup_el_265]
  in let tup_el_268 = toErl "blake2b"
  in let tup_el_269 = toErl 1
  in let head_267 = ErlangTuple [tup_el_268, tup_el_269]
  in let
    head_238 =
      ErlangTuple
        [ErlangCons head_240 ErlangEmptyList,
         ErlangCons head_243
           (ErlangCons head_247
              (ErlangCons head_251
                 (ErlangCons head_255
                    (ErlangCons head_259
                       (ErlangCons head_263
                          (ErlangCons head_267 ErlangEmptyList))))))]
  in let head_274 = toErl "MCL_BLS12_381"
  in let tup_el_278 = toErl "g1_neg"
  in let tup_el_279 = toErl 1
  in let head_277 = ErlangTuple [tup_el_278, tup_el_279]
  in let tup_el_282 = toErl "g1_norm"
  in let tup_el_283 = toErl 1
  in let head_281 = ErlangTuple [tup_el_282, tup_el_283]
  in let tup_el_286 = toErl "g1_valid"
  in let tup_el_287 = toErl 1
  in let head_285 = ErlangTuple [tup_el_286, tup_el_287]
  in let tup_el_290 = toErl "g1_is_zero"
  in let tup_el_291 = toErl 1
  in let head_289 = ErlangTuple [tup_el_290, tup_el_291]
  in let tup_el_294 = toErl "g1_add"
  in let tup_el_295 = toErl 2
  in let head_293 = ErlangTuple [tup_el_294, tup_el_295]
  in let tup_el_298 = toErl "g1_mul"
  in let tup_el_299 = toErl 2
  in let head_297 = ErlangTuple [tup_el_298, tup_el_299]
  in let tup_el_302 = toErl "g2_neg"
  in let tup_el_303 = toErl 1
  in let head_301 = ErlangTuple [tup_el_302, tup_el_303]
  in let tup_el_306 = toErl "g2_norm"
  in let tup_el_307 = toErl 1
  in let head_305 = ErlangTuple [tup_el_306, tup_el_307]
  in let tup_el_310 = toErl "g2_valid"
  in let tup_el_311 = toErl 1
  in let head_309 = ErlangTuple [tup_el_310, tup_el_311]
  in let tup_el_314 = toErl "g2_is_zero"
  in let tup_el_315 = toErl 1
  in let head_313 = ErlangTuple [tup_el_314, tup_el_315]
  in let tup_el_318 = toErl "g2_add"
  in let tup_el_319 = toErl 2
  in let head_317 = ErlangTuple [tup_el_318, tup_el_319]
  in let tup_el_322 = toErl "g2_mul"
  in let tup_el_323 = toErl 2
  in let head_321 = ErlangTuple [tup_el_322, tup_el_323]
  in let tup_el_326 = toErl "gt_inv"
  in let tup_el_327 = toErl 1
  in let head_325 = ErlangTuple [tup_el_326, tup_el_327]
  in let tup_el_330 = toErl "gt_add"
  in let tup_el_331 = toErl 2
  in let head_329 = ErlangTuple [tup_el_330, tup_el_331]
  in let tup_el_334 = toErl "gt_mul"
  in let tup_el_335 = toErl 2
  in let head_333 = ErlangTuple [tup_el_334, tup_el_335]
  in let tup_el_338 = toErl "gt_pow"
  in let tup_el_339 = toErl 2
  in let head_337 = ErlangTuple [tup_el_338, tup_el_339]
  in let tup_el_342 = toErl "gt_is_one"
  in let tup_el_343 = toErl 1
  in let head_341 = ErlangTuple [tup_el_342, tup_el_343]
  in let tup_el_346 = toErl "pairing"
  in let tup_el_347 = toErl 2
  in let head_345 = ErlangTuple [tup_el_346, tup_el_347]
  in let tup_el_350 = toErl "miller_loop"
  in let tup_el_351 = toErl 2
  in let head_349 = ErlangTuple [tup_el_350, tup_el_351]
  in let tup_el_354 = toErl "final_exp"
  in let tup_el_355 = toErl 1
  in let head_353 = ErlangTuple [tup_el_354, tup_el_355]
  in let tup_el_358 = toErl "int_to_fr"
  in let tup_el_359 = toErl 1
  in let head_357 = ErlangTuple [tup_el_358, tup_el_359]
  in let tup_el_362 = toErl "int_to_fp"
  in let tup_el_363 = toErl 1
  in let head_361 = ErlangTuple [tup_el_362, tup_el_363]
  in let tup_el_366 = toErl "fr_to_int"
  in let tup_el_367 = toErl 1
  in let head_365 = ErlangTuple [tup_el_366, tup_el_367]
  in let tup_el_370 = toErl "fp_to_int"
  in let tup_el_371 = toErl 1
  in let head_369 = ErlangTuple [tup_el_370, tup_el_371]
  in let
    head_272 =
      ErlangTuple
        [ErlangCons head_274 ErlangEmptyList,
         ErlangCons head_277
           (ErlangCons head_281
              (ErlangCons head_285
                 (ErlangCons head_289
                    (ErlangCons head_293
                       (ErlangCons head_297
                          (ErlangCons head_301
                             (ErlangCons head_305
                                (ErlangCons head_309
                                   (ErlangCons head_313
                                      (ErlangCons head_317
                                         (ErlangCons head_321
                                            (ErlangCons head_325
                                               (ErlangCons head_329
                                                  (ErlangCons head_333
                                                     (ErlangCons head_337
                                                        (ErlangCons head_341
                                                           (ErlangCons head_345
                                                              (ErlangCons
                                                                 head_349
                                                                 (ErlangCons
                                                                    head_353
                                                                    (ErlangCons
                                                                       head_357
                                                                       (ErlangCons
                                                                          head_361
                                                                          (ErlangCons
                                                                             head_365
                                                                             (ErlangCons
                                                                                head_369
                                                                                ErlangEmptyList)))))))))))))))))))))))]
  in let head_376 = toErl "StringInternal"
  in let tup_el_380 = toErl "length"
  in let tup_el_381 = toErl 1
  in let head_379 = ErlangTuple [tup_el_380, tup_el_381]
  in let tup_el_384 = toErl "concat"
  in let tup_el_385 = toErl 2
  in let head_383 = ErlangTuple [tup_el_384, tup_el_385]
  in let tup_el_388 = toErl "to_list"
  in let tup_el_389 = toErl 1
  in let head_387 = ErlangTuple [tup_el_388, tup_el_389]
  in let tup_el_392 = toErl "from_list"
  in let tup_el_393 = toErl 1
  in let head_391 = ErlangTuple [tup_el_392, tup_el_393]
  in let tup_el_396 = toErl "sha3"
  in let tup_el_397 = toErl 1
  in let head_395 = ErlangTuple [tup_el_396, tup_el_397]
  in let tup_el_400 = toErl "sha256"
  in let tup_el_401 = toErl 1
  in let head_399 = ErlangTuple [tup_el_400, tup_el_401]
  in let tup_el_404 = toErl "blake2b"
  in let tup_el_405 = toErl 1
  in let head_403 = ErlangTuple [tup_el_404, tup_el_405]
  in let tup_el_408 = toErl "to_lower"
  in let tup_el_409 = toErl 1
  in let head_407 = ErlangTuple [tup_el_408, tup_el_409]
  in let tup_el_412 = toErl "to_upper"
  in let tup_el_413 = toErl 1
  in let head_411 = ErlangTuple [tup_el_412, tup_el_413]
  in let
    head_374 =
      ErlangTuple
        [ErlangCons head_376 ErlangEmptyList,
         ErlangCons head_379
           (ErlangCons head_383
              (ErlangCons head_387
                 (ErlangCons head_391
                    (ErlangCons head_395
                       (ErlangCons head_399
                          (ErlangCons head_403
                             (ErlangCons head_407
                                (ErlangCons head_411 ErlangEmptyList))))))))]
  in let head_418 = toErl "Char"
  in let tup_el_422 = toErl "to_int"
  in let tup_el_423 = toErl 1
  in let head_421 = ErlangTuple [tup_el_422, tup_el_423]
  in let tup_el_426 = toErl "from_int"
  in let tup_el_427 = toErl 1
  in let head_425 = ErlangTuple [tup_el_426, tup_el_427]
  in let
    head_416 =
      ErlangTuple
        [ErlangCons head_418 ErlangEmptyList,
         ErlangCons head_421 (ErlangCons head_425 ErlangEmptyList)]
  in let head_432 = toErl "Auth"
  in let tup_el_436 = toErl "tx_hash"
  in let head_435 = ErlangTuple [tup_el_436, ErlangAtom "none"]
  in let tup_el_440 = toErl "tx"
  in let head_439 = ErlangTuple [tup_el_440, ErlangAtom "none"]
  in let
    head_430 =
      ErlangTuple
        [ErlangCons head_432 ErlangEmptyList,
         ErlangCons head_435 (ErlangCons head_439 ErlangEmptyList)]
  in let head_446 = toErl "Bits"
  in let tup_el_450 = toErl "set"
  in let tup_el_451 = toErl 2
  in let head_449 = ErlangTuple [tup_el_450, tup_el_451]
  in let tup_el_454 = toErl "clear"
  in let tup_el_455 = toErl 2
  in let head_453 = ErlangTuple [tup_el_454, tup_el_455]
  in let tup_el_458 = toErl "test"
  in let tup_el_459 = toErl 2
  in let head_457 = ErlangTuple [tup_el_458, tup_el_459]
  in let tup_el_462 = toErl "sum"
  in let tup_el_463 = toErl 1
  in let head_461 = ErlangTuple [tup_el_462, tup_el_463]
  in let tup_el_466 = toErl "intersection"
  in let tup_el_467 = toErl 2
  in let head_465 = ErlangTuple [tup_el_466, tup_el_467]
  in let tup_el_470 = toErl "union"
  in let tup_el_471 = toErl 2
  in let head_469 = ErlangTuple [tup_el_470, tup_el_471]
  in let tup_el_474 = toErl "difference"
  in let tup_el_475 = toErl 2
  in let head_473 = ErlangTuple [tup_el_474, tup_el_475]
  in let tup_el_478 = toErl "none"
  in let head_477 = ErlangTuple [tup_el_478, ErlangAtom "none"]
  in let tup_el_482 = toErl "all"
  in let head_481 = ErlangTuple [tup_el_482, ErlangAtom "none"]
  in let
    head_444 =
      ErlangTuple
        [ErlangCons head_446 ErlangEmptyList,
         ErlangCons head_449
           (ErlangCons head_453
              (ErlangCons head_457
                 (ErlangCons head_461
                    (ErlangCons head_465
                       (ErlangCons head_469
                          (ErlangCons head_473
                             (ErlangCons head_477
                                (ErlangCons head_481 ErlangEmptyList))))))))]
  in let head_488 = toErl "Bytes"
  in let tup_el_492 = toErl "to_int"
  in let tup_el_493 = toErl 1
  in let head_491 = ErlangTuple [tup_el_492, tup_el_493]
  in let tup_el_496 = toErl "to_str"
  in let tup_el_497 = toErl 1
  in let head_495 = ErlangTuple [tup_el_496, tup_el_497]
  in let tup_el_500 = toErl "concat"
  in let tup_el_501 = toErl 2
  in let head_499 = ErlangTuple [tup_el_500, tup_el_501]
  in let tup_el_504 = toErl "split"
  in let tup_el_505 = toErl 1
  in let head_503 = ErlangTuple [tup_el_504, tup_el_505]
  in let
    head_486 =
      ErlangTuple
        [ErlangCons head_488 ErlangEmptyList,
         ErlangCons head_491
           (ErlangCons head_495
              (ErlangCons head_499 (ErlangCons head_503 ErlangEmptyList)))]
  in let head_510 = toErl "Int"
  in let tup_el_514 = toErl "to_str"
  in let tup_el_515 = toErl 1
  in let head_513 = ErlangTuple [tup_el_514, tup_el_515]
  in let
    head_508 =
      ErlangTuple
        [ErlangCons head_510 ErlangEmptyList,
         ErlangCons head_513 ErlangEmptyList]
  in let head_520 = toErl "Address"
  in let tup_el_524 = toErl "to_str"
  in let tup_el_525 = toErl 1
  in let head_523 = ErlangTuple [tup_el_524, tup_el_525]
  in let tup_el_528 = toErl "to_contract"
  in let tup_el_529 = toErl 1
  in let head_527 = ErlangTuple [tup_el_528, tup_el_529]
  in let tup_el_532 = toErl "is_oracle"
  in let tup_el_533 = toErl 1
  in let head_531 = ErlangTuple [tup_el_532, tup_el_533]
  in let tup_el_536 = toErl "is_contract"
  in let tup_el_537 = toErl 1
  in let head_535 = ErlangTuple [tup_el_536, tup_el_537]
  in let tup_el_540 = toErl "is_payable"
  in let tup_el_541 = toErl 1
  in let head_539 = ErlangTuple [tup_el_540, tup_el_541]
  in let
    head_518 =
      ErlangTuple
        [ErlangCons head_520 ErlangEmptyList,
         ErlangCons head_523
           (ErlangCons head_527
              (ErlangCons head_531
                 (ErlangCons head_535 (ErlangCons head_539 ErlangEmptyList))))]
  in let
    arg_545 =
      flmap
        (\ lc_549 ->
           case lc_549 of
             (ErlangTuple [ns_547, funs_548]) ->
               flmap
                 (\ lc_553 ->
                    case lc_553 of
                      (ErlangTuple [fun_551, arity_552]) ->
                        let   
                          tup_el_555 =
                            BIF.erlang__op_append
                              [ns_547, ErlangCons fun_551 ErlangEmptyList]
                        in let
                          tup_el_561 =
                            BIF.erlang__apply__2
                              [mkname_13,
                               ErlangCons ns_547
                                 (ErlangCons fun_551 ErlangEmptyList)]
                        in let tup_el_560 = ErlangTuple [tup_el_561, arity_552]
                        in let lcRet_554 = ErlangTuple [tup_el_555, tup_el_560]
                        in ErlangCons lcRet_554 ErlangEmptyList
                      _ -> ErlangEmptyList)
                 funs_548
             _ -> ErlangEmptyList)
        (ErlangCons head_14
           (ErlangCons head_26
              (ErlangCons head_76
                 (ErlangCons head_94
                    (ErlangCons head_124
                       (ErlangCons head_170
                          (ErlangCons head_204
                             (ErlangCons head_238
                                (ErlangCons head_272
                                   (ErlangCons head_374
                                      (ErlangCons head_416
                                         (ErlangCons head_430
                                            (ErlangCons head_444
                                               (ErlangCons head_486
                                                  (ErlangCons head_508
                                                     (ErlangCons head_518
                                                        ErlangEmptyList))))))))))))))))
  in BIF.maps__from_list__1 [arg_545]
erlps__builtins__0 args =
  EXC.badarity (ErlangFun 0 erlps__builtins__0) args

erlps__state_layout__1 :: ErlangFun
erlps__state_layout__1 [env_0] =
  let    tup_el_5 = toErl 1
  in let arg_3 = ErlangTuple [ErlangAtom "reg", tup_el_5]
  in
    BIF.do_remote_fun_call "Maps" "erlps__get__3"
      [ErlangAtom "state_layout", env_0, arg_3]
erlps__state_layout__1 [arg_6] = EXC.function_clause unit
erlps__state_layout__1 args =
  EXC.badarity (ErlangFun 1 erlps__state_layout__1) args

erlps__init_type_env__0 :: ErlangFun
erlps__init_type_env__0 [] =
  let   
    basetx_90 =
      ErlangTuple
        [ErlangAtom "variant",
         ErlangCons
           (ErlangCons (ErlangAtom "address")
              (ErlangCons (ErlangAtom "integer")
                 (ErlangCons (ErlangAtom "string") ErlangEmptyList)))
           (ErlangCons ErlangEmptyList
              (ErlangCons ErlangEmptyList
                 (ErlangCons ErlangEmptyList
                    (ErlangCons ErlangEmptyList
                       (ErlangCons ErlangEmptyList
                          (ErlangCons
                             (ErlangCons (ErlangAtom "string") ErlangEmptyList)
                             (ErlangCons
                                (ErlangCons (ErlangAtom "hash") ErlangEmptyList)
                                (ErlangCons
                                   (ErlangCons (ErlangAtom "hash")
                                      ErlangEmptyList)
                                   (ErlangCons
                                      (ErlangCons (ErlangAtom "address")
                                         (ErlangCons (ErlangAtom "hash")
                                            ErlangEmptyList))
                                      (ErlangCons
                                         (ErlangCons (ErlangAtom "address")
                                            ErlangEmptyList)
                                         (ErlangCons
                                            (ErlangCons (ErlangAtom "address")
                                               (ErlangCons
                                                  (ErlangAtom "integer")
                                                  ErlangEmptyList))
                                            (ErlangCons
                                               (ErlangCons
                                                  (ErlangAtom "address")
                                                  (ErlangCons
                                                     (ErlangAtom "integer")
                                                     ErlangEmptyList))
                                               (ErlangCons
                                                  (ErlangCons
                                                     (ErlangAtom "address")
                                                     ErlangEmptyList)
                                                  (ErlangCons
                                                     (ErlangCons
                                                        (ErlangAtom "address")
                                                        ErlangEmptyList)
                                                     (ErlangCons
                                                        (ErlangCons
                                                           (ErlangAtom
                                                              "address")
                                                           ErlangEmptyList)
                                                        (ErlangCons
                                                           (ErlangCons
                                                              (ErlangAtom
                                                                 "address")
                                                              ErlangEmptyList)
                                                           (ErlangCons
                                                              (ErlangCons
                                                                 (ErlangAtom
                                                                    "address")
                                                                 ErlangEmptyList)
                                                              (ErlangCons
                                                                 (ErlangCons
                                                                    (ErlangAtom
                                                                       "address")
                                                                    ErlangEmptyList)
                                                                 (ErlangCons
                                                                    (ErlangCons
                                                                       (ErlangAtom
                                                                          "integer")
                                                                       ErlangEmptyList)
                                                                    (ErlangCons
                                                                       (ErlangCons
                                                                          (ErlangAtom
                                                                             "address")
                                                                          (ErlangCons
                                                                             (ErlangAtom
                                                                                "integer")
                                                                             ErlangEmptyList))
                                                                       (ErlangCons
                                                                          ErlangEmptyList
                                                                          ErlangEmptyList)))))))))))))))))))))]
  in let head_92 = toErl "int"
  in let head_95 = toErl "bool"
  in let head_98 = toErl "bits"
  in let head_101 = toErl "char"
  in let head_104 = toErl "string"
  in let head_107 = toErl "address"
  in let head_110 = toErl "hash"
  in let head_113 = toErl "signature"
  in let head_116 = toErl "oracle"
  in let head_119 = toErl "oracle_query"
  in let head_122 = toErl "list"
  in let head_125 = toErl "map"
  in let head_128 = toErl "option"
  in let head_131 = toErl "Chain"
  in let head_133 = toErl "ttl"
  in let head_136 = toErl "AENS"
  in let head_138 = toErl "pointee"
  in let head_141 = toErl "AENS"
  in let head_143 = toErl "name"
  in let head_146 = toErl "Chain"
  in let head_148 = toErl "ga_meta_tx"
  in let head_151 = toErl "Chain"
  in let head_153 = toErl "paying_for_tx"
  in let head_156 = toErl "Chain"
  in let head_158 = toErl "base_tx"
  in let head_161 = toErl "MCL_BLS12_381"
  in let head_163 = toErl "fr"
  in let head_166 = toErl "MCL_BLS12_381"
  in let head_168 = toErl "fp"
  in let
    val_170 =
      ErlangFun 1
        (let
           lambda_171 [(ErlangEmptyList)] = ErlangAtom "integer"
           lambda_171 [arg_172] = EXC.function_clause unit
           lambda_171 args = EXC.badarity (ErlangFun 1 lambda_171) args
         in lambda_171)
  in let
    val_173 =
      ErlangFun 1
        (let
           lambda_174 [(ErlangEmptyList)] = ErlangAtom "boolean"
           lambda_174 [arg_175] = EXC.function_clause unit
           lambda_174 args = EXC.badarity (ErlangFun 1 lambda_174) args
         in lambda_174)
  in let
    val_176 =
      ErlangFun 1
        (let
           lambda_177 [(ErlangEmptyList)] = ErlangAtom "bits"
           lambda_177 [arg_178] = EXC.function_clause unit
           lambda_177 args = EXC.badarity (ErlangFun 1 lambda_177) args
         in lambda_177)
  in let
    val_179 =
      ErlangFun 1
        (let
           lambda_180 [(ErlangEmptyList)] = ErlangAtom "integer"
           lambda_180 [arg_181] = EXC.function_clause unit
           lambda_180 args = EXC.badarity (ErlangFun 1 lambda_180) args
         in lambda_180)
  in let
    val_182 =
      ErlangFun 1
        (let
           lambda_183 [(ErlangEmptyList)] = ErlangAtom "string"
           lambda_183 [arg_184] = EXC.function_clause unit
           lambda_183 args = EXC.badarity (ErlangFun 1 lambda_183) args
         in lambda_183)
  in let
    val_185 =
      ErlangFun 1
        (let
           lambda_186 [(ErlangEmptyList)] = ErlangAtom "address"
           lambda_186 [arg_187] = EXC.function_clause unit
           lambda_186 args = EXC.badarity (ErlangFun 1 lambda_186) args
         in lambda_186)
  in let
    val_188 =
      ErlangFun 1
        (let
           lambda_189 [(ErlangEmptyList)] = ErlangAtom "hash"
           lambda_189 [arg_190] = EXC.function_clause unit
           lambda_189 args = EXC.badarity (ErlangFun 1 lambda_189) args
         in lambda_189)
  in let
    val_191 =
      ErlangFun 1
        (let
           lambda_192 [(ErlangEmptyList)] = ErlangAtom "signature"
           lambda_192 [arg_193] = EXC.function_clause unit
           lambda_192 args = EXC.badarity (ErlangFun 1 lambda_192) args
         in lambda_192)
  in let
    val_194 =
      ErlangFun 1
        (let
           lambda_195 [(ErlangCons q_197 (ErlangCons r_198 (ErlangEmptyList)))]
             =
             ErlangTuple [ErlangAtom "oracle", q_197, r_198]
           lambda_195 [arg_196] = EXC.function_clause unit
           lambda_195 args = EXC.badarity (ErlangFun 1 lambda_195) args
         in lambda_195)
  in let
    val_202 =
      ErlangFun 1
        (let
           lambda_203 [(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))] =
             ErlangAtom "oracle_query"
           lambda_203 [arg_204] = EXC.function_clause unit
           lambda_203 args = EXC.badarity (ErlangFun 1 lambda_203) args
         in lambda_203)
  in let
    val_205 =
      ErlangFun 1
        (let
           lambda_206 [(ErlangCons t_208 (ErlangEmptyList))] =
             ErlangTuple [ErlangAtom "list", t_208]
           lambda_206 [arg_207] = EXC.function_clause unit
           lambda_206 args = EXC.badarity (ErlangFun 1 lambda_206) args
         in lambda_206)
  in let
    val_211 =
      ErlangFun 1
        (let
           lambda_212 [(ErlangCons k_214 (ErlangCons v_215 (ErlangEmptyList)))]
             =
             ErlangTuple [ErlangAtom "map", k_214, v_215]
           lambda_212 [arg_213] = EXC.function_clause unit
           lambda_212 args = EXC.badarity (ErlangFun 1 lambda_212) args
         in lambda_212)
  in let
    val_219 =
      ErlangFun 1
        (let
           lambda_220 [(ErlangCons t_222 (ErlangEmptyList))] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons ErlangEmptyList
                  (ErlangCons (ErlangCons t_222 ErlangEmptyList)
                     ErlangEmptyList)]
           lambda_220 [arg_221] = EXC.function_clause unit
           lambda_220 args = EXC.badarity (ErlangFun 1 lambda_220) args
         in lambda_220)
  in let
    val_231 =
      ErlangFun 1
        (let
           lambda_232 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons (ErlangCons (ErlangAtom "integer") ErlangEmptyList)
                  (ErlangCons
                     (ErlangCons (ErlangAtom "integer") ErlangEmptyList)
                     ErlangEmptyList)]
           lambda_232 [arg_233] = EXC.function_clause unit
           lambda_232 args = EXC.badarity (ErlangFun 1 lambda_232) args
         in lambda_232)
  in let
    val_244 =
      ErlangFun 1
        (let
           lambda_245 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                  (ErlangCons
                     (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                     (ErlangCons
                        (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                        (ErlangCons
                           (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                           ErlangEmptyList)))]
           lambda_245 [arg_246] = EXC.function_clause unit
           lambda_245 args = EXC.badarity (ErlangFun 1 lambda_245) args
         in lambda_245)
  in let
    val_265 =
      ErlangFun 1
        (let
           lambda_266 [(ErlangEmptyList)] =
             let   
               head_273 =
                 ErlangTuple
                   [ErlangAtom "variant",
                    ErlangCons
                      (ErlangCons (ErlangAtom "integer") ErlangEmptyList)
                      (ErlangCons
                         (ErlangCons (ErlangAtom "integer") ErlangEmptyList)
                         ErlangEmptyList)]
             in let
               tup_el_288 =
                 ErlangTuple
                   [ErlangAtom "variant",
                    ErlangCons
                      (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                      (ErlangCons
                         (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                         (ErlangCons
                            (ErlangCons (ErlangAtom "address") ErlangEmptyList)
                            (ErlangCons
                               (ErlangCons (ErlangAtom "address")
                                  ErlangEmptyList)
                               ErlangEmptyList)))]
             in let
               head_285 =
                 ErlangTuple [ErlangAtom "map", ErlangAtom "string", tup_el_288]
             in
               ErlangTuple
                 [ErlangAtom "variant",
                  ErlangCons
                    (ErlangCons (ErlangAtom "address")
                       (ErlangCons head_273
                          (ErlangCons head_285 ErlangEmptyList)))
                    ErlangEmptyList]
           lambda_266 [arg_267] = EXC.function_clause unit
           lambda_266 args = EXC.badarity (ErlangFun 1 lambda_266) args
         in lambda_266)
  in let
    val_309 =
      ErlangFun 1
        (let
           lambda_310 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons
                  (ErlangCons (ErlangAtom "address")
                     (ErlangCons (ErlangAtom "integer") ErlangEmptyList))
                  ErlangEmptyList]
           lambda_310 [arg_311] = EXC.function_clause unit
           lambda_310 args = EXC.badarity (ErlangFun 1 lambda_310) args
         in lambda_310)
  in let
    val_320 =
      ErlangFun 1
        (let
           lambda_321 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons
                  (ErlangCons (ErlangAtom "address")
                     (ErlangCons (ErlangAtom "integer") ErlangEmptyList))
                  ErlangEmptyList]
           lambda_321 [arg_322] = EXC.function_clause unit
           lambda_321 args = EXC.badarity (ErlangFun 1 lambda_321) args
         in lambda_321)
  in let
    val_331 =
      ErlangFun 1
        (let
           lambda_332 [(ErlangEmptyList)] = basetx_90
           lambda_332 [arg_333] = EXC.function_clause unit
           lambda_332 args = EXC.badarity (ErlangFun 1 lambda_332) args
         in lambda_332)
  in let
    val_334 =
      ErlangFun 1
        (let
           lambda_335 [(ErlangEmptyList)] =
             let tup_el_338 = toErl 32
             in ErlangTuple [ErlangAtom "bytes", tup_el_338]
           lambda_335 [arg_336] = EXC.function_clause unit
           lambda_335 args = EXC.badarity (ErlangFun 1 lambda_335) args
         in lambda_335)
  in let
    val_339 =
      ErlangFun 1
        (let
           lambda_340 [(ErlangEmptyList)] =
             let tup_el_343 = toErl 48
             in ErlangTuple [ErlangAtom "bytes", tup_el_343]
           lambda_340 [arg_341] = EXC.function_clause unit
           lambda_340 args = EXC.badarity (ErlangFun 1 lambda_340) args
         in lambda_340)
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangCons head_92 ErlangEmptyList) val_170,
          DT.Tuple (ErlangCons head_95 ErlangEmptyList) val_173,
          DT.Tuple (ErlangCons head_98 ErlangEmptyList) val_176,
          DT.Tuple (ErlangCons head_101 ErlangEmptyList) val_179,
          DT.Tuple (ErlangCons head_104 ErlangEmptyList) val_182,
          DT.Tuple (ErlangCons head_107 ErlangEmptyList) val_185,
          DT.Tuple (ErlangCons head_110 ErlangEmptyList) val_188,
          DT.Tuple (ErlangCons head_113 ErlangEmptyList) val_191,
          DT.Tuple (ErlangCons head_116 ErlangEmptyList) val_194,
          DT.Tuple (ErlangCons head_119 ErlangEmptyList) val_202,
          DT.Tuple (ErlangCons head_122 ErlangEmptyList) val_205,
          DT.Tuple (ErlangCons head_125 ErlangEmptyList) val_211,
          DT.Tuple (ErlangCons head_128 ErlangEmptyList) val_219,
          DT.Tuple
            (ErlangCons head_131 (ErlangCons head_133 ErlangEmptyList))
            val_231,
          DT.Tuple
            (ErlangCons head_136 (ErlangCons head_138 ErlangEmptyList))
            val_244,
          DT.Tuple
            (ErlangCons head_141 (ErlangCons head_143 ErlangEmptyList))
            val_265,
          DT.Tuple
            (ErlangCons head_146 (ErlangCons head_148 ErlangEmptyList))
            val_309,
          DT.Tuple
            (ErlangCons head_151 (ErlangCons head_153 ErlangEmptyList))
            val_320,
          DT.Tuple
            (ErlangCons head_156 (ErlangCons head_158 ErlangEmptyList))
            val_331,
          DT.Tuple
            (ErlangCons head_161 (ErlangCons head_163 ErlangEmptyList))
            val_334,
          DT.Tuple
            (ErlangCons head_166 (ErlangCons head_168 ErlangEmptyList))
            val_339])
erlps__init_type_env__0 args =
  EXC.badarity (ErlangFun 0 erlps__init_type_env__0) args

erlps__is_no_code__1 :: ErlangFun
erlps__is_no_code__1 [env_0] =
  erlps__get_option__2 [ErlangAtom "no_code", env_0]
erlps__is_no_code__1 [arg_3] = EXC.function_clause unit
erlps__is_no_code__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_no_code__1) args

erlps__get_option__2 :: ErlangFun
erlps__get_option__2 [opt_0, env_1] =
  erlps__get_option__3 [opt_0, env_1, ErlangAtom "false"]
erlps__get_option__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__get_option__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_option__2) args

erlps__get_option__3 :: ErlangFun
erlps__get_option__3 [opt_0, env_1, default_2] =
  let
    arg_4 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [ErlangAtom "options", env_1, ErlangEmptyList]
  in
    BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
      [opt_0, arg_4, default_2]
erlps__get_option__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__get_option__3 args =
  EXC.badarity (ErlangFun 3 erlps__get_option__3) args

erlps__to_fcode__2 :: ErlangFun
erlps__to_fcode__2 [env_0,
                    (ErlangCons (ErlangTuple [contract_1, attrs_2,
                                              con_4@(ErlangTuple [(ErlangAtom "con"),
                                                                  _, name_3]),
                                              decls_5]) rest_6)]
  | ((==) contract_1 (ErlangAtom "contract_main")) ||
      (((==) contract_1 (ErlangAtom "contract_interface")) ||
         ((==) contract_1 (ErlangAtom "contract_child"))) =
  let
    case_7 =
      BIF.erlang__op_exactEq
        [contract_1, ErlangAtom "contract_interface"]
  in
    case case_7 of
      (ErlangAtom "false") ->
        case env_0 of
          (ErlangMap map_10) | (DM.Just builtins_11) <-
                                 (Map.lookup (ErlangAtom "builtins") map_10) ->
            let    val_16 = ErlangTuple [ErlangAtom "contract_def", name_3]
            in let head_24 = toErl "state"
            in let head_29 = toErl "put"
            in let head_34 = toErl "Chain"
            in let head_36 = toErl "event"
            in let
              val_38 = ErlangTuple [ErlangAtom "get_state", ErlangAtom "none"]
            in let tup_el_43 = toErl 1
            in let val_41 = ErlangTuple [ErlangAtom "set_state", tup_el_43]
            in let tup_el_46 = toErl 1
            in let val_44 = ErlangTuple [ErlangAtom "chain_event", tup_el_46]
            in let
              mapExt_47 =
                ErlangMap
                  (Map.fromFoldable
                     [DT.Tuple
                        (ErlangCons name_3 (ErlangCons head_24 ErlangEmptyList))
                        val_38,
                      DT.Tuple
                        (ErlangCons name_3 (ErlangCons head_29 ErlangEmptyList))
                        val_41,
                      DT.Tuple
                        (ErlangCons name_3
                           (ErlangCons head_34
                              (ErlangCons head_36 ErlangEmptyList)))
                        val_44])
            in let val_19 = BIF.maps__merge__2 [builtins_11, mapExt_47]
            in let
              mapExt_49 =
                ErlangMap
                  (Map.fromFoldable
                     [DT.Tuple (ErlangAtom "context") val_16,
                      DT.Tuple (ErlangAtom "builtins") val_19])
            in let conenv_51 = BIF.maps__merge__2 [env_0, mapExt_49]
            in
              case conenv_51 of
                (ErlangMap map_52) | (DM.Just prevfuns_53) <-
                                       (Map.lookup (ErlangAtom "functions")
                                          map_52) ->
                  let env1_57 = erlps__decls_to_fcode__2 [conenv_51, decls_5]
                  in
                    case env1_57 of
                      (ErlangMap map_58) | (DM.Just funs_59) <-
                                             (Map.lookup
                                                (ErlangAtom "functions")
                                                map_58) ->
                        let    head_65 = toErl "state"
                        in let
                          arg_68 =
                            ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
                        in let
                          statetype_71 =
                            erlps__lookup_type__4
                              [env1_57,
                               ErlangCons name_3
                                 (ErlangCons head_65 ErlangEmptyList),
                               ErlangEmptyList, arg_68]
                        in let head_76 = toErl "event"
                        in let
                          eventtype_80 =
                            erlps__lookup_type__4
                              [env1_57,
                               ErlangCons name_3
                                 (ErlangCons head_76 ErlangEmptyList),
                               ErlangEmptyList, ErlangAtom "none"]
                        in let statelayout_82 = erlps__state_layout__1 [env1_57]
                        in let
                          payable_86 =
                            BIF.do_remote_fun_call "Proplists"
                              "erlps__get_value__3"
                              [ErlangAtom "payable", attrs_2,
                               ErlangAtom "false"]
                        in let
                          arg_102 =
                            erlps__add_event_function__3
                              [env1_57, eventtype_80, funs_59]
                        in let
                          val_98 =
                            erlps__add_init_function__4
                              [env1_57, con_4, statetype_71, arg_102]
                        in let
                          confcode_106 =
                            ErlangMap
                              (Map.fromFoldable
                                 [DT.Tuple (ErlangAtom "contract_name") name_3,
                                  DT.Tuple (ErlangAtom "state_type")
                                    statetype_71,
                                  DT.Tuple (ErlangAtom "state_layout")
                                    statelayout_82,
                                  DT.Tuple (ErlangAtom "event_type")
                                    eventtype_80,
                                  DT.Tuple (ErlangAtom "payable") payable_86,
                                  DT.Tuple (ErlangAtom "functions") val_98])
                        in
                          case contract_1 of
                            (ErlangAtom "contract_main") ->
                              case rest_6 of
                                (ErlangEmptyList) ->
                                  ErlangTuple [env1_57, confcode_106]
                                _ -> EXC.badmatch rest_6
                            (ErlangAtom "contract_child") ->
                              let   
                                env2_114 =
                                  erlps__add_child_con__3
                                    [env1_57, name_3, confcode_106]
                              in let
                                mapExt_118 =
                                  ErlangMap
                                    (Map.singleton (ErlangAtom "functions")
                                       prevfuns_53)
                              in let
                                env3_121 =
                                  case findMissingKey env2_114
                                         [ErlangAtom "functions"] of
                                    (DM.Nothing) ->
                                      BIF.maps__merge__2 [env2_114, mapExt_118]
                                    (DM.Just missing_120) ->
                                      EXC.badkey missing_120
                              in erlps__to_fcode__2 [env3_121, rest_6]
                            something_else -> EXC.case_clause something_else
                      _ -> EXC.badmatch env1_57
                _ -> EXC.badmatch conenv_51
          _ -> EXC.badmatch env_0
      (ErlangAtom "true") ->
        let   
          val_127 = ErlangTuple [ErlangAtom "abstract_contract", name_3]
        in let
          mapExt_130 =
            ErlangMap (Map.singleton (ErlangAtom "context") val_127)
        in let arg_124 = BIF.maps__merge__2 [env_0, mapExt_130]
        in let env1_133 = erlps__decls_to_fcode__2 [arg_124, decls_5]
        in erlps__to_fcode__2 [env1_133, rest_6]
      something_else -> EXC.case_clause something_else
erlps__to_fcode__2 [_env_0,
                    (ErlangCons notmain_2@(ErlangTuple [notmainhead_1, _, _,
                                                        _]) (ErlangEmptyList))]
  | (/=) notmainhead_1 (ErlangAtom "contract_def") =
  let
    arg_3 =
      ErlangTuple
        [ErlangAtom "last_declaration_must_be_contract_def", notmain_2]
  in erlps__fcode_error__1 [arg_3]
erlps__to_fcode__2 [env_0,
                    (ErlangCons (ErlangTuple [(ErlangAtom "namespace"), _,
                                              (ErlangTuple [(ErlangAtom "con"),
                                                            _, con_1]),
                                              decls_2]) code_3)]
  =
  let    val_7 = ErlangTuple [ErlangAtom "namespace", con_1]
  in let
    mapExt_10 =
      ErlangMap (Map.singleton (ErlangAtom "context") val_7)
  in let arg_4 = BIF.maps__merge__2 [env_0, mapExt_10]
  in let env1_13 = erlps__decls_to_fcode__2 [arg_4, decls_2]
  in erlps__to_fcode__2 [env1_13, code_3]
erlps__to_fcode__2 [arg_16, arg_17] = EXC.function_clause unit
erlps__to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_fcode__2) args

erlps__decls_to_fcode__2 :: ErlangFun
erlps__decls_to_fcode__2 [env_0, decls_1] =
  let    env1_4 = erlps__add_fun_env__2 [env_0, decls_1]
  in let
    arg_5 =
      ErlangFun 2
        (let
           lambda_6 [d_9, e_10] = erlps__decl_to_fcode__2 [e_10, d_9]
           lambda_6 [arg_7, arg_8] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
         in lambda_6)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_5, env1_4, decls_1]
erlps__decls_to_fcode__2 [arg_15, arg_16] =
  EXC.function_clause unit
erlps__decls_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__decls_to_fcode__2) args

erlps__decl_to_fcode__2 :: ErlangFun
erlps__decl_to_fcode__2 [env_1@(ErlangMap map_0),
                         (ErlangTuple [(ErlangAtom "fun_decl"), _, id_2, _])]
  | (DM.Just (ErlangTuple [(ErlangAtom "contract_def"), _])) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  let case_3 = erlps__is_no_code__1 [env_1]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_5 = ErlangTuple [ErlangAtom "missing_definition", id_2]
        in erlps__fcode_error__1 [arg_5]
      (ErlangAtom "true") -> env_1
      something_else -> EXC.case_clause something_else
erlps__decl_to_fcode__2 [env_0,
                         (ErlangTuple [(ErlangAtom "fun_decl"), _, _, _])]
  =
  env_0
erlps__decl_to_fcode__2 [env_0,
                         (ErlangTuple [(ErlangAtom "type_def"), _ann_1, name_2,
                                       args_3, def_4])]
  =
  erlps__typedef_to_fcode__4 [env_0, name_2, args_3, def_4]
erlps__decl_to_fcode__2 [env_2@(ErlangMap map_0),
                         (ErlangTuple [(ErlangAtom "letfun"), ann_3,
                                       id_5@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_4]),
                                       args_6, ret_7, body_8])]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    attrs_10 = erlps__get_attributes__1 [ann_3]
  in let arg_12 = erlps__qname__2 [env_2, name_4]
  in let fname_15 = erlps__lookup_fun__2 [env_2, arg_12]
  in let fargs_18 = erlps__args_to_fcode__2 [env_2, args_6]
  in let fret_21 = erlps__type_to_fcode__2 [env_2, ret_7]
  in let
    val_25 =
      flmap
        (\ lc_28 ->
           case lc_28 of
             (ErlangTuple [x_27, _]) -> ErlangCons x_27 ErlangEmptyList
             _ -> ErlangEmptyList)
        fargs_18
  in let
    mapExt_30 = ErlangMap (Map.singleton (ErlangAtom "vars") val_25)
  in let arg_22 = BIF.maps__merge__2 [env_2, mapExt_30]
  in let fbody_33 = erlps__expr_to_fcode__2 [arg_22, body_8]
  in let
    cond_34 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "entrypoint", ann_3, ErlangAtom "false"]
  in let
    _ =
      case cond_34 of
        (ErlangAtom "true") ->
          let
            lcRet_38 =
              erlps__ensure_first_order_entrypoint__6
                [ann_3, id_5, args_6, ret_7, fargs_18, fret_21]
          in ErlangCons lcRet_38 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    def_53 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "attrs") attrs_10,
            DT.Tuple (ErlangAtom "args") fargs_18,
            DT.Tuple (ErlangAtom "return") fret_21,
            DT.Tuple (ErlangAtom "body") fbody_33])
  in let mapExt_57 = ErlangMap (Map.singleton fname_15 def_53)
  in let newfuns_59 = BIF.maps__merge__2 [funs_1, mapExt_57]
  in let
    mapExt_63 =
      ErlangMap (Map.singleton (ErlangAtom "functions") newfuns_59)
  in
    case findMissingKey env_2 [ErlangAtom "functions"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_63]
      (DM.Just missing_65) -> EXC.badkey missing_65
erlps__decl_to_fcode__2 [arg_66, arg_67] =
  EXC.function_clause unit
erlps__decl_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__decl_to_fcode__2) args

erlps__typedef_to_fcode__4 :: ErlangFun
erlps__typedef_to_fcode__4 [env_0,
                            id_2@(ErlangTuple [(ErlangAtom "id"), _, name_1]),
                            xs_3, def_4]
  =
  let   
    _ = erlps__check_state_and_event_types__3 [env_0, id_2, xs_3]
  in let q_10 = erlps__qname__2 [env_0, name_1]
  in let
    fdef_66 =
      ErlangFun 1
        (let
           lambda_11 [args_13]
             | (ErlangAtom "true") ==
                 (falsifyErrors
                    (\ _ ->
                       let    lop_14 = BIF.erlang__length__1 [args_13]
                       in let rop_16 = BIF.erlang__length__1 [xs_3]
                       in BIF.erlang__op_eq [lop_14, rop_16])) =
             let   
               arg_19 =
                 flmap
                   (\ lc_22 ->
                      case lc_22 of
                        (ErlangTuple [(ErlangAtom "tvar"), _, x_21]) ->
                          ErlangCons x_21 ErlangEmptyList
                        _ -> ErlangEmptyList)
                   xs_3
             in let
               arg_18 =
                 BIF.do_remote_fun_call "Lists" "erlps__zip__2"
                   [arg_19, args_13]
             in let sub_25 = BIF.maps__from_list__1 [arg_18]
             in
               case def_4 of
                 (ErlangTuple [(ErlangAtom "record_t"), fields_27]) ->
                   let
                     tup_el_29 =
                       flmap
                         (\ lc_32 ->
                            case lc_32 of
                              (ErlangTuple [(ErlangAtom "field_t"), _, _,
                                            t_31]) ->
                                let
                                  lcRet_33 =
                                    erlps__type_to_fcode__3
                                      [env_0, sub_25, t_31]
                                in ErlangCons lcRet_33 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         fields_27
                   in ErlangTuple [ErlangAtom "tuple", tup_el_29]
                 (ErlangTuple [(ErlangAtom "variant_t"), cons_37]) ->
                   let
                     fcons_51 =
                       flmap
                         (\ lc_40 ->
                            case lc_40 of
                              (ErlangTuple [(ErlangAtom "constr_t"), _, _,
                                            ts_42]) ->
                                let
                                  lcRet_41 =
                                    flmap
                                      (\ lc_46 ->
                                         let
                                           lcRet_47 =
                                             erlps__type_to_fcode__3
                                               [env_0, sub_25, lc_46]
                                         in ErlangCons lcRet_47 ErlangEmptyList)
                                      ts_42
                                in ErlangCons lcRet_41 ErlangEmptyList
                              _ -> EXC.badmatch lc_40)
                         cons_37
                   in ErlangTuple [ErlangAtom "variant", fcons_51]
                 (ErlangTuple [(ErlangAtom "alias_t"), type_54]) ->
                   erlps__type_to_fcode__3 [env_0, sub_25, type_54]
                 something_else -> EXC.case_clause something_else
           lambda_11 [args_58] =
             let    tup_el_62 = BIF.erlang__length__1 [args_58]
             in let tup_el_64 = BIF.erlang__length__1 [xs_3]
             in let
               arg_59 =
                 ErlangTuple
                   [ErlangAtom "type_arity_mismatch", name_1, tup_el_62,
                    tup_el_64]
             in erlps__internal_error__1 [arg_59]
           lambda_11 [arg_12] = EXC.function_clause unit
           lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
         in lambda_11)
  in let
    constructors_114 =
      case def_4 of
        (ErlangTuple [(ErlangAtom "variant_t"), cons_68]) ->
          let   
            arities_76 =
              flmap
                (\ lc_71 ->
                   case lc_71 of
                     (ErlangTuple [(ErlangAtom "constr_t"), _, _, args_73]) ->
                       let lcRet_72 = BIF.erlang__length__1 [args_73]
                       in ErlangCons lcRet_72 ErlangEmptyList
                     _ -> EXC.badmatch lc_71)
                cons_68
          in let arg_78 = toErl 0
          in let lop_80 = BIF.erlang__length__1 [cons_68]
          in let rop_82 = toErl 1
          in let arg_79 = BIF.erlang__op_minus [lop_80, rop_82]
          in let
            lcSrc_77 =
              BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_78, arg_79]
          in let
            tags_89 =
              flmap
                (\ lc_84 ->
                   let
                     lcRet_85 =
                       ErlangTuple [ErlangAtom "con_tag", lc_84, arities_76]
                   in ErlangCons lcRet_85 ErlangEmptyList)
                lcSrc_77
          in let
            getname_93 =
              ErlangFun 1
                (let
                   lambda_90 [(ErlangTuple [(ErlangAtom "constr_t"), _,
                                            (ErlangTuple [(ErlangAtom "con"), _,
                                                          c_92]),
                                            _])]
                     =
                     c_92
                   lambda_90 [arg_91] = EXC.function_clause unit
                   lambda_90 args = EXC.badarity (ErlangFun 1 lambda_90) args
                 in lambda_90)
          in let
            qname_101 =
              ErlangFun 1
                (let
                   lambda_94 [con_96] =
                     let
                       arg_98 =
                         BIF.erlang__apply__2
                           [getname_93, ErlangCons con_96 ErlangEmptyList]
                     in erlps__qname__2 [env_0, arg_98]
                   lambda_94 [arg_95] = EXC.function_clause unit
                   lambda_94 args = EXC.badarity (ErlangFun 1 lambda_94) args
                 in lambda_94)
          in let
            lcSrc_103 =
              BIF.do_remote_fun_call "Lists" "erlps__zip__2" [tags_89, cons_68]
          in let
            arg_102 =
              flmap
                (\ lc_108 ->
                   case lc_108 of
                     (ErlangTuple [tag_106, con_107]) ->
                       let   
                         tup_el_110 =
                           BIF.erlang__apply__2
                             [qname_101, ErlangCons con_107 ErlangEmptyList]
                       in let lcRet_109 = ErlangTuple [tup_el_110, tag_106]
                       in ErlangCons lcRet_109 ErlangEmptyList
                     _ -> ErlangEmptyList)
                lcSrc_103
          in BIF.maps__from_list__1 [arg_102]
        _ -> ErlangMap Map.empty
  in let
    env1_117 = erlps__bind_constructors__2 [env_0, constructors_114]
  in let
    env2_129 =
      case name_1 of
        (ErlangCons (ErlangInt num_119) (ErlangCons (ErlangInt num_120) (ErlangCons (ErlangInt num_121) (ErlangCons (ErlangInt num_122) (ErlangCons (ErlangInt num_123) (ErlangEmptyList)))))) | (ErlangInt
                                                                                                                                                                                                    num_119) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      101)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_120) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      118)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_121) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      101)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_122) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      110)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_123) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      116) ->
          let
            mapExt_127 =
              ErlangMap (Map.singleton (ErlangAtom "event_type") def_4)
          in BIF.maps__merge__2 [env1_117, mapExt_127]
        _ -> env1_117
  in let
    env3_133 =
      erlps__compute_state_layout__3 [env2_129, name_1, fdef_66]
  in erlps__bind_type__3 [env3_133, q_10, fdef_66]
erlps__typedef_to_fcode__4 [arg_137, arg_138, arg_139, arg_140] =
  EXC.function_clause unit
erlps__typedef_to_fcode__4 args =
  EXC.badarity (ErlangFun 4 erlps__typedef_to_fcode__4) args

erlps__compute_state_layout__3 :: ErlangFun
erlps__compute_state_layout__3 [env_1@(ErlangMap map_0),
                                (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangEmptyList)))))),
                                type_7]
  | (DM.Just (ErlangTuple [(ErlangAtom "contract_def"), _])) <-
      (Map.lookup (ErlangAtom "context") map_0)
  , (ErlangInt num_2) == (toErl 115)
  , (ErlangInt num_3) == (toErl 116)
  , (ErlangInt num_4) == (toErl 97)
  , (ErlangInt num_5) == (toErl 116)
  , (ErlangInt num_6) == (toErl 101) =
  let   
    nolayout_10 =
      erlps__get_option__2 [ErlangAtom "no_flatten_state", env_1]
  in let
    case_11 =
      BIF.erlang__apply__2
        [type_7, ErlangCons ErlangEmptyList ErlangEmptyList]
  in let
    layout_21 =
      case case_11 of
        _ | (==) (ErlangAtom "true") nolayout_10 ->
          let tup_el_15 = toErl 1
          in ErlangTuple [ErlangAtom "reg", tup_el_15]
        t_16 ->
          let    arg_17 = toErl 1
          in let
            matchExpr_20 = erlps__compute_state_layout__2 [arg_17, t_16]
          in
            case matchExpr_20 of
              (ErlangTuple [_, l_19]) -> l_19
              _ -> EXC.badmatch matchExpr_20
  in let
    mapExt_25 =
      ErlangMap (Map.singleton (ErlangAtom "state_layout") layout_21)
  in BIF.maps__merge__2 [env_1, mapExt_25]
erlps__compute_state_layout__3 [env_0, _, _] = env_0
erlps__compute_state_layout__3 [arg_1, arg_2, arg_3] =
  EXC.function_clause unit
erlps__compute_state_layout__3 args =
  EXC.badarity (ErlangFun 3 erlps__compute_state_layout__3) args

erlps__compute_state_layout__2 :: ErlangFun
erlps__compute_state_layout__2 [r_0,
                                (ErlangTuple [(ErlangAtom "tuple"),
                                              (ErlangCons t_1 (ErlangEmptyList))])]
  =
  erlps__compute_state_layout__2 [r_0, t_1]
erlps__compute_state_layout__2 [r_0,
                                (ErlangTuple [(ErlangAtom "tuple"), ts_1])]
  =
  let matchExpr_6 = erlps__compute_state_layout__2 [r_0, ts_1]
  in
    case matchExpr_6 of
      (ErlangTuple [r1_4, ls_5]) ->
        let tup_el_8 = ErlangTuple [ErlangAtom "tuple", ls_5]
        in ErlangTuple [r1_4, tup_el_8]
      _ -> EXC.badmatch matchExpr_6
erlps__compute_state_layout__2 [r_0, (ErlangEmptyList)] =
  ErlangTuple [r_0, ErlangEmptyList]
erlps__compute_state_layout__2 [r_0, (ErlangCons h_1 t_2)] =
  let matchExpr_7 = erlps__compute_state_layout__2 [r_0, h_1]
  in
    case matchExpr_7 of
      (ErlangTuple [r1_5, h1_6]) ->
        let matchExpr_12 = erlps__compute_state_layout__2 [r1_5, t_2]
        in
          case matchExpr_12 of
            (ErlangTuple [r2_10, t1_11]) ->
              ErlangTuple [r2_10, ErlangCons h1_6 t1_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__compute_state_layout__2 [r_0, _] =
  let    rop_3 = toErl 1
  in let tup_el_1 = BIF.erlang__op_plus [r_0, rop_3]
  in let tup_el_4 = ErlangTuple [ErlangAtom "reg", r_0]
  in ErlangTuple [tup_el_1, tup_el_4]
erlps__compute_state_layout__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__compute_state_layout__2 args =
  EXC.badarity (ErlangFun 2 erlps__compute_state_layout__2) args

erlps__check_state_and_event_types__3 :: ErlangFun
erlps__check_state_and_event_types__3 [(ErlangMap map_0), id_1,
                                       (ErlangCons _ _)]
  | (DM.Just (ErlangTuple [(ErlangAtom "contract_def"), _])) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  case id_1 of
    (ErlangTuple [(ErlangAtom "id"), _,
                  (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangCons (ErlangInt num_7) (ErlangEmptyList))))))]) | (ErlangInt
                                                                                                                                                                                                      num_3) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        115)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_4) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        116)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_5) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        97)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_6) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        116)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_7) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        101) ->
      let arg_8 = ErlangTuple [ErlangAtom "parameterized_state", id_1]
      in erlps__fcode_error__1 [arg_8]
    (ErlangTuple [(ErlangAtom "id"), _,
                  (ErlangCons (ErlangInt num_11) (ErlangCons (ErlangInt num_12) (ErlangCons (ErlangInt num_13) (ErlangCons (ErlangInt num_14) (ErlangCons (ErlangInt num_15) (ErlangEmptyList))))))]) | (ErlangInt
                                                                                                                                                                                                           num_11) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             101)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_12) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             118)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_13) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             101)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_14) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             110)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_15) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             116) ->
      let arg_16 = ErlangTuple [ErlangAtom "parameterized_event", id_1]
      in erlps__fcode_error__1 [arg_16]
    _ -> ErlangAtom "ok"
erlps__check_state_and_event_types__3 [_, _, _] = ErlangAtom "ok"
erlps__check_state_and_event_types__3 [arg_0, arg_1, arg_2] =
  EXC.function_clause unit
erlps__check_state_and_event_types__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_state_and_event_types__3)
    args

erlps__type_to_fcode__2 :: ErlangFun
erlps__type_to_fcode__2 [env_0, type_1] =
  let arg_3 = ErlangMap Map.empty
  in erlps__type_to_fcode__3 [env_0, arg_3, type_1]
erlps__type_to_fcode__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__type_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__type_to_fcode__2) args

erlps__type_to_fcode__3 :: ErlangFun
erlps__type_to_fcode__3 [_env_0, _sub_1,
                         (ErlangTuple [(ErlangAtom "con"), _, _])]
  =
  ErlangAtom "contract"
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "app_t"), _,
                                       t_3@(ErlangTuple [id_2, _, _]),
                                       types_4])]
  | (weakEq id_2 (ErlangAtom "id")) ||
      (weakEq id_2 (ErlangAtom "qid")) =
  let
    arg_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__type_to_fcode__3 [env_0, sub_1, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        types_4
  in erlps__lookup_type__3 [env_0, t_3, arg_7]
erlps__type_to_fcode__3 [env_0, _sub_1,
                         t_3@(ErlangTuple [id_2, _, _])]
  | (weakEq id_2 (ErlangAtom "id")) ||
      (weakEq id_2 (ErlangAtom "qid")) =
  erlps__lookup_type__3 [env_0, t_3, ErlangEmptyList]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "tuple_t"), _, types_2])]
  =
  let
    tup_el_4 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__type_to_fcode__3 [env_0, sub_1, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        types_2
  in ErlangTuple [ErlangAtom "tuple", tup_el_4]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "record_t"), fields_2])]
  =
  let   
    fieldtype_6 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "field_t"), _, _, ty_5])] =
             ty_5
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    tup_el_12 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [fieldtype_6, fields_2]
  in let
    arg_9 =
      ErlangTuple [ErlangAtom "tuple_t", ErlangEmptyList, tup_el_12]
  in erlps__type_to_fcode__3 [env_0, sub_1, arg_9]
erlps__type_to_fcode__3 [_env_0, _sub_1,
                         (ErlangTuple [(ErlangAtom "bytes_t"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "bytes", n_2]
erlps__type_to_fcode__3 [_env_0, _sub_1,
                         (ErlangTuple [(ErlangAtom "tvar"), ann_2,
                                       (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangEmptyList)))))])]
  | (ErlangInt num_3) == (toErl 118)
  , (ErlangInt num_4) == (toErl 111)
  , (ErlangInt num_5) == (toErl 105)
  , (ErlangInt num_6) == (toErl 100) =
  let arg_7 = ErlangTuple [ErlangAtom "found_void", ann_2]
  in erlps__fcode_error__1 [arg_7]
erlps__type_to_fcode__3 [_env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "tvar"), _, x_2])]
  =
  let arg_5 = ErlangTuple [ErlangAtom "tvar", x_2]
  in
    BIF.do_remote_fun_call "Maps" "erlps__get__3" [x_2, sub_1, arg_5]
erlps__type_to_fcode__3 [_env_0, _sub_1,
                         (ErlangTuple [(ErlangAtom "fun_t"), ann_2, _,
                                       (ErlangAtom "var_args"), _])]
  =
  let    tup_el_8 = toErl "a very suspicious function"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", ann_2, tup_el_8]
  in let
    arg_3 = ErlangTuple [ErlangAtom "var_args_not_set", tup_el_5]
  in erlps__fcode_error__1 [arg_3]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "fun_t"), _, named_2, args_3,
                                       res_4])]
  =
  let   
    fnamed_12 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [(ErlangAtom "named_arg_t"), _, _, arg_6, _]) ->
               let lcRet_8 = erlps__type_to_fcode__3 [env_0, sub_1, arg_6]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        named_2
  in let
    fargs_20 =
      flmap
        (\ lc_15 ->
           let lcRet_16 = erlps__type_to_fcode__3 [env_0, sub_1, lc_15]
           in ErlangCons lcRet_16 ErlangEmptyList)
        args_3
  in let tup_el_22 = BIF.erlang__op_append [fnamed_12, fargs_20]
  in let tup_el_25 = erlps__type_to_fcode__3 [env_0, sub_1, res_4]
  in ErlangTuple [ErlangAtom "function", tup_el_22, tup_el_25]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "if_t"), _, _, _, else_2])]
  =
  erlps__type_to_fcode__3 [env_0, sub_1, else_2]
erlps__type_to_fcode__3 [_env_0, _sub_1, type_2] =
  let arg_3 = ErlangTuple [ErlangAtom "todo", type_2]
  in BIF.erlang__error__1 [arg_3]
erlps__type_to_fcode__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__type_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__type_to_fcode__3) args

erlps__args_to_fcode__2 :: ErlangFun
erlps__args_to_fcode__2 [env_0, args_1] =
  flmap
    (\ lc_5 ->
       case lc_5 of
         (ErlangTuple [(ErlangAtom "typed"), _, arg_3, type_4]) ->
           let
             lcRet_6 =
               case arg_3 of
                 (ErlangTuple [(ErlangAtom "id"), _, name_8]) ->
                   let tup_el_10 = erlps__type_to_fcode__2 [env_0, type_4]
                   in ErlangTuple [name_8, tup_el_10]
                 _ ->
                   let arg_13 = ErlangTuple [ErlangAtom "bad_arg", arg_3]
                   in erlps__internal_error__1 [arg_13]
           in ErlangCons lcRet_6 ErlangEmptyList
         _ -> ErlangEmptyList)
    args_1
erlps__args_to_fcode__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__args_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__args_to_fcode__2) args

erlps__make_let__2 :: ErlangFun
erlps__make_let__2 [expr_0, body_1] =
  case expr_0 of
    (ErlangTuple [(ErlangAtom "var"), _]) ->
      BIF.erlang__apply__2 [body_1, ErlangCons expr_0 ErlangEmptyList]
    (ErlangTuple [(ErlangAtom "lit"),
                  (ErlangTuple [(ErlangAtom "int"), _])]) ->
      BIF.erlang__apply__2 [body_1, ErlangCons expr_0 ErlangEmptyList]
    (ErlangTuple [(ErlangAtom "lit"),
                  (ErlangTuple [(ErlangAtom "bool"), _])]) ->
      BIF.erlang__apply__2 [body_1, ErlangCons expr_0 ErlangEmptyList]
    _ ->
      let    x_9 = erlps__fresh_name__0 []
      in let arg_14 = ErlangTuple [ErlangAtom "var", x_9]
      in let
        tup_el_13 =
          BIF.erlang__apply__2 [body_1, ErlangCons arg_14 ErlangEmptyList]
      in ErlangTuple [ErlangAtom "let", x_9, expr_0, tup_el_13]
erlps__make_let__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__make_let__2 args =
  EXC.badarity (ErlangFun 2 erlps__make_let__2) args

erlps__let_bind__3 :: ErlangFun
erlps__let_bind__3 [x_0, (ErlangTuple [(ErlangAtom "var"), y_1]),
                    body_2]
  =
  let head_4 = ErlangTuple [x_0, y_1]
  in erlps__rename__2 [ErlangCons head_4 ErlangEmptyList, body_2]
erlps__let_bind__3 [x_0, expr_1, body_2] =
  ErlangTuple [ErlangAtom "let", x_0, expr_1, body_2]
erlps__let_bind__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__let_bind__3 args =
  EXC.badarity (ErlangFun 3 erlps__let_bind__3) args

erlps__let_bind__2 :: ErlangFun
erlps__let_bind__2 [binds_0, body_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [(ErlangTuple [x_6, e_7]), rest_8] =
             erlps__let_bind__3 [x_6, e_7, rest_8]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_2, body_1, binds_0]
erlps__let_bind__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__let_bind__2 args =
  EXC.badarity (ErlangFun 2 erlps__let_bind__2) args

erlps__expr_to_fcode__2 :: ErlangFun
erlps__expr_to_fcode__2 [env_0,
                         (ErlangTuple [(ErlangAtom "typed"), _, expr_1,
                                       type_2])]
  =
  erlps__expr_to_fcode__3 [env_0, type_2, expr_1]
erlps__expr_to_fcode__2 [env_0, expr_1] =
  erlps__expr_to_fcode__3 [env_0, ErlangAtom "no_type", expr_1]
erlps__expr_to_fcode__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__expr_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__expr_to_fcode__2) args

erlps__expr_to_fcode__3 :: ErlangFun
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "int"), _, n_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "int", n_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "char"), _, n_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "int", n_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "bool"), _, b_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "bool", b_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "string"), _, s_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "string", s_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "account_pubkey"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "account_pubkey", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "contract_pubkey"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "contract_pubkey", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "oracle_pubkey"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "oracle_pubkey", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "oracle_query_id"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "oracle_query_id", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "bytes"), _, b_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "bytes", b_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "id"), _, x_2])]
  =
  erlps__resolve_var__2 [env_0, ErlangCons x_2 ErlangEmptyList]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "qid"), ann_2, x_3])]
  =
  let case_4 = erlps__resolve_var__2 [env_0, x_3]
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "builtin_u"), b_7, ar_8]) | (((((((==)
                                                                    b_7
                                                                    (ErlangAtom
                                                                       "oracle_query")) ||
                                                                   ((==) b_7
                                                                      (ErlangAtom
                                                                         "oracle_get_question"))) ||
                                                                  ((==) b_7
                                                                     (ErlangAtom
                                                                        "oracle_get_answer"))) ||
                                                                 ((==) b_7
                                                                    (ErlangAtom
                                                                       "oracle_respond"))) ||
                                                                ((==) b_7
                                                                   (ErlangAtom
                                                                      "oracle_register"))) ||
                                                               ((==) b_7
                                                                  (ErlangAtom
                                                                     "oracle_check"))) ||
                                                              ((==) b_7
                                                                 (ErlangAtom
                                                                    "oracle_check_query")) ->
        let    otype_11 = erlps__get_oracle_type__2 [b_7, type_1]
        in let matchExpr_16 = erlps__type_to_fcode__2 [env_0, otype_11]
        in
          case matchExpr_16 of
            (ErlangTuple [(ErlangAtom "oracle"), qtype_14, rtype_15]) ->
              let   
                _ =
                  erlps__validate_oracle_type__4
                    [ann_2, otype_11, qtype_14, rtype_15]
              in let tup_el_23 = ErlangTuple [ErlangAtom "typerep", qtype_14]
              in let head_21 = ErlangTuple [ErlangAtom "lit", tup_el_23]
              in let tup_el_29 = ErlangTuple [ErlangAtom "typerep", rtype_15]
              in let head_27 = ErlangTuple [ErlangAtom "lit", tup_el_29]
              in
                ErlangTuple
                  [ErlangAtom "builtin_u", b_7, ar_8,
                   ErlangCons head_21 (ErlangCons head_27 ErlangEmptyList)]
            _ -> EXC.badmatch matchExpr_16
      (ErlangTuple [(ErlangAtom "builtin_u"),
                    b_38@(ErlangAtom "aens_resolve"), ar_39]) ->
        case type_1 of
          (ErlangTuple [(ErlangAtom "fun_t"), _, _, _, restype_40]) ->
            let    aenstype_44 = erlps__type_to_fcode__2 [env_0, restype_40]
            in let
              _ =
                erlps__validate_aens_resolve_type__3
                  [ann_2, restype_40, aenstype_44]
            in let
              tup_el_50 = ErlangTuple [ErlangAtom "typerep", aenstype_44]
            in let head_48 = ErlangTuple [ErlangAtom "lit", tup_el_50]
            in
              ErlangTuple
                [ErlangAtom "builtin_u", b_38, ar_39,
                 ErlangCons head_48 ErlangEmptyList]
          _ -> EXC.badmatch type_1
      (ErlangTuple [(ErlangAtom "builtin_u"),
                    b_59@(ErlangAtom "bytes_split"), ar_60]) ->
        case type_1 of
          (ErlangTuple [(ErlangAtom "fun_t"), _, _, _,
                        (ErlangTuple [(ErlangAtom "tuple_t"), _,
                                      (ErlangCons (ErlangTuple [(ErlangAtom "bytes_t"),
                                                                _,
                                                                n_61]) (ErlangCons _ (ErlangEmptyList)))])]) ->
            let    tup_el_69 = ErlangTuple [ErlangAtom "int", n_61]
            in let head_67 = ErlangTuple [ErlangAtom "lit", tup_el_69]
            in
              ErlangTuple
                [ErlangAtom "builtin_u", b_59, ar_60,
                 ErlangCons head_67 ErlangEmptyList]
          _ -> EXC.badmatch type_1
      other_73 -> other_73
erlps__expr_to_fcode__3 [env_0, type_1,
                         con_3@(ErlangTuple [c_2, _, _])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let   
    tup_el_9 =
      ErlangTuple [ErlangAtom "typed", ErlangEmptyList, con_3, type_1]
  in let
    arg_6 =
      ErlangTuple
        [ErlangAtom "app", ErlangEmptyList, tup_el_9, ErlangEmptyList]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_6]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _,
                                       (ErlangTuple [(ErlangAtom "typed"), _,
                                                     con_3@(ErlangTuple [c_2, _,
                                                                         _]),
                                                     _]),
                                       args_4])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let matchExpr_9 = erlps__lookup_con__2 [env_0, con_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangAtom "con_tag"), i_7, arities_8]) ->
        let    rop_12 = toErl 1
        in let arg_10 = BIF.erlang__op_plus [i_7, rop_12]
        in let
          arity_14 =
            BIF.do_remote_fun_call "Lists" "erlps__nth__2"
              [arg_10, arities_8]
        in let lop_16 = BIF.erlang__length__1 [args_4]
        in let case_15 = BIF.erlang__op_eq [lop_16, arity_14]
        in
          case case_15 of
            (ErlangAtom "true") ->
              let
                tup_el_22 =
                  flmap
                    (\ lc_25 ->
                       let lcRet_26 = erlps__expr_to_fcode__2 [env_0, lc_25]
                       in ErlangCons lcRet_26 ErlangEmptyList)
                    args_4
              in ErlangTuple [ErlangAtom "con", arities_8, i_7, tup_el_22]
            (ErlangAtom "false") ->
              let    tup_el_32 = BIF.erlang__length__1 [args_4]
              in let
                arg_29 =
                  ErlangTuple
                    [ErlangAtom "constructor_arity_mismatch", con_3, tup_el_32,
                     arity_14]
              in erlps__internal_error__1 [arg_29]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_9
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "tuple"), _, es_2])]
  =
  let
    arg_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__expr_to_fcode__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        es_2
  in erlps__make_tuple__1 [arg_3]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "proj"), _ann_2,
                                       rec_4@(ErlangTuple [(ErlangAtom "typed"),
                                                           _, _, rectype_3]),
                                       (ErlangTuple [(ErlangAtom "id"), _,
                                                     x_5])])]
  =
  case rectype_3 of
    (ErlangTuple [(ErlangAtom "con"), _, _]) | (ErlangAtom "true") ==
                                                 (falsifyErrors
                                                    (\ _ ->
                                                       let
                                                         rop_8 = toErl "address"
                                                       in
                                                         BIF.erlang__op_eq
                                                           [x_5, rop_8])) ->
      let head_12 = erlps__expr_to_fcode__2 [env_0, rec_4]
      in
        ErlangTuple
          [ErlangAtom "op", ErlangAtom "contract_to_address",
           ErlangCons head_12 ErlangEmptyList]
    (ErlangTuple [(ErlangAtom "con"), _, _]) ->
      case type_1 of
        (ErlangTuple [(ErlangAtom "fun_t"), _, _, args_16, ret_17]) ->
          let   
            fargs_25 =
              flmap
                (\ lc_21 ->
                   let lcRet_22 = erlps__type_to_fcode__2 [env_0, lc_21]
                   in ErlangCons lcRet_22 ErlangEmptyList)
                args_16
          in let tup_el_28 = erlps__type_to_fcode__2 [env_0, ret_17]
          in let tup_el_31 = erlps__expr_to_fcode__2 [env_0, rec_4]
          in let tup_el_36 = BIF.erlang__list_to_binary__1 [x_5]
          in let
            tup_el_34 = ErlangTuple [ErlangAtom "entrypoint", tup_el_36]
          in
            ErlangTuple
              [ErlangAtom "remote_u", fargs_25, tup_el_28, tup_el_31,
               tup_el_34]
        _ -> EXC.badmatch type_1
    (ErlangTuple [(ErlangAtom "record_t"),
                  (ErlangCons _ (ErlangEmptyList))]) ->
      erlps__expr_to_fcode__2 [env_0, rec_4]
    (ErlangTuple [(ErlangAtom "record_t"), _]) ->
      let    tup_el_41 = erlps__expr_to_fcode__2 [env_0, rec_4]
      in let tup_el_44 = erlps__field_index__2 [rec_4, x_5]
      in ErlangTuple [ErlangAtom "proj", tup_el_41, tup_el_44]
    something_else -> EXC.case_clause something_else
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"),
                                       (ErlangCons fieldt_1 (ErlangEmptyList))]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2,
                                       fields_3@(ErlangCons _ (ErlangEmptyList))])]
  =
  let matchExpr_7 = erlps__field_value__2 [fieldt_1, fields_3]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "set"), e_6]) ->
        erlps__expr_to_fcode__2 [env_0, e_6]
      _ -> EXC.badmatch matchExpr_7
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fieldtypes_1]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2,
                                       fields_3])]
  =
  let   
    fval_13 =
      ErlangFun 1
        (let
           lambda_4 [f_6] =
             let matchExpr_10 = erlps__field_value__2 [f_6, fields_3]
             in
               case matchExpr_10 of
                 (ErlangTuple [(ErlangAtom "set"), e_9]) ->
                   erlps__expr_to_fcode__2 [env_0, e_9]
                 _ -> EXC.badmatch matchExpr_10
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    arg_14 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [fval_13, fieldtypes_1]
  in erlps__make_tuple__1 [arg_14]
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"),
                                       (ErlangCons fieldt_1 (ErlangEmptyList))]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2, rec_3,
                                       fields_4])]
  =
  let case_5 = erlps__field_value__2 [fieldt_1, fields_4]
  in
    case case_5 of
      (ErlangAtom "false") -> erlps__expr_to_fcode__2 [env_0, rec_3]
      (ErlangTuple [(ErlangAtom "set"), e_10]) ->
        erlps__expr_to_fcode__2 [env_0, e_10]
      (ErlangTuple [(ErlangAtom "upd"), z_13, e_14]) ->
        let    tup_el_17 = erlps__expr_to_fcode__2 [env_0, rec_3]
        in let arg_21 = erlps__bind_var__2 [env_0, z_13]
        in let tup_el_20 = erlps__expr_to_fcode__2 [arg_21, e_14]
        in ErlangTuple [ErlangAtom "let", z_13, tup_el_17, tup_el_20]
      something_else -> EXC.case_clause something_else
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fieldtypes_1]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2, rec_3,
                                       fields_4])]
  =
  let    x_5 = erlps__fresh_name__0 []
  in let
    proj_16 =
      ErlangFun 1
        (let
           lambda_6 [i_8] =
             let    tup_el_10 = ErlangTuple [ErlangAtom "var", x_5]
             in let rop_15 = toErl 1
             in let tup_el_13 = BIF.erlang__op_minus [i_8, rop_15]
             in ErlangTuple [ErlangAtom "proj", tup_el_10, tup_el_13]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    comp_38 =
      ErlangFun 1
        (let
           lambda_17 [(ErlangTuple [i_19, (ErlangAtom "false")])] =
             BIF.erlang__apply__2 [proj_16, ErlangCons i_19 ErlangEmptyList]
           lambda_17 [(ErlangTuple [_,
                                    (ErlangTuple [(ErlangAtom "set"), e_22])])]
             =
             erlps__expr_to_fcode__2 [env_0, e_22]
           lambda_17 [(ErlangTuple [i_25,
                                    (ErlangTuple [(ErlangAtom "upd"), z_26,
                                                  e_27])])]
             =
             let   
               tup_el_30 =
                 BIF.erlang__apply__2 [proj_16, ErlangCons i_25 ErlangEmptyList]
             in let arg_34 = erlps__bind_var__2 [env_0, z_26]
             in let tup_el_33 = erlps__expr_to_fcode__2 [arg_34, e_27]
             in ErlangTuple [ErlangAtom "let", z_26, tup_el_30, tup_el_33]
           lambda_17 [arg_18] = EXC.function_clause unit
           lambda_17 args = EXC.badarity (ErlangFun 1 lambda_17) args
         in lambda_17)
  in let
    set_74 =
      ErlangFun 2
        (let
           lambda_39 [(ErlangTuple [_, (ErlangAtom "false")]), r_42] = r_42
           lambda_39 [(ErlangTuple [i_43,
                                    (ErlangTuple [(ErlangAtom "set"), e_44])]),
                      r_45]
             =
             let    rop_50 = toErl 1
             in let tup_el_48 = BIF.erlang__op_minus [i_43, rop_50]
             in let tup_el_51 = erlps__expr_to_fcode__2 [env_0, e_44]
             in
               ErlangTuple [ErlangAtom "set_proj", r_45, tup_el_48, tup_el_51]
           lambda_39 [(ErlangTuple [i_54,
                                    (ErlangTuple [(ErlangAtom "upd"), z_55,
                                                  e_56])]),
                      r_57]
             =
             let    rop_62 = toErl 1
             in let tup_el_60 = BIF.erlang__op_minus [i_54, rop_62]
             in let
               tup_el_66 =
                 BIF.erlang__apply__2 [proj_16, ErlangCons i_54 ErlangEmptyList]
             in let arg_70 = erlps__bind_var__2 [env_0, z_55]
             in let tup_el_69 = erlps__expr_to_fcode__2 [arg_70, e_56]
             in let
               tup_el_63 =
                 ErlangTuple [ErlangAtom "let", z_55, tup_el_66, tup_el_69]
             in
               ErlangTuple [ErlangAtom "set_proj", r_57, tup_el_60, tup_el_63]
           lambda_39 [arg_40, arg_41] = EXC.function_clause unit
           lambda_39 args = EXC.badarity (ErlangFun 2 lambda_39) args
         in lambda_39)
  in let lop_75 = BIF.erlang__length__1 [fields_4]
  in let rop_77 = BIF.erlang__length__1 [fieldtypes_1]
  in let expand_79 = BIF.erlang__op_eq [lop_75, rop_77]
  in let lcSrc_80 = erlps__indexed__1 [fieldtypes_1]
  in let
    updates_90 =
      flmap
        (\ lc_84 ->
           case lc_84 of
             (ErlangTuple [i_82, ft_83]) ->
               let    tup_el_87 = erlps__field_value__2 [ft_83, fields_4]
               in let lcRet_85 = ErlangTuple [i_82, tup_el_87]
               in ErlangCons lcRet_85 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_80
  in let
    body_101 =
      case expand_79 of
        (ErlangAtom "true") ->
          let
            tup_el_93 =
              BIF.do_remote_fun_call "Lists" "erlps__map__2"
                [comp_38, updates_90]
          in ErlangTuple [ErlangAtom "tuple", tup_el_93]
        (ErlangAtom "false") ->
          let arg_97 = ErlangTuple [ErlangAtom "var", x_5]
          in
            BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
              [set_74, arg_97, updates_90]
        something_else -> EXC.case_clause something_else
  in let tup_el_104 = erlps__expr_to_fcode__2 [env_0, rec_3]
  in ErlangTuple [ErlangAtom "let", x_5, tup_el_104, body_101]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "list"), _, es_2])]
  =
  let
    arg_3 =
      ErlangFun 2
        (let
           lambda_4 [e_7, l_8] =
             let head_12 = erlps__expr_to_fcode__2 [env_0, e_7]
             in
               ErlangTuple
                 [ErlangAtom "op", ErlangAtom "::",
                  ErlangCons head_12 (ErlangCons l_8 ErlangEmptyList)]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_3, ErlangAtom "nil", es_2]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _,
                                       (ErlangTuple [(ErlangAtom ".."), _]),
                                       (ErlangCons a_2 (ErlangCons b_3 (ErlangEmptyList)))])]
  =
  let    head_6 = toErl "ListInternal"
  in let head_8 = toErl "from_to"
  in let
    matchExpr_11 =
      erlps__resolve_fun__2
        [env_0, ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList)]
  in
    case matchExpr_11 of
      (ErlangTuple [(ErlangAtom "def_u"), fromto_10, _]) ->
        let    head_15 = erlps__expr_to_fcode__2 [env_0, a_2]
        in let head_19 = erlps__expr_to_fcode__2 [env_0, b_3]
        in
          ErlangTuple
            [ErlangAtom "def", fromto_10,
             ErlangCons head_15 (ErlangCons head_19 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_11
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), _, yield_2,
                                       (ErlangEmptyList)])]
  =
  let head_6 = erlps__expr_to_fcode__2 [env_0, yield_2]
  in
    ErlangTuple
      [ErlangAtom "op", ErlangAtom "::",
       ErlangCons head_6
         (ErlangCons (ErlangAtom "nil") ErlangEmptyList)]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_bind"),
                                                                 pat_5@(ErlangTuple [(ErlangAtom "typed"),
                                                                                     _,
                                                                                     _,
                                                                                     pattype_4]),
                                                                 bindexpr_6]) rest_7)])]
  =
  let    arg_8 = erlps__fresh_name__0 []
  in let env1_11 = erlps__bind_var__2 [env_0, arg_8]
  in let tup_el_24 = ErlangTuple [ErlangAtom "id", as_2, arg_8]
  in let
    tup_el_21 =
      ErlangTuple [ErlangAtom "typed", as_2, tup_el_24, pattype_4]
  in let
    tup_el_34 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_7]
  in let
    head_30 = ErlangTuple [ErlangAtom "case", as_2, pat_5, tup_el_34]
  in let tup_el_46 = toErl "_"
  in let tup_el_43 = ErlangTuple [ErlangAtom "id", as_2, tup_el_46]
  in let
    tup_el_47 =
      ErlangTuple [ErlangAtom "list", as_2, ErlangEmptyList]
  in let
    head_40 =
      ErlangTuple [ErlangAtom "case", as_2, tup_el_43, tup_el_47]
  in let
    arg_18 =
      ErlangTuple
        [ErlangAtom "switch", as_2, tup_el_21,
         ErlangCons head_30 (ErlangCons head_40 ErlangEmptyList)]
  in let tup_el_16 = erlps__expr_to_fcode__2 [env1_11, arg_18]
  in let
    bind_52 =
      ErlangTuple
        [ErlangAtom "lam", ErlangCons arg_8 ErlangEmptyList, tup_el_16]
  in let head_55 = toErl "ListInternal"
  in let head_57 = toErl "flat_map"
  in let
    matchExpr_60 =
      erlps__resolve_fun__2
        [env_0, ErlangCons head_55 (ErlangCons head_57 ErlangEmptyList)]
  in
    case matchExpr_60 of
      (ErlangTuple [(ErlangAtom "def_u"), flatmap_59, _]) ->
        let head_66 = erlps__expr_to_fcode__2 [env_0, bindexpr_6]
        in
          ErlangTuple
            [ErlangAtom "def", flatmap_59,
             ErlangCons bind_52 (ErlangCons head_66 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_60
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_if"),
                                                                 _,
                                                                 cond_4]) rest_5)])]
  =
  let    arg_6 = erlps__expr_to_fcode__2 [env_0, cond_4]
  in let
    arg_12 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_5]
  in let arg_9 = erlps__expr_to_fcode__3 [env_0, type_1, arg_12]
  in erlps__make_if__3 [arg_6, arg_9, ErlangAtom "nil"]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons lv_4@(ErlangTuple [(ErlangAtom "letval"),
                                                                      _, _,
                                                                      _]) rest_5)])]
  =
  let   
    head_14 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_5]
  in let
    arg_8 =
      ErlangTuple
        [ErlangAtom "block", as_2,
         ErlangCons lv_4 (ErlangCons head_14 ErlangEmptyList)]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_8]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons lf_4@(ErlangTuple [(ErlangAtom "letfun"),
                                                                      _, _, _,
                                                                      _,
                                                                      _]) rest_5)])]
  =
  let   
    head_14 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_5]
  in let
    arg_8 =
      ErlangTuple
        [ErlangAtom "block", as_2,
         ErlangCons lf_4 (ErlangCons head_14 ErlangEmptyList)]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_8]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "if"), _, cond_2, then_3,
                                       else_4])]
  =
  let    arg_5 = erlps__expr_to_fcode__2 [env_0, cond_2]
  in let arg_8 = erlps__expr_to_fcode__2 [env_0, then_3]
  in let arg_11 = erlps__expr_to_fcode__2 [env_0, else_4]
  in erlps__make_if__3 [arg_5, arg_8, arg_11]
erlps__expr_to_fcode__3 [env_0, _,
                         (ErlangTuple [(ErlangAtom "switch"), _,
                                       expr_3@(ErlangTuple [(ErlangAtom "typed"),
                                                            _, e_1, type_2]),
                                       alts_4])]
  =
  let
    switch_16 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let    arg_11 = erlps__type_to_fcode__2 [env_0, type_2]
             in let
               tup_el_9 = erlps__alts_to_fcode__4 [env_0, arg_11, x_7, alts_4]
             in ErlangTuple [ErlangAtom "switch", tup_el_9]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in
    case e_1 of
      (ErlangTuple [(ErlangAtom "id"), _, x_18]) ->
        BIF.erlang__apply__2 [switch_16, ErlangCons x_18 ErlangEmptyList]
      _ ->
        let    x_21 = erlps__fresh_name__0 []
        in let tup_el_24 = erlps__expr_to_fcode__2 [env_0, expr_3]
        in let
          tup_el_27 =
            BIF.erlang__apply__2 [switch_16, ErlangCons x_21 ErlangEmptyList]
        in ErlangTuple [ErlangAtom "let", x_21, tup_el_24, tup_el_27]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "block"), _, stmts_2])]
  =
  erlps__stmts_to_fcode__2 [env_0, stmts_2]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         expr_3@(ErlangTuple [(ErlangAtom "app"), _,
                                              (ErlangTuple [op_2, _]),
                                              (ErlangCons _ (ErlangCons _ (ErlangEmptyList)))])]
  | (weakEq op_2 (ErlangAtom "&&")) ||
      (weakEq op_2 (ErlangAtom "||")) =
  let tree_6 = erlps__expr_to_decision_tree__2 [env_0, expr_3]
  in erlps__decision_tree_to_fcode__1 [tree_6]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _ann_2,
                                       (ErlangTuple [op_3, _]),
                                       (ErlangCons a_4 (ErlangCons b_5 (ErlangEmptyList)))])]
  | isEAtom op_3 =
  let    head_9 = erlps__expr_to_fcode__2 [env_0, a_4]
  in let head_13 = erlps__expr_to_fcode__2 [env_0, b_5]
  in
    ErlangTuple
      [ErlangAtom "op", op_3,
       ErlangCons head_9 (ErlangCons head_13 ErlangEmptyList)]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _ann_2,
                                       (ErlangTuple [op_3, _]),
                                       (ErlangCons a_4 (ErlangEmptyList))])]
  | isEAtom op_3 =
  case op_3 of
    (ErlangAtom "-") ->
      let    tup_el_13 = toErl 0
      in let tup_el_11 = ErlangTuple [ErlangAtom "int", tup_el_13]
      in let head_9 = ErlangTuple [ErlangAtom "lit", tup_el_11]
      in let head_15 = erlps__expr_to_fcode__2 [env_0, a_4]
      in
        ErlangTuple
          [ErlangAtom "op", ErlangAtom "-",
           ErlangCons head_9 (ErlangCons head_15 ErlangEmptyList)]
    (ErlangAtom "!") ->
      let head_22 = erlps__expr_to_fcode__2 [env_0, a_4]
      in
        ErlangTuple
          [ErlangAtom "op", ErlangAtom "!",
           ErlangCons head_22 ErlangEmptyList]
    something_else -> EXC.case_clause something_else
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "app"), _,
                                       fun_5@(ErlangTuple [(ErlangAtom "typed"),
                                                           _, fune_2,
                                                           (ErlangTuple [(ErlangAtom "fun_t"),
                                                                         _,
                                                                         namedargst_3,
                                                                         argst_4,
                                                                         _])]),
                                       args_6])]
  =
  let    args1_9 = erlps__get_named_args__2 [namedargst_3, args_6]
  in let
    fargs_16 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__expr_to_fcode__2 [env_0, lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        args1_9
  in let case_17 = erlps__expr_to_fcode__2 [env_0, fun_5]
  in
    case case_17 of
      (ErlangTuple [(ErlangAtom "builtin_u"), b_20, _ar_21,
                    typeargs_22]) ->
        let    arg_23 = erlps__state_layout__1 [env_0]
        in let arg_26 = BIF.erlang__op_append [fargs_16, typeargs_22]
        in erlps__builtin_to_fcode__3 [arg_23, b_20, arg_26]
      (ErlangTuple [(ErlangAtom "builtin_u"),
                    (ErlangAtom "chain_clone"), _ar_29]) ->
        case argst_4 of
          (ErlangAtom "var_args") ->
            let arg_31 = ErlangTuple [ErlangAtom "var_args_not_set", fune_2]
            in erlps__fcode_error__1 [arg_31]
          _ ->
            let   
              arg_34 =
                flmap
                  (\ lc_37 ->
                     let lcRet_38 = erlps__type_to_fcode__2 [env_0, lc_37]
                     in ErlangCons lcRet_38 ErlangEmptyList)
                  argst_4
            in let
              finitargst_41 =
                BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
                  [arg_34]
            in let arg_42 = erlps__state_layout__1 [env_0]
            in let head_46 = ErlangTuple [ErlangAtom "lit", finitargst_41]
            in
              erlps__builtin_to_fcode__3
                [arg_42, ErlangAtom "chain_clone", ErlangCons head_46 fargs_16]
      (ErlangTuple [(ErlangAtom "builtin_u"),
                    (ErlangAtom "chain_create"), _ar_50]) ->
        let case_51 = ErlangTuple [argst_4, type_1]
        in
          case case_51 of
            (ErlangTuple [(ErlangAtom "var_args"), _]) ->
              let arg_54 = ErlangTuple [ErlangAtom "var_args_not_set", fune_2]
              in erlps__fcode_error__1 [arg_54]
            (ErlangTuple [_,
                          (ErlangTuple [(ErlangAtom "con"), _,
                                        contract_57])]) ->
              let   
                arg_58 =
                  flmap
                    (\ lc_61 ->
                       let lcRet_62 = erlps__type_to_fcode__2 [env_0, lc_61]
                       in ErlangCons lcRet_62 ErlangEmptyList)
                    argst_4
              in let
                finitargst_65 =
                  BIF.do_remote_fun_call "Aeb.Fate.Data"
                    "erlps__make_typerep__1" [arg_58]
              in let arg_66 = erlps__state_layout__1 [env_0]
              in let
                tup_el_72 =
                  ErlangTuple [ErlangAtom "contract_code", contract_57]
              in let head_70 = ErlangTuple [ErlangAtom "lit", tup_el_72]
              in let head_76 = ErlangTuple [ErlangAtom "lit", finitargst_65]
              in
                erlps__builtin_to_fcode__3
                  [arg_66, ErlangAtom "chain_create",
                   ErlangCons head_70 (ErlangCons head_76 fargs_16)]
            (ErlangTuple [_, _]) ->
              let
                arg_80 = ErlangTuple [ErlangAtom "not_a_contract_type", type_1]
              in erlps__fcode_error__1 [arg_80]
            something_else -> EXC.case_clause something_else
      (ErlangTuple [(ErlangAtom "builtin_u"), b_83, _ar_84]) ->
        let arg_85 = erlps__state_layout__1 [env_0]
        in erlps__builtin_to_fcode__3 [arg_85, b_83, fargs_16]
      (ErlangTuple [(ErlangAtom "def_u"), f_89, _ar_90]) ->
        ErlangTuple [ErlangAtom "def", f_89, fargs_16]
      (ErlangTuple [(ErlangAtom "remote_u"), rargst_94, rrett_95,
                    ct_96, rfun_97]) ->
        ErlangTuple
          [ErlangAtom "remote", rargst_94, rrett_95, ct_96, rfun_97,
           fargs_16]
      ffun_104 ->
        let
          call_123 =
            ErlangFun 1
              (let
                 lambda_105 [x_107] =
                   let    tup_el_111 = ErlangTuple [ErlangAtom "var", x_107]
                   in let tup_el_114 = toErl 0
                   in let
                     tup_el_109 =
                       ErlangTuple [ErlangAtom "proj", tup_el_111, tup_el_114]
                   in let tup_el_118 = ErlangTuple [ErlangAtom "var", x_107]
                   in let tup_el_121 = toErl 1
                   in let
                     head_116 =
                       ErlangTuple [ErlangAtom "proj", tup_el_118, tup_el_121]
                   in
                     ErlangTuple
                       [ErlangAtom "funcall", tup_el_109,
                        ErlangCons head_116 fargs_16]
                 lambda_105 [arg_106] = EXC.function_clause unit
                 lambda_105 args = EXC.badarity (ErlangFun 1 lambda_105) args
               in lambda_105)
        in
          case ffun_104 of
            (ErlangTuple [(ErlangAtom "var"), x_125]) ->
              BIF.erlang__apply__2 [call_123, ErlangCons x_125 ErlangEmptyList]
            _ ->
              let    x_128 = erlps__fresh_name__0 []
              in let
                tup_el_132 =
                  BIF.erlang__apply__2
                    [call_123, ErlangCons x_128 ErlangEmptyList]
              in ErlangTuple [ErlangAtom "let", x_128, ffun_104, tup_el_132]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map"), _,
                                       (ErlangEmptyList)])]
  =
  ErlangTuple
    [ErlangAtom "builtin", ErlangAtom "map_empty", ErlangEmptyList]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "map"), ann_2, kvs_3])]
  =
  let   
    fields_18 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [k_5, v_6]) ->
               let    head_12 = ErlangTuple [ErlangAtom "map_get", ann_2, k_5]
               in let
                 lcRet_8 =
                   ErlangTuple
                     [ErlangAtom "field", ann_2,
                      ErlangCons head_12 ErlangEmptyList, v_6]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        kvs_3
  in let
    tup_el_24 =
      ErlangTuple [ErlangAtom "map", ann_2, ErlangEmptyList]
  in let
    arg_21 =
      ErlangTuple [ErlangAtom "map", ann_2, tup_el_24, fields_18]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_21]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map"), _, map_2, kvs_3])]
  =
  let    arg_4 = erlps__expr_to_fcode__2 [env_0, map_2]
  in let
    arg_7 =
      ErlangFun 1
        (let
           lambda_8 [map1_10] =
             let
               arg_11 =
                 ErlangFun 2
                   (let
                      lambda_12 [fld_15, m_16] =
                        case fld_15 of
                          (ErlangTuple [(ErlangAtom "field"), _,
                                        (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                  _,
                                                                  k_18]) (ErlangEmptyList)),
                                        v_19]) ->
                            let   
                              head_25 = erlps__expr_to_fcode__2 [env_0, k_18]
                            in let
                              head_29 = erlps__expr_to_fcode__2 [env_0, v_19]
                            in
                              ErlangTuple
                                [ErlangAtom "op", ErlangAtom "map_set",
                                 ErlangCons m_16
                                   (ErlangCons head_25
                                      (ErlangCons head_29 ErlangEmptyList))]
                          (ErlangTuple [(ErlangAtom "field_upd"), _,
                                        (ErlangCons mapget_33 (ErlangEmptyList)),
                                        (ErlangTuple [(ErlangAtom "typed"), _,
                                                      (ErlangTuple [(ErlangAtom "lam"),
                                                                    _,
                                                                    (ErlangCons (ErlangTuple [(ErlangAtom "arg"),
                                                                                              _,
                                                                                              (ErlangTuple [(ErlangAtom "id"),
                                                                                                            _,
                                                                                                            z_34]),
                                                                                              _]) (ErlangEmptyList)),
                                                                    v_35]),
                                                      _])]) | onElement
                                                                (toErl 1)
                                                                mapget_33 weakEq
                                                                (ErlangAtom
                                                                   "map_get") ->
                            let
                              matchExpr_39 =
                                BIF.erlang__tuple_to_list__1 [mapget_33]
                            in
                              case matchExpr_39 of
                                (ErlangCons (ErlangAtom "map_get") (ErlangCons _ (ErlangCons k_37 default_38))) ->
                                  let   
                                    arg_40 =
                                      erlps__expr_to_fcode__2 [env_0, k_37]
                                  in let
                                    arg_43 =
                                      ErlangFun 1
                                        (let
                                           lambda_44 [key_46] =
                                             let   
                                               z1_47 = erlps__fresh_name__0 []
                                             in let
                                               getexpr_68 =
                                                 case default_38 of
                                                   (ErlangEmptyList) ->
                                                     ErlangTuple
                                                       [ErlangAtom "op",
                                                        ErlangAtom "map_get",
                                                        ErlangCons map1_10
                                                          (ErlangCons key_46
                                                             ErlangEmptyList)]
                                                   (ErlangCons d_56 (ErlangEmptyList)) ->
                                                     let
                                                       head_64 =
                                                         erlps__expr_to_fcode__2
                                                           [env_0, d_56]
                                                     in
                                                       ErlangTuple
                                                         [ErlangAtom "op",
                                                          ErlangAtom
                                                            "map_get_d",
                                                          ErlangCons map1_10
                                                            (ErlangCons key_46
                                                               (ErlangCons
                                                                  head_64
                                                                  ErlangEmptyList))]
                                                   something_else ->
                                                     EXC.case_clause
                                                       something_else
                                             in let
                                               head_82 =
                                                 ErlangTuple [z_34, z1_47]
                                             in let
                                               arg_87 =
                                                 erlps__bind_var__2
                                                   [env_0, z_34]
                                             in let
                                               arg_86 =
                                                 erlps__expr_to_fcode__2
                                                   [arg_87, v_35]
                                             in let
                                               head_80 =
                                                 erlps__rename__2
                                                   [ErlangCons head_82
                                                      ErlangEmptyList,
                                                    arg_86]
                                             in let
                                               tup_el_72 =
                                                 ErlangTuple
                                                   [ErlangAtom "op",
                                                    ErlangAtom "map_set",
                                                    ErlangCons m_16
                                                      (ErlangCons key_46
                                                         (ErlangCons head_80
                                                            ErlangEmptyList))]
                                             in
                                               ErlangTuple
                                                 [ErlangAtom "let", z1_47,
                                                  getexpr_68, tup_el_72]
                                           lambda_44 [arg_45] =
                                             EXC.function_clause unit
                                           lambda_44 args =
                                             EXC.badarity
                                               (ErlangFun 1 lambda_44) args
                                         in lambda_44)
                                  in erlps__make_let__2 [arg_40, arg_43]
                                _ -> EXC.badmatch matchExpr_39
                          something_else -> EXC.case_clause something_else
                      lambda_12 [arg_13, arg_14] = EXC.function_clause unit
                      lambda_12 args = EXC.badarity (ErlangFun 2 lambda_12) args
                    in lambda_12)
             in
               BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
                 [arg_11, map1_10, kvs_3]
           lambda_8 [arg_9] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
         in lambda_8)
  in erlps__make_let__2 [arg_4, arg_7]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map_get"), _, map_2,
                                       key_3])]
  =
  let    head_7 = erlps__expr_to_fcode__2 [env_0, map_2]
  in let head_11 = erlps__expr_to_fcode__2 [env_0, key_3]
  in
    ErlangTuple
      [ErlangAtom "op", ErlangAtom "map_get",
       ErlangCons head_7 (ErlangCons head_11 ErlangEmptyList)]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map_get"), _, map_2, key_3,
                                       def_4])]
  =
  let    head_8 = erlps__expr_to_fcode__2 [env_0, map_2]
  in let head_12 = erlps__expr_to_fcode__2 [env_0, key_3]
  in let head_16 = erlps__expr_to_fcode__2 [env_0, def_4]
  in
    ErlangTuple
      [ErlangAtom "op", ErlangAtom "map_get_d",
       ErlangCons head_8
         (ErlangCons head_12 (ErlangCons head_16 ErlangEmptyList))]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "lam"), _, args_2, body_3])]
  =
  let   
    getarg_7 =
      ErlangFun 1
        (let
           lambda_4 [(ErlangTuple [(ErlangAtom "arg"), _,
                                   (ErlangTuple [(ErlangAtom "id"), _, x_6]),
                                   _])]
             =
             x_6
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    xs_10 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [getarg_7, args_2]
  in let arg_14 = erlps__bind_vars__2 [env_0, xs_10]
  in let tup_el_13 = erlps__expr_to_fcode__2 [arg_14, body_3]
  in ErlangTuple [ErlangAtom "lam", xs_10, tup_el_13]
erlps__expr_to_fcode__3 [_env_0, type_1, expr_2] =
  let    tup_el_5 = ErlangTuple [expr_2, ErlangAtom ":", type_1]
  in let arg_3 = ErlangTuple [ErlangAtom "todo", tup_el_5]
  in BIF.erlang__error__1 [arg_3]
erlps__expr_to_fcode__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__expr_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__expr_to_fcode__3) args

erlps__make_if__3 :: ErlangFun
erlps__make_if__3 [(ErlangTuple [(ErlangAtom "var"), x_0]),
                   then_1, else_2]
  =
  let   
    tup_el_11 = ErlangTuple [ErlangAtom "bool", ErlangAtom "false"]
  in let tup_el_14 = ErlangTuple [ErlangAtom "nosplit", else_2]
  in let
    head_9 = ErlangTuple [ErlangAtom "case", tup_el_11, tup_el_14]
  in let
    tup_el_20 = ErlangTuple [ErlangAtom "bool", ErlangAtom "true"]
  in let tup_el_23 = ErlangTuple [ErlangAtom "nosplit", then_1]
  in let
    head_18 = ErlangTuple [ErlangAtom "case", tup_el_20, tup_el_23]
  in let
    tup_el_4 =
      ErlangTuple
        [ErlangAtom "split", ErlangAtom "boolean", x_0,
         ErlangCons head_9 (ErlangCons head_18 ErlangEmptyList)]
  in ErlangTuple [ErlangAtom "switch", tup_el_4]
erlps__make_if__3 [cond_0, then_1, else_2] =
  let    x_3 = erlps__fresh_name__0 []
  in let arg_8 = ErlangTuple [ErlangAtom "var", x_3]
  in let tup_el_7 = erlps__make_if__3 [arg_8, then_1, else_2]
  in ErlangTuple [ErlangAtom "let", x_3, cond_0, tup_el_7]
erlps__make_if__3 [arg_13, arg_14, arg_15] =
  EXC.function_clause unit
erlps__make_if__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_if__3) args

erlps__make_tuple__1 :: ErlangFun
erlps__make_tuple__1 [(ErlangCons e_0 (ErlangEmptyList))] = e_0
erlps__make_tuple__1 [es_0] =
  ErlangTuple [ErlangAtom "tuple", es_0]
erlps__make_tuple__1 [arg_3] = EXC.function_clause unit
erlps__make_tuple__1 args =
  EXC.badarity (ErlangFun 1 erlps__make_tuple__1) args

erlps__strip_singleton_tuples__1 :: ErlangFun
erlps__strip_singleton_tuples__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                                (ErlangCons t_0 (ErlangEmptyList))])]
  =
  erlps__strip_singleton_tuples__1 [t_0]
erlps__strip_singleton_tuples__1 [t_0] = t_0
erlps__strip_singleton_tuples__1 [arg_1] =
  EXC.function_clause unit
erlps__strip_singleton_tuples__1 args =
  EXC.badarity (ErlangFun 1 erlps__strip_singleton_tuples__1) args

erlps__get_oracle_type__2 :: ErlangFun
erlps__get_oracle_type__2 [(ErlangAtom "oracle_register"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _, _,
                                         otype_0])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_query"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_get_question"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_get_answer"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_check"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_check_query"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_respond"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__get_oracle_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_oracle_type__2) args

erlps__validate_oracle_type__4 :: ErlangFun
erlps__validate_oracle_type__4 [ann_0, type_1, qtype_2, rtype_3]
  =
  let   
    arg_5 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "polymorphic",
         ErlangAtom "query", ann_0, type_1]
  in let _ = erlps__ensure_monomorphic__2 [qtype_2, arg_5]
  in let
    arg_12 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "polymorphic",
         ErlangAtom "response", ann_0, type_1]
  in let _ = erlps__ensure_monomorphic__2 [rtype_3, arg_12]
  in let
    arg_19 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "higher_order",
         ErlangAtom "query", ann_0, type_1]
  in let _ = erlps__ensure_first_order__2 [qtype_2, arg_19]
  in let
    arg_26 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "higher_order",
         ErlangAtom "response", ann_0, type_1]
  in let _ = erlps__ensure_first_order__2 [rtype_3, arg_26]
  in ErlangAtom "ok"
erlps__validate_oracle_type__4 [arg_32, arg_33, arg_34, arg_35] =
  EXC.function_clause unit
erlps__validate_oracle_type__4 args =
  EXC.badarity (ErlangFun 4 erlps__validate_oracle_type__4) args

erlps__validate_aens_resolve_type__3 :: ErlangFun
erlps__validate_aens_resolve_type__3 [ann_0,
                                      (ErlangTuple [(ErlangAtom "app_t"), _, _,
                                                    (ErlangCons type_1 (ErlangEmptyList))]),
                                      (ErlangTuple [(ErlangAtom "variant"),
                                                    (ErlangCons (ErlangEmptyList) (ErlangCons (ErlangCons ftype_2 (ErlangEmptyList)) (ErlangEmptyList)))])]
  =
  case ftype_2 of
    (ErlangAtom "string") -> ErlangAtom "ok"
    (ErlangAtom "address") -> ErlangAtom "ok"
    (ErlangAtom "contract") -> ErlangAtom "ok"
    (ErlangTuple [(ErlangAtom "oracle"), _, _]) -> ErlangAtom "ok"
    (ErlangAtom "oracle_query") -> ErlangAtom "ok"
    _ ->
      let
        arg_4 =
          ErlangTuple
            [ErlangAtom "invalid_aens_resolve_type", ann_0, type_1]
      in erlps__fcode_error__1 [arg_4]
erlps__validate_aens_resolve_type__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__validate_aens_resolve_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__validate_aens_resolve_type__3)
    args

erlps__ensure_first_order_entrypoint__6 :: ErlangFun
erlps__ensure_first_order_entrypoint__6 [ann_0,
                                         id_2@(ErlangTuple [(ErlangAtom "id"),
                                                            _, name_1]),
                                         args_3, ret_4, fargs_5, fret_6]
  =
  let   
    lcSrc_7 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2" [args_3, fargs_5]
  in let
    _ =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangTuple [(ErlangAtom "typed"), ann1_10, x_11,
                                         t_12]),
                           (ErlangTuple [_, ft_13])]) ->
               let   
                 tup_el_22 = ErlangTuple [ErlangAtom "argument", x_11, t_12]
               in let
                 arg_17 =
                   ErlangTuple
                     [ErlangAtom "invalid_entrypoint",
                      ErlangAtom "higher_order", ann1_10, id_2, tup_el_22]
               in let lcRet_15 = erlps__ensure_first_order__2 [ft_13, arg_17]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_7
  in let rop_28 = toErl "init"
  in let cond_26 = BIF.erlang__op_neq [name_1, rop_28]
  in let
    _ =
      case cond_26 of
        (ErlangAtom "true") ->
          let    tup_el_36 = ErlangTuple [ErlangAtom "result", ret_4]
          in let
            arg_31 =
              ErlangTuple
                [ErlangAtom "invalid_entrypoint", ErlangAtom "higher_order",
                 ann_0, id_2, tup_el_36]
          in let lcRet_29 = erlps__ensure_first_order__2 [fret_6, arg_31]
          in ErlangCons lcRet_29 ErlangEmptyList
        _ -> ErlangEmptyList
  in ErlangAtom "ok"
erlps__ensure_first_order_entrypoint__6 [arg_39, arg_40, arg_41,
                                         arg_42, arg_43, arg_44]
  =
  EXC.function_clause unit
erlps__ensure_first_order_entrypoint__6 args =
  EXC.badarity
    (ErlangFun 6 erlps__ensure_first_order_entrypoint__6) args

erlps__ensure_monomorphic__2 :: ErlangFun
erlps__ensure_monomorphic__2 [type_0, err_1] =
  let case_2 = erlps__is_monomorphic__1 [type_0]
  in
    case case_2 of
      (ErlangAtom "true") -> ErlangAtom "ok"
      (ErlangAtom "false") -> erlps__fcode_error__1 [err_1]
      something_else -> EXC.case_clause something_else
erlps__ensure_monomorphic__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__ensure_monomorphic__2 args =
  EXC.badarity (ErlangFun 2 erlps__ensure_monomorphic__2) args

erlps__ensure_first_order__2 :: ErlangFun
erlps__ensure_first_order__2 [type_0, err_1] =
  let case_2 = erlps__is_first_order__1 [type_0]
  in
    case case_2 of
      (ErlangAtom "true") -> ErlangAtom "ok"
      (ErlangAtom "false") -> erlps__fcode_error__1 [err_1]
      something_else -> EXC.case_clause something_else
erlps__ensure_first_order__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__ensure_first_order__2 args =
  EXC.badarity (ErlangFun 2 erlps__ensure_first_order__2) args

erlps__is_monomorphic__1 :: ErlangFun
erlps__is_monomorphic__1 [(ErlangTuple [(ErlangAtom "tvar"), _])]
  =
  ErlangAtom "false"
erlps__is_monomorphic__1 [ts_0] | isEList ts_0 =
  let arg_1 = ErlangFun 1 erlps__is_monomorphic__1
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, ts_0]
erlps__is_monomorphic__1 [tup_0] | isETuple tup_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [tup_0]
  in erlps__is_monomorphic__1 [arg_1]
erlps__is_monomorphic__1 [_] = ErlangAtom "true"
erlps__is_monomorphic__1 [arg_0] = EXC.function_clause unit
erlps__is_monomorphic__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_monomorphic__1) args

erlps__is_first_order__1 :: ErlangFun
erlps__is_first_order__1 [(ErlangTuple [(ErlangAtom "function"),
                                        _, _])]
  =
  ErlangAtom "false"
erlps__is_first_order__1 [ts_0] | isEList ts_0 =
  let arg_1 = ErlangFun 1 erlps__is_first_order__1
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, ts_0]
erlps__is_first_order__1 [tup_0] | isETuple tup_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [tup_0]
  in erlps__is_first_order__1 [arg_1]
erlps__is_first_order__1 [_] = ErlangAtom "true"
erlps__is_first_order__1 [arg_0] = EXC.function_clause unit
erlps__is_first_order__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_first_order__1) args

erlps__alts_to_fcode__4 :: ErlangFun
erlps__alts_to_fcode__4 [env_0, type_1, x_2, alts_3] =
  let   
    falts_10 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__alt_to_fcode__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        alts_3
  in let head_13 = ErlangTuple [x_2, type_1]
  in
    erlps__split_tree__3
      [env_0, ErlangCons head_13 ErlangEmptyList, falts_10]
erlps__alts_to_fcode__4 [arg_18, arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__alts_to_fcode__4 args =
  EXC.badarity (ErlangFun 4 erlps__alts_to_fcode__4) args

erlps__split_tree__3 :: ErlangFun
erlps__split_tree__3 [_env_0, _vars_1, (ErlangEmptyList)] =
  BIF.erlang__error__1 [ErlangAtom "non_exhaustive_patterns"]
erlps__split_tree__3 [env_0, vars_1,
                      alts_4@(ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                       pats_2, body_3]) _)]
  =
  let case_5 = erlps__next_split__1 [pats_2]
  in
    case case_5 of
      (ErlangAtom "false") ->
        let   
          xs_11 =
            flmap
              (\ lc_9 ->
                 case lc_9 of
                   (ErlangTuple [x_8, _]) -> ErlangCons x_8 ErlangEmptyList
                   _ -> ErlangEmptyList)
              vars_1
        in let
          ys_16 =
            flmap
              (\ lc_14 ->
                 case lc_14 of
                   (ErlangTuple [(ErlangAtom "var"), y_13]) ->
                     ErlangCons y_13 ErlangEmptyList
                   _ -> ErlangEmptyList)
              pats_2
        in let
          lcSrc_17 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [ys_16, xs_11]
        in let
          ren_32 =
            flmap
              (\ lc_22 ->
                 case lc_22 of
                   (ErlangTuple [y_20, x_21]) ->
                     let cond_23 = BIF.erlang__op_neq [x_21, y_20]
                     in
                       case cond_23 of
                         (ErlangAtom "true") ->
                           let    rop_28 = toErl "_"
                           in let cond_26 = BIF.erlang__op_neq [y_20, rop_28]
                           in
                             case cond_26 of
                               (ErlangAtom "true") ->
                                 let lcRet_29 = ErlangTuple [y_20, x_21]
                                 in ErlangCons lcRet_29 ErlangEmptyList
                               _ -> ErlangEmptyList
                         _ -> ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_17
        in let tup_el_34 = erlps__rename__2 [ren_32, body_3]
        in ErlangTuple [ErlangAtom "nosplit", tup_el_34]
      i_37 | isEInt i_37 ->
        let    rop_40 = toErl 1
        in let arg_38 = BIF.erlang__op_minus [i_37, rop_40]
        in let
          matchExpr_46 =
            BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_38, vars_1]
        in
          case matchExpr_46 of
            (ErlangTuple [vars0_42,
                          (ErlangCons (ErlangTuple [x_43,
                                                    type_44]) vars1_45)]) ->
              let    type1_48 = erlps__strip_singleton_tuples__1 [type_44]
              in let
                arg_51 =
                  flmap
                    (\ lc_54 ->
                       let lcRet_55 = erlps__split_alt__2 [i_37, lc_54]
                       in ErlangCons lcRet_55 ErlangEmptyList)
                    alts_4
              in let salts_58 = erlps__merge_alts__3 [i_37, x_43, arg_51]
              in let
                makecase_80 =
                  ErlangFun 2
                    (let
                       lambda_59 [(ErlangTuple [(ErlangAtom "var"), z_62]),
                                  split_63]
                         =
                         let    tup_el_67 = toErl "_"
                         in let
                           tup_el_65 = ErlangTuple [ErlangAtom "var", tup_el_67]
                         in let head_70 = ErlangTuple [z_62, x_43]
                         in let
                           tup_el_68 =
                             erlps__rename_split__2
                               [ErlangCons head_70 ErlangEmptyList, split_63]
                         in
                           ErlangTuple [ErlangAtom "case", tup_el_65, tup_el_68]
                       lambda_59 [spat_75, split_76] =
                         ErlangTuple [ErlangAtom "case", spat_75, split_76]
                       lambda_59 [arg_60, arg_61] = EXC.function_clause unit
                       lambda_59 args =
                         EXC.badarity (ErlangFun 2 lambda_59) args
                     in lambda_59)
              in let
                cases_98 =
                  flmap
                    (\ lc_84 ->
                       case lc_84 of
                         (ErlangTuple [spat_82, falts_83]) ->
                           let   
                             lop_92 = erlps__split_vars__2 [spat_82, type1_48]
                           in let
                             rop_91 = BIF.erlang__op_append [lop_92, vars1_45]
                           in let
                             arg_89 = BIF.erlang__op_append [vars0_42, rop_91]
                           in let
                             arg_87 =
                               erlps__split_tree__3 [env_0, arg_89, falts_83]
                           in let
                             lcRet_85 =
                               BIF.erlang__apply__2
                                 [makecase_80,
                                  ErlangCons spat_82
                                    (ErlangCons arg_87 ErlangEmptyList)]
                           in ErlangCons lcRet_85 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    salts_58
              in ErlangTuple [ErlangAtom "split", type1_48, x_43, cases_98]
            _ -> EXC.badmatch matchExpr_46
      something_else -> EXC.case_clause something_else
erlps__split_tree__3 [arg_103, arg_104, arg_105] =
  EXC.function_clause unit
erlps__split_tree__3 args =
  EXC.badarity (ErlangFun 3 erlps__split_tree__3) args

erlps__merge_alts__3 :: ErlangFun
erlps__merge_alts__3 [i_0, x_1, alts_2] =
  erlps__merge_alts__4 [i_0, x_1, alts_2, ErlangEmptyList]
erlps__merge_alts__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__merge_alts__3 args =
  EXC.badarity (ErlangFun 3 erlps__merge_alts__3) args

erlps__merge_alts__4 :: ErlangFun
erlps__merge_alts__4 [i_0, x_1, alts_2, alts1_3] =
  let
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [a_8, as_9] = erlps__merge_alt__4 [i_0, x_1, a_8, as_9]
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_4, alts1_3, alts_2]
erlps__merge_alts__4 [arg_16, arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__merge_alts__4 args =
  EXC.badarity (ErlangFun 4 erlps__merge_alts__4) args

erlps__merge_alt__4 :: ErlangFun
erlps__merge_alt__4 [_, _, (ErlangTuple [p_0, a_1]),
                     (ErlangEmptyList)]
  =
  let head_2 = ErlangTuple [p_0, ErlangCons a_1 ErlangEmptyList]
  in ErlangCons head_2 ErlangEmptyList
erlps__merge_alt__4 [i_0, x_1, (ErlangTuple [p_2, a_3]),
                     (ErlangCons (ErlangTuple [q_4, as_5]) rest_6)]
  =
  let   
    match_18 =
      ErlangFun 2
        (let
           lambda_7 [(ErlangTuple [(ErlangAtom "var"), _]),
                     (ErlangTuple [(ErlangAtom "var"), _])]
             =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "tuple"), _]),
                     (ErlangTuple [(ErlangAtom "tuple"), _])]
             =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "bool"), b_10]),
                     (ErlangTuple [(ErlangAtom "bool"), b_11])]
             | b_11 == b_10 =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "int"), n_12]),
                     (ErlangTuple [(ErlangAtom "int"), n_13])]
             | n_13 == n_12 =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "string"), s_14]),
                     (ErlangTuple [(ErlangAtom "string"), s_15])]
             | s_15 == s_14 =
             ErlangAtom "match"
           lambda_7 [(ErlangAtom "nil"), (ErlangAtom "nil")] =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "::"), _, _]),
                     (ErlangTuple [(ErlangAtom "::"), _, _])]
             =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "con"), _, c_16, _]),
                     (ErlangTuple [(ErlangAtom "con"), _, c_17, _])]
             | c_17 == c_16 =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "con"), _, _, _]),
                     (ErlangTuple [(ErlangAtom "con"), _, _, _])]
             =
             ErlangAtom "mismatch"
           lambda_7 [(ErlangTuple [(ErlangAtom "var"), _]), _] =
             ErlangAtom "expand"
           lambda_7 [_, (ErlangTuple [(ErlangAtom "var"), _])] =
             ErlangAtom "insert"
           lambda_7 [_, _] = ErlangAtom "mismatch"
           lambda_7 [arg_8, arg_9] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 2 lambda_7) args
         in lambda_7)
  in let
    case_19 =
      BIF.erlang__apply__2
        [match_18, ErlangCons p_2 (ErlangCons q_4 ErlangEmptyList)]
  in
    case case_19 of
      (ErlangAtom "match") ->
        let head_23 = ErlangTuple [q_4, ErlangCons a_3 as_5]
        in ErlangCons head_23 rest_6
      (ErlangAtom "mismatch") ->
        let    head_29 = ErlangTuple [q_4, as_5]
        in let arg_35 = ErlangTuple [p_2, a_3]
        in let tail_32 = erlps__merge_alt__4 [i_0, x_1, arg_35, rest_6]
        in ErlangCons head_29 tail_32
      (ErlangAtom "expand") ->
        let matchExpr_46 = erlps__expand__5 [i_0, x_1, p_2, q_4, a_3]
        in
          case matchExpr_46 of
            (ErlangTuple [before_44, after_45]) ->
              let    head_51 = ErlangTuple [q_4, as_5]
              in let
                tail_54 = erlps__merge_alts__4 [i_0, x_1, after_45, rest_6]
              in
                erlps__merge_alts__4
                  [i_0, x_1, before_44, ErlangCons head_51 tail_54]
            _ -> EXC.badmatch matchExpr_46
      (ErlangAtom "insert") ->
        let   
          head_59 = ErlangTuple [p_2, ErlangCons a_3 ErlangEmptyList]
        in let head_65 = ErlangTuple [q_4, as_5]
        in ErlangCons head_59 (ErlangCons head_65 rest_6)
      something_else -> EXC.case_clause something_else
erlps__merge_alt__4 [arg_69, arg_70, arg_71, arg_72] =
  EXC.function_clause unit
erlps__merge_alt__4 args =
  EXC.badarity (ErlangFun 4 erlps__merge_alt__4) args

erlps__expand__5 :: ErlangFun
erlps__expand__5 [i_0, x_1, p_2, q_3,
                  case_6@(ErlangTuple [(ErlangAtom "case"), ps_4, e_5])]
  =
  let    rop_9 = toErl 1
  in let arg_7 = BIF.erlang__op_minus [i_0, rop_9]
  in let
    matchExpr_14 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_7, ps_4]
  in
    case matchExpr_14 of
      (ErlangTuple [ps0_11,
                    (ErlangCons (ErlangTuple [(ErlangAtom "var"),
                                              y_12]) ps1_13)]) ->
        let    cond_16 = BIF.erlang__op_neq [y_12, x_1]
        in let
          arg_15 =
            case cond_16 of
              (ErlangAtom "true") ->
                let lcRet_19 = ErlangTuple [y_12, x_1]
                in ErlangCons lcRet_19 ErlangEmptyList
              _ -> ErlangEmptyList
        in let matchExpr_25 = erlps__rename_fpats__2 [arg_15, ps0_11]
        in
          case matchExpr_25 of
            (ErlangTuple [ps0r_23, ren1_24]) ->
              let matchExpr_30 = erlps__rename_fpats__2 [ren1_24, ps1_13]
              in
                case matchExpr_30 of
                  (ErlangTuple [ps1r_28, ren2_29]) ->
                    let    e1_33 = erlps__rename__2 [ren2_29, e_5]
                    in let
                      splice_45 =
                        ErlangFun 1
                          (let
                             lambda_34 [n_36] =
                               let    tup_el_43 = toErl "_"
                               in let
                                 arg_41 =
                                   ErlangTuple [ErlangAtom "var", tup_el_43]
                               in let
                                 lop_39 =
                                   BIF.do_remote_fun_call "Lists"
                                     "erlps__duplicate__2" [n_36, arg_41]
                               in let
                                 rop_38 =
                                   BIF.erlang__op_append [lop_39, ps1r_28]
                               in BIF.erlang__op_append [ps0r_23, rop_38]
                             lambda_34 [arg_35] = EXC.function_clause unit
                             lambda_34 args =
                               EXC.badarity (ErlangFun 1 lambda_34) args
                           in lambda_34)
                    in let
                      type_55 =
                        ErlangFun 1
                          (let
                             lambda_46 [(ErlangTuple [(ErlangAtom "tuple"),
                                                      xs_48])]
                               =
                               let tup_el_50 = BIF.erlang__length__1 [xs_48]
                               in ErlangTuple [ErlangAtom "tuple", tup_el_50]
                             lambda_46 [(ErlangTuple [(ErlangAtom "bool"), _])]
                               =
                               ErlangAtom "bool"
                             lambda_46 [(ErlangTuple [(ErlangAtom "int"), _])] =
                               ErlangAtom "int"
                             lambda_46 [(ErlangTuple [(ErlangAtom "string"),
                                                      _])]
                               =
                               ErlangAtom "string"
                             lambda_46 [(ErlangAtom "nil")] = ErlangAtom "list"
                             lambda_46 [(ErlangTuple [(ErlangAtom "::"), _, _])]
                               =
                               ErlangAtom "list"
                             lambda_46 [(ErlangTuple [(ErlangAtom "con"), as_52,
                                                      _, _])]
                               =
                               ErlangTuple [ErlangAtom "variant", as_52]
                             lambda_46 [arg_47] = EXC.function_clause unit
                             lambda_46 args =
                               EXC.badarity (ErlangFun 1 lambda_46) args
                           in lambda_46)
                    in let
                      mkcase_68 =
                        ErlangFun 2
                          (let
                             lambda_56 [pat_59, vars_60] =
                               let   
                                 tup_el_64 =
                                   BIF.erlang__apply__2
                                     [splice_45,
                                      ErlangCons vars_60 ErlangEmptyList]
                               in let
                                 tup_el_62 =
                                   ErlangTuple
                                     [ErlangAtom "case", tup_el_64, e1_33]
                               in ErlangTuple [pat_59, tup_el_62]
                             lambda_56 [arg_57, arg_58] =
                               EXC.function_clause unit
                             lambda_56 args =
                               EXC.badarity (ErlangFun 2 lambda_56) args
                           in lambda_56)
                    in let
                      case_69 =
                        BIF.erlang__apply__2
                          [type_55, ErlangCons q_3 ErlangEmptyList]
                    in
                      case case_69 of
                        (ErlangTuple [(ErlangAtom "tuple"), n_72]) ->
                          let
                            head_74 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons q_3
                                   (ErlangCons n_72 ErlangEmptyList)]
                          in
                            ErlangTuple
                              [ErlangCons head_74 ErlangEmptyList,
                               ErlangEmptyList]
                        (ErlangAtom "bool") ->
                          let
                            tup_el_80 =
                              flmap
                                (\ lc_87 ->
                                   let   
                                     arg_89 =
                                       ErlangTuple [ErlangAtom "bool", lc_87]
                                   in let arg_92 = toErl 0
                                   in let
                                     lcRet_88 =
                                       BIF.erlang__apply__2
                                         [mkcase_68,
                                          ErlangCons arg_89
                                            (ErlangCons arg_92 ErlangEmptyList)]
                                   in ErlangCons lcRet_88 ErlangEmptyList)
                                (ErlangCons (ErlangAtom "false")
                                   (ErlangCons (ErlangAtom "true")
                                      ErlangEmptyList))
                          in ErlangTuple [tup_el_80, ErlangEmptyList]
                        (ErlangAtom "int") ->
                          let    arg_98 = toErl 0
                          in let
                            head_96 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons q_3
                                   (ErlangCons arg_98 ErlangEmptyList)]
                          in let head_102 = ErlangTuple [p_2, case_6]
                          in
                            ErlangTuple
                              [ErlangCons head_96 ErlangEmptyList,
                               ErlangCons head_102 ErlangEmptyList]
                        (ErlangAtom "string") ->
                          let    arg_109 = toErl 0
                          in let
                            head_107 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons q_3
                                   (ErlangCons arg_109 ErlangEmptyList)]
                          in let head_113 = ErlangTuple [p_2, case_6]
                          in
                            ErlangTuple
                              [ErlangCons head_107 ErlangEmptyList,
                               ErlangCons head_113 ErlangEmptyList]
                        (ErlangAtom "list") ->
                          let    arg_120 = toErl 0
                          in let
                            head_118 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons (ErlangAtom "nil")
                                   (ErlangCons arg_120 ErlangEmptyList)]
                          in let tup_el_126 = erlps__fresh_name__0 []
                          in let tup_el_127 = erlps__fresh_name__0 []
                          in let
                            arg_124 =
                              ErlangTuple
                                [ErlangAtom "::", tup_el_126, tup_el_127]
                          in let arg_128 = toErl 2
                          in let
                            head_123 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons arg_124
                                   (ErlangCons arg_128 ErlangEmptyList)]
                          in
                            ErlangTuple
                              [ErlangCons head_118
                                 (ErlangCons head_123 ErlangEmptyList),
                               ErlangEmptyList]
                        (ErlangTuple [(ErlangAtom "variant"), as_132]) ->
                          let    lcSrc_134 = erlps__indexed__1 [as_132]
                          in let
                            tup_el_133 =
                              flmap
                                (\ lc_138 ->
                                   case lc_138 of
                                     (ErlangTuple [c_136, ar_137]) ->
                                       let    rop_145 = toErl 1
                                       in let
                                         tup_el_143 =
                                           BIF.erlang__op_minus [c_136, rop_145]
                                       in let arg_148 = toErl 1
                                       in let
                                         lcSrc_147 =
                                           BIF.do_remote_fun_call "Lists"
                                             "erlps__seq__2" [arg_148, ar_137]
                                       in let
                                         tup_el_146 =
                                           flmap
                                             (\ lc_150 ->
                                                case lc_150 of
                                                  _ ->
                                                    let
                                                      lcRet_151 =
                                                        erlps__fresh_name__0 []
                                                    in
                                                      ErlangCons lcRet_151
                                                        ErlangEmptyList)
                                             lcSrc_147
                                       in let
                                         arg_140 =
                                           ErlangTuple
                                             [ErlangAtom "con", as_132,
                                              tup_el_143, tup_el_146]
                                       in let
                                         lcRet_139 =
                                           BIF.erlang__apply__2
                                             [mkcase_68,
                                              ErlangCons arg_140
                                                (ErlangCons ar_137
                                                   ErlangEmptyList)]
                                       in ErlangCons lcRet_139 ErlangEmptyList
                                     _ -> ErlangEmptyList)
                                lcSrc_134
                          in ErlangTuple [tup_el_133, ErlangEmptyList]
                        something_else -> EXC.case_clause something_else
                  _ -> EXC.badmatch matchExpr_30
            _ -> EXC.badmatch matchExpr_25
      _ -> EXC.badmatch matchExpr_14
erlps__expand__5 [arg_155, arg_156, arg_157, arg_158, arg_159] =
  EXC.function_clause unit
erlps__expand__5 args =
  EXC.badarity (ErlangFun 5 erlps__expand__5) args

erlps__split_alt__2 :: ErlangFun
erlps__split_alt__2 [i_0,
                     (ErlangTuple [(ErlangAtom "case"), pats_1, body_2])]
  =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [i_0, rop_5]
  in let
    matchExpr_10 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_3, pats_1]
  in
    case matchExpr_10 of
      (ErlangTuple [pats0_7, (ErlangCons pat_8 pats1_9)]) ->
        let matchExpr_14 = erlps__split_pat__1 [pat_8]
        in
          case matchExpr_14 of
            (ErlangTuple [spat_12, innerpats_13]) ->
              let    rop_20 = BIF.erlang__op_append [innerpats_13, pats1_9]
              in let tup_el_18 = BIF.erlang__op_append [pats0_7, rop_20]
              in let
                tup_el_16 = ErlangTuple [ErlangAtom "case", tup_el_18, body_2]
              in ErlangTuple [spat_12, tup_el_16]
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_10
erlps__split_alt__2 [arg_24, arg_25] = EXC.function_clause unit
erlps__split_alt__2 args =
  EXC.badarity (ErlangFun 2 erlps__split_alt__2) args

erlps__split_pat__1 :: ErlangFun
erlps__split_pat__1 [p_0@(ErlangTuple [(ErlangAtom "var"), _])] =
  let    tup_el_3 = erlps__fresh_name__0 []
  in let tup_el_1 = ErlangTuple [ErlangAtom "var", tup_el_3]
  in ErlangTuple [tup_el_1, ErlangCons p_0 ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "bool"), b_0])] =
  let tup_el_1 = ErlangTuple [ErlangAtom "bool", b_0]
  in ErlangTuple [tup_el_1, ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "int"), n_0])] =
  let tup_el_1 = ErlangTuple [ErlangAtom "int", n_0]
  in ErlangTuple [tup_el_1, ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "string"), n_0])]
  =
  let tup_el_1 = ErlangTuple [ErlangAtom "string", n_0]
  in ErlangTuple [tup_el_1, ErlangEmptyList]
erlps__split_pat__1 [(ErlangAtom "nil")] =
  ErlangTuple [ErlangAtom "nil", ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "::"), p_0, q_1])]
  =
  let    tup_el_4 = erlps__fresh_name__0 []
  in let tup_el_5 = erlps__fresh_name__0 []
  in let
    tup_el_2 = ErlangTuple [ErlangAtom "::", tup_el_4, tup_el_5]
  in
    ErlangTuple
      [tup_el_2, ErlangCons p_0 (ErlangCons q_1 ErlangEmptyList)]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "con"), as_0, i_1,
                                   pats_2])]
  =
  let   
    xs_6 =
      flmap
        (\ lc_4 ->
           case lc_4 of
             _ ->
               let lcRet_5 = erlps__fresh_name__0 []
               in ErlangCons lcRet_5 ErlangEmptyList)
        pats_2
  in let tup_el_7 = ErlangTuple [ErlangAtom "con", as_0, i_1, xs_6]
  in ErlangTuple [tup_el_7, pats_2]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                   pats_0])]
  =
  let   
    xs_4 =
      flmap
        (\ lc_2 ->
           case lc_2 of
             _ ->
               let lcRet_3 = erlps__fresh_name__0 []
               in ErlangCons lcRet_3 ErlangEmptyList)
        pats_0
  in let tup_el_5 = ErlangTuple [ErlangAtom "tuple", xs_4]
  in ErlangTuple [tup_el_5, pats_0]
erlps__split_pat__1 [arg_9] = EXC.function_clause unit
erlps__split_pat__1 args =
  EXC.badarity (ErlangFun 1 erlps__split_pat__1) args

erlps__split_vars__2 :: ErlangFun
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "bool"), _]),
                      (ErlangAtom "boolean")]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "int"), _]),
                      (ErlangAtom "integer")]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "string"), _]),
                      (ErlangAtom "string")]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangAtom "nil"),
                      (ErlangTuple [(ErlangAtom "list"), _])]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "::"), x_0,
                                    xs_1]),
                      (ErlangTuple [(ErlangAtom "list"), t_2])]
  =
  let    head_3 = ErlangTuple [x_0, t_2]
  in let tup_el_9 = ErlangTuple [ErlangAtom "list", t_2]
  in let head_7 = ErlangTuple [xs_1, tup_el_9]
  in ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList)
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "con"), _, i_0,
                                    xs_1]),
                      (ErlangTuple [(ErlangAtom "variant"), cons_2])]
  =
  let    rop_7 = toErl 1
  in let arg_5 = BIF.erlang__op_plus [i_0, rop_7]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_5, cons_2]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_1, arg_4]
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "tuple"), xs_0]),
                      (ErlangTuple [(ErlangAtom "tuple"), ts_1])]
  =
  BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_0, ts_1]
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "var"), x_0]),
                      t_1]
  =
  let head_2 = ErlangTuple [x_0, t_1]
  in ErlangCons head_2 ErlangEmptyList
erlps__split_vars__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__split_vars__2 args =
  EXC.badarity (ErlangFun 2 erlps__split_vars__2) args

erlps__next_split__1 :: ErlangFun
erlps__next_split__1 [pats_0] =
  let   
    isvar_3 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [(ErlangAtom "var"), _])] =
             ErlangAtom "true"
           lambda_1 [_] = ErlangAtom "false"
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let lcSrc_5 = erlps__indexed__1 [pats_0]
  in let
    case_4 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [i_7, p_8]) ->
               let   
                 op_arg_11 =
                   BIF.erlang__apply__2
                     [isvar_3, ErlangCons p_8 ErlangEmptyList]
               in let cond_10 = BIF.erlang__not__1 [op_arg_11]
               in
                 case cond_10 of
                   (ErlangAtom "true") -> ErlangCons i_7 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in
    case case_4 of
      (ErlangEmptyList) -> ErlangAtom "false"
      (ErlangCons i_15 _) -> i_15
      something_else -> EXC.case_clause something_else
erlps__next_split__1 [arg_16] = EXC.function_clause unit
erlps__next_split__1 args =
  EXC.badarity (ErlangFun 1 erlps__next_split__1) args

erlps__alt_to_fcode__2 :: ErlangFun
erlps__alt_to_fcode__2 [env_0,
                        (ErlangTuple [(ErlangAtom "case"), _, pat_1, expr_2])]
  =
  let    fpat_5 = erlps__pat_to_fcode__2 [env_0, pat_1]
  in let arg_8 = erlps__pat_vars__1 [fpat_5]
  in let arg_6 = erlps__bind_vars__2 [env_0, arg_8]
  in let fexpr_11 = erlps__expr_to_fcode__2 [arg_6, expr_2]
  in
    ErlangTuple
      [ErlangAtom "case", ErlangCons fpat_5 ErlangEmptyList, fexpr_11]
erlps__alt_to_fcode__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__alt_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__alt_to_fcode__2) args

erlps__pat_to_fcode__2 :: ErlangFun
erlps__pat_to_fcode__2 [env_0,
                        (ErlangTuple [(ErlangAtom "typed"), _, pat_1, type_2])]
  =
  erlps__pat_to_fcode__3 [env_0, type_2, pat_1]
erlps__pat_to_fcode__2 [env_0, pat_1] =
  erlps__pat_to_fcode__3 [env_0, ErlangAtom "no_type", pat_1]
erlps__pat_to_fcode__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__pat_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__pat_to_fcode__2) args

erlps__pat_to_fcode__3 :: ErlangFun
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "id"), _, x_2])]
  =
  ErlangTuple [ErlangAtom "var", x_2]
erlps__pat_to_fcode__3 [env_0, _type_1,
                        con_3@(ErlangTuple [c_2, _, _])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let matchExpr_8 = erlps__lookup_con__2 [env_0, con_3]
  in
    case matchExpr_8 of
      (ErlangTuple [(ErlangAtom "con_tag"), i_6, as_7]) ->
        ErlangTuple [ErlangAtom "con", as_7, i_6, ErlangEmptyList]
      _ -> EXC.badmatch matchExpr_8
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "app"), _,
                                      (ErlangTuple [(ErlangAtom "typed"), _,
                                                    con_3@(ErlangTuple [c_2, _,
                                                                        _]),
                                                    _]),
                                      pats_4])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let matchExpr_9 = erlps__lookup_con__2 [env_0, con_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangAtom "con_tag"), i_7, as_8]) ->
        let
          tup_el_13 =
            flmap
              (\ lc_16 ->
                 let lcRet_17 = erlps__pat_to_fcode__2 [env_0, lc_16]
                 in ErlangCons lcRet_17 ErlangEmptyList)
              pats_4
        in ErlangTuple [ErlangAtom "con", as_8, i_7, tup_el_13]
      _ -> EXC.badmatch matchExpr_9
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "tuple"), _, pats_2])]
  =
  let
    arg_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__pat_to_fcode__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        pats_2
  in erlps__make_tuple__1 [arg_3]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "bool"), _, b_2])]
  =
  ErlangTuple [ErlangAtom "bool", b_2]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "int"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "int", n_2]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "char"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "int", n_2]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "string"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "string", n_2]
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "list"), _, ps_2])]
  =
  let
    arg_3 =
      ErlangFun 2
        (let
           lambda_4 [p_7, qs_8] =
             let tup_el_10 = erlps__pat_to_fcode__2 [env_0, p_7]
             in ErlangTuple [ErlangAtom "::", tup_el_10, qs_8]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_3, ErlangAtom "nil", ps_2]
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "app"), _,
                                      (ErlangTuple [(ErlangAtom "::"), _]),
                                      (ErlangCons p_2 (ErlangCons q_3 (ErlangEmptyList)))])]
  =
  let    tup_el_5 = erlps__pat_to_fcode__2 [env_0, p_2]
  in let tup_el_8 = erlps__pat_to_fcode__2 [env_0, q_3]
  in ErlangTuple [ErlangAtom "::", tup_el_5, tup_el_8]
erlps__pat_to_fcode__3 [env_0,
                        (ErlangTuple [(ErlangAtom "record_t"), fields_1]),
                        (ErlangTuple [(ErlangAtom "record"), _, fieldpats_2])]
  =
  let   
    fieldpat_13 =
      ErlangFun 1
        (let
           lambda_3 [f_5] =
             let case_6 = erlps__field_value__2 [f_5, fieldpats_2]
             in
               case case_6 of
                 (ErlangAtom "false") ->
                   let tup_el_11 = toErl "_"
                   in ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_11]
                 (ErlangTuple [(ErlangAtom "set"), pat_12]) -> pat_12
                 something_else -> EXC.case_clause something_else
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    arg_14 =
      flmap
        (\ lc_17 ->
           let   
             arg_20 =
               BIF.erlang__apply__2
                 [fieldpat_13, ErlangCons lc_17 ErlangEmptyList]
           in let lcRet_18 = erlps__pat_to_fcode__2 [env_0, arg_20]
           in ErlangCons lcRet_18 ErlangEmptyList)
        fields_1
  in erlps__make_tuple__1 [arg_14]
erlps__pat_to_fcode__3 [_env_0, type_1, pat_2] =
  let
    arg_3 =
      ErlangTuple [ErlangAtom "todo", pat_2, ErlangAtom ":", type_1]
  in BIF.erlang__error__1 [arg_3]
erlps__pat_to_fcode__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__pat_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__pat_to_fcode__3) args

erlps__decision_op__3 :: ErlangFun
erlps__decision_op__3 [(ErlangAtom "&&"),
                       (ErlangTuple [(ErlangAtom "atom"), a_0]), b_1]
  =
  ErlangTuple [ErlangAtom "if", a_0, b_1, ErlangAtom "false"]
erlps__decision_op__3 [(ErlangAtom "&&"), (ErlangAtom "false"),
                       _]
  =
  ErlangAtom "false"
erlps__decision_op__3 [(ErlangAtom "&&"), (ErlangAtom "true"),
                       b_0]
  =
  b_0
erlps__decision_op__3 [(ErlangAtom "||"),
                       (ErlangTuple [(ErlangAtom "atom"), a_0]), b_1]
  =
  ErlangTuple [ErlangAtom "if", a_0, ErlangAtom "true", b_1]
erlps__decision_op__3 [(ErlangAtom "||"), (ErlangAtom "false"),
                       b_0]
  =
  b_0
erlps__decision_op__3 [(ErlangAtom "||"), (ErlangAtom "true"), _]
  =
  ErlangAtom "true"
erlps__decision_op__3 [op_0,
                       (ErlangTuple [(ErlangAtom "if"), a_1, then_2, else_3]),
                       b_4]
  =
  let    tup_el_7 = erlps__decision_op__3 [op_0, then_2, b_4]
  in let tup_el_11 = erlps__decision_op__3 [op_0, else_3, b_4]
  in ErlangTuple [ErlangAtom "if", a_1, tup_el_7, tup_el_11]
erlps__decision_op__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__decision_op__3 args =
  EXC.badarity (ErlangFun 3 erlps__decision_op__3) args

erlps__expr_to_decision_tree__2 :: ErlangFun
erlps__expr_to_decision_tree__2 [env_0,
                                 (ErlangTuple [(ErlangAtom "app"), _ann_1,
                                               (ErlangTuple [op_2, _]),
                                               (ErlangCons a_3 (ErlangCons b_4 (ErlangEmptyList)))])]
  | (weakEq op_2 (ErlangAtom "&&")) ||
      (weakEq op_2 (ErlangAtom "||")) =
  let    arg_6 = erlps__expr_to_decision_tree__2 [env_0, a_3]
  in let arg_9 = erlps__expr_to_decision_tree__2 [env_0, b_4]
  in erlps__decision_op__3 [op_2, arg_6, arg_9]
erlps__expr_to_decision_tree__2 [env_0,
                                 (ErlangTuple [(ErlangAtom "typed"), _, expr_1,
                                               _])]
  =
  erlps__expr_to_decision_tree__2 [env_0, expr_1]
erlps__expr_to_decision_tree__2 [env_0, expr_1] =
  let tup_el_3 = erlps__expr_to_fcode__2 [env_0, expr_1]
  in ErlangTuple [ErlangAtom "atom", tup_el_3]
erlps__expr_to_decision_tree__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__expr_to_decision_tree__2 args =
  EXC.badarity (ErlangFun 2 erlps__expr_to_decision_tree__2) args

erlps__decision_tree_to_fcode__1 :: ErlangFun
erlps__decision_tree_to_fcode__1 [(ErlangAtom "false")] =
  let
    tup_el_1 = ErlangTuple [ErlangAtom "bool", ErlangAtom "false"]
  in ErlangTuple [ErlangAtom "lit", tup_el_1]
erlps__decision_tree_to_fcode__1 [(ErlangAtom "true")] =
  let tup_el_1 = ErlangTuple [ErlangAtom "bool", ErlangAtom "true"]
  in ErlangTuple [ErlangAtom "lit", tup_el_1]
erlps__decision_tree_to_fcode__1 [(ErlangTuple [(ErlangAtom "atom"),
                                                b_0])]
  =
  b_0
erlps__decision_tree_to_fcode__1 [(ErlangTuple [(ErlangAtom "if"),
                                                a_0, then_1, else_2])]
  =
  let    x_3 = erlps__fresh_name__0 []
  in let
    tup_el_16 = ErlangTuple [ErlangAtom "bool", ErlangAtom "false"]
  in let tup_el_21 = erlps__decision_tree_to_fcode__1 [else_2]
  in let tup_el_19 = ErlangTuple [ErlangAtom "nosplit", tup_el_21]
  in let
    head_14 = ErlangTuple [ErlangAtom "case", tup_el_16, tup_el_19]
  in let
    tup_el_26 = ErlangTuple [ErlangAtom "bool", ErlangAtom "true"]
  in let tup_el_31 = erlps__decision_tree_to_fcode__1 [then_1]
  in let tup_el_29 = ErlangTuple [ErlangAtom "nosplit", tup_el_31]
  in let
    head_24 = ErlangTuple [ErlangAtom "case", tup_el_26, tup_el_29]
  in let
    tup_el_9 =
      ErlangTuple
        [ErlangAtom "split", ErlangAtom "boolean", x_3,
         ErlangCons head_14 (ErlangCons head_24 ErlangEmptyList)]
  in let tup_el_7 = ErlangTuple [ErlangAtom "switch", tup_el_9]
  in ErlangTuple [ErlangAtom "let", x_3, a_0, tup_el_7]
erlps__decision_tree_to_fcode__1 [arg_34] =
  EXC.function_clause unit
erlps__decision_tree_to_fcode__1 args =
  EXC.badarity (ErlangFun 1 erlps__decision_tree_to_fcode__1) args

erlps__stmts_to_fcode__2 :: ErlangFun
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons (ErlangTuple [(ErlangAtom "letval"), _,
                                                    (ErlangTuple [(ErlangAtom "typed"),
                                                                  _,
                                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                x_1]),
                                                                  _]),
                                                    expr_2]) stmts_3)]
  =
  let    tup_el_6 = erlps__expr_to_fcode__2 [env_0, expr_2]
  in let arg_10 = erlps__bind_var__2 [env_0, x_1]
  in let tup_el_9 = erlps__stmts_to_fcode__2 [arg_10, stmts_3]
  in ErlangTuple [ErlangAtom "let", x_1, tup_el_6, tup_el_9]
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons (ErlangTuple [(ErlangAtom "letval"),
                                                    ann_1, pat_2,
                                                    expr_3]) stmts_4)]
  =
  let   
    tup_el_15 = ErlangTuple [ErlangAtom "block", ann_1, stmts_4]
  in let
    head_11 =
      ErlangTuple [ErlangAtom "case", ann_1, pat_2, tup_el_15]
  in let
    arg_6 =
      ErlangTuple
        [ErlangAtom "switch", ann_1, expr_3,
         ErlangCons head_11 ErlangEmptyList]
  in erlps__expr_to_fcode__2 [env_0, arg_6]
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons (ErlangTuple [(ErlangAtom "letfun"),
                                                    ann_1,
                                                    (ErlangTuple [(ErlangAtom "id"),
                                                                  _, x_2]),
                                                    args_3, _type_4,
                                                    expr_5]) stmts_6)]
  =
  let   
    lamargs_22 =
      flmap
        (\ lc_9 ->
           let
             lcRet_10 =
               case lc_9 of
                 (ErlangTuple [(ErlangAtom "typed"), ann1_12, id_13, t_14]) ->
                   ErlangTuple [ErlangAtom "arg", ann1_12, id_13, t_14]
                 _ ->
                   let arg_19 = ErlangTuple [ErlangAtom "bad_arg", lc_9]
                   in erlps__internal_error__1 [arg_19]
           in ErlangCons lcRet_10 ErlangEmptyList)
        args_3
  in let
    arg_27 =
      ErlangTuple [ErlangAtom "lam", ann_1, lamargs_22, expr_5]
  in let tup_el_25 = erlps__expr_to_fcode__2 [env_0, arg_27]
  in let arg_33 = erlps__bind_var__2 [env_0, x_2]
  in let tup_el_32 = erlps__stmts_to_fcode__2 [arg_33, stmts_6]
  in ErlangTuple [ErlangAtom "let", x_2, tup_el_25, tup_el_32]
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons expr_1 (ErlangEmptyList))]
  =
  erlps__expr_to_fcode__2 [env_0, expr_1]
erlps__stmts_to_fcode__2 [env_0, (ErlangCons expr_1 stmts_2)] =
  let    tup_el_4 = toErl "_"
  in let tup_el_5 = erlps__expr_to_fcode__2 [env_0, expr_1]
  in let tup_el_8 = erlps__stmts_to_fcode__2 [env_0, stmts_2]
  in ErlangTuple [ErlangAtom "let", tup_el_4, tup_el_5, tup_el_8]
erlps__stmts_to_fcode__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__stmts_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__stmts_to_fcode__2) args

erlps__op_builtins__0 :: ErlangFun
erlps__op_builtins__0 [] =
  ErlangCons (ErlangAtom "map_from_list")
    (ErlangCons (ErlangAtom "map_to_list")
       (ErlangCons (ErlangAtom "map_delete")
          (ErlangCons (ErlangAtom "map_member")
             (ErlangCons (ErlangAtom "map_size")
                (ErlangCons (ErlangAtom "stringinternal_length")
                   (ErlangCons (ErlangAtom "stringinternal_concat")
                      (ErlangCons (ErlangAtom "stringinternal_to_list")
                         (ErlangCons (ErlangAtom "stringinternal_from_list")
                            (ErlangCons (ErlangAtom "stringinternal_sha3")
                               (ErlangCons (ErlangAtom "stringinternal_sha256")
                                  (ErlangCons
                                     (ErlangAtom "stringinternal_blake2b")
                                     (ErlangCons (ErlangAtom "char_to_int")
                                        (ErlangCons (ErlangAtom "char_from_int")
                                           (ErlangCons
                                              (ErlangAtom
                                                 "stringinternal_to_lower")
                                              (ErlangCons
                                                 (ErlangAtom
                                                    "stringinternal_to_upper")
                                                 (ErlangCons
                                                    (ErlangAtom "bits_set")
                                                    (ErlangCons
                                                       (ErlangAtom "bits_clear")
                                                       (ErlangCons
                                                          (ErlangAtom
                                                             "bits_test")
                                                          (ErlangCons
                                                             (ErlangAtom
                                                                "bits_sum")
                                                             (ErlangCons
                                                                (ErlangAtom
                                                                   "bits_intersection")
                                                                (ErlangCons
                                                                   (ErlangAtom
                                                                      "bits_union")
                                                                   (ErlangCons
                                                                      (ErlangAtom
                                                                         "bits_difference")
                                                                      (ErlangCons
                                                                         (ErlangAtom
                                                                            "int_to_str")
                                                                         (ErlangCons
                                                                            (ErlangAtom
                                                                               "address_to_str")
                                                                            (ErlangCons
                                                                               (ErlangAtom
                                                                                  "crypto_verify_sig")
                                                                               (ErlangCons
                                                                                  (ErlangAtom
                                                                                     "address_to_contract")
                                                                                  (ErlangCons
                                                                                     (ErlangAtom
                                                                                        "crypto_verify_sig_secp256k1")
                                                                                     (ErlangCons
                                                                                        (ErlangAtom
                                                                                           "crypto_sha3")
                                                                                        (ErlangCons
                                                                                           (ErlangAtom
                                                                                              "crypto_sha256")
                                                                                           (ErlangCons
                                                                                              (ErlangAtom
                                                                                                 "crypto_blake2b")
                                                                                              (ErlangCons
                                                                                                 (ErlangAtom
                                                                                                    "crypto_ecverify_secp256k1")
                                                                                                 (ErlangCons
                                                                                                    (ErlangAtom
                                                                                                       "crypto_ecrecover_secp256k1")
                                                                                                    (ErlangCons
                                                                                                       (ErlangAtom
                                                                                                          "mcl_bls12_381_g1_neg")
                                                                                                       (ErlangCons
                                                                                                          (ErlangAtom
                                                                                                             "mcl_bls12_381_g1_norm")
                                                                                                          (ErlangCons
                                                                                                             (ErlangAtom
                                                                                                                "mcl_bls12_381_g1_valid")
                                                                                                             (ErlangCons
                                                                                                                (ErlangAtom
                                                                                                                   "mcl_bls12_381_g1_is_zero")
                                                                                                                (ErlangCons
                                                                                                                   (ErlangAtom
                                                                                                                      "mcl_bls12_381_g1_add")
                                                                                                                   (ErlangCons
                                                                                                                      (ErlangAtom
                                                                                                                         "mcl_bls12_381_g1_mul")
                                                                                                                      (ErlangCons
                                                                                                                         (ErlangAtom
                                                                                                                            "mcl_bls12_381_g2_neg")
                                                                                                                         (ErlangCons
                                                                                                                            (ErlangAtom
                                                                                                                               "mcl_bls12_381_g2_norm")
                                                                                                                            (ErlangCons
                                                                                                                               (ErlangAtom
                                                                                                                                  "mcl_bls12_381_g2_valid")
                                                                                                                               (ErlangCons
                                                                                                                                  (ErlangAtom
                                                                                                                                     "mcl_bls12_381_g2_is_zero")
                                                                                                                                  (ErlangCons
                                                                                                                                     (ErlangAtom
                                                                                                                                        "mcl_bls12_381_g2_add")
                                                                                                                                     (ErlangCons
                                                                                                                                        (ErlangAtom
                                                                                                                                           "mcl_bls12_381_g2_mul")
                                                                                                                                        (ErlangCons
                                                                                                                                           (ErlangAtom
                                                                                                                                              "mcl_bls12_381_gt_inv")
                                                                                                                                           (ErlangCons
                                                                                                                                              (ErlangAtom
                                                                                                                                                 "mcl_bls12_381_gt_add")
                                                                                                                                              (ErlangCons
                                                                                                                                                 (ErlangAtom
                                                                                                                                                    "mcl_bls12_381_gt_mul")
                                                                                                                                                 (ErlangCons
                                                                                                                                                    (ErlangAtom
                                                                                                                                                       "mcl_bls12_381_gt_pow")
                                                                                                                                                    (ErlangCons
                                                                                                                                                       (ErlangAtom
                                                                                                                                                          "mcl_bls12_381_gt_is_one")
                                                                                                                                                       (ErlangCons
                                                                                                                                                          (ErlangAtom
                                                                                                                                                             "mcl_bls12_381_pairing")
                                                                                                                                                          (ErlangCons
                                                                                                                                                             (ErlangAtom
                                                                                                                                                                "mcl_bls12_381_miller_loop")
                                                                                                                                                             (ErlangCons
                                                                                                                                                                (ErlangAtom
                                                                                                                                                                   "mcl_bls12_381_final_exp")
                                                                                                                                                                (ErlangCons
                                                                                                                                                                   (ErlangAtom
                                                                                                                                                                      "mcl_bls12_381_int_to_fr")
                                                                                                                                                                   (ErlangCons
                                                                                                                                                                      (ErlangAtom
                                                                                                                                                                         "mcl_bls12_381_int_to_fp")
                                                                                                                                                                      (ErlangCons
                                                                                                                                                                         (ErlangAtom
                                                                                                                                                                            "mcl_bls12_381_fr_to_int")
                                                                                                                                                                         (ErlangCons
                                                                                                                                                                            (ErlangAtom
                                                                                                                                                                               "mcl_bls12_381_fp_to_int")
                                                                                                                                                                            ErlangEmptyList))))))))))))))))))))))))))))))))))))))))))))))))))))))))
erlps__op_builtins__0 args =
  EXC.badarity (ErlangFun 0 erlps__op_builtins__0) args

erlps__set_state__2 :: ErlangFun
erlps__set_state__2 [(ErlangTuple [(ErlangAtom "reg"), r_0]),
                     val_1]
  =
  ErlangTuple [ErlangAtom "set_state", r_0, val_1]
erlps__set_state__2 [(ErlangTuple [(ErlangAtom "tuple"), ls_0]),
                     val_1]
  =
  let
    arg_3 =
      ErlangFun 1
        (let
           lambda_4 [x_6] =
             let   
               arg_7 =
                 ErlangFun 2
                   (let
                      lambda_8 [(ErlangTuple [i_11, l_12]), code_13] =
                        let    tup_el_15 = toErl "_"
                        in let rop_23 = toErl 1
                        in let tup_el_21 = BIF.erlang__op_minus [i_11, rop_23]
                        in let
                          arg_18 =
                            ErlangTuple [ErlangAtom "proj", x_6, tup_el_21]
                        in let tup_el_16 = erlps__set_state__2 [l_12, arg_18]
                        in
                          ErlangTuple
                            [ErlangAtom "let", tup_el_15, tup_el_16, code_13]
                      lambda_8 [arg_9, arg_10] = EXC.function_clause unit
                      lambda_8 args = EXC.badarity (ErlangFun 2 lambda_8) args
                    in lambda_8)
             in let arg_25 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
             in let arg_28 = erlps__indexed__1 [ls_0]
             in
               BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
                 [arg_7, arg_25, arg_28]
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in erlps__make_let__2 [val_1, arg_3]
erlps__set_state__2 [arg_30, arg_31] = EXC.function_clause unit
erlps__set_state__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_state__2) args

erlps__get_state__1 :: ErlangFun
erlps__get_state__1 [(ErlangTuple [(ErlangAtom "reg"), r_0])] =
  ErlangTuple [ErlangAtom "get_state", r_0]
erlps__get_state__1 [(ErlangTuple [(ErlangAtom "tuple"), ls_0])]
  =
  let
    tup_el_2 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = erlps__get_state__1 [lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        ls_0
  in ErlangTuple [ErlangAtom "tuple", tup_el_2]
erlps__get_state__1 [arg_8] = EXC.function_clause unit
erlps__get_state__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_state__1) args

erlps__builtin_to_fcode__3 :: ErlangFun
erlps__builtin_to_fcode__3 [layout_0, (ErlangAtom "set_state"),
                            (ErlangCons val_1 (ErlangEmptyList))]
  =
  erlps__set_state__2 [layout_0, val_1]
erlps__builtin_to_fcode__3 [layout_0, (ErlangAtom "get_state"),
                            (ErlangEmptyList)]
  =
  erlps__get_state__1 [layout_0]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "require"),
                            (ErlangCons cond_1 (ErlangCons msg_2 (ErlangEmptyList)))]
  =
  let    arg_4 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "builtin", ErlangAtom "abort",
         ErlangCons msg_2 ErlangEmptyList]
  in erlps__make_if__3 [cond_1, arg_4, arg_7]
erlps__builtin_to_fcode__3 [_layout_0,
                            (ErlangAtom "chain_event"),
                            (ErlangCons event_1 (ErlangEmptyList))]
  =
  ErlangTuple
    [ErlangAtom "def", ErlangAtom "event",
     ErlangCons event_1 ErlangEmptyList]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "map_delete"),
                            (ErlangCons key_1 (ErlangCons map_2 (ErlangEmptyList)))]
  =
  ErlangTuple
    [ErlangAtom "op", ErlangAtom "map_delete",
     ErlangCons map_2 (ErlangCons key_1 ErlangEmptyList)]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "map_member"),
                            (ErlangCons key_1 (ErlangCons map_2 (ErlangEmptyList)))]
  =
  ErlangTuple
    [ErlangAtom "op", ErlangAtom "map_member",
     ErlangCons map_2 (ErlangCons key_1 ErlangEmptyList)]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "map_lookup"),
                            (ErlangCons key0_1 (ErlangCons map0_2 (ErlangEmptyList)))]
  =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [key_7] =
             let
               arg_9 =
                 ErlangFun 1
                   (let
                      lambda_10 [map_12] =
                        let   
                          arg_13 =
                            ErlangTuple
                              [ErlangAtom "op", ErlangAtom "map_member",
                               ErlangCons map_12
                                 (ErlangCons key_7 ErlangEmptyList)]
                        in let head_24 = toErl 0
                        in let head_26 = toErl 1
                        in let tup_el_28 = toErl 1
                        in let
                          head_30 =
                            ErlangTuple
                              [ErlangAtom "op", ErlangAtom "map_get",
                               ErlangCons map_12
                                 (ErlangCons key_7 ErlangEmptyList)]
                        in let
                          arg_21 =
                            ErlangTuple
                              [ErlangAtom "con",
                               ErlangCons head_24
                                 (ErlangCons head_26 ErlangEmptyList),
                               tup_el_28, ErlangCons head_30 ErlangEmptyList]
                        in let head_42 = toErl 0
                        in let head_44 = toErl 1
                        in let tup_el_46 = toErl 0
                        in let
                          arg_39 =
                            ErlangTuple
                              [ErlangAtom "con",
                               ErlangCons head_42
                                 (ErlangCons head_44 ErlangEmptyList),
                               tup_el_46, ErlangEmptyList]
                        in erlps__make_if__3 [arg_13, arg_21, arg_39]
                      lambda_10 [arg_11] = EXC.function_clause unit
                      lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
                    in lambda_10)
             in erlps__make_let__2 [map0_2, arg_9]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__make_let__2 [key0_1, arg_4]
erlps__builtin_to_fcode__3 [_layout_0,
                            (ErlangAtom "map_lookup_default"),
                            (ErlangCons key_1 (ErlangCons map_2 (ErlangCons def_3 (ErlangEmptyList))))]
  =
  ErlangTuple
    [ErlangAtom "op", ErlangAtom "map_get_d",
     ErlangCons map_2
       (ErlangCons key_1 (ErlangCons def_3 ErlangEmptyList))]
erlps__builtin_to_fcode__3 [_layout_0, builtin_1, args_2] =
  let    arg_5 = erlps__op_builtins__0 []
  in let case_3 = BIF.lists__member__2 [builtin_1, arg_5]
  in
    case case_3 of
      (ErlangAtom "true") ->
        ErlangTuple [ErlangAtom "op", builtin_1, args_2]
      (ErlangAtom "false") ->
        ErlangTuple [ErlangAtom "builtin", builtin_1, args_2]
      something_else -> EXC.case_clause something_else
erlps__builtin_to_fcode__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__builtin_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__builtin_to_fcode__3) args

erlps__add_init_function__4 :: ErlangFun
erlps__add_init_function__4 [env_0, main_1, statetype_2, funs0_3]
  =
  let case_4 = erlps__is_no_code__1 [env_0]
  in
    case case_4 of
      (ErlangAtom "true") -> funs0_3
      (ErlangAtom "false") ->
        let   
          funs_10 =
            erlps__add_default_init_function__4
              [env_0, main_1, statetype_2, funs0_3]
        in let
          tup_el_12 =
            ErlangBinary (BIN.fromInts (toErl "init") (toErl 8) 1 BIN.Big)
        in let
          initname_13 = ErlangTuple [ErlangAtom "entrypoint", tup_el_12]
        in let matchExpr_18 = BIF.maps__get__2 [initname_13, funs_10]
        in
          case matchExpr_18 of
            (ErlangMap map_16) | (DM.Just initbody_17) <-
                                   (Map.lookup (ErlangAtom "body") map_16) ->
              let    val_26 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
              in let arg_30 = erlps__state_layout__1 [env_0]
              in let
                val_29 =
                  erlps__builtin_to_fcode__3
                    [arg_30, ErlangAtom "set_state",
                     ErlangCons initbody_17 ErlangEmptyList]
              in let
                mapExt_36 =
                  ErlangMap
                    (Map.fromFoldable
                       [DT.Tuple (ErlangAtom "return") val_26,
                        DT.Tuple (ErlangAtom "body") val_29])
              in let val_22 = BIF.maps__merge__2 [matchExpr_18, mapExt_36]
              in let mapExt_38 = ErlangMap (Map.singleton initname_13 val_22)
              in let funs1_40 = BIF.maps__merge__2 [funs_10, mapExt_38]
              in funs1_40
            _ -> EXC.badmatch matchExpr_18
      something_else -> EXC.case_clause something_else
erlps__add_init_function__4 [arg_41, arg_42, arg_43, arg_44] =
  EXC.function_clause unit
erlps__add_init_function__4 args =
  EXC.badarity (ErlangFun 4 erlps__add_init_function__4) args

erlps__add_default_init_function__4 :: ErlangFun
erlps__add_default_init_function__4 [_env_0, main_1, statetype_2,
                                     funs_3]
  =
  let   
    tup_el_5 =
      ErlangBinary (BIN.fromInts (toErl "init") (toErl 8) 1 BIN.Big)
  in let
    initname_6 = ErlangTuple [ErlangAtom "entrypoint", tup_el_5]
  in let
    case_7 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [initname_6, funs_3, ErlangAtom "none"]
  in
    case case_7 of
      (ErlangAtom "none") | (ErlangAtom "true") ==
                              (falsifyErrors
                                 (\ _ ->
                                    let
                                      rop_12 =
                                        ErlangTuple
                                          [ErlangAtom "tuple", ErlangEmptyList]
                                    in
                                      BIF.erlang__op_eq
                                        [statetype_2, rop_12])) ->
        let    val_24 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
        in let val_27 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
        in let
          val_17 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "attrs") ErlangEmptyList,
                  DT.Tuple (ErlangAtom "args") ErlangEmptyList,
                  DT.Tuple (ErlangAtom "return") val_24,
                  DT.Tuple (ErlangAtom "body") val_27])
        in let mapExt_30 = ErlangMap (Map.singleton initname_6 val_17)
        in BIF.maps__merge__2 [funs_3, mapExt_30]
      (ErlangAtom "none") ->
        let
          arg_32 = ErlangTuple [ErlangAtom "missing_init_function", main_1]
        in erlps__fcode_error__1 [arg_32]
      _ -> funs_3
erlps__add_default_init_function__4 [arg_35, arg_36, arg_37,
                                     arg_38]
  =
  EXC.function_clause unit
erlps__add_default_init_function__4 args =
  EXC.badarity (ErlangFun 4 erlps__add_default_init_function__4)
    args

erlps__add_event_function__3 :: ErlangFun
erlps__add_event_function__3 [_env_0, (ErlangAtom "none"),
                              funs_1]
  =
  funs_1
erlps__add_event_function__3 [env_0, eventftype_1, funs_2] =
  let    val_5 = erlps__event_function__2 [env_0, eventftype_1]
  in let
    mapExt_8 = ErlangMap (Map.singleton (ErlangAtom "event") val_5)
  in BIF.maps__merge__2 [funs_2, mapExt_8]
erlps__add_event_function__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__add_event_function__3 args =
  EXC.badarity (ErlangFun 3 erlps__add_event_function__3) args

erlps__event_function__2 :: ErlangFun
erlps__event_function__2 [_env_2@(ErlangMap map_0),
                          eventtype_4@(ErlangTuple [(ErlangAtom "variant"),
                                                    fcons_3])]
  | (DM.Just (ErlangTuple [(ErlangAtom "variant_t"),
                           eventcons_1])) <-
      (Map.lookup (ErlangAtom "event_type") map_0) =
  let    lcSrc_5 = erlps__indexed__1 [eventcons_1]
  in let
    cons_19 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [i_7,
                           (ErlangTuple [(ErlangAtom "constr_t"), ann_8,
                                         (ErlangTuple [(ErlangAtom "con"), _,
                                                       name_9]),
                                         _])]) ->
               let    rop_15 = toErl 1
               in let tup_el_13 = BIF.erlang__op_minus [i_7, rop_15]
               in let
                 tup_el_16 =
                   BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
                     [ErlangAtom "indices", ann_8]
               in let lcRet_11 = ErlangTuple [name_9, tup_el_13, tup_el_16]
               in ErlangCons lcRet_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in let
    arities_25 =
      flmap
        (\ lc_22 ->
           let lcRet_23 = BIF.erlang__length__1 [lc_22]
           in ErlangCons lcRet_23 ErlangEmptyList)
        fcons_3
  in let
    case_92 =
      ErlangFun 1
        (let
           lambda_26 [(ErlangTuple [name_28, tag_29, ixs_30])] =
             let    arg_31 = toErl 32
             in let arg_32 = BIF.erlang__list_to_binary__1 [name_28]
             in let
               matchExpr_35 =
                 BIF.do_remote_fun_call "Eblake2" "erlps__blake2b__2"
                   [arg_31, arg_32]
             in
               case matchExpr_35 of
                 (ErlangTuple [(ErlangAtom "ok"), hashvalue_34]) ->
                   let   
                     tup_el_37 = ErlangTuple [ErlangAtom "bytes", hashvalue_34]
                   in let hash_40 = ErlangTuple [ErlangAtom "lit", tup_el_37]
                   in let arg_42 = toErl 1
                   in let arg_43 = BIF.erlang__length__1 [ixs_30]
                   in let
                     lcSrc_41 =
                       BIF.do_remote_fun_call "Lists" "erlps__seq__2"
                         [arg_42, arg_43]
                   in let
                     vars_51 =
                       flmap
                         (\ lc_46 ->
                            let    lop_48 = toErl "arg"
                            in let
                              rop_49 = BIF.erlang__integer_to_list__1 [lc_46]
                            in let
                              lcRet_47 = BIF.erlang__op_append [lop_48, rop_49]
                            in ErlangCons lcRet_47 ErlangEmptyList)
                         lcSrc_41
                   in let
                     ivars_54 =
                       BIF.do_remote_fun_call "Lists" "erlps__zip__2"
                         [ixs_30, vars_51]
                   in let
                     case_55 =
                       flmap
                         (\ lc_58 ->
                            case lc_58 of
                              (ErlangTuple [(ErlangAtom "notindexed"), v_57]) ->
                                ErlangCons v_57 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         ivars_54
                   in let
                     payload_67 =
                       case case_55 of
                         (ErlangEmptyList) ->
                           let    tup_el_63 = ErlangBinary (BIN.concat [])
                           in let
                             tup_el_61 =
                               ErlangTuple [ErlangAtom "string", tup_el_63]
                           in ErlangTuple [ErlangAtom "lit", tup_el_61]
                         (ErlangCons v_64 (ErlangEmptyList)) ->
                           ErlangTuple [ErlangAtom "var", v_64]
                         something_else -> EXC.case_clause something_else
                   in let
                     indices_74 =
                       flmap
                         (\ lc_70 ->
                            case lc_70 of
                              (ErlangTuple [(ErlangAtom "indexed"), v_69]) ->
                                let
                                  lcRet_71 =
                                    ErlangTuple [ErlangAtom "var", v_69]
                                in ErlangCons lcRet_71 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         ivars_54
                   in let
                     body_82 =
                       ErlangTuple
                         [ErlangAtom "builtin", ErlangAtom "chain_event",
                          ErlangCons payload_67 (ErlangCons hash_40 indices_74)]
                   in let
                     tup_el_84 =
                       ErlangTuple
                         [ErlangAtom "con", arities_25, tag_29, vars_51]
                   in let
                     tup_el_89 = ErlangTuple [ErlangAtom "nosplit", body_82]
                   in ErlangTuple [ErlangAtom "case", tup_el_84, tup_el_89]
                 _ -> EXC.badmatch matchExpr_35
           lambda_26 [arg_27] = EXC.function_clause unit
           lambda_26 args = EXC.badarity (ErlangFun 1 lambda_26) args
         in lambda_26)
  in let tup_el_102 = toErl "e"
  in let head_101 = ErlangTuple [tup_el_102, eventtype_4]
  in let
    val_105 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
  in let tup_el_113 = toErl "e"
  in let
    tup_el_114 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [case_92, cons_19]
  in let
    tup_el_110 =
      ErlangTuple
        [ErlangAtom "split", eventtype_4, tup_el_113, tup_el_114]
  in let val_108 = ErlangTuple [ErlangAtom "switch", tup_el_110]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "attrs")
            (ErlangCons (ErlangAtom "private") ErlangEmptyList),
          DT.Tuple (ErlangAtom "args")
            (ErlangCons head_101 ErlangEmptyList),
          DT.Tuple (ErlangAtom "return") val_105,
          DT.Tuple (ErlangAtom "body") val_108])
erlps__event_function__2 [arg_117, arg_118] =
  EXC.function_clause unit
erlps__event_function__2 args =
  EXC.badarity (ErlangFun 2 erlps__event_function__2) args

erlps__lambda_lift__1 :: ErlangFun
erlps__lambda_lift__1 [fcode_3@(ErlangMap map_0)]
  | (DM.Just statelayout_2) <-
      (Map.lookup (ErlangAtom "state_layout") map_0)
  , (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    _ = erlps__init_lambda_funs__0 []
  in let
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [_, body_8] =
             erlps__lambda_lift_fun__2 [statelayout_2, body_8]
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let
    funs1_12 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_4, funs_1]
  in let newfuns_13 = erlps__get_lambda_funs__0 []
  in let val_16 = BIF.maps__merge__2 [funs1_12, newfuns_13]
  in let
    mapExt_19 =
      ErlangMap (Map.singleton (ErlangAtom "functions") val_16)
  in
    case findMissingKey fcode_3 [ErlangAtom "functions"] of
      (DM.Nothing) -> BIF.maps__merge__2 [fcode_3, mapExt_19]
      (DM.Just missing_21) -> EXC.badkey missing_21
erlps__lambda_lift__1 [arg_22] = EXC.function_clause unit
erlps__lambda_lift__1 args =
  EXC.badarity (ErlangFun 1 erlps__lambda_lift__1) args

erlps__init_lambda_funs__0 :: ErlangFun
erlps__init_lambda_funs__0 [] =
  let arg_1 = ErlangMap Map.empty
  in BIF.erlang__put__2 [ErlangAtom "%lambdalifted", arg_1]
erlps__init_lambda_funs__0 args =
  EXC.badarity (ErlangFun 0 erlps__init_lambda_funs__0) args

erlps__get_lambda_funs__0 :: ErlangFun
erlps__get_lambda_funs__0 [] =
  BIF.erlang__erase__1 [ErlangAtom "%lambdalifted"]
erlps__get_lambda_funs__0 args =
  EXC.badarity (ErlangFun 0 erlps__get_lambda_funs__0) args

erlps__add_lambda_fun__1 :: ErlangFun
erlps__add_lambda_fun__1 [def_0] =
  let    name_1 = erlps__fresh_fun__0 []
  in let funs_3 = BIF.erlang__get__1 [ErlangAtom "%lambdalifted"]
  in let mapExt_9 = ErlangMap (Map.singleton name_1 def_0)
  in let arg_5 = BIF.maps__merge__2 [funs_3, mapExt_9]
  in let _ = BIF.erlang__put__2 [ErlangAtom "%lambdalifted", arg_5]
  in name_1
erlps__add_lambda_fun__1 [arg_11] = EXC.function_clause unit
erlps__add_lambda_fun__1 args =
  EXC.badarity (ErlangFun 1 erlps__add_lambda_fun__1) args

erlps__lambda_lift_fun__2 :: ErlangFun
erlps__lambda_lift_fun__2 [layout_0, def_3@(ErlangMap map_1)]
  | (DM.Just body_2) <- (Map.lookup (ErlangAtom "body") map_1) =
  let    val_6 = erlps__lambda_lift_expr__2 [layout_0, body_2]
  in let
    mapExt_9 = ErlangMap (Map.singleton (ErlangAtom "body") val_6)
  in
    case findMissingKey def_3 [ErlangAtom "body"] of
      (DM.Nothing) -> BIF.maps__merge__2 [def_3, mapExt_9]
      (DM.Just missing_11) -> EXC.badkey missing_11
erlps__lambda_lift_fun__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__lambda_lift_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__lambda_lift_fun__2) args

erlps__lifted_fun__3 :: ErlangFun
erlps__lifted_fun__3 [(ErlangCons z_0 (ErlangEmptyList)), xs_1,
                      body_2]
  =
  let    head_11 = ErlangTuple [z_0, ErlangAtom "any"]
  in let
    tail_14 =
      flmap
        (\ lc_17 ->
           let lcRet_18 = ErlangTuple [lc_17, ErlangAtom "any"]
           in ErlangCons lcRet_18 ErlangEmptyList)
        xs_1
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "attrs")
            (ErlangCons (ErlangAtom "private") ErlangEmptyList),
          DT.Tuple (ErlangAtom "args") (ErlangCons head_11 tail_14),
          DT.Tuple (ErlangAtom "return") (ErlangAtom "any"),
          DT.Tuple (ErlangAtom "body") body_2])
erlps__lifted_fun__3 [fvs_0, xs_1, body_2] =
  let    z_3 = toErl "%env"
  in let
    proj_21 =
      ErlangFun 2
        (let
           lambda_4 [(ErlangTuple [i_7, y_8]), e_9] =
             let    tup_el_14 = ErlangTuple [ErlangAtom "var", z_3]
             in let rop_19 = toErl 1
             in let tup_el_17 = BIF.erlang__op_minus [i_7, rop_19]
             in let
               tup_el_12 = ErlangTuple [ErlangAtom "proj", tup_el_14, tup_el_17]
             in ErlangTuple [ErlangAtom "let", y_8, tup_el_12, e_9]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in let head_30 = ErlangTuple [z_3, ErlangAtom "any"]
  in let
    tail_33 =
      flmap
        (\ lc_36 ->
           let lcRet_37 = ErlangTuple [lc_36, ErlangAtom "any"]
           in ErlangCons lcRet_37 ErlangEmptyList)
        xs_1
  in let arg_44 = erlps__indexed__1 [fvs_0]
  in let
    val_41 =
      BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
        [proj_21, body_2, arg_44]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "attrs")
            (ErlangCons (ErlangAtom "private") ErlangEmptyList),
          DT.Tuple (ErlangAtom "args") (ErlangCons head_30 tail_33),
          DT.Tuple (ErlangAtom "return") (ErlangAtom "any"),
          DT.Tuple (ErlangAtom "body") val_41])
erlps__lifted_fun__3 [arg_46, arg_47, arg_48] =
  EXC.function_clause unit
erlps__lifted_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__lifted_fun__3) args

erlps__make_closure__3 :: ErlangFun
erlps__make_closure__3 [fvs_0, xs_1, body_2] =
  let    arg_3 = erlps__lifted_fun__3 [fvs_0, xs_1, body_2]
  in let fun_7 = erlps__add_lambda_fun__1 [arg_3]
  in let
    tup_14 =
      ErlangFun 1
        (let
           lambda_8 [(ErlangCons y_10 (ErlangEmptyList))] = y_10
           lambda_8 [ys_11] = ErlangTuple [ErlangAtom "tuple", ys_11]
           lambda_8 [arg_9] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
         in lambda_8)
  in let
    arg_18 =
      flmap
        (\ lc_21 ->
           let lcRet_22 = ErlangTuple [ErlangAtom "var", lc_21]
           in ErlangCons lcRet_22 ErlangEmptyList)
        fvs_0
  in let
    tup_el_17 =
      BIF.erlang__apply__2 [tup_14, ErlangCons arg_18 ErlangEmptyList]
  in ErlangTuple [ErlangAtom "closure", fun_7, tup_el_17]
erlps__make_closure__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__make_closure__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_closure__3) args

erlps__lambda_lift_expr__2 :: ErlangFun
erlps__lambda_lift_expr__2 [layout_0,
                            (ErlangTuple [(ErlangAtom "lam"), xs_1, body_2])]
  =
  let    arg_3 = ErlangTuple [ErlangAtom "lam", xs_1, body_2]
  in let fvs_7 = erlps__free_vars__1 [arg_3]
  in let arg_10 = erlps__lambda_lift_expr__2 [layout_0, body_2]
  in erlps__make_closure__3 [fvs_7, xs_1, arg_10]
erlps__lambda_lift_expr__2 [layout_0, uexpr_1]
  | (onElement (toErl 1) uexpr_1 weakEq (ErlangAtom "def_u")) ||
      (onElement (toErl 1) uexpr_1 weakEq (ErlangAtom "builtin_u")) =
  let matchExpr_6 = BIF.erlang__tuple_to_list__1 [uexpr_1]
  in
    case matchExpr_6 of
      (ErlangCons tag_3 (ErlangCons f_4 (ErlangCons ar_5 _))) ->
        let   
          extraargs_9 =
            case uexpr_1 of
              (ErlangTuple [(ErlangAtom "builtin_u"), _, _, typeargs_8]) ->
                typeargs_8
              _ -> ErlangEmptyList
        in let arg_11 = toErl 1
        in let
          lcSrc_10 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_11, ar_5]
        in let
          xs_21 =
            flmap
              (\ lc_14 ->
                 let    head_17 = toErl "arg"
                 in let
                   lcRet_15 =
                     BIF.do_remote_fun_call "Lists" "erlps__concat__1"
                       [ErlangCons head_17 (ErlangCons lc_14 ErlangEmptyList)]
                 in ErlangCons lcRet_15 ErlangEmptyList)
              lcSrc_10
        in let
          lop_22 =
            flmap
              (\ lc_25 ->
                 let lcRet_26 = ErlangTuple [ErlangAtom "var", lc_25]
                 in ErlangCons lcRet_26 ErlangEmptyList)
              xs_21
        in let args_30 = BIF.erlang__op_append [lop_22, extraargs_9]
        in let
          body_38 =
            case tag_3 of
              (ErlangAtom "builtin_u") ->
                erlps__builtin_to_fcode__3 [layout_0, f_4, args_30]
              (ErlangAtom "def_u") ->
                ErlangTuple [ErlangAtom "def", f_4, args_30]
              something_else -> EXC.case_clause something_else
        in erlps__make_closure__3 [ErlangEmptyList, xs_21, body_38]
      _ -> EXC.badmatch matchExpr_6
erlps__lambda_lift_expr__2 [layout_0,
                            (ErlangTuple [(ErlangAtom "remote_u"), argst_1,
                                          rett_2, ct_3, f_4])]
  =
  let    fvs_6 = erlps__free_vars__1 [ct_3]
  in let ct1_9 = erlps__lambda_lift_expr__2 [layout_0, ct_3]
  in let namedargcount_10 = toErl 3
  in let arg_12 = toErl 1
  in let lop_14 = BIF.erlang__length__1 [argst_1]
  in let arg_13 = BIF.erlang__op_plus [lop_14, namedargcount_10]
  in let
    lcSrc_11 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_12, arg_13]
  in let
    xs_25 =
      flmap
        (\ lc_18 ->
           let    head_21 = toErl "arg"
           in let
             lcRet_19 =
               BIF.do_remote_fun_call "Lists" "erlps__concat__1"
                 [ErlangCons head_21 (ErlangCons lc_18 ErlangEmptyList)]
           in ErlangCons lcRet_19 ErlangEmptyList)
        lcSrc_11
  in let
    args_32 =
      flmap
        (\ lc_28 ->
           let lcRet_29 = ErlangTuple [ErlangAtom "var", lc_28]
           in ErlangCons lcRet_29 ErlangEmptyList)
        xs_25
  in let
    arg_35 =
      ErlangTuple
        [ErlangAtom "remote", argst_1, rett_2, ct1_9, f_4, args_32]
  in erlps__make_closure__3 [fvs_6, xs_25, arg_35]
erlps__lambda_lift_expr__2 [layout_0, expr_1] =
  case expr_1 of
    (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_1
    (ErlangAtom "nil") -> expr_1
    (ErlangTuple [(ErlangAtom "var"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "closure"), _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "def"), d_3, as_4]) ->
      let tup_el_7 = erlps__lambda_lift_exprs__2 [layout_0, as_4]
      in ErlangTuple [ErlangAtom "def", d_3, tup_el_7]
    (ErlangTuple [(ErlangAtom "builtin"), b_10, as_11]) ->
      let tup_el_14 = erlps__lambda_lift_exprs__2 [layout_0, as_11]
      in ErlangTuple [ErlangAtom "builtin", b_10, tup_el_14]
    (ErlangTuple [(ErlangAtom "remote"), argst_17, rett_18, ct_19,
                  f_20, as_21]) ->
      let    tup_el_25 = erlps__lambda_lift_expr__2 [layout_0, ct_19]
      in let tup_el_29 = erlps__lambda_lift_exprs__2 [layout_0, as_21]
      in
        ErlangTuple
          [ErlangAtom "remote", argst_17, rett_18, tup_el_25, f_20,
           tup_el_29]
    (ErlangTuple [(ErlangAtom "con"), ar_32, c_33, as_34]) ->
      let tup_el_38 = erlps__lambda_lift_exprs__2 [layout_0, as_34]
      in ErlangTuple [ErlangAtom "con", ar_32, c_33, tup_el_38]
    (ErlangTuple [(ErlangAtom "tuple"), as_41]) ->
      let tup_el_43 = erlps__lambda_lift_exprs__2 [layout_0, as_41]
      in ErlangTuple [ErlangAtom "tuple", tup_el_43]
    (ErlangTuple [(ErlangAtom "proj"), a_46, i_47]) ->
      let tup_el_49 = erlps__lambda_lift_expr__2 [layout_0, a_46]
      in ErlangTuple [ErlangAtom "proj", tup_el_49, i_47]
    (ErlangTuple [(ErlangAtom "set_proj"), a_53, i_54, b_55]) ->
      let    tup_el_57 = erlps__lambda_lift_expr__2 [layout_0, a_53]
      in let tup_el_61 = erlps__lambda_lift_expr__2 [layout_0, b_55]
      in
        ErlangTuple [ErlangAtom "set_proj", tup_el_57, i_54, tup_el_61]
    (ErlangTuple [(ErlangAtom "op"), op_64, as_65]) ->
      let tup_el_68 = erlps__lambda_lift_exprs__2 [layout_0, as_65]
      in ErlangTuple [ErlangAtom "op", op_64, tup_el_68]
    (ErlangTuple [(ErlangAtom "let"), x_71, a_72, b_73]) ->
      let    tup_el_76 = erlps__lambda_lift_expr__2 [layout_0, a_72]
      in let tup_el_79 = erlps__lambda_lift_expr__2 [layout_0, b_73]
      in ErlangTuple [ErlangAtom "let", x_71, tup_el_76, tup_el_79]
    (ErlangTuple [(ErlangAtom "funcall"), a_82, bs_83]) ->
      let    tup_el_85 = erlps__lambda_lift_expr__2 [layout_0, a_82]
      in let tup_el_88 = erlps__lambda_lift_exprs__2 [layout_0, bs_83]
      in ErlangTuple [ErlangAtom "funcall", tup_el_85, tup_el_88]
    (ErlangTuple [(ErlangAtom "set_state"), r_91, a_92]) ->
      let tup_el_95 = erlps__lambda_lift_expr__2 [layout_0, a_92]
      in ErlangTuple [ErlangAtom "set_state", r_91, tup_el_95]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "switch"), s_98]) ->
      let tup_el_100 = erlps__lambda_lift_expr__2 [layout_0, s_98]
      in ErlangTuple [ErlangAtom "switch", tup_el_100]
    (ErlangTuple [(ErlangAtom "split"), type_103, x_104,
                  alts_105]) ->
      let tup_el_109 = erlps__lambda_lift_exprs__2 [layout_0, alts_105]
      in ErlangTuple [ErlangAtom "split", type_103, x_104, tup_el_109]
    (ErlangTuple [(ErlangAtom "nosplit"), a_112]) ->
      let tup_el_114 = erlps__lambda_lift_expr__2 [layout_0, a_112]
      in ErlangTuple [ErlangAtom "nosplit", tup_el_114]
    (ErlangTuple [(ErlangAtom "case"), p_117, s_118]) ->
      let tup_el_121 = erlps__lambda_lift_expr__2 [layout_0, s_118]
      in ErlangTuple [ErlangAtom "case", p_117, tup_el_121]
    something_else -> EXC.case_clause something_else
erlps__lambda_lift_expr__2 [arg_124, arg_125] =
  EXC.function_clause unit
erlps__lambda_lift_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__lambda_lift_expr__2) args

erlps__lambda_lift_exprs__2 :: ErlangFun
erlps__lambda_lift_exprs__2 [layout_0, as_1] =
  flmap
    (\ lc_4 ->
       let lcRet_5 = erlps__lambda_lift_expr__2 [layout_0, lc_4]
       in ErlangCons lcRet_5 ErlangEmptyList)
    as_1
erlps__lambda_lift_exprs__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__lambda_lift_exprs__2 args =
  EXC.badarity (ErlangFun 2 erlps__lambda_lift_exprs__2) args

erlps__optimize_fcode__1 :: ErlangFun
erlps__optimize_fcode__1 [code_2@(ErlangMap map_0)]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let   
    arg_6 =
      ErlangFun 2
        (let
           lambda_7 [name_10, def_11] =
             erlps__optimize_fun__3 [code_2, name_10, def_11]
           lambda_7 [arg_8, arg_9] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 2 lambda_7) args
         in lambda_7)
  in let
    val_5 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_6, funs_1]
  in let
    mapExt_16 =
      ErlangMap (Map.singleton (ErlangAtom "functions") val_5)
  in let
    code1_19 =
      case findMissingKey code_2 [ErlangAtom "functions"] of
        (DM.Nothing) -> BIF.maps__merge__2 [code_2, mapExt_16]
        (DM.Just missing_18) -> EXC.badkey missing_18
  in erlps__eliminate_dead_code__1 [code1_19]
erlps__optimize_fcode__1 [arg_21] = EXC.function_clause unit
erlps__optimize_fcode__1 args =
  EXC.badarity (ErlangFun 1 erlps__optimize_fcode__1) args

erlps__optimize_fun__3 :: ErlangFun
erlps__optimize_fun__3 [fcode_0, fun_1, def_4@(ErlangMap map_2)]
  | (DM.Just body_3) <- (Map.lookup (ErlangAtom "body") map_2) =
  let    arg_12 = erlps__inliner__3 [fcode_0, fun_1, body_3]
  in let arg_11 = erlps__inline_local_functions__1 [arg_12]
  in let arg_10 = erlps__bind_subexpressions__1 [arg_11]
  in let arg_9 = erlps__let_floating__1 [arg_10]
  in let arg_8 = erlps__simplifier__1 [arg_9]
  in let val_7 = erlps__drop_unused_lets__1 [arg_8]
  in let
    mapExt_16 = ErlangMap (Map.singleton (ErlangAtom "body") val_7)
  in
    case findMissingKey def_4 [ErlangAtom "body"] of
      (DM.Nothing) -> BIF.maps__merge__2 [def_4, mapExt_16]
      (DM.Just missing_18) -> EXC.badkey missing_18
erlps__optimize_fun__3 [arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__optimize_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__optimize_fun__3) args

erlps__inliner__3 :: ErlangFun
erlps__inliner__3 [fcode_0, fun_1,
                   e_4@(ErlangTuple [(ErlangAtom "def"), fun1_2, args_3])]
  | weakNEq fun1_2 fun_1 =
  let case_5 = erlps__should_inline__2 [fcode_0, fun1_2]
  in
    case case_5 of
      (ErlangAtom "false") -> e_4
      (ErlangAtom "true") -> erlps__inline__3 [fcode_0, fun1_2, args_3]
      something_else -> EXC.case_clause something_else
erlps__inliner__3 [_fcode_0, _fun_1, e_2] = e_2
erlps__inliner__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__inliner__3 args =
  EXC.badarity (ErlangFun 3 erlps__inliner__3) args

erlps__should_inline__2 :: ErlangFun
erlps__should_inline__2 [_fcode_0, _fun1_1] =
  let    arg_4 = toErl "true"
  in let rop_3 = BIF.erlang__list_to_atom__1 [arg_4]
  in BIF.erlang__op_eq [ErlangAtom "false", rop_3]
erlps__should_inline__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__should_inline__2 args =
  EXC.badarity (ErlangFun 2 erlps__should_inline__2) args

erlps__inline__3 :: ErlangFun
erlps__inline__3 [_fcode_0, fun_1, args_2] =
  ErlangTuple [ErlangAtom "def", fun_1, args_2]
erlps__inline__3 [arg_6, arg_7, arg_8] = EXC.function_clause unit
erlps__inline__3 args =
  EXC.badarity (ErlangFun 3 erlps__inline__3) args

erlps__bind_subexpressions__1 :: ErlangFun
erlps__bind_subexpressions__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__bind_subexpressions__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__bind_subexpressions__1 [arg_3] = EXC.function_clause unit
erlps__bind_subexpressions__1 args =
  EXC.badarity (ErlangFun 1 erlps__bind_subexpressions__1) args

erlps__bind_subexpressions__2 :: ErlangFun
erlps__bind_subexpressions__2 [_,
                               (ErlangTuple [(ErlangAtom "tuple"), es_0])]
  =
  let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [xs_5] = ErlangTuple [ErlangAtom "tuple", xs_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in erlps__make_lets__2 [es_0, arg_2]
erlps__bind_subexpressions__2 [_,
                               (ErlangTuple [(ErlangAtom "set_proj"), a_0, i_1,
                                             b_2])]
  =
  let
    arg_8 =
      ErlangFun 1
        (let
           lambda_9 [(ErlangCons x_11 (ErlangCons y_12 (ErlangEmptyList)))]
             =
             ErlangTuple [ErlangAtom "set_proj", x_11, i_1, y_12]
           lambda_9 [arg_10] = EXC.function_clause unit
           lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
         in lambda_9)
  in
    erlps__make_lets__2
      [ErlangCons a_0 (ErlangCons b_2 ErlangEmptyList), arg_8]
erlps__bind_subexpressions__2 [_, e_0] = e_0
erlps__bind_subexpressions__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__bind_subexpressions__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_subexpressions__2) args

erlps__make_lets__2 :: ErlangFun
erlps__make_lets__2 [es_0, body_1] =
  erlps__make_lets__3 [es_0, ErlangEmptyList, body_1]
erlps__make_lets__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__make_lets__2 args =
  EXC.badarity (ErlangFun 2 erlps__make_lets__2) args

erlps__make_lets__3 :: ErlangFun
erlps__make_lets__3 [(ErlangEmptyList), xs_0, body_1] =
  let
    arg_2 = BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [xs_0]
  in
    BIF.erlang__apply__2 [body_1, ErlangCons arg_2 ErlangEmptyList]
erlps__make_lets__3 [(ErlangCons e_0@(ErlangTuple [(ErlangAtom "var"),
                                                   _]) es_1),
                     xs_2, body_3]
  =
  erlps__make_lets__3 [es_1, ErlangCons e_0 xs_2, body_3]
erlps__make_lets__3 [(ErlangCons e_0@(ErlangTuple [(ErlangAtom "lit"),
                                                   _]) es_1),
                     xs_2, body_3]
  =
  erlps__make_lets__3 [es_1, ErlangCons e_0 xs_2, body_3]
erlps__make_lets__3 [(ErlangCons e_0 es_1), xs_2, body_3] =
  let
    arg_5 =
      ErlangFun 1
        (let
           lambda_6 [x_8] =
             erlps__make_lets__3 [es_1, ErlangCons x_8 xs_2, body_3]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in erlps__make_let__2 [e_0, arg_5]
erlps__make_lets__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__make_lets__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_lets__3) args

erlps__inline_local_functions__1 :: ErlangFun
erlps__inline_local_functions__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__inline_local_functions__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__inline_local_functions__1 [arg_3] =
  EXC.function_clause unit
erlps__inline_local_functions__1 args =
  EXC.badarity (ErlangFun 1 erlps__inline_local_functions__1) args

erlps__inline_local_functions__2 :: ErlangFun
erlps__inline_local_functions__2 [env_0,
                                  expr_6@(ErlangTuple [(ErlangAtom "funcall"),
                                                       (ErlangTuple [(ErlangAtom "proj"),
                                                                     (ErlangTuple [(ErlangAtom "var"),
                                                                                   y_1]),
                                                                     (ErlangInt num_2)]),
                                                       (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                                                 (ErlangTuple [(ErlangAtom "var"),
                                                                                               y_3]),
                                                                                 (ErlangInt num_4)]) args_5)])]
  | (ErlangInt num_2) == (toErl 0)
  , (ErlangInt num_4) == (toErl 1)
  , y_3 == y_1 =
  let
    case_7 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [y_1, env_0, ErlangAtom "free"]
  in
    case case_7 of
      (ErlangTuple [(ErlangAtom "lam"), xs_11, body_12]) ->
        let
          arg_13 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_11, args_5]
        in erlps__let_bind__2 [arg_13, body_12]
      _ -> expr_6
erlps__inline_local_functions__2 [_, expr_0] = expr_0
erlps__inline_local_functions__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__inline_local_functions__2 args =
  EXC.badarity (ErlangFun 2 erlps__inline_local_functions__2) args

erlps__let_floating__1 :: ErlangFun
erlps__let_floating__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__let_float__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__let_floating__1 [arg_3] = EXC.function_clause unit
erlps__let_floating__1 args =
  EXC.badarity (ErlangFun 1 erlps__let_floating__1) args

erlps__let_float__2 :: ErlangFun
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "let"), x_0, e_1, body_2])]
  =
  let    tup_el_6 = ErlangTuple [ErlangAtom "here", e_1]
  in let
    arg_3 = ErlangTuple [ErlangAtom "let", x_0, tup_el_6, body_2]
  in erlps__pull_out_let__1 [arg_3]
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "proj"), e_0, i_1])]
  =
  let    tup_el_4 = ErlangTuple [ErlangAtom "here", e_0]
  in let arg_2 = ErlangTuple [ErlangAtom "proj", tup_el_4, i_1]
  in erlps__pull_out_let__1 [arg_2]
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "set_proj"), e_0, i_1, v_2])]
  =
  let    tup_el_5 = ErlangTuple [ErlangAtom "here", e_0]
  in let tup_el_9 = ErlangTuple [ErlangAtom "here", v_2]
  in let
    arg_3 =
      ErlangTuple [ErlangAtom "set_proj", tup_el_5, i_1, tup_el_9]
  in erlps__pull_out_let__1 [arg_3]
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "op"), op_0, es_1])]
  =
  let   
    arg_2 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = ErlangTuple [ErlangAtom "here", lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        es_1
  in let matchExpr_11 = erlps__pull_out_let__1 [arg_2]
  in
    case matchExpr_11 of
      (ErlangTuple [lets_9, es1_10]) ->
        let arg_13 = ErlangTuple [ErlangAtom "op", op_0, es1_10]
        in erlps__let_bind__2 [lets_9, arg_13]
      _ -> EXC.badmatch matchExpr_11
erlps__let_float__2 [_, e_0] = e_0
erlps__let_float__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__let_float__2 args =
  EXC.badarity (ErlangFun 2 erlps__let_float__2) args

erlps__pull_out_let__1 :: ErlangFun
erlps__pull_out_let__1 [expr_0] | isETuple expr_0 =
  let    arg_1 = BIF.erlang__tuple_to_list__1 [expr_0]
  in let matchExpr_5 = erlps__pull_out_let__1 [arg_1]
  in
    case matchExpr_5 of
      (ErlangTuple [lets_3, es_4]) ->
        let inner_7 = BIF.erlang__list_to_tuple__1 [es_4]
        in erlps__let_bind__2 [lets_3, inner_7]
      _ -> EXC.badmatch matchExpr_5
erlps__pull_out_let__1 [es_0] | isEList es_0 =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "here"), _])] =
             ErlangAtom "false"
           lambda_3 [_] = ErlangAtom "true"
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    case_1 =
      BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
        [arg_2, es_0]
  in
    case case_1 of
      (ErlangTuple [es0_6,
                    (ErlangCons (ErlangTuple [(ErlangAtom "here"),
                                              e_7]) es1_8)]) ->
        let case_9 = erlps__let_view__1 [e_7]
        in
          case case_9 of
            (ErlangTuple [(ErlangEmptyList), _]) ->
              let matchExpr_14 = erlps__pull_out_let__1 [es1_8]
              in
                case matchExpr_14 of
                  (ErlangTuple [lets_12, es2_13]) ->
                    let   
                      rop_18 =
                        BIF.erlang__op_append
                          [ErlangCons e_7 ErlangEmptyList, es2_13]
                    in let tup_el_16 = BIF.erlang__op_append [es0_6, rop_18]
                    in ErlangTuple [lets_12, tup_el_16]
                  _ -> EXC.badmatch matchExpr_14
            (ErlangTuple [lets_23, e1_24]) ->
              let matchExpr_28 = erlps__pull_out_let__1 [es1_8]
              in
                case matchExpr_28 of
                  (ErlangTuple [lets1_26, es2_27]) ->
                    let    tup_el_29 = BIF.erlang__op_append [lets_23, lets1_26]
                    in let
                      rop_34 =
                        BIF.erlang__op_append
                          [ErlangCons e1_24 ErlangEmptyList, es2_27]
                    in let tup_el_32 = BIF.erlang__op_append [es0_6, rop_34]
                    in ErlangTuple [tup_el_29, tup_el_32]
                  _ -> EXC.badmatch matchExpr_28
            something_else -> EXC.case_clause something_else
      (ErlangTuple [_, (ErlangEmptyList)]) ->
        ErlangTuple [ErlangEmptyList, es_0]
      something_else -> EXC.case_clause something_else
erlps__pull_out_let__1 [arg_41] = EXC.function_clause unit
erlps__pull_out_let__1 args =
  EXC.badarity (ErlangFun 1 erlps__pull_out_let__1) args

erlps__let_view__1 :: ErlangFun
erlps__let_view__1 [e_0] =
  erlps__let_view__3 [e_0, ErlangEmptyList, ErlangEmptyList]
erlps__let_view__1 [arg_4] = EXC.function_clause unit
erlps__let_view__1 args =
  EXC.badarity (ErlangFun 1 erlps__let_view__1) args

erlps__let_view__3 :: ErlangFun
erlps__let_view__3 [(ErlangTuple [(ErlangAtom "let"), x_0, e_1,
                                  rest_2]),
                    ren_3, lets_4]
  =
  let    z_5 = erlps__fresh_name__0 []
  in let head_8 = ErlangTuple [x_0, z_5]
  in let tup_el_15 = erlps__rename__2 [ren_3, e_1]
  in let head_13 = ErlangTuple [z_5, tup_el_15]
  in
    erlps__let_view__3
      [rest_2, ErlangCons head_8 ren_3, ErlangCons head_13 lets_4]
erlps__let_view__3 [e_0, ren_1, lets_2] =
  let   
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [lets_2]
  in let tup_el_5 = erlps__rename__2 [ren_1, e_0]
  in ErlangTuple [tup_el_3, tup_el_5]
erlps__let_view__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__let_view__3 args =
  EXC.badarity (ErlangFun 3 erlps__let_view__3) args

erlps__simplifier__1 :: ErlangFun
erlps__simplifier__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__simplify__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__simplifier__1 [arg_3] = EXC.function_clause unit
erlps__simplifier__1 args =
  EXC.badarity (ErlangFun 1 erlps__simplifier__1) args

erlps__simplify__2 :: ErlangFun
erlps__simplify__2 [_env_0,
                    (ErlangTuple [(ErlangAtom "proj"),
                                  (ErlangTuple [(ErlangAtom "tuple"), es_1]),
                                  i_2])]
  =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_plus [i_2, rop_5]
  in let
    it_7 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_3, es_1]
  in let x_8 = erlps__fresh_name__0 []
  in let dup_10 = erlps__safe_to_duplicate__1 [it_7]
  in let
    val_13 =
      case ErlangAtom "true" of
        _ | (==) (ErlangAtom "true") dup_10 -> it_7
        _ -> ErlangTuple [ErlangAtom "var", x_8]
  in let
    arg_14 =
      ErlangFun 2
        (let
           lambda_15 [(ErlangTuple [j_18, e_19]), rest_20]
             | weakEq i_2 j_18 =
             case dup_10 of
               (ErlangAtom "true") -> rest_20
               (ErlangAtom "false") ->
                 ErlangTuple [ErlangAtom "let", x_8, e_19, rest_20]
               something_else -> EXC.case_clause something_else
           lambda_15 [(ErlangTuple [_, e_26]), rest_27] =
             let case_28 = erlps__read_only__1 [e_26]
             in
               case case_28 of
                 (ErlangAtom "true") -> rest_27
                 (ErlangAtom "false") ->
                   let tup_el_31 = toErl "_"
                   in ErlangTuple [ErlangAtom "let", tup_el_31, e_26, rest_27]
                 something_else -> EXC.case_clause something_else
           lambda_15 [arg_16, arg_17] = EXC.function_clause unit
           lambda_15 args = EXC.badarity (ErlangFun 2 lambda_15) args
         in lambda_15)
  in let arg_35 = erlps__indexed__1 [es_1]
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_14, val_13, arg_35]
erlps__simplify__2 [env_0,
                    expr_3@(ErlangTuple [(ErlangAtom "proj"),
                                         (ErlangTuple [(ErlangAtom "var"),
                                                       x_1]),
                                         i_2])]
  =
  let    arg_7 = ErlangTuple [ErlangAtom "var", x_1]
  in let case_4 = erlps__simpl_proj__3 [env_0, i_2, arg_7]
  in
    case case_4 of
      (ErlangAtom "false") -> expr_3
      e_10 -> e_10
erlps__simplify__2 [env_0,
                    (ErlangTuple [(ErlangAtom "switch"), split_1])]
  =
  let
    case_2 = erlps__simpl_switch__3 [env_0, ErlangEmptyList, split_1]
  in
    case case_2 of
      (ErlangAtom "nomatch") ->
        let   
          tup_el_13 =
            ErlangBinary
              (BIN.fromInts (toErl "Incomplete patterns") (toErl 8) 1 BIN.Big)
        in let tup_el_11 = ErlangTuple [ErlangAtom "string", tup_el_13]
        in let head_9 = ErlangTuple [ErlangAtom "lit", tup_el_11]
        in
          ErlangTuple
            [ErlangAtom "builtin", ErlangAtom "abort",
             ErlangCons head_9 ErlangEmptyList]
      (ErlangAtom "stuck") ->
        ErlangTuple [ErlangAtom "switch", split_1]
      expr_17 -> expr_17
erlps__simplify__2 [_, e_0] = e_0
erlps__simplify__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__simplify__2 args =
  EXC.badarity (ErlangFun 2 erlps__simplify__2) args

erlps__simpl_proj__3 :: ErlangFun
erlps__simpl_proj__3 [env_0, i_1, expr_2] =
  let
    ifsafe_8 =
      ErlangFun 1
        (let
           lambda_3 [e_5] =
             let case_6 = erlps__safe_to_duplicate__1 [e_5]
             in
               case case_6 of
                 (ErlangAtom "true") -> e_5
                 (ErlangAtom "false") -> ErlangAtom "false"
                 something_else -> EXC.case_clause something_else
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in
    case expr_2 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "var"), x_10]) ->
        let
          arg_13 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [x_10, env_0, ErlangAtom "false"]
        in erlps__simpl_proj__3 [env_0, i_1, arg_13]
      (ErlangTuple [(ErlangAtom "tuple"), es_17]) ->
        let    rop_21 = toErl 1
        in let arg_19 = BIF.erlang__op_plus [i_1, rop_21]
        in let
          arg_18 =
            BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_19, es_17]
        in
          BIF.erlang__apply__2
            [ifsafe_8, ErlangCons arg_18 ErlangEmptyList]
      (ErlangTuple [(ErlangAtom "set_proj"), _, i_24,
                    val_25]) | i_24 == i_1 ->
        BIF.erlang__apply__2
          [ifsafe_8, ErlangCons val_25 ErlangEmptyList]
      (ErlangTuple [(ErlangAtom "set_proj"), e_28, _, _]) ->
        erlps__simpl_proj__3 [env_0, i_1, e_28]
      (ErlangTuple [(ErlangAtom "proj"), e_32, j_33]) ->
        let arg_36 = erlps__simpl_proj__3 [env_0, j_33, e_32]
        in erlps__simpl_proj__3 [env_0, i_1, arg_36]
      _ -> ErlangAtom "false"
erlps__simpl_proj__3 [arg_40, arg_41, arg_42] =
  EXC.function_clause unit
erlps__simpl_proj__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_proj__3) args

erlps__get_catchalls__1 :: ErlangFun
erlps__get_catchalls__1 [alts_0] =
  flmap
    (\ lc_3 ->
       case lc_3 of
         c_2@(ErlangTuple [(ErlangAtom "case"),
                           (ErlangTuple [(ErlangAtom "var"), _]), _]) ->
           ErlangCons c_2 ErlangEmptyList
         _ -> ErlangEmptyList)
    alts_0
erlps__get_catchalls__1 [arg_5] = EXC.function_clause unit
erlps__get_catchalls__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_catchalls__1) args

erlps__add_catchalls__2 :: ErlangFun
erlps__add_catchalls__2 [alts_0, (ErlangEmptyList)] = alts_0
erlps__add_catchalls__2 [alts_0, catchalls_1] =
  let   
    arg_3 =
      ErlangFun 1
        (let
           lambda_4 [(ErlangTuple [(ErlangAtom "case"),
                                   (ErlangTuple [(ErlangAtom "var"), _]), _])]
             =
             ErlangAtom "false"
           lambda_4 [_] = ErlangAtom "true"
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    case_2 =
      BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
        [arg_3, alts_0]
  in
    case case_2 of
      (ErlangTuple [alts1_7, (ErlangCons c_8 (ErlangEmptyList))]) ->
        let
          head_11 = erlps__nest_catchalls__1 [ErlangCons c_8 catchalls_1]
        in
          BIF.erlang__op_append
            [alts1_7, ErlangCons head_11 ErlangEmptyList]
      (ErlangTuple [_, (ErlangEmptyList)]) ->
        let head_18 = erlps__nest_catchalls__1 [catchalls_1]
        in
          BIF.erlang__op_append
            [alts_0, ErlangCons head_18 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__add_catchalls__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__add_catchalls__2 args =
  EXC.badarity (ErlangFun 2 erlps__add_catchalls__2) args

erlps__nest_catchalls__1 :: ErlangFun
erlps__nest_catchalls__1 [(ErlangCons c_0@(ErlangTuple [(ErlangAtom "case"),
                                                        (ErlangTuple [(ErlangAtom "var"),
                                                                      _]),
                                                        (ErlangTuple [(ErlangAtom "nosplit"),
                                                                      _])]) _)]
  =
  c_0
erlps__nest_catchalls__1 [(ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                    p_0@(ErlangTuple [(ErlangAtom "var"),
                                                                      _]),
                                                    (ErlangTuple [(ErlangAtom "split"),
                                                                  type_1, x_2,
                                                                  alts_3])]) catchalls_4)]
  =
  let    tup_el_11 = erlps__add_catchalls__2 [alts_3, catchalls_4]
  in let
    tup_el_7 =
      ErlangTuple [ErlangAtom "split", type_1, x_2, tup_el_11]
  in ErlangTuple [ErlangAtom "case", p_0, tup_el_7]
erlps__nest_catchalls__1 [arg_14] = EXC.function_clause unit
erlps__nest_catchalls__1 args =
  EXC.badarity (ErlangFun 1 erlps__nest_catchalls__1) args

erlps__simpl_switch__3 :: ErlangFun
erlps__simpl_switch__3 [_env_0, _,
                        (ErlangTuple [(ErlangAtom "nosplit"), e_1])]
  =
  e_1
erlps__simpl_switch__3 [env_0, catchalls_1,
                        (ErlangTuple [(ErlangAtom "split"), type_2, x_3,
                                      alts_4])]
  =
  let    alts1_7 = erlps__add_catchalls__2 [alts_4, catchalls_1]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "split", type_2, x_3, alts1_7]
  in let stuck_14 = ErlangTuple [ErlangAtom "switch", tup_el_9]
  in let arg_17 = ErlangTuple [ErlangAtom "var", x_3]
  in let case_15 = erlps__constructor_form__2 [env_0, arg_17]
  in
    case case_15 of
      (ErlangAtom "false") -> stuck_14
      e_20 ->
        let case_21 = erlps__simpl_case__3 [env_0, e_20, alts1_7]
        in
          case case_21 of
            (ErlangAtom "stuck") -> stuck_14
            res_25 -> res_25
erlps__simpl_switch__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__simpl_switch__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_switch__3) args

erlps__simpl_case__3 :: ErlangFun
erlps__simpl_case__3 [_, _, (ErlangEmptyList)] =
  ErlangAtom "nomatch"
erlps__simpl_case__3 [env_0, e_1,
                      (ErlangCons (ErlangTuple [(ErlangAtom "case"), pat_2,
                                                body_3]) alts_4)]
  =
  let case_5 = erlps__match_pat__2 [pat_2, e_1]
  in
    case case_5 of
      (ErlangAtom "false") -> erlps__simpl_case__3 [env_0, e_1, alts_4]
      binds_11 ->
        let    arg_13 = BIF.maps__from_list__1 [binds_11]
        in let env1_15 = BIF.maps__merge__2 [env_0, arg_13]
        in let arg_18 = erlps__get_catchalls__1 [alts_4]
        in let case_16 = erlps__simpl_switch__3 [env1_15, arg_18, body_3]
        in
          case case_16 of
            (ErlangAtom "nomatch") ->
              erlps__simpl_case__3 [env_0, e_1, alts_4]
            (ErlangAtom "stuck") -> ErlangAtom "stuck"
            body1_24 -> erlps__let_bind__2 [binds_11, body1_24]
erlps__simpl_case__3 [arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__simpl_case__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_case__3) args

erlps__match_pat__2 :: ErlangFun
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "tuple"), xs_0]),
                     (ErlangTuple [(ErlangAtom "tuple"), es_1])]
  =
  BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_0, es_1]
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "con"), _, c_0,
                                   xs_1]),
                     (ErlangTuple [(ErlangAtom "con"), _, c_2, es_3])]
  | c_2 == c_0 =
  BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_1, es_3]
erlps__match_pat__2 [l_0,
                     (ErlangTuple [(ErlangAtom "lit"), l_1])]
  | l_1 == l_0 =
  ErlangEmptyList
erlps__match_pat__2 [(ErlangAtom "nil"), (ErlangAtom "nil")] =
  ErlangEmptyList
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "::"), x_0, y_1]),
                     (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "::"),
                                   (ErlangCons a_2 (ErlangCons b_3 (ErlangEmptyList)))])]
  =
  let    head_4 = ErlangTuple [x_0, a_2]
  in let head_8 = ErlangTuple [y_1, b_3]
  in ErlangCons head_4 (ErlangCons head_8 ErlangEmptyList)
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "var"), x_0]),
                     e_1]
  =
  let head_2 = ErlangTuple [x_0, e_1]
  in ErlangCons head_2 ErlangEmptyList
erlps__match_pat__2 [_, _] = ErlangAtom "false"
erlps__match_pat__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__match_pat__2 args =
  EXC.badarity (ErlangFun 2 erlps__match_pat__2) args

erlps__constructor_form__2 :: ErlangFun
erlps__constructor_form__2 [env_0, expr_1] =
  case expr_1 of
    (ErlangTuple [(ErlangAtom "var"), x_3]) ->
      let
        case_4 =
          BIF.do_remote_fun_call "Maps" "erlps__get__3"
            [x_3, env_0, ErlangAtom "free"]
      in
        case case_4 of
          (ErlangAtom "free") -> ErlangAtom "false"
          e_8 -> erlps__constructor_form__2 [env_0, e_8]
    (ErlangTuple [(ErlangAtom "set_proj"), e_11, i_12, v_13]) ->
      let case_14 = erlps__constructor_form__2 [env_0, e_11]
      in
        case case_14 of
          (ErlangTuple [(ErlangAtom "tuple"), es_17]) ->
            let    rop_22 = toErl 1
            in let arg_20 = BIF.erlang__op_plus [i_12, rop_22]
            in let tup_el_19 = erlps__setnth__3 [arg_20, v_13, es_17]
            in ErlangTuple [ErlangAtom "tuple", tup_el_19]
          _ -> ErlangAtom "false"
    (ErlangTuple [(ErlangAtom "proj"), e_25, i_26]) ->
      let case_27 = erlps__constructor_form__2 [env_0, e_25]
      in
        case case_27 of
          (ErlangTuple [(ErlangAtom "tuple"), es_30]) ->
            let    rop_35 = toErl 1
            in let arg_33 = BIF.erlang__op_plus [i_26, rop_35]
            in let
              arg_32 =
                BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_33, es_30]
            in erlps__constructor_form__2 [env_0, arg_32]
          _ -> ErlangAtom "false"
    (ErlangTuple [(ErlangAtom "con"), _, _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "tuple"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_1
    (ErlangAtom "nil") -> expr_1
    (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "::"), _]) -> expr_1
    _ -> ErlangAtom "false"
erlps__constructor_form__2 [arg_37, arg_38] =
  EXC.function_clause unit
erlps__constructor_form__2 args =
  EXC.badarity (ErlangFun 2 erlps__constructor_form__2) args

erlps__drop_unused_lets__1 :: ErlangFun
erlps__drop_unused_lets__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__drop_unused_lets__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__drop_unused_lets__1 [arg_3] = EXC.function_clause unit
erlps__drop_unused_lets__1 args =
  EXC.badarity (ErlangFun 1 erlps__drop_unused_lets__1) args

erlps__drop_unused_lets__2 :: ErlangFun
erlps__drop_unused_lets__2 [_,
                            expr_3@(ErlangTuple [(ErlangAtom "let"), x_0, e_1,
                                                 body_2])]
  =
  let    tup_el_5 = erlps__read_only__1 [e_1]
  in let arg_10 = erlps__free_vars__1 [body_2]
  in let op_arg_8 = BIF.lists__member__2 [x_0, arg_10]
  in let tup_el_7 = BIF.erlang__not__1 [op_arg_8]
  in let case_4 = ErlangTuple [tup_el_5, tup_el_7]
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "true"), (ErlangAtom "true")]) ->
        body_2
      (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "true")]) ->
        let tup_el_13 = toErl "_"
        in ErlangTuple [ErlangAtom "let", tup_el_13, e_1, body_2]
      _ -> expr_3
erlps__drop_unused_lets__2 [_, expr_0] = expr_0
erlps__drop_unused_lets__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__drop_unused_lets__2 args =
  EXC.badarity (ErlangFun 2 erlps__drop_unused_lets__2) args

erlps__safe_to_duplicate__1 :: ErlangFun
erlps__safe_to_duplicate__1 [(ErlangTuple [(ErlangAtom "lit"),
                                           _])]
  =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [(ErlangTuple [(ErlangAtom "var"),
                                           _])]
  =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [(ErlangAtom "nil")] =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                           (ErlangEmptyList)])]
  =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [_] = ErlangAtom "false"
erlps__safe_to_duplicate__1 [arg_0] = EXC.function_clause unit
erlps__safe_to_duplicate__1 args =
  EXC.badarity (ErlangFun 1 erlps__safe_to_duplicate__1) args

erlps__read_only__1 :: ErlangFun
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "lit"), _])] =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "var"), _])] =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangAtom "nil")] = ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "con"), _, _,
                                   es_0])]
  =
  erlps__read_only__1 [es_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "tuple"), es_0])]
  =
  erlps__read_only__1 [es_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "proj"), e_0, _])]
  =
  erlps__read_only__1 [e_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "set_proj"), a_0,
                                   _, b_1])]
  =
  erlps__read_only__1
    [ErlangCons a_0 (ErlangCons b_1 ErlangEmptyList)]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "op"), _, es_0])]
  =
  erlps__read_only__1 [es_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "get_state"), _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "set_state"), _,
                                   _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "def_u"), _, _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "remote_u"), _, _,
                                   _, _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "builtin_u"), _,
                                   _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "builtin_u"), _,
                                   _, _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "lam"), _, _])] =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "def"), _, _])] =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "remote"), _, _,
                                   _, _, _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "builtin"), _,
                                   _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "switch"),
                                   split_0])]
  =
  erlps__read_only__1 [split_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "split"), _, _,
                                   cases_0])]
  =
  erlps__read_only__1 [cases_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "nosplit"), e_0])]
  =
  erlps__read_only__1 [e_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "case"), _,
                                   split_0])]
  =
  erlps__read_only__1 [split_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "let"), _, a_0,
                                   b_1])]
  =
  erlps__read_only__1
    [ErlangCons a_0 (ErlangCons b_1 ErlangEmptyList)]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "funcall"), _,
                                   _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "closure"), _,
                                   _])]
  =
  erlps__internal_error__1 [ErlangAtom "no_closures_here"]
erlps__read_only__1 [es_0] | isEList es_0 =
  let arg_1 = ErlangFun 1 erlps__read_only__1
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, es_0]
erlps__read_only__1 [arg_3] = EXC.function_clause unit
erlps__read_only__1 args =
  EXC.badarity (ErlangFun 1 erlps__read_only__1) args

erlps__eliminate_dead_code__1 :: ErlangFun
erlps__eliminate_dead_code__1 [code_2@(ErlangMap map_0)]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    usedfuns_4 = erlps__used_functions__1 [funs_1]
  in let
    arg_8 =
      ErlangFun 2
        (let
           lambda_9 [name_12, _] = BIF.maps__is_key__2 [name_12, usedfuns_4]
           lambda_9 [arg_10, arg_11] = EXC.function_clause unit
           lambda_9 args = EXC.badarity (ErlangFun 2 lambda_9) args
         in lambda_9)
  in let
    val_7 =
      BIF.do_remote_fun_call "Maps" "erlps__filter__2" [arg_8, funs_1]
  in let
    mapExt_16 =
      ErlangMap (Map.singleton (ErlangAtom "functions") val_7)
  in
    case findMissingKey code_2 [ErlangAtom "functions"] of
      (DM.Nothing) -> BIF.maps__merge__2 [code_2, mapExt_16]
      (DM.Just missing_18) -> EXC.badkey missing_18
erlps__eliminate_dead_code__1 [arg_19] = EXC.function_clause unit
erlps__eliminate_dead_code__1 args =
  EXC.badarity (ErlangFun 1 erlps__eliminate_dead_code__1) args

erlps__used_functions__1 :: ErlangFun
erlps__used_functions__1 [funs_0] =
  let    lcSrc_1 = BIF.maps__to_list__1 [funs_0]
  in let
    exported_12 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [fun_3, (ErlangMap map_4)]) | (DM.Just attrs_5) <-
                                                          (Map.lookup
                                                             (ErlangAtom
                                                                "attrs")
                                                             map_4) ->
               let   
                 op_arg_8 = BIF.lists__member__2 [ErlangAtom "private", attrs_5]
               in let cond_7 = BIF.erlang__not__1 [op_arg_8]
               in
                 case cond_7 of
                   (ErlangAtom "true") -> ErlangCons fun_3 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_1
  in let arg_13 = ErlangMap Map.empty
  in erlps__used_functions__3 [arg_13, exported_12, funs_0]
erlps__used_functions__1 [arg_16] = EXC.function_clause unit
erlps__used_functions__1 args =
  EXC.badarity (ErlangFun 1 erlps__used_functions__1) args

erlps__used_functions__3 :: ErlangFun
erlps__used_functions__3 [used_0, (ErlangEmptyList), _] = used_0
erlps__used_functions__3 [used_0, (ErlangCons name_1 rest_2),
                          defs_3]
  =
  let case_4 = BIF.maps__is_key__2 [name_1, used_0]
  in
    case case_4 of
      (ErlangAtom "true") ->
        erlps__used_functions__3 [used_0, rest_2, defs_3]
      (ErlangAtom "false") ->
        let   
          case_10 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [name_1, defs_3, ErlangAtom "undef"]
        in let
          new_17 =
            case case_10 of
              (ErlangAtom "undef") -> ErlangEmptyList
              (ErlangMap map_14) | (DM.Just body_15) <-
                                     (Map.lookup (ErlangAtom "body") map_14) ->
                erlps__used_defs__1 [body_15]
              something_else -> EXC.case_clause something_else
        in let
          mapExt_22 = ErlangMap (Map.singleton name_1 (ErlangAtom "true"))
        in let arg_18 = BIF.maps__merge__2 [used_0, mapExt_22]
        in let arg_24 = BIF.erlang__op_append [new_17, rest_2]
        in erlps__used_functions__3 [arg_18, arg_24, defs_3]
      something_else -> EXC.case_clause something_else
erlps__used_functions__3 [arg_28, arg_29, arg_30] =
  EXC.function_clause unit
erlps__used_functions__3 args =
  EXC.badarity (ErlangFun 3 erlps__used_functions__3) args

erlps__lookup_type__3 :: ErlangFun
erlps__lookup_type__3 [env_0,
                       (ErlangTuple [(ErlangAtom "id"), _, name_1]), args_2]
  =
  erlps__lookup_type__3
    [env_0, ErlangCons name_1 ErlangEmptyList, args_2]
erlps__lookup_type__3 [env_0,
                       (ErlangTuple [(ErlangAtom "qid"), _, name_1]), args_2]
  =
  erlps__lookup_type__3 [env_0, name_1, args_2]
erlps__lookup_type__3 [env_0, name_1, args_2] =
  let
    case_3 =
      erlps__lookup_type__4
        [env_0, name_1, args_2, ErlangAtom "not_found"]
  in
    case case_3 of
      (ErlangAtom "not_found") ->
        let arg_8 = ErlangTuple [ErlangAtom "unknown_type", name_1]
        in erlps__internal_error__1 [arg_8]
      type_11 -> type_11
erlps__lookup_type__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__lookup_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__lookup_type__3) args

erlps__lookup_type__4 :: ErlangFun
erlps__lookup_type__4 [(ErlangMap map_0), name_2, args_3,
                       default_4]
  | (DM.Just typeenv_1) <-
      (Map.lookup (ErlangAtom "type_env") map_0) =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_2, typeenv_1, ErlangAtom "false"]
  in
    case case_5 of
      (ErlangAtom "false") -> default_4
      fun_9 ->
        BIF.erlang__apply__2 [fun_9, ErlangCons args_3 ErlangEmptyList]
erlps__lookup_type__4 [arg_12, arg_13, arg_14, arg_15] =
  EXC.function_clause unit
erlps__lookup_type__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_type__4) args

erlps__bind_type__3 :: ErlangFun
erlps__bind_type__3 [env_2@(ErlangMap map_0), q_3, fdef_4]
  | (DM.Just tenv_1) <-
      (Map.lookup (ErlangAtom "type_env") map_0) =
  let    mapExt_11 = ErlangMap (Map.singleton q_3 fdef_4)
  in let val_7 = BIF.maps__merge__2 [tenv_1, mapExt_11]
  in let
    mapExt_13 =
      ErlangMap (Map.singleton (ErlangAtom "type_env") val_7)
  in
    case findMissingKey env_2 [ErlangAtom "type_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_13]
      (DM.Just missing_15) -> EXC.badkey missing_15
erlps__bind_type__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__bind_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_type__3) args

erlps__bind_constructors__2 :: ErlangFun
erlps__bind_constructors__2 [env_2@(ErlangMap map_0), newcons_3]
  | (DM.Just conenv_1) <-
      (Map.lookup (ErlangAtom "con_env") map_0) =
  let    val_6 = BIF.maps__merge__2 [conenv_1, newcons_3]
  in let
    mapExt_9 = ErlangMap (Map.singleton (ErlangAtom "con_env") val_6)
  in
    case findMissingKey env_2 [ErlangAtom "con_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_9]
      (DM.Just missing_11) -> EXC.badkey missing_11
erlps__bind_constructors__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__bind_constructors__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_constructors__2) args

erlps__add_child_con__3 :: ErlangFun
erlps__add_child_con__3 [env_2@(ErlangMap map_0), name_3,
                         fcode_4]
  | (DM.Just cenv_1) <-
      (Map.lookup (ErlangAtom "child_con_env") map_0) =
  let    mapExt_11 = ErlangMap (Map.singleton name_3 fcode_4)
  in let val_7 = BIF.maps__merge__2 [cenv_1, mapExt_11]
  in let
    mapExt_13 =
      ErlangMap (Map.singleton (ErlangAtom "child_con_env") val_7)
  in
    case findMissingKey env_2 [ErlangAtom "child_con_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_13]
      (DM.Just missing_15) -> EXC.badkey missing_15
erlps__add_child_con__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__add_child_con__3 args =
  EXC.badarity (ErlangFun 3 erlps__add_child_con__3) args

erlps__add_fun_env__2 :: ErlangFun
erlps__add_fun_env__2 [env_1@(ErlangMap map_0), _]
  | (DM.Just (ErlangTuple [(ErlangAtom "abstract_contract"),
                           _])) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  env_1
erlps__add_fun_env__2 [env_2@(ErlangMap map_0), decls_3]
  | (DM.Just funenv_1) <-
      (Map.lookup (ErlangAtom "fun_env") map_0) =
  let   
    entry_36 =
      ErlangFun 1
        (let
           lambda_4 [(ErlangTuple [(ErlangAtom "letfun"), ann_6,
                                   (ErlangTuple [(ErlangAtom "id"), _, name_7]),
                                   args_8, _, _])]
             =
             let    tup_el_10 = erlps__qname__2 [env_2, name_7]
             in let tup_el_14 = erlps__make_fun_name__3 [env_2, ann_6, name_7]
             in let tup_el_18 = BIF.erlang__length__1 [args_8]
             in let tup_el_13 = ErlangTuple [tup_el_14, tup_el_18]
             in let head_9 = ErlangTuple [tup_el_10, tup_el_13]
             in ErlangCons head_9 ErlangEmptyList
           lambda_4 [(ErlangTuple [(ErlangAtom "fun_decl"), ann_21,
                                   (ErlangTuple [(ErlangAtom "id"), _,
                                                 name_22]),
                                   (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                                 argtypes_23, _])])]
             =
             let    tup_el_25 = erlps__qname__2 [env_2, name_22]
             in let
               tup_el_29 = erlps__make_fun_name__3 [env_2, ann_21, name_22]
             in let tup_el_33 = BIF.erlang__length__1 [argtypes_23]
             in let tup_el_28 = ErlangTuple [tup_el_29, tup_el_33]
             in let head_24 = ErlangTuple [tup_el_25, tup_el_28]
             in ErlangCons head_24 ErlangEmptyList
           lambda_4 [_] = ErlangEmptyList
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    arg_37 =
      BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
        [entry_36, decls_3]
  in let funenv1_40 = BIF.maps__from_list__1 [arg_37]
  in let val_43 = BIF.maps__merge__2 [funenv_1, funenv1_40]
  in let
    mapExt_46 =
      ErlangMap (Map.singleton (ErlangAtom "fun_env") val_43)
  in
    case findMissingKey env_2 [ErlangAtom "fun_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_46]
      (DM.Just missing_48) -> EXC.badkey missing_48
erlps__add_fun_env__2 [arg_49, arg_50] = EXC.function_clause unit
erlps__add_fun_env__2 args =
  EXC.badarity (ErlangFun 2 erlps__add_fun_env__2) args

erlps__make_fun_name__3 :: ErlangFun
erlps__make_fun_name__3 [(ErlangMap map_0), ann_2, name_3]
  | (DM.Just context_1) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  let
    entrypoint_7 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "entrypoint", ann_2, ErlangAtom "false"]
  in
    case context_1 of
      (ErlangTuple [(ErlangAtom "contract_def"), main_9]) ->
        case ErlangAtom "true" of
          _ | (==) (ErlangAtom "true") entrypoint_7 ->
            let tup_el_11 = BIF.erlang__list_to_binary__1 [name_3]
            in ErlangTuple [ErlangAtom "entrypoint", tup_el_11]
          _ ->
            ErlangTuple
              [ErlangAtom "local_fun",
               ErlangCons main_9 (ErlangCons name_3 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "namespace"), lib_19]) ->
        ErlangTuple
          [ErlangAtom "local_fun",
           ErlangCons lib_19 (ErlangCons name_3 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__make_fun_name__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__make_fun_name__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_fun_name__3) args

erlps__current_namespace__1 :: ErlangFun
erlps__current_namespace__1 [(ErlangMap map_0)]
  | (DM.Just cxt_1) <- (Map.lookup (ErlangAtom "context") map_0) =
  case cxt_1 of
    (ErlangTuple [(ErlangAtom "abstract_contract"), con_3]) -> con_3
    (ErlangTuple [(ErlangAtom "contract_def"), con_4]) -> con_4
    (ErlangTuple [(ErlangAtom "namespace"), ns_5]) -> ns_5
    something_else -> EXC.case_clause something_else
erlps__current_namespace__1 [arg_6] = EXC.function_clause unit
erlps__current_namespace__1 args =
  EXC.badarity (ErlangFun 1 erlps__current_namespace__1) args

erlps__qname__2 :: ErlangFun
erlps__qname__2 [env_0, name_1] =
  let head_2 = erlps__current_namespace__1 [env_0]
  in ErlangCons head_2 (ErlangCons name_1 ErlangEmptyList)
erlps__qname__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__qname__2 args =
  EXC.badarity (ErlangFun 2 erlps__qname__2) args

erlps__lookup_fun__2 :: ErlangFun
erlps__lookup_fun__2 [(ErlangMap map_0), name_2]
  | (DM.Just funenv_1) <-
      (Map.lookup (ErlangAtom "fun_env") map_0) =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_2, funenv_1, ErlangAtom "false"]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_7 = ErlangTuple [ErlangAtom "unbound_name", name_2]
        in BIF.erlang__error__1 [arg_7]
      (ErlangTuple [fname_10, _]) -> fname_10
      something_else -> EXC.case_clause something_else
erlps__lookup_fun__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lookup_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_fun__2) args

erlps__lookup_con__2 :: ErlangFun
erlps__lookup_con__2 [env_0,
                      (ErlangTuple [(ErlangAtom "con"), _, con_1])]
  =
  erlps__lookup_con__2 [env_0, ErlangCons con_1 ErlangEmptyList]
erlps__lookup_con__2 [env_0,
                      (ErlangTuple [(ErlangAtom "qcon"), _, con_1])]
  =
  erlps__lookup_con__2 [env_0, con_1]
erlps__lookup_con__2 [(ErlangMap map_0), con_2]
  | (DM.Just conenv_1) <-
      (Map.lookup (ErlangAtom "con_env") map_0) =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [con_2, conenv_1, ErlangAtom "false"]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_7 = ErlangTuple [ErlangAtom "unbound_constructor", con_2]
        in BIF.erlang__error__1 [arg_7]
      tag_10 -> tag_10
erlps__lookup_con__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lookup_con__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_con__2) args

erlps__bind_vars__2 :: ErlangFun
erlps__bind_vars__2 [env_0, xs_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [x_6, e_7] = erlps__bind_var__2 [e_7, x_6]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_2, env_0, xs_1]
erlps__bind_vars__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__bind_vars__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_vars__2) args

erlps__bind_var__2 :: ErlangFun
erlps__bind_var__2 [env_2@(ErlangMap map_0), x_3]
  | (DM.Just vars_1) <- (Map.lookup (ErlangAtom "vars") map_0) =
  let
    mapExt_9 =
      ErlangMap
        (Map.singleton (ErlangAtom "vars") (ErlangCons x_3 vars_1))
  in
    case findMissingKey env_2 [ErlangAtom "vars"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_9]
      (DM.Just missing_11) -> EXC.badkey missing_11
erlps__bind_var__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__bind_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_var__2) args

erlps__resolve_var__2 :: ErlangFun
erlps__resolve_var__2 [env_2@(ErlangMap map_0),
                       (ErlangCons x_3 (ErlangEmptyList))]
  | (DM.Just vars_1) <- (Map.lookup (ErlangAtom "vars") map_0) =
  let case_4 = BIF.lists__member__2 [x_3, vars_1]
  in
    case case_4 of
      (ErlangAtom "true") -> ErlangTuple [ErlangAtom "var", x_3]
      (ErlangAtom "false") ->
        erlps__resolve_fun__2 [env_2, ErlangCons x_3 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__resolve_var__2 [env_0, q_1] =
  erlps__resolve_fun__2 [env_0, q_1]
erlps__resolve_var__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__resolve_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__resolve_var__2) args

erlps__resolve_fun__2 :: ErlangFun
erlps__resolve_fun__2 [env_3@(ErlangMap map_0), q_4]
  | (DM.Just builtin_2) <-
      (Map.lookup (ErlangAtom "builtins") map_0)
  , (DM.Just funs_1) <- (Map.lookup (ErlangAtom "fun_env") map_0) =
  let   
    tup_el_6 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [q_4, funs_1, ErlangAtom "not_found"]
  in let
    tup_el_10 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [q_4, builtin_2, ErlangAtom "not_found"]
  in let case_5 = ErlangTuple [tup_el_6, tup_el_10]
  in
    case case_5 of
      (ErlangTuple [(ErlangAtom "not_found"),
                    (ErlangAtom "not_found")]) ->
        let arg_14 = ErlangTuple [ErlangAtom "unbound_variable", q_4]
        in erlps__internal_error__1 [arg_14]
      (ErlangTuple [_, (ErlangTuple [b_17, (ErlangAtom "none")])]) ->
        let arg_18 = erlps__state_layout__1 [env_3]
        in erlps__builtin_to_fcode__3 [arg_18, b_17, ErlangEmptyList]
      (ErlangTuple [_, (ErlangTuple [b_22, ar_23])]) ->
        ErlangTuple [ErlangAtom "builtin_u", b_22, ar_23]
      (ErlangTuple [(ErlangTuple [fun_27, ar_28]), _]) ->
        ErlangTuple [ErlangAtom "def_u", fun_27, ar_28]
      something_else -> EXC.case_clause something_else
erlps__resolve_fun__2 [arg_32, arg_33] = EXC.function_clause unit
erlps__resolve_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__resolve_fun__2) args

erlps__init_fresh_names__0 :: ErlangFun
erlps__init_fresh_names__0 [] =
  let arg_1 = toErl 0
  in BIF.erlang__put__2 [ErlangAtom "%fresh", arg_1]
erlps__init_fresh_names__0 args =
  EXC.badarity (ErlangFun 0 erlps__init_fresh_names__0) args

erlps__clear_fresh_names__0 :: ErlangFun
erlps__clear_fresh_names__0 [] =
  BIF.erlang__erase__1 [ErlangAtom "%fresh"]
erlps__clear_fresh_names__0 args =
  EXC.badarity (ErlangFun 0 erlps__clear_fresh_names__0) args

erlps__fresh_name__0 :: ErlangFun
erlps__fresh_name__0 [] =
  let arg_0 = toErl "%"
  in erlps__fresh_name__1 [arg_0]
erlps__fresh_name__0 args =
  EXC.badarity (ErlangFun 0 erlps__fresh_name__0) args

erlps__fresh_fun__0 :: ErlangFun
erlps__fresh_fun__0 [] =
  let    arg_3 = toErl "^"
  in let head_2 = erlps__fresh_name__1 [arg_3]
  in
    ErlangTuple
      [ErlangAtom "local_fun", ErlangCons head_2 ErlangEmptyList]
erlps__fresh_fun__0 args =
  EXC.badarity (ErlangFun 0 erlps__fresh_fun__0) args

erlps__fresh_name__1 :: ErlangFun
erlps__fresh_name__1 [prefix_0] =
  let    n_2 = BIF.erlang__get__1 [ErlangAtom "%fresh"]
  in let rop_6 = toErl 1
  in let arg_4 = BIF.erlang__op_plus [n_2, rop_6]
  in let _ = BIF.erlang__put__2 [ErlangAtom "%fresh", arg_4]
  in
    BIF.do_remote_fun_call "Lists" "erlps__concat__1"
      [ErlangCons prefix_0 (ErlangCons n_2 ErlangEmptyList)]
erlps__fresh_name__1 [arg_12] = EXC.function_clause unit
erlps__fresh_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__fresh_name__1) args

erlps__pat_vars__1 :: ErlangFun
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "var"), x_0])] =
  let    rop_3 = toErl "_"
  in let cond_1 = BIF.erlang__op_neq [x_0, rop_3]
  in
    case cond_1 of
      (ErlangAtom "true") -> ErlangCons x_0 ErlangEmptyList
      _ -> ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "bool"), _])] =
  ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "int"), _])] =
  ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "string"), _])] =
  ErlangEmptyList
erlps__pat_vars__1 [(ErlangAtom "nil")] = ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "::"), p_0, q_1])]
  =
  let    lop_2 = erlps__pat_vars__1 [p_0]
  in let rop_4 = erlps__pat_vars__1 [q_1]
  in BIF.erlang__op_append [lop_2, rop_4]
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "tuple"), ps_0])] =
  erlps__pat_vars__1 [ps_0]
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "con"), _, _,
                                  ps_0])]
  =
  erlps__pat_vars__1 [ps_0]
erlps__pat_vars__1 [ps_0] | isEList ps_0 =
  flmap
    (\ lc_3 ->
       let lcSrc_4 = erlps__pat_vars__1 [lc_3]
       in flmap (\ lc_7 -> ErlangCons lc_7 ErlangEmptyList) lcSrc_4)
    ps_0
erlps__pat_vars__1 [arg_9] = EXC.function_clause unit
erlps__pat_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__pat_vars__1) args

erlps__fsplit_pat_vars__1 :: ErlangFun
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "var"),
                                         x_0])]
  =
  let    rop_3 = toErl "_"
  in let cond_1 = BIF.erlang__op_neq [x_0, rop_3]
  in
    case cond_1 of
      (ErlangAtom "true") -> ErlangCons x_0 ErlangEmptyList
      _ -> ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "bool"),
                                         _])]
  =
  ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "int"), _])]
  =
  ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "string"),
                                         _])]
  =
  ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangAtom "nil")] = ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "::"), p_0,
                                         q_1])]
  =
  ErlangCons p_0 (ErlangCons q_1 ErlangEmptyList)
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                         ps_0])]
  =
  ps_0
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "con"), _,
                                         _, ps_0])]
  =
  ps_0
erlps__fsplit_pat_vars__1 [arg_1] = EXC.function_clause unit
erlps__fsplit_pat_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__fsplit_pat_vars__1) args

erlps__free_vars__1 :: ErlangFun
erlps__free_vars__1 [xs_0] | isEList xs_0 =
  let
    arg_1 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__free_vars__1 [lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        xs_0
  in BIF.do_remote_fun_call "Lists" "erlps__umerge__1" [arg_1]
erlps__free_vars__1 [expr_0] =
  case expr_0 of
    (ErlangTuple [(ErlangAtom "var"), x_2]) ->
      ErlangCons x_2 ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lit"), _]) -> ErlangEmptyList
    (ErlangAtom "nil") -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "def"), _, as_5]) ->
      erlps__free_vars__1 [as_5]
    (ErlangTuple [(ErlangAtom "def_u"), _, _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "remote"), _, _, ct_7, _, as_8]) ->
      erlps__free_vars__1 [ErlangCons ct_7 as_8]
    (ErlangTuple [(ErlangAtom "remote_u"), _, _, ct_12, _]) ->
      erlps__free_vars__1 [ct_12]
    (ErlangTuple [(ErlangAtom "builtin"), _, as_14]) ->
      erlps__free_vars__1 [as_14]
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) ->
      ErlangEmptyList
    (ErlangTuple [(ErlangAtom "con"), _, _, as_16]) ->
      erlps__free_vars__1 [as_16]
    (ErlangTuple [(ErlangAtom "tuple"), as_18]) ->
      erlps__free_vars__1 [as_18]
    (ErlangTuple [(ErlangAtom "proj"), a_20, _]) ->
      erlps__free_vars__1 [a_20]
    (ErlangTuple [(ErlangAtom "set_proj"), a_22, _, b_23]) ->
      erlps__free_vars__1
        [ErlangCons a_22 (ErlangCons b_23 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "op"), _, as_29]) ->
      erlps__free_vars__1 [as_29]
    (ErlangTuple [(ErlangAtom "let"), x_31, a_32, b_33]) ->
      let
        head_37 =
          ErlangTuple
            [ErlangAtom "lam", ErlangCons x_31 ErlangEmptyList, b_33]
      in
        erlps__free_vars__1
          [ErlangCons a_32 (ErlangCons head_37 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "funcall"), a_44, bs_45]) ->
      erlps__free_vars__1 [ErlangCons a_44 bs_45]
    (ErlangTuple [(ErlangAtom "set_state"), _, a_49]) ->
      erlps__free_vars__1 [a_49]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lam"), xs_51, b_52]) ->
      let    lop_53 = erlps__free_vars__1 [b_52]
      in let
        rop_55 = BIF.do_remote_fun_call "Lists" "erlps__sort__1" [xs_51]
      in BIF.erlang__op_unAppend [lop_53, rop_55]
    (ErlangTuple [(ErlangAtom "closure"), _, a_57]) ->
      erlps__free_vars__1 [a_57]
    (ErlangTuple [(ErlangAtom "switch"), a_59]) ->
      erlps__free_vars__1 [a_59]
    (ErlangTuple [(ErlangAtom "split"), _, x_61, as_62]) ->
      let head_64 = ErlangTuple [ErlangAtom "var", x_61]
      in erlps__free_vars__1 [ErlangCons head_64 as_62]
    (ErlangTuple [(ErlangAtom "nosplit"), a_68]) ->
      erlps__free_vars__1 [a_68]
    (ErlangTuple [(ErlangAtom "case"), p_70, a_71]) ->
      let    lop_72 = erlps__free_vars__1 [a_71]
      in let arg_75 = erlps__fsplit_pat_vars__1 [p_70]
      in let
        rop_74 = BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_75]
      in BIF.erlang__op_unAppend [lop_72, rop_74]
    something_else -> EXC.case_clause something_else
erlps__free_vars__1 [arg_77] = EXC.function_clause unit
erlps__free_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__free_vars__1) args

erlps__used_defs__1 :: ErlangFun
erlps__used_defs__1 [xs_0] | isEList xs_0 =
  let
    arg_1 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__used_defs__1 [lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        xs_0
  in BIF.do_remote_fun_call "Lists" "erlps__umerge__1" [arg_1]
erlps__used_defs__1 [expr_0] =
  case expr_0 of
    (ErlangTuple [(ErlangAtom "var"), _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lit"), _]) -> ErlangEmptyList
    (ErlangAtom "nil") -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "def"), f_2, as_3]) ->
      let arg_7 = erlps__used_defs__1 [as_3]
      in
        BIF.do_remote_fun_call "Lists" "erlps__umerge__2"
          [ErlangCons f_2 ErlangEmptyList, arg_7]
    (ErlangTuple [(ErlangAtom "def_u"), f_9, _]) ->
      ErlangCons f_9 ErlangEmptyList
    (ErlangTuple [(ErlangAtom "remote"), _, _, ct_12, _, as_13]) ->
      erlps__used_defs__1 [ErlangCons ct_12 as_13]
    (ErlangTuple [(ErlangAtom "remote_u"), _, _, ct_17, _]) ->
      erlps__used_defs__1 [ct_17]
    (ErlangTuple [(ErlangAtom "builtin"), _, as_19]) ->
      erlps__used_defs__1 [as_19]
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) ->
      ErlangEmptyList
    (ErlangTuple [(ErlangAtom "con"), _, _, as_21]) ->
      erlps__used_defs__1 [as_21]
    (ErlangTuple [(ErlangAtom "tuple"), as_23]) ->
      erlps__used_defs__1 [as_23]
    (ErlangTuple [(ErlangAtom "proj"), a_25, _]) ->
      erlps__used_defs__1 [a_25]
    (ErlangTuple [(ErlangAtom "set_proj"), a_27, _, b_28]) ->
      erlps__used_defs__1
        [ErlangCons a_27 (ErlangCons b_28 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "op"), _, as_34]) ->
      erlps__used_defs__1 [as_34]
    (ErlangTuple [(ErlangAtom "let"), _, a_36, b_37]) ->
      erlps__used_defs__1
        [ErlangCons a_36 (ErlangCons b_37 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "funcall"), a_43, bs_44]) ->
      erlps__used_defs__1 [ErlangCons a_43 bs_44]
    (ErlangTuple [(ErlangAtom "set_state"), _, a_48]) ->
      erlps__used_defs__1 [a_48]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lam"), _, b_50]) ->
      erlps__used_defs__1 [b_50]
    (ErlangTuple [(ErlangAtom "closure"), f_52, a_53]) ->
      let arg_57 = erlps__used_defs__1 [a_53]
      in
        BIF.do_remote_fun_call "Lists" "erlps__umerge__2"
          [ErlangCons f_52 ErlangEmptyList, arg_57]
    (ErlangTuple [(ErlangAtom "switch"), a_59]) ->
      erlps__used_defs__1 [a_59]
    (ErlangTuple [(ErlangAtom "split"), _, _, as_61]) ->
      erlps__used_defs__1 [as_61]
    (ErlangTuple [(ErlangAtom "nosplit"), a_63]) ->
      erlps__used_defs__1 [a_63]
    (ErlangTuple [(ErlangAtom "case"), _, a_65]) ->
      erlps__used_defs__1 [a_65]
    something_else -> EXC.case_clause something_else
erlps__used_defs__1 [arg_67] = EXC.function_clause unit
erlps__used_defs__1 args =
  EXC.badarity (ErlangFun 1 erlps__used_defs__1) args

erlps__bottom_up__2 :: ErlangFun
erlps__bottom_up__2 [f_0, expr_1] =
  let arg_3 = ErlangMap Map.empty
  in erlps__bottom_up__3 [f_0, arg_3, expr_1]
erlps__bottom_up__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__bottom_up__2 args =
  EXC.badarity (ErlangFun 2 erlps__bottom_up__2) args

erlps__bottom_up__3 :: ErlangFun
erlps__bottom_up__3 [f_0, env_1, expr_2] =
  let
    arg_4 =
      case expr_2 of
        (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_2
        (ErlangAtom "nil") -> expr_2
        (ErlangTuple [(ErlangAtom "var"), _]) -> expr_2
        (ErlangTuple [(ErlangAtom "def"), d_6, es_7]) ->
          let
            tup_el_10 =
              flmap
                (\ lc_13 ->
                   let lcRet_14 = erlps__bottom_up__3 [f_0, env_1, lc_13]
                   in ErlangCons lcRet_14 ErlangEmptyList)
                es_7
          in ErlangTuple [ErlangAtom "def", d_6, tup_el_10]
        (ErlangTuple [(ErlangAtom "def_u"), _, _]) -> expr_2
        (ErlangTuple [(ErlangAtom "builtin"), b_18, es_19]) ->
          let
            tup_el_22 =
              flmap
                (\ lc_25 ->
                   let lcRet_26 = erlps__bottom_up__3 [f_0, env_1, lc_25]
                   in ErlangCons lcRet_26 ErlangEmptyList)
                es_19
          in ErlangTuple [ErlangAtom "builtin", b_18, tup_el_22]
        (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> expr_2
        (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) -> expr_2
        (ErlangTuple [(ErlangAtom "remote"), argst_30, rett_31, ct_32,
                      fun_33, es_34]) ->
          let    tup_el_38 = erlps__bottom_up__3 [f_0, env_1, ct_32]
          in let
            tup_el_43 =
              flmap
                (\ lc_46 ->
                   let lcRet_47 = erlps__bottom_up__3 [f_0, env_1, lc_46]
                   in ErlangCons lcRet_47 ErlangEmptyList)
                es_34
          in
            ErlangTuple
              [ErlangAtom "remote", argst_30, rett_31, tup_el_38, fun_33,
               tup_el_43]
        (ErlangTuple [(ErlangAtom "remote_u"), argst_51, rett_52, ct_53,
                      fun_54]) ->
          let tup_el_58 = erlps__bottom_up__3 [f_0, env_1, ct_53]
          in
            ErlangTuple
              [ErlangAtom "remote_u", argst_51, rett_52, tup_el_58, fun_54]
        (ErlangTuple [(ErlangAtom "con"), ar_63, i_64, es_65]) ->
          let
            tup_el_69 =
              flmap
                (\ lc_72 ->
                   let lcRet_73 = erlps__bottom_up__3 [f_0, env_1, lc_72]
                   in ErlangCons lcRet_73 ErlangEmptyList)
                es_65
          in ErlangTuple [ErlangAtom "con", ar_63, i_64, tup_el_69]
        (ErlangTuple [(ErlangAtom "tuple"), es_77]) ->
          let
            tup_el_79 =
              flmap
                (\ lc_82 ->
                   let lcRet_83 = erlps__bottom_up__3 [f_0, env_1, lc_82]
                   in ErlangCons lcRet_83 ErlangEmptyList)
                es_77
          in ErlangTuple [ErlangAtom "tuple", tup_el_79]
        (ErlangTuple [(ErlangAtom "proj"), e_87, i_88]) ->
          let tup_el_90 = erlps__bottom_up__3 [f_0, env_1, e_87]
          in ErlangTuple [ErlangAtom "proj", tup_el_90, i_88]
        (ErlangTuple [(ErlangAtom "set_proj"), r_95, i_96, e_97]) ->
          let    tup_el_99 = erlps__bottom_up__3 [f_0, env_1, r_95]
          in let tup_el_104 = erlps__bottom_up__3 [f_0, env_1, e_97]
          in
            ErlangTuple [ErlangAtom "set_proj", tup_el_99, i_96, tup_el_104]
        (ErlangTuple [(ErlangAtom "op"), op_108, es_109]) ->
          let
            tup_el_112 =
              flmap
                (\ lc_115 ->
                   let lcRet_116 = erlps__bottom_up__3 [f_0, env_1, lc_115]
                   in ErlangCons lcRet_116 ErlangEmptyList)
                es_109
          in ErlangTuple [ErlangAtom "op", op_108, tup_el_112]
        (ErlangTuple [(ErlangAtom "funcall"), fun_120, es_121]) ->
          let    tup_el_123 = erlps__bottom_up__3 [f_0, env_1, fun_120]
          in let
            tup_el_127 =
              flmap
                (\ lc_130 ->
                   let lcRet_131 = erlps__bottom_up__3 [f_0, env_1, lc_130]
                   in ErlangCons lcRet_131 ErlangEmptyList)
                es_121
          in ErlangTuple [ErlangAtom "funcall", tup_el_123, tup_el_127]
        (ErlangTuple [(ErlangAtom "set_state"), r_135, e_136]) ->
          let tup_el_139 = erlps__bottom_up__3 [f_0, env_1, e_136]
          in ErlangTuple [ErlangAtom "set_state", r_135, tup_el_139]
        (ErlangTuple [(ErlangAtom "get_state"), _]) -> expr_2
        (ErlangTuple [(ErlangAtom "closure"), f_143,
                      cenv_144]) | f_143 == f_0 ->
          let tup_el_147 = erlps__bottom_up__3 [f_0, env_1, cenv_144]
          in ErlangTuple [ErlangAtom "closure", f_0, tup_el_147]
        (ErlangTuple [(ErlangAtom "switch"), split_151]) ->
          let tup_el_153 = erlps__bottom_up__3 [f_0, env_1, split_151]
          in ErlangTuple [ErlangAtom "switch", tup_el_153]
        (ErlangTuple [(ErlangAtom "lam"), xs_157, b_158]) ->
          let tup_el_161 = erlps__bottom_up__3 [f_0, env_1, b_158]
          in ErlangTuple [ErlangAtom "lam", xs_157, tup_el_161]
        (ErlangTuple [(ErlangAtom "let"), x_165, e_166, body_167]) ->
          let    e1_171 = erlps__bottom_up__3 [f_0, env_1, e_166]
          in let
            shouldfreshen_178 =
              ErlangFun 1
                (let
                   lambda_172 [y_175@(ErlangCons (ErlangInt num_174) _)]
                     | (ErlangInt num_174) == (toErl 37) =
                     BIF.maps__is_key__2 [y_175, env_1]
                   lambda_172 [_] = ErlangAtom "true"
                   lambda_172 [arg_173] = EXC.function_clause unit
                   lambda_172 args = EXC.badarity (ErlangFun 1 lambda_172) args
                 in lambda_172)
          in let
            case_179 =
              BIF.erlang__apply__2
                [shouldfreshen_178, ErlangCons x_165 ErlangEmptyList]
          in
            case case_179 of
              (ErlangAtom "true") ->
                let    z_182 = erlps__fresh_name__0 []
                in let mapExt_186 = ErlangMap (Map.singleton z_182 e1_171)
                in let env1_188 = BIF.maps__merge__2 [env_1, mapExt_186]
                in let head_197 = ErlangTuple [x_165, z_182]
                in let
                  arg_195 =
                    erlps__rename__2
                      [ErlangCons head_197 ErlangEmptyList, body_167]
                in let tup_el_192 = erlps__bottom_up__3 [f_0, env1_188, arg_195]
                in ErlangTuple [ErlangAtom "let", z_182, e1_171, tup_el_192]
              (ErlangAtom "false") ->
                let    mapExt_205 = ErlangMap (Map.singleton x_165 e1_171)
                in let env1_207 = BIF.maps__merge__2 [env_1, mapExt_205]
                in let
                  tup_el_211 = erlps__bottom_up__3 [f_0, env1_207, body_167]
                in ErlangTuple [ErlangAtom "let", x_165, e1_171, tup_el_211]
              something_else -> EXC.case_clause something_else
        (ErlangTuple [(ErlangAtom "split"), type_215, x_216,
                      cases_217]) ->
          let
            tup_el_221 =
              flmap
                (\ lc_224 ->
                   let lcRet_225 = erlps__bottom_up__3 [f_0, env_1, lc_224]
                   in ErlangCons lcRet_225 ErlangEmptyList)
                cases_217
          in ErlangTuple [ErlangAtom "split", type_215, x_216, tup_el_221]
        (ErlangTuple [(ErlangAtom "nosplit"), e_229]) ->
          let tup_el_231 = erlps__bottom_up__3 [f_0, env_1, e_229]
          in ErlangTuple [ErlangAtom "nosplit", tup_el_231]
        (ErlangTuple [(ErlangAtom "case"), pat_235, split_236]) ->
          let tup_el_239 = erlps__bottom_up__3 [f_0, env_1, split_236]
          in ErlangTuple [ErlangAtom "case", pat_235, tup_el_239]
        something_else -> EXC.case_clause something_else
  in
    BIF.erlang__apply__2
      [f_0, ErlangCons env_1 (ErlangCons arg_4 ErlangEmptyList)]
erlps__bottom_up__3 [arg_244, arg_245, arg_246] =
  EXC.function_clause unit
erlps__bottom_up__3 args =
  EXC.badarity (ErlangFun 3 erlps__bottom_up__3) args

erlps__get_named_args__2 :: ErlangFun
erlps__get_named_args__2 [namedargst_0, args_1] =
  let   
    isnamed_4 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "named_arg"), _, _, _])] =
             ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    matchExpr_9 =
      BIF.do_remote_fun_call "Lists" "erlps__partition__2"
        [isnamed_4, args_1]
  in
    case matchExpr_9 of
      (ErlangTuple [named_7, notnamed_8]) ->
        let
          namedargs_16 =
            flmap
              (\ lc_12 ->
                 let lcRet_13 = erlps__get_named_arg__2 [lc_12, named_7]
                 in ErlangCons lcRet_13 ErlangEmptyList)
              namedargst_0
        in BIF.erlang__op_append [namedargs_16, notnamed_8]
      _ -> EXC.badmatch matchExpr_9
erlps__get_named_args__2 [arg_19, arg_20] =
  EXC.function_clause unit
erlps__get_named_args__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_named_args__2) args

erlps__get_named_arg__2 :: ErlangFun
erlps__get_named_arg__2 [(ErlangTuple [(ErlangAtom "named_arg_t"),
                                       _,
                                       (ErlangTuple [(ErlangAtom "id"), _,
                                                     name_0]),
                                       _, default_1]),
                         args_2]
  =
  let
    case_3 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [(ErlangAtom "named_arg"), _,
                           (ErlangTuple [(ErlangAtom "id"), _, x_5]), val_6]) ->
               let cond_8 = BIF.erlang__op_eq [x_5, name_0]
               in
                 case cond_8 of
                   (ErlangAtom "true") -> ErlangCons val_6 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        args_2
  in
    case case_3 of
      (ErlangCons val_12 (ErlangEmptyList)) -> val_12
      (ErlangEmptyList) -> default_1
      something_else -> EXC.case_clause something_else
erlps__get_named_arg__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__get_named_arg__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_named_arg__2) args

erlps__rename__2 :: ErlangFun
erlps__rename__2 [ren_0, expr_1] =
  case expr_1 of
    (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_1
    (ErlangAtom "nil") -> ErlangAtom "nil"
    (ErlangTuple [(ErlangAtom "var"), x_3]) ->
      let tup_el_5 = erlps__rename_var__2 [ren_0, x_3]
      in ErlangTuple [ErlangAtom "var", tup_el_5]
    (ErlangTuple [(ErlangAtom "def"), d_8, es_9]) ->
      let
        tup_el_12 =
          flmap
            (\ lc_15 ->
               let lcRet_16 = erlps__rename__2 [ren_0, lc_15]
               in ErlangCons lcRet_16 ErlangEmptyList)
            es_9
      in ErlangTuple [ErlangAtom "def", d_8, tup_el_12]
    (ErlangTuple [(ErlangAtom "def_u"), _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "builtin"), b_19, es_20]) ->
      let
        tup_el_23 =
          flmap
            (\ lc_26 ->
               let lcRet_27 = erlps__rename__2 [ren_0, lc_26]
               in ErlangCons lcRet_27 ErlangEmptyList)
            es_20
      in ErlangTuple [ErlangAtom "builtin", b_19, tup_el_23]
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "remote"), argst_30, rett_31, ct_32,
                  f_33, es_34]) ->
      let    tup_el_38 = erlps__rename__2 [ren_0, ct_32]
      in let
        tup_el_42 =
          flmap
            (\ lc_45 ->
               let lcRet_46 = erlps__rename__2 [ren_0, lc_45]
               in ErlangCons lcRet_46 ErlangEmptyList)
            es_34
      in
        ErlangTuple
          [ErlangAtom "remote", argst_30, rett_31, tup_el_38, f_33,
           tup_el_42]
    (ErlangTuple [(ErlangAtom "remote_u"), argst_49, rett_50, ct_51,
                  f_52]) ->
      let tup_el_56 = erlps__rename__2 [ren_0, ct_51]
      in
        ErlangTuple
          [ErlangAtom "remote_u", argst_49, rett_50, tup_el_56, f_52]
    (ErlangTuple [(ErlangAtom "con"), ar_60, i_61, es_62]) ->
      let
        tup_el_66 =
          flmap
            (\ lc_69 ->
               let lcRet_70 = erlps__rename__2 [ren_0, lc_69]
               in ErlangCons lcRet_70 ErlangEmptyList)
            es_62
      in ErlangTuple [ErlangAtom "con", ar_60, i_61, tup_el_66]
    (ErlangTuple [(ErlangAtom "tuple"), es_73]) ->
      let
        tup_el_75 =
          flmap
            (\ lc_78 ->
               let lcRet_79 = erlps__rename__2 [ren_0, lc_78]
               in ErlangCons lcRet_79 ErlangEmptyList)
            es_73
      in ErlangTuple [ErlangAtom "tuple", tup_el_75]
    (ErlangTuple [(ErlangAtom "proj"), e_82, i_83]) ->
      let tup_el_85 = erlps__rename__2 [ren_0, e_82]
      in ErlangTuple [ErlangAtom "proj", tup_el_85, i_83]
    (ErlangTuple [(ErlangAtom "set_proj"), r_89, i_90, e_91]) ->
      let    tup_el_93 = erlps__rename__2 [ren_0, r_89]
      in let tup_el_97 = erlps__rename__2 [ren_0, e_91]
      in
        ErlangTuple [ErlangAtom "set_proj", tup_el_93, i_90, tup_el_97]
    (ErlangTuple [(ErlangAtom "op"), op_100, es_101]) ->
      let
        tup_el_104 =
          flmap
            (\ lc_107 ->
               let lcRet_108 = erlps__rename__2 [ren_0, lc_107]
               in ErlangCons lcRet_108 ErlangEmptyList)
            es_101
      in ErlangTuple [ErlangAtom "op", op_100, tup_el_104]
    (ErlangTuple [(ErlangAtom "funcall"), fun_111, es_112]) ->
      let    tup_el_114 = erlps__rename__2 [ren_0, fun_111]
      in let
        tup_el_117 =
          flmap
            (\ lc_120 ->
               let lcRet_121 = erlps__rename__2 [ren_0, lc_120]
               in ErlangCons lcRet_121 ErlangEmptyList)
            es_112
      in ErlangTuple [ErlangAtom "funcall", tup_el_114, tup_el_117]
    (ErlangTuple [(ErlangAtom "set_state"), r_124, e_125]) ->
      let tup_el_128 = erlps__rename__2 [ren_0, e_125]
      in ErlangTuple [ErlangAtom "set_state", r_124, tup_el_128]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "closure"), f_131, env_132]) ->
      let tup_el_135 = erlps__rename__2 [ren_0, env_132]
      in ErlangTuple [ErlangAtom "closure", f_131, tup_el_135]
    (ErlangTuple [(ErlangAtom "switch"), split_138]) ->
      let tup_el_140 = erlps__rename_split__2 [ren_0, split_138]
      in ErlangTuple [ErlangAtom "switch", tup_el_140]
    (ErlangTuple [(ErlangAtom "lam"), xs_143, b_144]) ->
      let matchExpr_149 = erlps__rename_bindings__2 [ren_0, xs_143]
      in
        case matchExpr_149 of
          (ErlangTuple [zs_147, ren1_148]) ->
            let tup_el_152 = erlps__rename__2 [ren1_148, b_144]
            in ErlangTuple [ErlangAtom "lam", zs_147, tup_el_152]
          _ -> EXC.badmatch matchExpr_149
    (ErlangTuple [(ErlangAtom "let"), x_155, e_156, body_157]) ->
      let matchExpr_162 = erlps__rename_binding__2 [ren_0, x_155]
      in
        case matchExpr_162 of
          (ErlangTuple [z_160, ren1_161]) ->
            let    tup_el_165 = erlps__rename__2 [ren_0, e_156]
            in let tup_el_168 = erlps__rename__2 [ren1_161, body_157]
            in ErlangTuple [ErlangAtom "let", z_160, tup_el_165, tup_el_168]
          _ -> EXC.badmatch matchExpr_162
    something_else -> EXC.case_clause something_else
erlps__rename__2 [arg_171, arg_172] = EXC.function_clause unit
erlps__rename__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename__2) args

erlps__rename_var__2 :: ErlangFun
erlps__rename_var__2 [ren_0, x_1] =
  BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
    [x_1, ren_0, x_1]
erlps__rename_var__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__rename_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_var__2) args

erlps__rename_binding__2 :: ErlangFun
erlps__rename_binding__2 [ren_0, x_1] =
  let    arg_3 = toErl 1
  in let
    ren1_5 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [x_1, arg_3, ren_0]
  in let arg_8 = toErl 2
  in let case_6 = BIF.lists__keymember__3 [x_1, arg_8, ren_0]
  in
    case case_6 of
      (ErlangAtom "false") -> ErlangTuple [x_1, ren1_5]
      (ErlangAtom "true") ->
        let    z_12 = erlps__fresh_name__0 []
        in let head_15 = ErlangTuple [x_1, z_12]
        in ErlangTuple [z_12, ErlangCons head_15 ren1_5]
      something_else -> EXC.case_clause something_else
erlps__rename_binding__2 [arg_19, arg_20] =
  EXC.function_clause unit
erlps__rename_binding__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_binding__2) args

erlps__rename_bindings__2 :: ErlangFun
erlps__rename_bindings__2 [ren_0, (ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, ren_0]
erlps__rename_bindings__2 [ren_0, (ErlangCons x_1 xs_2)] =
  let matchExpr_7 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_7 of
      (ErlangTuple [z_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_bindings__2 [ren1_6, xs_2]
        in
          case matchExpr_12 of
            (ErlangTuple [zs_10, ren2_11]) ->
              ErlangTuple [ErlangCons z_5 zs_10, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_bindings__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__rename_bindings__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_bindings__2) args

erlps__rename_fpats__2 :: ErlangFun
erlps__rename_fpats__2 [ren_0, (ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, ren_0]
erlps__rename_fpats__2 [ren_0, (ErlangCons p_1 ps_2)] =
  let matchExpr_7 = erlps__rename_fpat__2 [ren_0, p_1]
  in
    case matchExpr_7 of
      (ErlangTuple [q_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_fpats__2 [ren1_6, ps_2]
        in
          case matchExpr_12 of
            (ErlangTuple [qs_10, ren2_11]) ->
              ErlangTuple [ErlangCons q_5 qs_10, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_fpats__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__rename_fpats__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_fpats__2) args

erlps__rename_fpat__2 :: ErlangFun
erlps__rename_fpat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "bool"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "int"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "string"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0, p_1@(ErlangAtom "nil")] =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "::"), p_1, q_2])]
  =
  let matchExpr_7 = erlps__rename_fpat__2 [ren_0, p_1]
  in
    case matchExpr_7 of
      (ErlangTuple [p1_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_fpat__2 [ren1_6, q_2]
        in
          case matchExpr_12 of
            (ErlangTuple [q1_10, ren2_11]) ->
              let tup_el_13 = ErlangTuple [ErlangAtom "::", p1_5, q1_10]
              in ErlangTuple [tup_el_13, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let matchExpr_6 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_6 of
      (ErlangTuple [z_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "var", z_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "con"), ar_1, c_2, ps_3])]
  =
  let matchExpr_8 = erlps__rename_fpats__2 [ren_0, ps_3]
  in
    case matchExpr_8 of
      (ErlangTuple [ps1_6, ren1_7]) ->
        let tup_el_9 = ErlangTuple [ErlangAtom "con", ar_1, c_2, ps1_6]
        in ErlangTuple [tup_el_9, ren1_7]
      _ -> EXC.badmatch matchExpr_8
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "tuple"), ps_1])]
  =
  let matchExpr_6 = erlps__rename_fpats__2 [ren_0, ps_1]
  in
    case matchExpr_6 of
      (ErlangTuple [ps1_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "tuple", ps1_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_fpat__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__rename_fpat__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_fpat__2) args

erlps__rename_spat__2 :: ErlangFun
erlps__rename_spat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "bool"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "int"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "string"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0, p_1@(ErlangAtom "nil")] =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "::"), x_1, y_2])]
  =
  let matchExpr_7 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_7 of
      (ErlangTuple [x1_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_binding__2 [ren1_6, y_2]
        in
          case matchExpr_12 of
            (ErlangTuple [y1_10, ren2_11]) ->
              let tup_el_13 = ErlangTuple [ErlangAtom "::", x1_5, y1_10]
              in ErlangTuple [tup_el_13, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let matchExpr_6 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_6 of
      (ErlangTuple [z_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "var", z_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "con"), ar_1, c_2, xs_3])]
  =
  let matchExpr_8 = erlps__rename_bindings__2 [ren_0, xs_3]
  in
    case matchExpr_8 of
      (ErlangTuple [zs_6, ren1_7]) ->
        let tup_el_9 = ErlangTuple [ErlangAtom "con", ar_1, c_2, zs_6]
        in ErlangTuple [tup_el_9, ren1_7]
      _ -> EXC.badmatch matchExpr_8
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "tuple"), xs_1])]
  =
  let matchExpr_6 = erlps__rename_bindings__2 [ren_0, xs_1]
  in
    case matchExpr_6 of
      (ErlangTuple [zs_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "tuple", zs_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_spat__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__rename_spat__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_spat__2) args

erlps__rename_split__2 :: ErlangFun
erlps__rename_split__2 [ren_0,
                        (ErlangTuple [(ErlangAtom "split"), type_1, x_2,
                                      cases_3])]
  =
  let    tup_el_6 = erlps__rename_var__2 [ren_0, x_2]
  in let
    tup_el_9 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__rename_case__2 [ren_0, lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        cases_3
  in ErlangTuple [ErlangAtom "split", type_1, tup_el_6, tup_el_9]
erlps__rename_split__2 [ren_0,
                        (ErlangTuple [(ErlangAtom "nosplit"), e_1])]
  =
  let tup_el_3 = erlps__rename__2 [ren_0, e_1]
  in ErlangTuple [ErlangAtom "nosplit", tup_el_3]
erlps__rename_split__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__rename_split__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_split__2) args

erlps__rename_case__2 :: ErlangFun
erlps__rename_case__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "case"), pat_1, split_2])]
  =
  let matchExpr_7 = erlps__rename_spat__2 [ren_0, pat_1]
  in
    case matchExpr_7 of
      (ErlangTuple [pat1_5, ren1_6]) ->
        let tup_el_10 = erlps__rename_split__2 [ren1_6, split_2]
        in ErlangTuple [ErlangAtom "case", pat1_5, tup_el_10]
      _ -> EXC.badmatch matchExpr_7
erlps__rename_case__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__rename_case__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_case__2) args

erlps__field_index__2 :: ErlangFun
erlps__field_index__2 [(ErlangTuple [(ErlangAtom "typed"), _, _,
                                     recty_0]),
                       x_1]
  =
  erlps__field_index__2 [recty_0, x_1]
erlps__field_index__2 [(ErlangTuple [(ErlangAtom "record_t"),
                                     fields_0]),
                       x_1]
  =
  let   
    isx_7 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_t"), _,
                                   (ErlangTuple [(ErlangAtom "id"), _, y_4]),
                                   _])]
             =
             BIF.erlang__op_eq [x_1, y_4]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let lcSrc_8 = erlps__indexed__1 [fields_0]
  in let
    matchExpr_18 =
      flmap
        (\ lc_12 ->
           case lc_12 of
             (ErlangTuple [i_10, field_11]) ->
               let
                 cond_13 =
                   BIF.erlang__apply__2
                     [isx_7, ErlangCons field_11 ErlangEmptyList]
               in
                 case cond_13 of
                   (ErlangAtom "true") -> ErlangCons i_10 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_8
  in
    case matchExpr_18 of
      (ErlangCons i_17 (ErlangEmptyList)) ->
        let rop_20 = toErl 1
        in BIF.erlang__op_minus [i_17, rop_20]
      _ -> EXC.badmatch matchExpr_18
erlps__field_index__2 [arg_21, arg_22] = EXC.function_clause unit
erlps__field_index__2 args =
  EXC.badarity (ErlangFun 2 erlps__field_index__2) args

erlps__field_value__2 :: ErlangFun
erlps__field_value__2 [(ErlangTuple [(ErlangAtom "field_t"), _,
                                     (ErlangTuple [(ErlangAtom "id"), _, x_0]),
                                     _]),
                       fields_1]
  =
  let   
    view_18 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field"), _,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                             _,
                                                             (ErlangTuple [(ErlangAtom "id"),
                                                                           _,
                                                                           y_4])]) (ErlangEmptyList)),
                                   e_5])]
             =
             let tup_el_7 = ErlangTuple [ErlangAtom "set", e_5]
             in ErlangTuple [y_4, tup_el_7]
           lambda_2 [(ErlangTuple [(ErlangAtom "field_upd"), _,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                             _,
                                                             (ErlangTuple [(ErlangAtom "id"),
                                                                           _,
                                                                           y_10])]) (ErlangEmptyList)),
                                   (ErlangTuple [(ErlangAtom "typed"), _,
                                                 (ErlangTuple [(ErlangAtom "lam"),
                                                               _,
                                                               (ErlangCons (ErlangTuple [(ErlangAtom "arg"),
                                                                                         _,
                                                                                         (ErlangTuple [(ErlangAtom "id"),
                                                                                                       _,
                                                                                                       z_11]),
                                                                                         _]) (ErlangEmptyList)),
                                                               e_12]),
                                                 _])])]
             =
             let tup_el_14 = ErlangTuple [ErlangAtom "upd", z_11, e_12]
             in ErlangTuple [y_10, tup_el_14]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    lcSrc_20 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [view_18, fields_1]
  in let
    case_19 =
      flmap
        (\ lc_25 ->
           case lc_25 of
             (ErlangTuple [y_23, upd_24]) ->
               let cond_26 = BIF.erlang__op_eq [x_0, y_23]
               in
                 case cond_26 of
                   (ErlangAtom "true") -> ErlangCons upd_24 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_20
  in
    case case_19 of
      (ErlangCons upd_30 (ErlangEmptyList)) -> upd_30
      (ErlangEmptyList) -> ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__field_value__2 [arg_31, arg_32] = EXC.function_clause unit
erlps__field_value__2 args =
  EXC.badarity (ErlangFun 2 erlps__field_value__2) args

erlps__get_attributes__1 :: ErlangFun
erlps__get_attributes__1 [ann_0] =
  let   
    cond_2 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "stateful", ann_0, ErlangAtom "false"]
  in let
    lop_1 =
      case cond_2 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "stateful") ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    cond_9 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "payable", ann_0, ErlangAtom "false"]
  in let
    lop_8 =
      case cond_9 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "payable") ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    op_arg_16 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "entrypoint", ann_0, ErlangAtom "false"]
  in let cond_15 = BIF.erlang__not__1 [op_arg_16]
  in let
    rop_14 =
      case cond_15 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "private") ErlangEmptyList
        _ -> ErlangEmptyList
  in let rop_7 = BIF.erlang__op_append [lop_8, rop_14]
  in BIF.erlang__op_append [lop_1, rop_7]
erlps__get_attributes__1 [arg_21] = EXC.function_clause unit
erlps__get_attributes__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_attributes__1) args

erlps__indexed__1 :: ErlangFun
erlps__indexed__1 [xs_0] =
  let    arg_2 = toErl 1
  in let arg_3 = BIF.erlang__length__1 [xs_0]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_1, xs_0]
erlps__indexed__1 [arg_6] = EXC.function_clause unit
erlps__indexed__1 args =
  EXC.badarity (ErlangFun 1 erlps__indexed__1) args

erlps__setnth__3 :: ErlangFun
erlps__setnth__3 [i_0, x_1, xs_2] =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [i_0, rop_5]
  in let
    matchExpr_9 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_3, xs_2]
  in
    case matchExpr_9 of
      (ErlangTuple [ys_7, (ErlangCons _ zs_8)]) ->
        let
          rop_11 =
            BIF.erlang__op_append [ErlangCons x_1 ErlangEmptyList, zs_8]
        in BIF.erlang__op_append [ys_7, rop_11]
      _ -> EXC.badmatch matchExpr_9
erlps__setnth__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__setnth__3 args =
  EXC.badarity (ErlangFun 3 erlps__setnth__3) args

erlps__fcode_error__1 :: ErlangFun
erlps__fcode_error__1 [error_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Code.Errors" "erlps__format__1"
        [error_0]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_1]
erlps__fcode_error__1 [arg_3] = EXC.function_clause unit
erlps__fcode_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__fcode_error__1) args

erlps__internal_error__1 :: ErlangFun
erlps__internal_error__1 [error_0] =
  let    arg_2 = toErl "~p\n"
  in let
    arg_1 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons error_0 ErlangEmptyList]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_1]
  in let arg_10 = toErl 0
  in let arg_11 = toErl 0
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__2"
        [arg_10, arg_11]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__3"
        [ErlangAtom "internal_error", arg_9, msg_6]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_7]
erlps__internal_error__1 [arg_13] = EXC.function_clause unit
erlps__internal_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__internal_error__1) args

erlps__format_fcode__1 :: ErlangFun
erlps__format_fcode__1 [(ErlangMap map_0)]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let arg_2 = erlps__format_funs__1 [funs_1]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_2]
erlps__format_fcode__1 [arg_4] = EXC.function_clause unit
erlps__format_fcode__1 args =
  EXC.badarity (ErlangFun 1 erlps__format_fcode__1) args

erlps__format_funs__1 :: ErlangFun
erlps__format_funs__1 [funs_0] =
  let    lcSrc_2 = BIF.maps__to_list__1 [funs_0]
  in let
    arg_1 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [name_4, def_5]) ->
               let lcRet_7 = erlps__pp_fun__2 [name_4, def_5]
               in ErlangCons lcRet_7 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_2
  in erlps__pp_above__1 [arg_1]
erlps__format_funs__1 [arg_10] = EXC.function_clause unit
erlps__format_funs__1 args =
  EXC.badarity (ErlangFun 1 erlps__format_funs__1) args

erlps__format_fexpr__1 :: ErlangFun
erlps__format_fexpr__1 [e_0] =
  let arg_1 = erlps__pp_fexpr__1 [e_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_1]
erlps__format_fexpr__1 [arg_3] = EXC.function_clause unit
erlps__format_fexpr__1 args =
  EXC.badarity (ErlangFun 1 erlps__format_fexpr__1) args

erlps__pp_fun__2 :: ErlangFun
erlps__pp_fun__2 [name_0, (ErlangMap map_1)]
  | (DM.Just body_4) <- (Map.lookup (ErlangAtom "body") map_1)
  , (DM.Just return_3) <- (Map.lookup (ErlangAtom "return") map_1)
  , (DM.Just args_2) <- (Map.lookup (ErlangAtom "args") map_1) =
  let   
    pparg_19 =
      ErlangFun 1
        (let
           lambda_5 [(ErlangTuple [x_7, t_8])] =
             let    head_10 = erlps__pp_text__1 [x_7]
             in let arg_14 = toErl " : "
             in let head_13 = erlps__pp_text__1 [arg_14]
             in let head_16 = erlps__pp_ftype__1 [t_8]
             in
               erlps__pp_beside__1
                 [ErlangCons head_10
                    (ErlangCons head_13 (ErlangCons head_16 ErlangEmptyList))]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in let arg_23 = toErl "function "
  in let head_22 = erlps__pp_text__1 [arg_23]
  in let head_25 = erlps__pp_fun_name__1 [name_0]
  in let arg_32 = toErl ","
  in let arg_31 = erlps__pp_text__1 [arg_32]
  in let
    arg_33 =
      flmap
        (\ lc_36 ->
           let
             lcRet_37 =
               BIF.erlang__apply__2 [pparg_19, ErlangCons lc_36 ErlangEmptyList]
           in ErlangCons lcRet_37 ErlangEmptyList)
        args_2
  in let arg_30 = erlps__pp_punctuate__2 [arg_31, arg_33]
  in let arg_29 = erlps__pp_par__1 [arg_30]
  in let head_28 = erlps__pp_parens__1 [arg_29]
  in let arg_42 = toErl " : "
  in let head_41 = erlps__pp_text__1 [arg_42]
  in let head_44 = erlps__pp_ftype__1 [return_3]
  in let arg_48 = toErl " ="
  in let head_47 = erlps__pp_text__1 [arg_48]
  in let
    arg_20 =
      erlps__pp_beside__1
        [ErlangCons head_22
           (ErlangCons head_25
              (ErlangCons head_28
                 (ErlangCons head_41
                    (ErlangCons head_44
                       (ErlangCons head_47 ErlangEmptyList)))))]
  in let arg_51 = toErl 2
  in let arg_52 = erlps__pp_fexpr__1 [body_4]
  in let
    arg_50 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_51, arg_52]
  in erlps__pp_above__2 [arg_20, arg_50]
erlps__pp_fun__2 [arg_54, arg_55] = EXC.function_clause unit
erlps__pp_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_fun__2) args

erlps__pp_fun_name__1 :: ErlangFun
erlps__pp_fun_name__1 [(ErlangAtom "event")] =
  erlps__pp_text__1 [ErlangAtom "event"]
erlps__pp_fun_name__1 [(ErlangTuple [(ErlangAtom "entrypoint"),
                                     e_0])]
  =
  let arg_1 = BIF.erlang__binary_to_list__1 [e_0]
  in erlps__pp_text__1 [arg_1]
erlps__pp_fun_name__1 [(ErlangTuple [(ErlangAtom "local_fun"),
                                     q_0])]
  =
  let    arg_3 = toErl "."
  in let
    arg_1 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [q_0, arg_3]
  in erlps__pp_text__1 [arg_1]
erlps__pp_fun_name__1 [arg_4] = EXC.function_clause unit
erlps__pp_fun_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_fun_name__1) args

erlps__pp_text__1 :: ErlangFun
erlps__pp_text__1 [(ErlangBinary binEnd_0)]
  | BIN.empty binEnd_0 =
  let arg_1 = toErl "\"\""
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [bin_0] | isEBinary bin_0 =
  let    arg_3 = toErl "~p"
  in let head_5 = BIF.erlang__binary_to_list__1 [bin_0]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons head_5 ErlangEmptyList]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_2]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [s_0] | isEList s_0 =
  let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__concat__1"
        [ErlangCons s_0 ErlangEmptyList]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [a_0] | isEAtom a_0 =
  let arg_1 = BIF.erlang__atom_to_list__1 [a_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [n_0] | isEInt n_0 =
  let arg_1 = BIF.erlang__integer_to_list__1 [n_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [arg_3] = EXC.function_clause unit
erlps__pp_text__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_text__1) args

erlps__pp_int__1 :: ErlangFun
erlps__pp_int__1 [i_0] =
  let arg_1 = BIF.erlang__integer_to_list__1 [i_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_int__1 [arg_3] = EXC.function_clause unit
erlps__pp_int__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_int__1) args

erlps__pp_beside__1 :: ErlangFun
erlps__pp_beside__1 [(ErlangEmptyList)] =
  BIF.do_remote_fun_call "Prettypr" "erlps__empty__0" []
erlps__pp_beside__1 [(ErlangCons x_0 (ErlangEmptyList))] = x_0
erlps__pp_beside__1 [(ErlangCons x_0 xs_1)] =
  let arg_3 = erlps__pp_beside__1 [xs_1]
  in erlps__pp_beside__2 [x_0, arg_3]
erlps__pp_beside__1 [arg_5] = EXC.function_clause unit
erlps__pp_beside__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_beside__1) args

erlps__pp_beside__2 :: ErlangFun
erlps__pp_beside__2 [a_0, b_1] =
  BIF.do_remote_fun_call "Prettypr" "erlps__beside__2" [a_0, b_1]
erlps__pp_beside__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__pp_beside__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_beside__2) args

erlps__pp_above__1 :: ErlangFun
erlps__pp_above__1 [(ErlangEmptyList)] =
  BIF.do_remote_fun_call "Prettypr" "erlps__empty__0" []
erlps__pp_above__1 [(ErlangCons x_0 (ErlangEmptyList))] = x_0
erlps__pp_above__1 [(ErlangCons x_0 xs_1)] =
  let arg_3 = erlps__pp_above__1 [xs_1]
  in erlps__pp_above__2 [x_0, arg_3]
erlps__pp_above__1 [arg_5] = EXC.function_clause unit
erlps__pp_above__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_above__1) args

erlps__pp_above__2 :: ErlangFun
erlps__pp_above__2 [a_0, b_1] =
  BIF.do_remote_fun_call "Prettypr" "erlps__above__2" [a_0, b_1]
erlps__pp_above__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__pp_above__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_above__2) args

erlps__pp_parens__1 :: ErlangFun
erlps__pp_parens__1 [doc_0] =
  let    arg_3 = toErl "("
  in let head_2 = erlps__pp_text__1 [arg_3]
  in let arg_8 = toErl ")"
  in let head_7 = erlps__pp_text__1 [arg_8]
  in
    erlps__pp_beside__1
      [ErlangCons head_2
         (ErlangCons doc_0 (ErlangCons head_7 ErlangEmptyList))]
erlps__pp_parens__1 [arg_10] = EXC.function_clause unit
erlps__pp_parens__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_parens__1) args

erlps__pp_braces__1 :: ErlangFun
erlps__pp_braces__1 [doc_0] =
  let    arg_3 = toErl "{"
  in let head_2 = erlps__pp_text__1 [arg_3]
  in let arg_8 = toErl "}"
  in let head_7 = erlps__pp_text__1 [arg_8]
  in
    erlps__pp_beside__1
      [ErlangCons head_2
         (ErlangCons doc_0 (ErlangCons head_7 ErlangEmptyList))]
erlps__pp_braces__1 [arg_10] = EXC.function_clause unit
erlps__pp_braces__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_braces__1) args

erlps__pp_punctuate__2 :: ErlangFun
erlps__pp_punctuate__2 [_sep_0, (ErlangEmptyList)] =
  ErlangEmptyList
erlps__pp_punctuate__2 [_sep_0,
                        (ErlangCons x_1 (ErlangEmptyList))]
  =
  ErlangCons x_1 ErlangEmptyList
erlps__pp_punctuate__2 [sep_0, (ErlangCons x_1 xs_2)] =
  let    head_3 = erlps__pp_beside__2 [x_1, sep_0]
  in let tail_6 = erlps__pp_punctuate__2 [sep_0, xs_2]
  in ErlangCons head_3 tail_6
erlps__pp_punctuate__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__pp_punctuate__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_punctuate__2) args

erlps__pp_par__1 :: ErlangFun
erlps__pp_par__1 [(ErlangEmptyList)] =
  BIF.do_remote_fun_call "Prettypr" "erlps__empty__0" []
erlps__pp_par__1 [xs_0] =
  BIF.do_remote_fun_call "Prettypr" "erlps__par__1" [xs_0]
erlps__pp_par__1 [arg_2] = EXC.function_clause unit
erlps__pp_par__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_par__1) args

erlps__pp_fexpr__1 :: ErlangFun
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "lit"),
                                  (ErlangTuple [(ErlangAtom "typerep"), t_0])])]
  =
  erlps__pp_ftype__1 [t_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "lit"),
                                  (ErlangTuple [tag_0, lit_1])])]
  =
  let arg_2 = ErlangTuple [tag_0, ErlangEmptyList, lit_1]
  in BIF.do_remote_fun_call "Aeso.Pretty" "erlps__expr__1" [arg_2]
erlps__pp_fexpr__1 [(ErlangAtom "nil")] =
  let arg_0 = toErl "[]"
  in erlps__pp_text__1 [arg_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "var"), x_0])] =
  erlps__pp_text__1 [x_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "def"), fun_0])] =
  erlps__pp_fun_name__1 [fun_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "def_u"), fun_0,
                                  ar_1])]
  =
  let    head_3 = erlps__pp_fun_name__1 [fun_0]
  in let arg_7 = toErl "/"
  in let head_6 = erlps__pp_text__1 [arg_7]
  in let head_9 = erlps__pp_int__1 [ar_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_3
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "def"), fun_0,
                                  args_1])]
  =
  let arg_2 = erlps__pp_fun_name__1 [fun_0]
  in erlps__pp_call__2 [arg_2, args_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "con"), _, i_0,
                                  (ErlangEmptyList)])]
  =
  let    arg_2 = toErl "C"
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let arg_3 = erlps__pp_int__1 [i_0]
  in erlps__pp_beside__2 [arg_1, arg_3]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "con"), _, i_0,
                                  es_1])]
  =
  let   
    arg_3 =
      ErlangTuple
        [ErlangAtom "con", ErlangEmptyList, i_0, ErlangEmptyList]
  in let arg_2 = erlps__pp_fexpr__1 [arg_3]
  in let arg_9 = ErlangTuple [ErlangAtom "tuple", es_1]
  in let arg_8 = erlps__pp_fexpr__1 [arg_9]
  in erlps__pp_beside__2 [arg_2, arg_8]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "tuple"), es_0])] =
  let    arg_4 = toErl ","
  in let arg_3 = erlps__pp_text__1 [arg_4]
  in let
    arg_5 =
      flmap
        (\ lc_8 ->
           let lcRet_9 = erlps__pp_fexpr__1 [lc_8]
           in ErlangCons lcRet_9 ErlangEmptyList)
        es_0
  in let arg_2 = erlps__pp_punctuate__2 [arg_3, arg_5]
  in let arg_1 = erlps__pp_par__1 [arg_2]
  in erlps__pp_parens__1 [arg_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "proj"), e_0,
                                  i_1])]
  =
  let    head_3 = erlps__pp_fexpr__1 [e_0]
  in let arg_7 = toErl "."
  in let head_6 = erlps__pp_text__1 [arg_7]
  in let head_9 = erlps__pp_int__1 [i_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_3
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "lam"), xs_0,
                                  a_1])]
  =
  let   
    tup_el_6 =
      flmap
        (\ lc_9 ->
           let lcRet_10 = ErlangTuple [ErlangAtom "var", lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        xs_0
  in let arg_4 = ErlangTuple [ErlangAtom "tuple", tup_el_6]
  in let head_3 = erlps__pp_fexpr__1 [arg_4]
  in let arg_15 = toErl "=>"
  in let head_14 = erlps__pp_text__1 [arg_15]
  in let arg_18 = toErl 2
  in let arg_19 = erlps__pp_fexpr__1 [a_1]
  in let
    head_17 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_18, arg_19]
  in
    erlps__pp_par__1
      [ErlangCons head_3
         (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "closure"), fun_0,
                                  clenv_1])]
  =
  let   
    fvs_6 =
      case clenv_1 of
        (ErlangTuple [(ErlangAtom "tuple"), xs_3]) -> xs_3
        (ErlangTuple [(ErlangAtom "var"), _]) ->
          ErlangCons clenv_1 ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in let arg_8 = toErl "__CLOSURE__"
  in let arg_7 = erlps__pp_text__1 [arg_8]
  in let head_10 = ErlangTuple [ErlangAtom "def", fun_0]
  in erlps__pp_call__2 [arg_7, ErlangCons head_10 fvs_6]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "set_proj"), e_0,
                                  i_1, a_2])]
  =
  let    arg_3 = erlps__pp_fexpr__1 [e_0]
  in let head_8 = erlps__pp_int__1 [i_1]
  in let arg_12 = toErl " = "
  in let head_11 = erlps__pp_text__1 [arg_12]
  in let head_14 = erlps__pp_fexpr__1 [a_2]
  in let
    arg_6 =
      erlps__pp_beside__1
        [ErlangCons head_8
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_5 = erlps__pp_braces__1 [arg_6]
  in erlps__pp_beside__2 [arg_3, arg_5]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "op"), op_0,
                                  args_3@(ErlangCons a_1 (ErlangCons b_2 (ErlangEmptyList)))])]
  =
  let case_4 = erlps__is_infix__1 [op_0]
  in
    case case_4 of
      (ErlangAtom "false") ->
        let arg_6 = erlps__pp_text__1 [op_0]
        in erlps__pp_call__2 [arg_6, args_3]
      (ErlangAtom "true") ->
        let    head_11 = erlps__pp_fexpr__1 [a_1]
        in let head_14 = erlps__pp_text__1 [op_0]
        in let head_17 = erlps__pp_fexpr__1 [b_2]
        in let
          arg_9 =
            erlps__pp_par__1
              [ErlangCons head_11
                 (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))]
        in erlps__pp_parens__1 [arg_9]
      something_else -> EXC.case_clause something_else
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "op"), op_0,
                                  args_2@(ErlangCons a_1 (ErlangEmptyList))])]
  =
  let case_3 = erlps__is_infix__1 [op_0]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_5 = erlps__pp_text__1 [op_0]
        in erlps__pp_call__2 [arg_5, args_2]
      (ErlangAtom "true") ->
        let    head_10 = erlps__pp_text__1 [op_0]
        in let head_13 = erlps__pp_fexpr__1 [a_1]
        in let
          arg_8 =
            erlps__pp_par__1
              [ErlangCons head_10 (ErlangCons head_13 ErlangEmptyList)]
        in erlps__pp_parens__1 [arg_8]
      something_else -> EXC.case_clause something_else
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "op"), op_0,
                                  as_1])]
  =
  let    arg_2 = erlps__pp_text__1 [op_0]
  in let arg_5 = ErlangTuple [ErlangAtom "tuple", as_1]
  in let arg_4 = erlps__pp_fexpr__1 [arg_5]
  in erlps__pp_beside__2 [arg_2, arg_4]
erlps__pp_fexpr__1 [expr_0@(ErlangTuple [(ErlangAtom "let"), _,
                                         _, _])]
  =
  let   
    lets_20 =
      ErlangFun 1
        (let
           lets_1 [(ErlangTuple [(ErlangAtom "let"), y_3, c_4, d_5])] =
             let matchExpr_10 = lets_1 [d_5]
             in
               case matchExpr_10 of
                 (ErlangTuple [ls_8, e_9]) ->
                   let head_12 = ErlangTuple [y_3, c_4]
                   in ErlangTuple [ErlangCons head_12 ls_8, e_9]
                 _ -> EXC.badmatch matchExpr_10
           lets_1 [e_17] = ErlangTuple [ErlangEmptyList, e_17]
           lets_1 [arg_2] = EXC.function_clause unit
           lets_1 args = EXC.badarity (ErlangFun 1 lets_1) args
         in lets_1)
  in let
    matchExpr_25 =
      BIF.erlang__apply__2 [lets_20, ErlangCons expr_0 ErlangEmptyList]
  in
    case matchExpr_25 of
      (ErlangTuple [ls_23, body_24]) ->
        let    arg_31 = toErl "let "
        in let head_30 = erlps__pp_text__1 [arg_31]
        in let
          arg_34 =
            flmap
              (\ lc_38 ->
                 case lc_38 of
                   (ErlangTuple [x_36, a_37]) ->
                     let    head_41 = erlps__pp_text__1 [x_36]
                     in let arg_45 = toErl "="
                     in let head_44 = erlps__pp_text__1 [arg_45]
                     in let arg_48 = toErl 2
                     in let arg_49 = erlps__pp_fexpr__1 [a_37]
                     in let
                       head_47 =
                         BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
                           [arg_48, arg_49]
                     in let
                       lcRet_39 =
                         erlps__pp_par__1
                           [ErlangCons head_41
                              (ErlangCons head_44
                                 (ErlangCons head_47 ErlangEmptyList))]
                     in ErlangCons lcRet_39 ErlangEmptyList
                   _ -> ErlangEmptyList)
              ls_23
        in let head_33 = erlps__pp_above__1 [arg_34]
        in let arg_54 = toErl " in "
        in let head_53 = erlps__pp_text__1 [arg_54]
        in let
          head_28 =
            erlps__pp_beside__1
              [ErlangCons head_30
                 (ErlangCons head_33 (ErlangCons head_53 ErlangEmptyList))]
        in let head_57 = erlps__pp_fexpr__1 [body_24]
        in let
          arg_26 =
            erlps__pp_par__1
              [ErlangCons head_28 (ErlangCons head_57 ErlangEmptyList)]
        in erlps__pp_parens__1 [arg_26]
      _ -> EXC.badmatch matchExpr_25
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "builtin_u"), b_0,
                                  n_1])]
  =
  let    head_3 = erlps__pp_text__1 [b_0]
  in let arg_7 = toErl "/"
  in let head_6 = erlps__pp_text__1 [arg_7]
  in let head_9 = erlps__pp_text__1 [n_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_3
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "builtin_u"), b_0,
                                  n_1, typeargs_2])]
  =
  let    head_4 = erlps__pp_text__1 [b_0]
  in let arg_8 = toErl "@"
  in let head_7 = erlps__pp_text__1 [arg_8]
  in let arg_11 = ErlangTuple [ErlangAtom "tuple", typeargs_2]
  in let head_10 = erlps__pp_fexpr__1 [arg_11]
  in let arg_16 = toErl "/"
  in let head_15 = erlps__pp_text__1 [arg_16]
  in let head_18 = erlps__pp_text__1 [n_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_4
         (ErlangCons head_7
            (ErlangCons head_10
               (ErlangCons head_15 (ErlangCons head_18 ErlangEmptyList))))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "builtin"), b_0,
                                  as_1])]
  =
  let arg_2 = erlps__pp_text__1 [b_0]
  in erlps__pp_call__2 [arg_2, as_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "remote_u"),
                                  argst_0, rett_1, ct_2, fun_3])]
  =
  let    head_5 = erlps__pp_fexpr__1 [ct_2]
  in let arg_9 = toErl "."
  in let head_8 = erlps__pp_text__1 [arg_9]
  in let head_11 = erlps__pp_fun_name__1 [fun_3]
  in let arg_15 = toErl " : "
  in let head_14 = erlps__pp_text__1 [arg_15]
  in let
    arg_18 = ErlangTuple [ErlangAtom "function", argst_0, rett_1]
  in let head_17 = erlps__pp_ftype__1 [arg_18]
  in
    erlps__pp_beside__1
      [ErlangCons head_5
         (ErlangCons head_8
            (ErlangCons head_11
               (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "remote"), argst_0,
                                  rett_1, ct_2, fun_3, as_4])]
  =
  let    head_8 = erlps__pp_fexpr__1 [ct_2]
  in let arg_12 = toErl "."
  in let head_11 = erlps__pp_text__1 [arg_12]
  in let head_14 = erlps__pp_fun_name__1 [fun_3]
  in let arg_18 = toErl " : "
  in let head_17 = erlps__pp_text__1 [arg_18]
  in let
    arg_21 = ErlangTuple [ErlangAtom "function", argst_0, rett_1]
  in let head_20 = erlps__pp_ftype__1 [arg_21]
  in let
    arg_6 =
      erlps__pp_beside__1
        [ErlangCons head_8
           (ErlangCons head_11
              (ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_20 ErlangEmptyList))))]
  in let arg_5 = erlps__pp_parens__1 [arg_6]
  in erlps__pp_call__2 [arg_5, as_4]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "funcall"), fun_0,
                                  as_1])]
  =
  let arg_2 = erlps__pp_fexpr__1 [fun_0]
  in erlps__pp_call__2 [arg_2, as_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "set_state"), r_0,
                                  a_1])]
  =
  let    arg_3 = toErl "set_state"
  in let arg_2 = erlps__pp_text__1 [arg_3]
  in let tup_el_7 = ErlangTuple [ErlangAtom "int", r_0]
  in let head_5 = ErlangTuple [ErlangAtom "lit", tup_el_7]
  in
    erlps__pp_call__2
      [arg_2, ErlangCons head_5 (ErlangCons a_1 ErlangEmptyList)]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "get_state"),
                                  r_0])]
  =
  let    arg_2 = toErl "get_state"
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let tup_el_6 = ErlangTuple [ErlangAtom "int", r_0]
  in let head_4 = ErlangTuple [ErlangAtom "lit", tup_el_6]
  in erlps__pp_call__2 [arg_1, ErlangCons head_4 ErlangEmptyList]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "switch"),
                                  split_0])]
  =
  erlps__pp_split__1 [split_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "contract_code"),
                                  contract_0])]
  =
  let    arg_2 = toErl "contract "
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let arg_3 = erlps__pp_text__1 [contract_0]
  in erlps__pp_beside__2 [arg_1, arg_3]
erlps__pp_fexpr__1 [arg_5] = EXC.function_clause unit
erlps__pp_fexpr__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_fexpr__1) args

erlps__pp_call__2 :: ErlangFun
erlps__pp_call__2 [fun_0, args_1] =
  let    arg_4 = ErlangTuple [ErlangAtom "tuple", args_1]
  in let arg_3 = erlps__pp_fexpr__1 [arg_4]
  in erlps__pp_beside__2 [fun_0, arg_3]
erlps__pp_call__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__pp_call__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_call__2) args

erlps__pp_call_t__2 :: ErlangFun
erlps__pp_call_t__2 [fun_0, args_1] =
  let    arg_2 = erlps__pp_text__1 [fun_0]
  in let arg_5 = ErlangTuple [ErlangAtom "tuple", args_1]
  in let arg_4 = erlps__pp_ftype__1 [arg_5]
  in erlps__pp_beside__2 [arg_2, arg_4]
erlps__pp_call_t__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__pp_call_t__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_call_t__2) args

erlps__pp_ftype__1 :: ErlangFun
erlps__pp_ftype__1 [t_0] | isEAtom t_0 = erlps__pp_text__1 [t_0]
erlps__pp_ftype__1 [(ErlangAtom "any")] =
  let arg_0 = toErl "_"
  in erlps__pp_text__1 [arg_0]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "tvar"), x_0])] =
  erlps__pp_text__1 [x_0]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "bytes"), n_0])] =
  let    arg_2 = toErl "bytes"
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let tup_el_6 = ErlangTuple [ErlangAtom "int", n_0]
  in let head_4 = ErlangTuple [ErlangAtom "lit", tup_el_6]
  in erlps__pp_call__2 [arg_1, ErlangCons head_4 ErlangEmptyList]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "oracle"), q_0,
                                  r_1])]
  =
  let arg_2 = toErl "oracle"
  in
    erlps__pp_call_t__2
      [arg_2, ErlangCons q_0 (ErlangCons r_1 ErlangEmptyList)]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "tuple"), ts_0])] =
  let    arg_4 = toErl " *"
  in let arg_3 = erlps__pp_text__1 [arg_4]
  in let
    arg_5 =
      flmap
        (\ lc_8 ->
           let lcRet_9 = erlps__pp_ftype__1 [lc_8]
           in ErlangCons lcRet_9 ErlangEmptyList)
        ts_0
  in let arg_2 = erlps__pp_punctuate__2 [arg_3, arg_5]
  in let arg_1 = erlps__pp_par__1 [arg_2]
  in erlps__pp_parens__1 [arg_1]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "list"), t_0])] =
  let arg_1 = toErl "list"
  in erlps__pp_call_t__2 [arg_1, ErlangCons t_0 ErlangEmptyList]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "function"),
                                  args_0, res_1])]
  =
  let    arg_4 = ErlangTuple [ErlangAtom "tuple", args_0]
  in let head_3 = erlps__pp_ftype__1 [arg_4]
  in let arg_9 = toErl "=>"
  in let head_8 = erlps__pp_text__1 [arg_9]
  in let head_11 = erlps__pp_ftype__1 [res_1]
  in
    erlps__pp_par__1
      [ErlangCons head_3
         (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "map"), key_0,
                                  val_1])]
  =
  let arg_2 = toErl "map"
  in
    erlps__pp_call_t__2
      [arg_2, ErlangCons key_0 (ErlangCons val_1 ErlangEmptyList)]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "variant"),
                                  cons_0])]
  =
  let    arg_3 = toErl " |"
  in let arg_2 = erlps__pp_text__1 [arg_3]
  in let lcSrc_5 = erlps__indexed__1 [cons_0]
  in let
    arg_4 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [i_7, args_8]) ->
               let
                 lcRet_10 =
                   case args_8 of
                     (ErlangEmptyList) ->
                       let    rop_17 = toErl 1
                       in let tup_el_15 = BIF.erlang__op_minus [i_7, rop_17]
                       in let
                         arg_12 =
                           ErlangTuple
                             [ErlangAtom "con", ErlangEmptyList, tup_el_15,
                              ErlangEmptyList]
                       in erlps__pp_fexpr__1 [arg_12]
                     _ ->
                       let    rop_25 = toErl 1
                       in let tup_el_23 = BIF.erlang__op_minus [i_7, rop_25]
                       in let
                         arg_20 =
                           ErlangTuple
                             [ErlangAtom "con", ErlangEmptyList, tup_el_23,
                              ErlangEmptyList]
                       in let arg_19 = erlps__pp_fexpr__1 [arg_20]
                       in let arg_28 = ErlangTuple [ErlangAtom "tuple", args_8]
                       in let arg_27 = erlps__pp_ftype__1 [arg_28]
                       in erlps__pp_beside__2 [arg_19, arg_27]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in let arg_1 = erlps__pp_punctuate__2 [arg_2, arg_4]
  in erlps__pp_par__1 [arg_1]
erlps__pp_ftype__1 [arg_31] = EXC.function_clause unit
erlps__pp_ftype__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_ftype__1) args

erlps__pp_split__1 :: ErlangFun
erlps__pp_split__1 [(ErlangTuple [(ErlangAtom "nosplit"), e_0])]
  =
  erlps__pp_fexpr__1 [e_0]
erlps__pp_split__1 [(ErlangTuple [(ErlangAtom "split"), type_0,
                                  x_1, alts_2])]
  =
  let    arg_8 = toErl "switch("
  in let head_7 = erlps__pp_text__1 [arg_8]
  in let head_10 = erlps__pp_text__1 [x_1]
  in let arg_14 = toErl " : "
  in let head_13 = erlps__pp_text__1 [arg_14]
  in let head_16 = erlps__pp_ftype__1 [type_0]
  in let arg_20 = toErl ")"
  in let head_19 = erlps__pp_text__1 [arg_20]
  in let
    head_5 =
      erlps__pp_beside__1
        [ErlangCons head_7
           (ErlangCons head_10
              (ErlangCons head_13
                 (ErlangCons head_16 (ErlangCons head_19 ErlangEmptyList))))]
  in let
    rop_23 =
      flmap
        (\ lc_26 ->
           let    arg_28 = toErl 2
           in let arg_29 = erlps__pp_case__1 [lc_26]
           in let
             lcRet_27 =
               BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
                 [arg_28, arg_29]
           in ErlangCons lcRet_27 ErlangEmptyList)
        alts_2
  in let
    arg_3 =
      BIF.erlang__op_append [ErlangCons head_5 ErlangEmptyList, rop_23]
  in erlps__pp_above__1 [arg_3]
erlps__pp_split__1 [arg_31] = EXC.function_clause unit
erlps__pp_split__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_split__1) args

erlps__pp_case__1 :: ErlangFun
erlps__pp_case__1 [(ErlangTuple [(ErlangAtom "case"), pat_0,
                                 split_1])]
  =
  let    arg_4 = erlps__pp_pat__1 [pat_0]
  in let arg_7 = toErl " =>"
  in let arg_6 = erlps__pp_text__1 [arg_7]
  in let head_3 = erlps__pp_beside__2 [arg_4, arg_6]
  in let arg_10 = toErl 2
  in let arg_11 = erlps__pp_split__1 [split_1]
  in let
    head_9 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_10, arg_11]
  in
    BIF.do_remote_fun_call "Prettypr" "erlps__sep__1"
      [ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList)]
erlps__pp_case__1 [arg_14] = EXC.function_clause unit
erlps__pp_case__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_case__1) args

erlps__pp_pat__1 :: ErlangFun
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "tuple"), xs_0])] =
  let   
    tup_el_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = ErlangTuple [ErlangAtom "var", lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        xs_0
  in let arg_1 = ErlangTuple [ErlangAtom "tuple", tup_el_3]
  in erlps__pp_fexpr__1 [arg_1]
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "::"), x_0, xs_1])] =
  let    head_6 = ErlangTuple [ErlangAtom "var", x_0]
  in let head_10 = ErlangTuple [ErlangAtom "var", xs_1]
  in let
    arg_2 =
      ErlangTuple
        [ErlangAtom "op", ErlangAtom "::",
         ErlangCons head_6 (ErlangCons head_10 ErlangEmptyList)]
  in erlps__pp_fexpr__1 [arg_2]
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "con"), as_0, i_1,
                                xs_2])]
  =
  let   
    tup_el_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = ErlangTuple [ErlangAtom "var", lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        xs_2
  in let
    arg_3 = ErlangTuple [ErlangAtom "con", as_0, i_1, tup_el_7]
  in erlps__pp_fexpr__1 [arg_3]
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "var"), x_0])] =
  let arg_1 = ErlangTuple [ErlangAtom "var", x_0]
  in erlps__pp_fexpr__1 [arg_1]
erlps__pp_pat__1 [p_1@(ErlangTuple [tag_0, _])]
  | ((weakEq tag_0 (ErlangAtom "bool")) ||
       (weakEq tag_0 (ErlangAtom "int"))) ||
      (weakEq tag_0 (ErlangAtom "string")) =
  let arg_2 = ErlangTuple [ErlangAtom "lit", p_1]
  in erlps__pp_fexpr__1 [arg_2]
erlps__pp_pat__1 [pat_0] = erlps__pp_fexpr__1 [pat_0]
erlps__pp_pat__1 [arg_2] = EXC.function_clause unit
erlps__pp_pat__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_pat__1) args

erlps__is_infix__1 :: ErlangFun
erlps__is_infix__1 [op_0] =
  let    arg_1 = BIF.erlang__atom_to_list__1 [op_0]
  in let c_3 = BIF.erlang__hd__1 [arg_1]
  in let rop_6 = toErl 97
  in let lop_4 = BIF.erlang__op_lesser [c_3, rop_6]
  in
    case lop_4 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") ->
        let rop_8 = toErl 122
        in BIF.erlang__op_greater [c_3, rop_8]
      _ -> EXC.badarg1 lop_4
erlps__is_infix__1 [arg_9] = EXC.function_clause unit
erlps__is_infix__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_infix__1) args