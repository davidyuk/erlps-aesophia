module Aeso.Ast.To.Fcode(erlps__ast_to_fcode__2,
                         erlps__format_fexpr__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__ast_to_fcode__2 :: ErlangFun
erlps__ast_to_fcode__2 [code_0, options_1] =
  let   
    verbose_4 =
      BIF.lists__member__2 [ErlangAtom "pp_fcode", options_1]
  in let _ = erlps__init_fresh_names__0 []
  in let arg_5 = erlps__init_env__1 [options_1]
  in let fcode1_8 = erlps__to_fcode__2 [arg_5, code_0]
  in let
    _ =
      case verbose_4 of
        (ErlangAtom "true") ->
          let    arg_11 = toErl "-- Before lambda lifting --\n~s\n\n"
          in let head_13 = erlps__format_fcode__1 [fcode1_8]
          in let
            lcRet_10 =
              BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                [arg_11, ErlangCons head_13 ErlangEmptyList]
          in ErlangCons lcRet_10 ErlangEmptyList
        _ -> ErlangEmptyList
  in let fcode2_17 = erlps__optimize_fcode__1 [fcode1_8]
  in let
    _ =
      case verbose_4 of
        (ErlangAtom "true") ->
          let cond_19 = BIF.erlang__op_neq [fcode2_17, fcode1_8]
          in
            case cond_19 of
              (ErlangAtom "true") ->
                let    arg_23 = toErl "-- After optimization --\n~s\n\n"
                in let head_25 = erlps__format_fcode__1 [fcode2_17]
                in let
                  lcRet_22 =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_23, ErlangCons head_25 ErlangEmptyList]
                in ErlangCons lcRet_22 ErlangEmptyList
              _ -> ErlangEmptyList
        _ -> ErlangEmptyList
  in let fcode3_29 = erlps__lambda_lift__1 [fcode2_17]
  in let
    _ =
      case verbose_4 of
        (ErlangAtom "true") ->
          let cond_31 = BIF.erlang__op_neq [fcode3_29, fcode2_17]
          in
            case cond_31 of
              (ErlangAtom "true") ->
                let    arg_35 = toErl "-- After lambda lifting --\n~s\n\n"
                in let head_37 = erlps__format_fcode__1 [fcode3_29]
                in let
                  lcRet_34 =
                    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                      [arg_35, ErlangCons head_37 ErlangEmptyList]
                in ErlangCons lcRet_34 ErlangEmptyList
              _ -> ErlangEmptyList
        _ -> ErlangEmptyList
  in let _ = erlps__clear_fresh_names__0 []
  in fcode3_29
erlps__ast_to_fcode__2 [arg_40, arg_41] =
  EXC.function_clause unit
erlps__ast_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__ast_to_fcode__2) args

erlps__init_env__1 :: ErlangFun
erlps__init_env__1 [options_0] =
  let    val_7 = erlps__init_type_env__0 []
  in let val_8 = ErlangMap Map.empty
  in let val_9 = erlps__builtins__0 []
  in let head_12 = toErl "None"
  in let head_15 = toErl "Some"
  in let head_18 = toErl "RelativeTTL"
  in let head_21 = toErl "FixedTTL"
  in let tup_el_25 = toErl 0
  in let head_27 = toErl 0
  in let head_29 = toErl 1
  in let
    val_23 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_25,
         ErlangCons head_27 (ErlangCons head_29 ErlangEmptyList)]
  in let tup_el_33 = toErl 1
  in let head_35 = toErl 0
  in let head_37 = toErl 1
  in let
    val_31 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_33,
         ErlangCons head_35 (ErlangCons head_37 ErlangEmptyList)]
  in let tup_el_41 = toErl 0
  in let head_43 = toErl 1
  in let head_45 = toErl 1
  in let
    val_39 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_41,
         ErlangCons head_43 (ErlangCons head_45 ErlangEmptyList)]
  in let tup_el_49 = toErl 1
  in let head_51 = toErl 1
  in let head_53 = toErl 1
  in let
    val_47 =
      ErlangTuple
        [ErlangAtom "con_tag", tup_el_49,
         ErlangCons head_51 (ErlangCons head_53 ErlangEmptyList)]
  in let
    val_10 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangCons head_12 ErlangEmptyList) val_23,
            DT.Tuple (ErlangCons head_15 ErlangEmptyList) val_31,
            DT.Tuple (ErlangCons head_18 ErlangEmptyList) val_39,
            DT.Tuple (ErlangCons head_21 ErlangEmptyList) val_47])
  in let val_56 = ErlangMap Map.empty
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "type_env") val_7,
          DT.Tuple (ErlangAtom "fun_env") val_8,
          DT.Tuple (ErlangAtom "builtins") val_9,
          DT.Tuple (ErlangAtom "con_env") val_10,
          DT.Tuple (ErlangAtom "options") options_0,
          DT.Tuple (ErlangAtom "functions") val_56])
erlps__init_env__1 [arg_57] = EXC.function_clause unit
erlps__init_env__1 args =
  EXC.badarity (ErlangFun 1 erlps__init_env__1) args

erlps__builtins__0 :: ErlangFun
erlps__builtins__0 [] =
  let   
    mkname_13 =
      ErlangFun 2
        (let
           lambda_0 [ns_3, fun_4] =
             let   
               arg_7 =
                 BIF.erlang__op_append [ns_3, ErlangCons fun_4 ErlangEmptyList]
             in let arg_12 = toErl "_"
             in let
               arg_6 =
                 BIF.do_remote_fun_call "String" "erlps__join__2"
                   [arg_7, arg_12]
             in let
               arg_5 =
                 BIF.do_remote_fun_call "String" "erlps__to_lower__1" [arg_6]
             in BIF.erlang__list_to_atom__1 [arg_5]
           lambda_0 [arg_1, arg_2] = EXC.function_clause unit
           lambda_0 args = EXC.badarity (ErlangFun 2 lambda_0) args
         in lambda_0)
  in let tup_el_18 = toErl "abort"
  in let tup_el_19 = toErl 1
  in let head_17 = ErlangTuple [tup_el_18, tup_el_19]
  in let tup_el_22 = toErl "require"
  in let tup_el_23 = toErl 2
  in let head_21 = ErlangTuple [tup_el_22, tup_el_23]
  in let
    head_14 =
      ErlangTuple
        [ErlangEmptyList,
         ErlangCons head_17 (ErlangCons head_21 ErlangEmptyList)]
  in let head_28 = toErl "Chain"
  in let tup_el_32 = toErl "spend"
  in let tup_el_33 = toErl 2
  in let head_31 = ErlangTuple [tup_el_32, tup_el_33]
  in let tup_el_36 = toErl "balance"
  in let tup_el_37 = toErl 1
  in let head_35 = ErlangTuple [tup_el_36, tup_el_37]
  in let tup_el_40 = toErl "block_hash"
  in let tup_el_41 = toErl 1
  in let head_39 = ErlangTuple [tup_el_40, tup_el_41]
  in let tup_el_44 = toErl "coinbase"
  in let head_43 = ErlangTuple [tup_el_44, ErlangAtom "none"]
  in let tup_el_48 = toErl "timestamp"
  in let head_47 = ErlangTuple [tup_el_48, ErlangAtom "none"]
  in let tup_el_52 = toErl "block_height"
  in let head_51 = ErlangTuple [tup_el_52, ErlangAtom "none"]
  in let tup_el_56 = toErl "difficulty"
  in let head_55 = ErlangTuple [tup_el_56, ErlangAtom "none"]
  in let tup_el_60 = toErl "gas_limit"
  in let head_59 = ErlangTuple [tup_el_60, ErlangAtom "none"]
  in let
    head_26 =
      ErlangTuple
        [ErlangCons head_28 ErlangEmptyList,
         ErlangCons head_31
           (ErlangCons head_35
              (ErlangCons head_39
                 (ErlangCons head_43
                    (ErlangCons head_47
                       (ErlangCons head_51
                          (ErlangCons head_55
                             (ErlangCons head_59 ErlangEmptyList)))))))]
  in let head_66 = toErl "Contract"
  in let tup_el_70 = toErl "address"
  in let head_69 = ErlangTuple [tup_el_70, ErlangAtom "none"]
  in let tup_el_74 = toErl "balance"
  in let head_73 = ErlangTuple [tup_el_74, ErlangAtom "none"]
  in let tup_el_78 = toErl "creator"
  in let head_77 = ErlangTuple [tup_el_78, ErlangAtom "none"]
  in let
    head_64 =
      ErlangTuple
        [ErlangCons head_66 ErlangEmptyList,
         ErlangCons head_69
           (ErlangCons head_73 (ErlangCons head_77 ErlangEmptyList))]
  in let head_84 = toErl "Call"
  in let tup_el_88 = toErl "origin"
  in let head_87 = ErlangTuple [tup_el_88, ErlangAtom "none"]
  in let tup_el_92 = toErl "caller"
  in let head_91 = ErlangTuple [tup_el_92, ErlangAtom "none"]
  in let tup_el_96 = toErl "value"
  in let head_95 = ErlangTuple [tup_el_96, ErlangAtom "none"]
  in let tup_el_100 = toErl "gas_price"
  in let head_99 = ErlangTuple [tup_el_100, ErlangAtom "none"]
  in let tup_el_104 = toErl "gas_left"
  in let tup_el_105 = toErl 0
  in let head_103 = ErlangTuple [tup_el_104, tup_el_105]
  in let
    head_82 =
      ErlangTuple
        [ErlangCons head_84 ErlangEmptyList,
         ErlangCons head_87
           (ErlangCons head_91
              (ErlangCons head_95
                 (ErlangCons head_99 (ErlangCons head_103 ErlangEmptyList))))]
  in let head_110 = toErl "Oracle"
  in let tup_el_114 = toErl "register"
  in let tup_el_115 = toErl 4
  in let head_113 = ErlangTuple [tup_el_114, tup_el_115]
  in let tup_el_118 = toErl "query_fee"
  in let tup_el_119 = toErl 1
  in let head_117 = ErlangTuple [tup_el_118, tup_el_119]
  in let tup_el_122 = toErl "query"
  in let tup_el_123 = toErl 5
  in let head_121 = ErlangTuple [tup_el_122, tup_el_123]
  in let tup_el_126 = toErl "get_question"
  in let tup_el_127 = toErl 2
  in let head_125 = ErlangTuple [tup_el_126, tup_el_127]
  in let tup_el_130 = toErl "respond"
  in let tup_el_131 = toErl 4
  in let head_129 = ErlangTuple [tup_el_130, tup_el_131]
  in let tup_el_134 = toErl "extend"
  in let tup_el_135 = toErl 3
  in let head_133 = ErlangTuple [tup_el_134, tup_el_135]
  in let tup_el_138 = toErl "get_answer"
  in let tup_el_139 = toErl 2
  in let head_137 = ErlangTuple [tup_el_138, tup_el_139]
  in let tup_el_142 = toErl "check"
  in let tup_el_143 = toErl 1
  in let head_141 = ErlangTuple [tup_el_142, tup_el_143]
  in let tup_el_146 = toErl "check_query"
  in let tup_el_147 = toErl 2
  in let head_145 = ErlangTuple [tup_el_146, tup_el_147]
  in let
    head_108 =
      ErlangTuple
        [ErlangCons head_110 ErlangEmptyList,
         ErlangCons head_113
           (ErlangCons head_117
              (ErlangCons head_121
                 (ErlangCons head_125
                    (ErlangCons head_129
                       (ErlangCons head_133
                          (ErlangCons head_137
                             (ErlangCons head_141
                                (ErlangCons head_145 ErlangEmptyList))))))))]
  in let head_152 = toErl "AENS"
  in let tup_el_156 = toErl "resolve"
  in let tup_el_157 = toErl 2
  in let head_155 = ErlangTuple [tup_el_156, tup_el_157]
  in let tup_el_160 = toErl "preclaim"
  in let tup_el_161 = toErl 3
  in let head_159 = ErlangTuple [tup_el_160, tup_el_161]
  in let tup_el_164 = toErl "claim"
  in let tup_el_165 = toErl 5
  in let head_163 = ErlangTuple [tup_el_164, tup_el_165]
  in let tup_el_168 = toErl "transfer"
  in let tup_el_169 = toErl 4
  in let head_167 = ErlangTuple [tup_el_168, tup_el_169]
  in let tup_el_172 = toErl "revoke"
  in let tup_el_173 = toErl 3
  in let head_171 = ErlangTuple [tup_el_172, tup_el_173]
  in let
    head_150 =
      ErlangTuple
        [ErlangCons head_152 ErlangEmptyList,
         ErlangCons head_155
           (ErlangCons head_159
              (ErlangCons head_163
                 (ErlangCons head_167 (ErlangCons head_171 ErlangEmptyList))))]
  in let head_178 = toErl "Map"
  in let tup_el_182 = toErl "from_list"
  in let tup_el_183 = toErl 1
  in let head_181 = ErlangTuple [tup_el_182, tup_el_183]
  in let tup_el_186 = toErl "to_list"
  in let tup_el_187 = toErl 1
  in let head_185 = ErlangTuple [tup_el_186, tup_el_187]
  in let tup_el_190 = toErl "lookup"
  in let tup_el_191 = toErl 2
  in let head_189 = ErlangTuple [tup_el_190, tup_el_191]
  in let tup_el_194 = toErl "lookup_default"
  in let tup_el_195 = toErl 3
  in let head_193 = ErlangTuple [tup_el_194, tup_el_195]
  in let tup_el_198 = toErl "delete"
  in let tup_el_199 = toErl 2
  in let head_197 = ErlangTuple [tup_el_198, tup_el_199]
  in let tup_el_202 = toErl "member"
  in let tup_el_203 = toErl 2
  in let head_201 = ErlangTuple [tup_el_202, tup_el_203]
  in let tup_el_206 = toErl "size"
  in let tup_el_207 = toErl 1
  in let head_205 = ErlangTuple [tup_el_206, tup_el_207]
  in let
    head_176 =
      ErlangTuple
        [ErlangCons head_178 ErlangEmptyList,
         ErlangCons head_181
           (ErlangCons head_185
              (ErlangCons head_189
                 (ErlangCons head_193
                    (ErlangCons head_197
                       (ErlangCons head_201
                          (ErlangCons head_205 ErlangEmptyList))))))]
  in let head_212 = toErl "Crypto"
  in let tup_el_216 = toErl "verify_sig"
  in let tup_el_217 = toErl 3
  in let head_215 = ErlangTuple [tup_el_216, tup_el_217]
  in let tup_el_220 = toErl "verify_sig_secp256k1"
  in let tup_el_221 = toErl 3
  in let head_219 = ErlangTuple [tup_el_220, tup_el_221]
  in let tup_el_224 = toErl "ecverify_secp256k1"
  in let tup_el_225 = toErl 3
  in let head_223 = ErlangTuple [tup_el_224, tup_el_225]
  in let tup_el_228 = toErl "ecrecover_secp256k1"
  in let tup_el_229 = toErl 2
  in let head_227 = ErlangTuple [tup_el_228, tup_el_229]
  in let tup_el_232 = toErl "sha3"
  in let tup_el_233 = toErl 1
  in let head_231 = ErlangTuple [tup_el_232, tup_el_233]
  in let tup_el_236 = toErl "sha256"
  in let tup_el_237 = toErl 1
  in let head_235 = ErlangTuple [tup_el_236, tup_el_237]
  in let tup_el_240 = toErl "blake2b"
  in let tup_el_241 = toErl 1
  in let head_239 = ErlangTuple [tup_el_240, tup_el_241]
  in let
    head_210 =
      ErlangTuple
        [ErlangCons head_212 ErlangEmptyList,
         ErlangCons head_215
           (ErlangCons head_219
              (ErlangCons head_223
                 (ErlangCons head_227
                    (ErlangCons head_231
                       (ErlangCons head_235
                          (ErlangCons head_239 ErlangEmptyList))))))]
  in let head_246 = toErl "Auth"
  in let tup_el_250 = toErl "tx_hash"
  in let head_249 = ErlangTuple [tup_el_250, ErlangAtom "none"]
  in let
    head_244 =
      ErlangTuple
        [ErlangCons head_246 ErlangEmptyList,
         ErlangCons head_249 ErlangEmptyList]
  in let head_256 = toErl "String"
  in let tup_el_260 = toErl "length"
  in let tup_el_261 = toErl 1
  in let head_259 = ErlangTuple [tup_el_260, tup_el_261]
  in let tup_el_264 = toErl "concat"
  in let tup_el_265 = toErl 2
  in let head_263 = ErlangTuple [tup_el_264, tup_el_265]
  in let tup_el_268 = toErl "sha3"
  in let tup_el_269 = toErl 1
  in let head_267 = ErlangTuple [tup_el_268, tup_el_269]
  in let tup_el_272 = toErl "sha256"
  in let tup_el_273 = toErl 1
  in let head_271 = ErlangTuple [tup_el_272, tup_el_273]
  in let tup_el_276 = toErl "blake2b"
  in let tup_el_277 = toErl 1
  in let head_275 = ErlangTuple [tup_el_276, tup_el_277]
  in let
    head_254 =
      ErlangTuple
        [ErlangCons head_256 ErlangEmptyList,
         ErlangCons head_259
           (ErlangCons head_263
              (ErlangCons head_267
                 (ErlangCons head_271 (ErlangCons head_275 ErlangEmptyList))))]
  in let head_282 = toErl "Bits"
  in let tup_el_286 = toErl "set"
  in let tup_el_287 = toErl 2
  in let head_285 = ErlangTuple [tup_el_286, tup_el_287]
  in let tup_el_290 = toErl "clear"
  in let tup_el_291 = toErl 2
  in let head_289 = ErlangTuple [tup_el_290, tup_el_291]
  in let tup_el_294 = toErl "test"
  in let tup_el_295 = toErl 2
  in let head_293 = ErlangTuple [tup_el_294, tup_el_295]
  in let tup_el_298 = toErl "sum"
  in let tup_el_299 = toErl 1
  in let head_297 = ErlangTuple [tup_el_298, tup_el_299]
  in let tup_el_302 = toErl "intersection"
  in let tup_el_303 = toErl 2
  in let head_301 = ErlangTuple [tup_el_302, tup_el_303]
  in let tup_el_306 = toErl "union"
  in let tup_el_307 = toErl 2
  in let head_305 = ErlangTuple [tup_el_306, tup_el_307]
  in let tup_el_310 = toErl "difference"
  in let tup_el_311 = toErl 2
  in let head_309 = ErlangTuple [tup_el_310, tup_el_311]
  in let tup_el_314 = toErl "none"
  in let head_313 = ErlangTuple [tup_el_314, ErlangAtom "none"]
  in let tup_el_318 = toErl "all"
  in let head_317 = ErlangTuple [tup_el_318, ErlangAtom "none"]
  in let
    head_280 =
      ErlangTuple
        [ErlangCons head_282 ErlangEmptyList,
         ErlangCons head_285
           (ErlangCons head_289
              (ErlangCons head_293
                 (ErlangCons head_297
                    (ErlangCons head_301
                       (ErlangCons head_305
                          (ErlangCons head_309
                             (ErlangCons head_313
                                (ErlangCons head_317 ErlangEmptyList))))))))]
  in let head_324 = toErl "Bytes"
  in let tup_el_328 = toErl "to_int"
  in let tup_el_329 = toErl 1
  in let head_327 = ErlangTuple [tup_el_328, tup_el_329]
  in let tup_el_332 = toErl "to_str"
  in let tup_el_333 = toErl 1
  in let head_331 = ErlangTuple [tup_el_332, tup_el_333]
  in let tup_el_336 = toErl "concat"
  in let tup_el_337 = toErl 2
  in let head_335 = ErlangTuple [tup_el_336, tup_el_337]
  in let tup_el_340 = toErl "split"
  in let tup_el_341 = toErl 1
  in let head_339 = ErlangTuple [tup_el_340, tup_el_341]
  in let
    head_322 =
      ErlangTuple
        [ErlangCons head_324 ErlangEmptyList,
         ErlangCons head_327
           (ErlangCons head_331
              (ErlangCons head_335 (ErlangCons head_339 ErlangEmptyList)))]
  in let head_346 = toErl "Int"
  in let tup_el_350 = toErl "to_str"
  in let tup_el_351 = toErl 1
  in let head_349 = ErlangTuple [tup_el_350, tup_el_351]
  in let
    head_344 =
      ErlangTuple
        [ErlangCons head_346 ErlangEmptyList,
         ErlangCons head_349 ErlangEmptyList]
  in let head_356 = toErl "Address"
  in let tup_el_360 = toErl "to_str"
  in let tup_el_361 = toErl 1
  in let head_359 = ErlangTuple [tup_el_360, tup_el_361]
  in let tup_el_364 = toErl "to_contract"
  in let tup_el_365 = toErl 1
  in let head_363 = ErlangTuple [tup_el_364, tup_el_365]
  in let tup_el_368 = toErl "is_oracle"
  in let tup_el_369 = toErl 1
  in let head_367 = ErlangTuple [tup_el_368, tup_el_369]
  in let tup_el_372 = toErl "is_contract"
  in let tup_el_373 = toErl 1
  in let head_371 = ErlangTuple [tup_el_372, tup_el_373]
  in let tup_el_376 = toErl "is_payable"
  in let tup_el_377 = toErl 1
  in let head_375 = ErlangTuple [tup_el_376, tup_el_377]
  in let
    head_354 =
      ErlangTuple
        [ErlangCons head_356 ErlangEmptyList,
         ErlangCons head_359
           (ErlangCons head_363
              (ErlangCons head_367
                 (ErlangCons head_371 (ErlangCons head_375 ErlangEmptyList))))]
  in let
    arg_381 =
      flmap
        (\ lc_385 ->
           case lc_385 of
             (ErlangTuple [ns_383, funs_384]) ->
               flmap
                 (\ lc_389 ->
                    case lc_389 of
                      (ErlangTuple [fun_387, arity_388]) ->
                        let   
                          tup_el_391 =
                            BIF.erlang__op_append
                              [ns_383, ErlangCons fun_387 ErlangEmptyList]
                        in let
                          tup_el_397 =
                            BIF.erlang__apply__2
                              [mkname_13,
                               ErlangCons ns_383
                                 (ErlangCons fun_387 ErlangEmptyList)]
                        in let tup_el_396 = ErlangTuple [tup_el_397, arity_388]
                        in let lcRet_390 = ErlangTuple [tup_el_391, tup_el_396]
                        in ErlangCons lcRet_390 ErlangEmptyList
                      _ -> ErlangEmptyList)
                 funs_384
             _ -> ErlangEmptyList)
        (ErlangCons head_14
           (ErlangCons head_26
              (ErlangCons head_64
                 (ErlangCons head_82
                    (ErlangCons head_108
                       (ErlangCons head_150
                          (ErlangCons head_176
                             (ErlangCons head_210
                                (ErlangCons head_244
                                   (ErlangCons head_254
                                      (ErlangCons head_280
                                         (ErlangCons head_322
                                            (ErlangCons head_344
                                               (ErlangCons head_354
                                                  ErlangEmptyList))))))))))))))
  in BIF.maps__from_list__1 [arg_381]
erlps__builtins__0 args =
  EXC.badarity (ErlangFun 0 erlps__builtins__0) args

erlps__state_layout__1 :: ErlangFun
erlps__state_layout__1 [env_0] =
  let    tup_el_5 = toErl 1
  in let arg_3 = ErlangTuple [ErlangAtom "reg", tup_el_5]
  in
    BIF.do_remote_fun_call "Maps" "erlps__get__3"
      [ErlangAtom "state_layout", env_0, arg_3]
erlps__state_layout__1 [arg_6] = EXC.function_clause unit
erlps__state_layout__1 args =
  EXC.badarity (ErlangFun 1 erlps__state_layout__1) args

erlps__init_type_env__0 :: ErlangFun
erlps__init_type_env__0 [] =
  let    head_1 = toErl "int"
  in let head_4 = toErl "bool"
  in let head_7 = toErl "bits"
  in let head_10 = toErl "char"
  in let head_13 = toErl "string"
  in let head_16 = toErl "address"
  in let head_19 = toErl "hash"
  in let head_22 = toErl "signature"
  in let head_25 = toErl "oracle"
  in let head_28 = toErl "oracle_query"
  in let head_31 = toErl "list"
  in let head_34 = toErl "map"
  in let head_37 = toErl "option"
  in let head_40 = toErl "Chain"
  in let head_42 = toErl "ttl"
  in let
    val_44 =
      ErlangFun 1
        (let
           lambda_45 [(ErlangEmptyList)] = ErlangAtom "integer"
           lambda_45 [arg_46] = EXC.function_clause unit
           lambda_45 args = EXC.badarity (ErlangFun 1 lambda_45) args
         in lambda_45)
  in let
    val_47 =
      ErlangFun 1
        (let
           lambda_48 [(ErlangEmptyList)] = ErlangAtom "boolean"
           lambda_48 [arg_49] = EXC.function_clause unit
           lambda_48 args = EXC.badarity (ErlangFun 1 lambda_48) args
         in lambda_48)
  in let
    val_50 =
      ErlangFun 1
        (let
           lambda_51 [(ErlangEmptyList)] = ErlangAtom "bits"
           lambda_51 [arg_52] = EXC.function_clause unit
           lambda_51 args = EXC.badarity (ErlangFun 1 lambda_51) args
         in lambda_51)
  in let
    val_53 =
      ErlangFun 1
        (let
           lambda_54 [(ErlangEmptyList)] = ErlangAtom "integer"
           lambda_54 [arg_55] = EXC.function_clause unit
           lambda_54 args = EXC.badarity (ErlangFun 1 lambda_54) args
         in lambda_54)
  in let
    val_56 =
      ErlangFun 1
        (let
           lambda_57 [(ErlangEmptyList)] = ErlangAtom "string"
           lambda_57 [arg_58] = EXC.function_clause unit
           lambda_57 args = EXC.badarity (ErlangFun 1 lambda_57) args
         in lambda_57)
  in let
    val_59 =
      ErlangFun 1
        (let
           lambda_60 [(ErlangEmptyList)] = ErlangAtom "address"
           lambda_60 [arg_61] = EXC.function_clause unit
           lambda_60 args = EXC.badarity (ErlangFun 1 lambda_60) args
         in lambda_60)
  in let
    val_62 =
      ErlangFun 1
        (let
           lambda_63 [(ErlangEmptyList)] = ErlangAtom "hash"
           lambda_63 [arg_64] = EXC.function_clause unit
           lambda_63 args = EXC.badarity (ErlangFun 1 lambda_63) args
         in lambda_63)
  in let
    val_65 =
      ErlangFun 1
        (let
           lambda_66 [(ErlangEmptyList)] = ErlangAtom "signature"
           lambda_66 [arg_67] = EXC.function_clause unit
           lambda_66 args = EXC.badarity (ErlangFun 1 lambda_66) args
         in lambda_66)
  in let
    val_68 =
      ErlangFun 1
        (let
           lambda_69 [(ErlangCons q_71 (ErlangCons r_72 (ErlangEmptyList)))]
             =
             ErlangTuple [ErlangAtom "oracle", q_71, r_72]
           lambda_69 [arg_70] = EXC.function_clause unit
           lambda_69 args = EXC.badarity (ErlangFun 1 lambda_69) args
         in lambda_69)
  in let
    val_76 =
      ErlangFun 1
        (let
           lambda_77 [(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))] =
             ErlangAtom "oracle_query"
           lambda_77 [arg_78] = EXC.function_clause unit
           lambda_77 args = EXC.badarity (ErlangFun 1 lambda_77) args
         in lambda_77)
  in let
    val_79 =
      ErlangFun 1
        (let
           lambda_80 [(ErlangCons t_82 (ErlangEmptyList))] =
             ErlangTuple [ErlangAtom "list", t_82]
           lambda_80 [arg_81] = EXC.function_clause unit
           lambda_80 args = EXC.badarity (ErlangFun 1 lambda_80) args
         in lambda_80)
  in let
    val_85 =
      ErlangFun 1
        (let
           lambda_86 [(ErlangCons k_88 (ErlangCons v_89 (ErlangEmptyList)))]
             =
             ErlangTuple [ErlangAtom "map", k_88, v_89]
           lambda_86 [arg_87] = EXC.function_clause unit
           lambda_86 args = EXC.badarity (ErlangFun 1 lambda_86) args
         in lambda_86)
  in let
    val_93 =
      ErlangFun 1
        (let
           lambda_94 [(ErlangCons t_96 (ErlangEmptyList))] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons ErlangEmptyList
                  (ErlangCons (ErlangCons t_96 ErlangEmptyList)
                     ErlangEmptyList)]
           lambda_94 [arg_95] = EXC.function_clause unit
           lambda_94 args = EXC.badarity (ErlangFun 1 lambda_94) args
         in lambda_94)
  in let
    val_105 =
      ErlangFun 1
        (let
           lambda_106 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons (ErlangCons (ErlangAtom "integer") ErlangEmptyList)
                  (ErlangCons
                     (ErlangCons (ErlangAtom "integer") ErlangEmptyList)
                     ErlangEmptyList)]
           lambda_106 [arg_107] = EXC.function_clause unit
           lambda_106 args = EXC.badarity (ErlangFun 1 lambda_106) args
         in lambda_106)
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangCons head_1 ErlangEmptyList) val_44,
          DT.Tuple (ErlangCons head_4 ErlangEmptyList) val_47,
          DT.Tuple (ErlangCons head_7 ErlangEmptyList) val_50,
          DT.Tuple (ErlangCons head_10 ErlangEmptyList) val_53,
          DT.Tuple (ErlangCons head_13 ErlangEmptyList) val_56,
          DT.Tuple (ErlangCons head_16 ErlangEmptyList) val_59,
          DT.Tuple (ErlangCons head_19 ErlangEmptyList) val_62,
          DT.Tuple (ErlangCons head_22 ErlangEmptyList) val_65,
          DT.Tuple (ErlangCons head_25 ErlangEmptyList) val_68,
          DT.Tuple (ErlangCons head_28 ErlangEmptyList) val_76,
          DT.Tuple (ErlangCons head_31 ErlangEmptyList) val_79,
          DT.Tuple (ErlangCons head_34 ErlangEmptyList) val_85,
          DT.Tuple (ErlangCons head_37 ErlangEmptyList) val_93,
          DT.Tuple
            (ErlangCons head_40 (ErlangCons head_42 ErlangEmptyList))
            val_105])
erlps__init_type_env__0 args =
  EXC.badarity (ErlangFun 0 erlps__init_type_env__0) args

erlps__is_no_code__1 :: ErlangFun
erlps__is_no_code__1 [env_0] =
  erlps__get_option__2 [ErlangAtom "no_code", env_0]
erlps__is_no_code__1 [arg_3] = EXC.function_clause unit
erlps__is_no_code__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_no_code__1) args

erlps__get_option__2 :: ErlangFun
erlps__get_option__2 [opt_0, env_1] =
  erlps__get_option__3 [opt_0, env_1, ErlangAtom "false"]
erlps__get_option__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__get_option__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_option__2) args

erlps__get_option__3 :: ErlangFun
erlps__get_option__3 [opt_0, env_1, default_2] =
  let
    arg_4 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [ErlangAtom "options", env_1, ErlangEmptyList]
  in
    BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
      [opt_0, arg_4, default_2]
erlps__get_option__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__get_option__3 args =
  EXC.badarity (ErlangFun 3 erlps__get_option__3) args

erlps__to_fcode__2 :: ErlangFun
erlps__to_fcode__2 [env_0,
                    (ErlangCons (ErlangTuple [(ErlangAtom "contract"), attrs_1,
                                              maincon_3@(ErlangTuple [(ErlangAtom "con"),
                                                                      _,
                                                                      main_2]),
                                              decls_4]) (ErlangEmptyList))]
  =
  case env_0 of
    (ErlangMap map_5) | (DM.Just builtins_6) <-
                          (Map.lookup (ErlangAtom "builtins") map_5) ->
      let    val_11 = ErlangTuple [ErlangAtom "main_contract", main_2]
      in let head_19 = toErl "state"
      in let head_24 = toErl "put"
      in let head_29 = toErl "Chain"
      in let head_31 = toErl "event"
      in let
        val_33 = ErlangTuple [ErlangAtom "get_state", ErlangAtom "none"]
      in let tup_el_38 = toErl 1
      in let val_36 = ErlangTuple [ErlangAtom "set_state", tup_el_38]
      in let tup_el_41 = toErl 1
      in let val_39 = ErlangTuple [ErlangAtom "chain_event", tup_el_41]
      in let
        mapExt_42 =
          ErlangMap
            (Map.fromFoldable
               [DT.Tuple
                  (ErlangCons main_2 (ErlangCons head_19 ErlangEmptyList))
                  val_33,
                DT.Tuple
                  (ErlangCons main_2 (ErlangCons head_24 ErlangEmptyList))
                  val_36,
                DT.Tuple
                  (ErlangCons main_2
                     (ErlangCons head_29 (ErlangCons head_31 ErlangEmptyList)))
                  val_39])
      in let val_14 = BIF.maps__merge__2 [builtins_6, mapExt_42]
      in let
        mapExt_44 =
          ErlangMap
            (Map.fromFoldable
               [DT.Tuple (ErlangAtom "context") val_11,
                DT.Tuple (ErlangAtom "builtins") val_14])
      in let mainenv_46 = BIF.maps__merge__2 [env_0, mapExt_44]
      in let env1_49 = erlps__decls_to_fcode__2 [mainenv_46, decls_4]
      in
        case env1_49 of
          (ErlangMap map_50) | (DM.Just funs_51) <-
                                 (Map.lookup (ErlangAtom "functions") map_50) ->
            let    head_57 = toErl "state"
            in let arg_60 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
            in let
              statetype_63 =
                erlps__lookup_type__4
                  [env1_49,
                   ErlangCons main_2 (ErlangCons head_57 ErlangEmptyList),
                   ErlangEmptyList, arg_60]
            in let head_68 = toErl "event"
            in let
              eventtype_72 =
                erlps__lookup_type__4
                  [env1_49,
                   ErlangCons main_2 (ErlangCons head_68 ErlangEmptyList),
                   ErlangEmptyList, ErlangAtom "none"]
            in let statelayout_74 = erlps__state_layout__1 [env1_49]
            in let
              payable_78 =
                BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
                  [ErlangAtom "payable", attrs_1, ErlangAtom "false"]
            in let
              arg_94 =
                erlps__add_event_function__3 [env1_49, eventtype_72, funs_51]
            in let
              val_90 =
                erlps__add_init_function__4
                  [env1_49, maincon_3, statetype_63, arg_94]
            in
              ErlangMap
                (Map.fromFoldable
                   [DT.Tuple (ErlangAtom "contract_name") main_2,
                    DT.Tuple (ErlangAtom "state_type") statetype_63,
                    DT.Tuple (ErlangAtom "state_layout") statelayout_74,
                    DT.Tuple (ErlangAtom "event_type") eventtype_72,
                    DT.Tuple (ErlangAtom "payable") payable_78,
                    DT.Tuple (ErlangAtom "functions") val_90])
          _ -> EXC.badmatch env1_49
    _ -> EXC.badmatch env_0
erlps__to_fcode__2 [_env_0,
                    (ErlangCons notcontract_1 (ErlangEmptyList))]
  =
  let
    arg_2 =
      ErlangTuple
        [ErlangAtom "last_declaration_must_be_contract", notcontract_1]
  in erlps__fcode_error__1 [arg_2]
erlps__to_fcode__2 [env_0,
                    (ErlangCons (ErlangTuple [(ErlangAtom "contract"), _,
                                              (ErlangTuple [(ErlangAtom "con"),
                                                            _, con_1]),
                                              decls_2]) code_3)]
  =
  let   
    val_7 = ErlangTuple [ErlangAtom "abstract_contract", con_1]
  in let
    mapExt_10 =
      ErlangMap (Map.singleton (ErlangAtom "context") val_7)
  in let arg_4 = BIF.maps__merge__2 [env_0, mapExt_10]
  in let env1_13 = erlps__decls_to_fcode__2 [arg_4, decls_2]
  in erlps__to_fcode__2 [env1_13, code_3]
erlps__to_fcode__2 [env_0,
                    (ErlangCons (ErlangTuple [(ErlangAtom "namespace"), _,
                                              (ErlangTuple [(ErlangAtom "con"),
                                                            _, con_1]),
                                              decls_2]) code_3)]
  =
  let    val_7 = ErlangTuple [ErlangAtom "namespace", con_1]
  in let
    mapExt_10 =
      ErlangMap (Map.singleton (ErlangAtom "context") val_7)
  in let arg_4 = BIF.maps__merge__2 [env_0, mapExt_10]
  in let env1_13 = erlps__decls_to_fcode__2 [arg_4, decls_2]
  in erlps__to_fcode__2 [env1_13, code_3]
erlps__to_fcode__2 [arg_16, arg_17] = EXC.function_clause unit
erlps__to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_fcode__2) args

erlps__decls_to_fcode__2 :: ErlangFun
erlps__decls_to_fcode__2 [env_0, decls_1] =
  let    env1_4 = erlps__add_fun_env__2 [env_0, decls_1]
  in let
    arg_5 =
      ErlangFun 2
        (let
           lambda_6 [d_9, e_10] =
             let r_13 = erlps__decl_to_fcode__2 [e_10, d_9]
             in r_13
           lambda_6 [arg_7, arg_8] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
         in lambda_6)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_5, env1_4, decls_1]
erlps__decls_to_fcode__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__decls_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__decls_to_fcode__2) args

erlps__decl_to_fcode__2 :: ErlangFun
erlps__decl_to_fcode__2 [env_1@(ErlangMap map_0),
                         (ErlangTuple [(ErlangAtom "fun_decl"), _, id_2, _])]
  | (DM.Just (ErlangTuple [(ErlangAtom "main_contract"), _])) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  let case_3 = erlps__is_no_code__1 [env_1]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_5 = ErlangTuple [ErlangAtom "missing_definition", id_2]
        in erlps__fcode_error__1 [arg_5]
      (ErlangAtom "true") -> env_1
      something_else -> EXC.case_clause something_else
erlps__decl_to_fcode__2 [env_0,
                         (ErlangTuple [(ErlangAtom "fun_decl"), _, _, _])]
  =
  env_0
erlps__decl_to_fcode__2 [env_0,
                         (ErlangTuple [(ErlangAtom "type_def"), _ann_1, name_2,
                                       args_3, def_4])]
  =
  erlps__typedef_to_fcode__4 [env_0, name_2, args_3, def_4]
erlps__decl_to_fcode__2 [env_2@(ErlangMap map_0),
                         (ErlangTuple [(ErlangAtom "letfun"), ann_3,
                                       id_5@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_4]),
                                       args_6, ret_7, body_8])]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    attrs_10 = erlps__get_attributes__1 [ann_3]
  in let arg_12 = erlps__qname__2 [env_2, name_4]
  in let fname_15 = erlps__lookup_fun__2 [env_2, arg_12]
  in let fargs_18 = erlps__args_to_fcode__2 [env_2, args_6]
  in let fret_21 = erlps__type_to_fcode__2 [env_2, ret_7]
  in let
    val_25 =
      flmap
        (\ lc_28 ->
           case lc_28 of
             (ErlangTuple [x_27, _]) -> ErlangCons x_27 ErlangEmptyList
             _ -> ErlangEmptyList)
        fargs_18
  in let
    mapExt_30 = ErlangMap (Map.singleton (ErlangAtom "vars") val_25)
  in let arg_22 = BIF.maps__merge__2 [env_2, mapExt_30]
  in let fbody_33 = erlps__expr_to_fcode__2 [arg_22, body_8]
  in let
    cond_34 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "entrypoint", ann_3, ErlangAtom "false"]
  in let
    _ =
      case cond_34 of
        (ErlangAtom "true") ->
          let
            lcRet_38 =
              erlps__ensure_first_order_entrypoint__6
                [ann_3, id_5, args_6, ret_7, fargs_18, fret_21]
          in ErlangCons lcRet_38 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    def_53 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "attrs") attrs_10,
            DT.Tuple (ErlangAtom "args") fargs_18,
            DT.Tuple (ErlangAtom "return") fret_21,
            DT.Tuple (ErlangAtom "body") fbody_33])
  in let mapExt_57 = ErlangMap (Map.singleton fname_15 def_53)
  in let newfuns_59 = BIF.maps__merge__2 [funs_1, mapExt_57]
  in let
    mapExt_63 =
      ErlangMap (Map.singleton (ErlangAtom "functions") newfuns_59)
  in
    case findMissingKey env_2 [ErlangAtom "functions"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_63]
      (DM.Just missing_65) -> EXC.badkey missing_65
erlps__decl_to_fcode__2 [arg_66, arg_67] =
  EXC.function_clause unit
erlps__decl_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__decl_to_fcode__2) args

erlps__typedef_to_fcode__4 :: ErlangFun
erlps__typedef_to_fcode__4 [env_0,
                            id_2@(ErlangTuple [(ErlangAtom "id"), _, name_1]),
                            xs_3, def_4]
  =
  let   
    _ = erlps__check_state_and_event_types__3 [env_0, id_2, xs_3]
  in let q_10 = erlps__qname__2 [env_0, name_1]
  in let
    fdef_66 =
      ErlangFun 1
        (let
           lambda_11 [args_13]
             | (ErlangAtom "true") ==
                 (falsifyErrors
                    (\ _ ->
                       let    lop_14 = BIF.erlang__length__1 [args_13]
                       in let rop_16 = BIF.erlang__length__1 [xs_3]
                       in BIF.erlang__op_eq [lop_14, rop_16])) =
             let   
               arg_19 =
                 flmap
                   (\ lc_22 ->
                      case lc_22 of
                        (ErlangTuple [(ErlangAtom "tvar"), _, x_21]) ->
                          ErlangCons x_21 ErlangEmptyList
                        _ -> ErlangEmptyList)
                   xs_3
             in let
               arg_18 =
                 BIF.do_remote_fun_call "Lists" "erlps__zip__2"
                   [arg_19, args_13]
             in let sub_25 = BIF.maps__from_list__1 [arg_18]
             in
               case def_4 of
                 (ErlangTuple [(ErlangAtom "record_t"), fields_27]) ->
                   let
                     tup_el_29 =
                       flmap
                         (\ lc_32 ->
                            case lc_32 of
                              (ErlangTuple [(ErlangAtom "field_t"), _, _,
                                            t_31]) ->
                                let
                                  lcRet_33 =
                                    erlps__type_to_fcode__3
                                      [env_0, sub_25, t_31]
                                in ErlangCons lcRet_33 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         fields_27
                   in ErlangTuple [ErlangAtom "tuple", tup_el_29]
                 (ErlangTuple [(ErlangAtom "variant_t"), cons_37]) ->
                   let
                     fcons_51 =
                       flmap
                         (\ lc_40 ->
                            case lc_40 of
                              (ErlangTuple [(ErlangAtom "constr_t"), _, _,
                                            ts_42]) ->
                                let
                                  lcRet_41 =
                                    flmap
                                      (\ lc_46 ->
                                         let
                                           lcRet_47 =
                                             erlps__type_to_fcode__3
                                               [env_0, sub_25, lc_46]
                                         in ErlangCons lcRet_47 ErlangEmptyList)
                                      ts_42
                                in ErlangCons lcRet_41 ErlangEmptyList
                              _ -> EXC.badmatch lc_40)
                         cons_37
                   in ErlangTuple [ErlangAtom "variant", fcons_51]
                 (ErlangTuple [(ErlangAtom "alias_t"), type_54]) ->
                   erlps__type_to_fcode__3 [env_0, sub_25, type_54]
                 something_else -> EXC.case_clause something_else
           lambda_11 [args_58] =
             let    tup_el_62 = BIF.erlang__length__1 [args_58]
             in let tup_el_64 = BIF.erlang__length__1 [xs_3]
             in let
               arg_59 =
                 ErlangTuple
                   [ErlangAtom "type_arity_mismatch", name_1, tup_el_62,
                    tup_el_64]
             in erlps__internal_error__1 [arg_59]
           lambda_11 [arg_12] = EXC.function_clause unit
           lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
         in lambda_11)
  in let
    constructors_114 =
      case def_4 of
        (ErlangTuple [(ErlangAtom "variant_t"), cons_68]) ->
          let   
            arities_76 =
              flmap
                (\ lc_71 ->
                   case lc_71 of
                     (ErlangTuple [(ErlangAtom "constr_t"), _, _, args_73]) ->
                       let lcRet_72 = BIF.erlang__length__1 [args_73]
                       in ErlangCons lcRet_72 ErlangEmptyList
                     _ -> EXC.badmatch lc_71)
                cons_68
          in let arg_78 = toErl 0
          in let lop_80 = BIF.erlang__length__1 [cons_68]
          in let rop_82 = toErl 1
          in let arg_79 = BIF.erlang__op_minus [lop_80, rop_82]
          in let
            lcSrc_77 =
              BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_78, arg_79]
          in let
            tags_89 =
              flmap
                (\ lc_84 ->
                   let
                     lcRet_85 =
                       ErlangTuple [ErlangAtom "con_tag", lc_84, arities_76]
                   in ErlangCons lcRet_85 ErlangEmptyList)
                lcSrc_77
          in let
            getname_93 =
              ErlangFun 1
                (let
                   lambda_90 [(ErlangTuple [(ErlangAtom "constr_t"), _,
                                            (ErlangTuple [(ErlangAtom "con"), _,
                                                          c_92]),
                                            _])]
                     =
                     c_92
                   lambda_90 [arg_91] = EXC.function_clause unit
                   lambda_90 args = EXC.badarity (ErlangFun 1 lambda_90) args
                 in lambda_90)
          in let
            qname_101 =
              ErlangFun 1
                (let
                   lambda_94 [con_96] =
                     let
                       arg_98 =
                         BIF.erlang__apply__2
                           [getname_93, ErlangCons con_96 ErlangEmptyList]
                     in erlps__qname__2 [env_0, arg_98]
                   lambda_94 [arg_95] = EXC.function_clause unit
                   lambda_94 args = EXC.badarity (ErlangFun 1 lambda_94) args
                 in lambda_94)
          in let
            lcSrc_103 =
              BIF.do_remote_fun_call "Lists" "erlps__zip__2" [tags_89, cons_68]
          in let
            arg_102 =
              flmap
                (\ lc_108 ->
                   case lc_108 of
                     (ErlangTuple [tag_106, con_107]) ->
                       let   
                         tup_el_110 =
                           BIF.erlang__apply__2
                             [qname_101, ErlangCons con_107 ErlangEmptyList]
                       in let lcRet_109 = ErlangTuple [tup_el_110, tag_106]
                       in ErlangCons lcRet_109 ErlangEmptyList
                     _ -> ErlangEmptyList)
                lcSrc_103
          in BIF.maps__from_list__1 [arg_102]
        _ -> ErlangMap Map.empty
  in let
    env1_117 = erlps__bind_constructors__2 [env_0, constructors_114]
  in let
    env2_129 =
      case name_1 of
        (ErlangCons (ErlangInt num_119) (ErlangCons (ErlangInt num_120) (ErlangCons (ErlangInt num_121) (ErlangCons (ErlangInt num_122) (ErlangCons (ErlangInt num_123) (ErlangEmptyList)))))) | (ErlangInt
                                                                                                                                                                                                    num_119) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      101)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_120) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      118)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_121) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      101)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_122) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      110)
                                                                                                                                                                                               , (ErlangInt
                                                                                                                                                                                                    num_123) ==
                                                                                                                                                                                                   (toErl
                                                                                                                                                                                                      116) ->
          let
            mapExt_127 =
              ErlangMap (Map.singleton (ErlangAtom "event_type") def_4)
          in BIF.maps__merge__2 [env1_117, mapExt_127]
        _ -> env1_117
  in let
    env3_133 =
      erlps__compute_state_layout__3 [env2_129, name_1, fdef_66]
  in erlps__bind_type__3 [env3_133, q_10, fdef_66]
erlps__typedef_to_fcode__4 [arg_137, arg_138, arg_139, arg_140] =
  EXC.function_clause unit
erlps__typedef_to_fcode__4 args =
  EXC.badarity (ErlangFun 4 erlps__typedef_to_fcode__4) args

erlps__compute_state_layout__3 :: ErlangFun
erlps__compute_state_layout__3 [env_1@(ErlangMap map_0),
                                (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangEmptyList)))))),
                                type_7]
  | (DM.Just (ErlangTuple [(ErlangAtom "main_contract"), _])) <-
      (Map.lookup (ErlangAtom "context") map_0)
  , (ErlangInt num_2) == (toErl 115)
  , (ErlangInt num_3) == (toErl 116)
  , (ErlangInt num_4) == (toErl 97)
  , (ErlangInt num_5) == (toErl 116)
  , (ErlangInt num_6) == (toErl 101) =
  let   
    nolayout_10 =
      erlps__get_option__2 [ErlangAtom "no_flatten_state", env_1]
  in let
    case_11 =
      BIF.erlang__apply__2
        [type_7, ErlangCons ErlangEmptyList ErlangEmptyList]
  in let
    layout_21 =
      case case_11 of
        _ | (==) (ErlangAtom "true") nolayout_10 ->
          let tup_el_15 = toErl 1
          in ErlangTuple [ErlangAtom "reg", tup_el_15]
        t_16 ->
          let    arg_17 = toErl 1
          in let
            matchExpr_20 = erlps__compute_state_layout__2 [arg_17, t_16]
          in
            case matchExpr_20 of
              (ErlangTuple [_, l_19]) -> l_19
              _ -> EXC.badmatch matchExpr_20
  in let
    mapExt_25 =
      ErlangMap (Map.singleton (ErlangAtom "state_layout") layout_21)
  in BIF.maps__merge__2 [env_1, mapExt_25]
erlps__compute_state_layout__3 [env_0, _, _] = env_0
erlps__compute_state_layout__3 [arg_1, arg_2, arg_3] =
  EXC.function_clause unit
erlps__compute_state_layout__3 args =
  EXC.badarity (ErlangFun 3 erlps__compute_state_layout__3) args

erlps__compute_state_layout__2 :: ErlangFun
erlps__compute_state_layout__2 [r_0,
                                (ErlangTuple [(ErlangAtom "tuple"),
                                              (ErlangCons t_1 (ErlangEmptyList))])]
  =
  erlps__compute_state_layout__2 [r_0, t_1]
erlps__compute_state_layout__2 [r_0,
                                (ErlangTuple [(ErlangAtom "tuple"), ts_1])]
  =
  let matchExpr_6 = erlps__compute_state_layout__2 [r_0, ts_1]
  in
    case matchExpr_6 of
      (ErlangTuple [r1_4, ls_5]) ->
        let tup_el_8 = ErlangTuple [ErlangAtom "tuple", ls_5]
        in ErlangTuple [r1_4, tup_el_8]
      _ -> EXC.badmatch matchExpr_6
erlps__compute_state_layout__2 [r_0, (ErlangEmptyList)] =
  ErlangTuple [r_0, ErlangEmptyList]
erlps__compute_state_layout__2 [r_0, (ErlangCons h_1 t_2)] =
  let matchExpr_7 = erlps__compute_state_layout__2 [r_0, h_1]
  in
    case matchExpr_7 of
      (ErlangTuple [r1_5, h1_6]) ->
        let matchExpr_12 = erlps__compute_state_layout__2 [r1_5, t_2]
        in
          case matchExpr_12 of
            (ErlangTuple [r2_10, t1_11]) ->
              ErlangTuple [r2_10, ErlangCons h1_6 t1_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__compute_state_layout__2 [r_0, _] =
  let    rop_3 = toErl 1
  in let tup_el_1 = BIF.erlang__op_plus [r_0, rop_3]
  in let tup_el_4 = ErlangTuple [ErlangAtom "reg", r_0]
  in ErlangTuple [tup_el_1, tup_el_4]
erlps__compute_state_layout__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__compute_state_layout__2 args =
  EXC.badarity (ErlangFun 2 erlps__compute_state_layout__2) args

erlps__check_state_and_event_types__3 :: ErlangFun
erlps__check_state_and_event_types__3 [(ErlangMap map_0), id_1,
                                       (ErlangCons _ _)]
  | (DM.Just (ErlangTuple [(ErlangAtom "main_contract"), _])) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  case id_1 of
    (ErlangTuple [(ErlangAtom "id"), _,
                  (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangCons (ErlangInt num_7) (ErlangEmptyList))))))]) | (ErlangInt
                                                                                                                                                                                                      num_3) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        115)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_4) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        116)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_5) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        97)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_6) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        116)
                                                                                                                                                                                                 , (ErlangInt
                                                                                                                                                                                                      num_7) ==
                                                                                                                                                                                                     (toErl
                                                                                                                                                                                                        101) ->
      let arg_8 = ErlangTuple [ErlangAtom "parameterized_state", id_1]
      in erlps__fcode_error__1 [arg_8]
    (ErlangTuple [(ErlangAtom "id"), _,
                  (ErlangCons (ErlangInt num_11) (ErlangCons (ErlangInt num_12) (ErlangCons (ErlangInt num_13) (ErlangCons (ErlangInt num_14) (ErlangCons (ErlangInt num_15) (ErlangEmptyList))))))]) | (ErlangInt
                                                                                                                                                                                                           num_11) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             101)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_12) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             118)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_13) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             101)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_14) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             110)
                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                           num_15) ==
                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                             116) ->
      let arg_16 = ErlangTuple [ErlangAtom "parameterized_event", id_1]
      in erlps__fcode_error__1 [arg_16]
    _ -> ErlangAtom "ok"
erlps__check_state_and_event_types__3 [_, _, _] = ErlangAtom "ok"
erlps__check_state_and_event_types__3 [arg_0, arg_1, arg_2] =
  EXC.function_clause unit
erlps__check_state_and_event_types__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_state_and_event_types__3)
    args

erlps__type_to_fcode__2 :: ErlangFun
erlps__type_to_fcode__2 [env_0, type_1] =
  let arg_3 = ErlangMap Map.empty
  in erlps__type_to_fcode__3 [env_0, arg_3, type_1]
erlps__type_to_fcode__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__type_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__type_to_fcode__2) args

erlps__type_to_fcode__3 :: ErlangFun
erlps__type_to_fcode__3 [_env_0, _sub_1,
                         (ErlangTuple [(ErlangAtom "con"), _, _])]
  =
  ErlangAtom "contract"
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "app_t"), _,
                                       t_3@(ErlangTuple [id_2, _, _]),
                                       types_4])]
  | (weakEq id_2 (ErlangAtom "id")) ||
      (weakEq id_2 (ErlangAtom "qid")) =
  let
    arg_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__type_to_fcode__3 [env_0, sub_1, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        types_4
  in erlps__lookup_type__3 [env_0, t_3, arg_7]
erlps__type_to_fcode__3 [env_0, _sub_1,
                         t_3@(ErlangTuple [id_2, _, _])]
  | (weakEq id_2 (ErlangAtom "id")) ||
      (weakEq id_2 (ErlangAtom "qid")) =
  erlps__lookup_type__3 [env_0, t_3, ErlangEmptyList]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "tuple_t"), _, types_2])]
  =
  let
    tup_el_4 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__type_to_fcode__3 [env_0, sub_1, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        types_2
  in ErlangTuple [ErlangAtom "tuple", tup_el_4]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "record_t"), fields_2])]
  =
  let   
    fieldtype_6 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "field_t"), _, _, ty_5])] =
             ty_5
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    tup_el_12 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [fieldtype_6, fields_2]
  in let
    arg_9 =
      ErlangTuple [ErlangAtom "tuple_t", ErlangEmptyList, tup_el_12]
  in erlps__type_to_fcode__3 [env_0, sub_1, arg_9]
erlps__type_to_fcode__3 [_env_0, _sub_1,
                         (ErlangTuple [(ErlangAtom "bytes_t"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "bytes", n_2]
erlps__type_to_fcode__3 [_env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "tvar"), _, x_2])]
  =
  let arg_5 = ErlangTuple [ErlangAtom "tvar", x_2]
  in
    BIF.do_remote_fun_call "Maps" "erlps__get__3" [x_2, sub_1, arg_5]
erlps__type_to_fcode__3 [env_0, sub_1,
                         (ErlangTuple [(ErlangAtom "fun_t"), _, named_2, args_3,
                                       res_4])]
  =
  let   
    fnamed_12 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [(ErlangAtom "named_arg_t"), _, _, arg_6, _]) ->
               let lcRet_8 = erlps__type_to_fcode__3 [env_0, sub_1, arg_6]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        named_2
  in let
    fargs_20 =
      flmap
        (\ lc_15 ->
           let lcRet_16 = erlps__type_to_fcode__3 [env_0, sub_1, lc_15]
           in ErlangCons lcRet_16 ErlangEmptyList)
        args_3
  in let tup_el_22 = BIF.erlang__op_append [fnamed_12, fargs_20]
  in let tup_el_25 = erlps__type_to_fcode__3 [env_0, sub_1, res_4]
  in ErlangTuple [ErlangAtom "function", tup_el_22, tup_el_25]
erlps__type_to_fcode__3 [_env_0, _sub_1, type_2] =
  let arg_3 = ErlangTuple [ErlangAtom "todo", type_2]
  in BIF.erlang__error__1 [arg_3]
erlps__type_to_fcode__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__type_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__type_to_fcode__3) args

erlps__args_to_fcode__2 :: ErlangFun
erlps__args_to_fcode__2 [env_0, args_1] =
  flmap
    (\ lc_5 ->
       case lc_5 of
         (ErlangTuple [(ErlangAtom "typed"), _, arg_3, type_4]) ->
           let
             lcRet_6 =
               case arg_3 of
                 (ErlangTuple [(ErlangAtom "id"), _, name_8]) ->
                   let tup_el_10 = erlps__type_to_fcode__2 [env_0, type_4]
                   in ErlangTuple [name_8, tup_el_10]
                 _ ->
                   let arg_13 = ErlangTuple [ErlangAtom "bad_arg", arg_3]
                   in erlps__internal_error__1 [arg_13]
           in ErlangCons lcRet_6 ErlangEmptyList
         _ -> ErlangEmptyList)
    args_1
erlps__args_to_fcode__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__args_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__args_to_fcode__2) args

erlps__make_let__2 :: ErlangFun
erlps__make_let__2 [expr_0, body_1] =
  case expr_0 of
    (ErlangTuple [(ErlangAtom "var"), _]) ->
      BIF.erlang__apply__2 [body_1, ErlangCons expr_0 ErlangEmptyList]
    (ErlangTuple [(ErlangAtom "lit"),
                  (ErlangTuple [(ErlangAtom "int"), _])]) ->
      BIF.erlang__apply__2 [body_1, ErlangCons expr_0 ErlangEmptyList]
    (ErlangTuple [(ErlangAtom "lit"),
                  (ErlangTuple [(ErlangAtom "bool"), _])]) ->
      BIF.erlang__apply__2 [body_1, ErlangCons expr_0 ErlangEmptyList]
    _ ->
      let    x_9 = erlps__fresh_name__0 []
      in let arg_14 = ErlangTuple [ErlangAtom "var", x_9]
      in let
        tup_el_13 =
          BIF.erlang__apply__2 [body_1, ErlangCons arg_14 ErlangEmptyList]
      in ErlangTuple [ErlangAtom "let", x_9, expr_0, tup_el_13]
erlps__make_let__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__make_let__2 args =
  EXC.badarity (ErlangFun 2 erlps__make_let__2) args

erlps__let_bind__3 :: ErlangFun
erlps__let_bind__3 [x_0, (ErlangTuple [(ErlangAtom "var"), y_1]),
                    body_2]
  =
  let head_4 = ErlangTuple [x_0, y_1]
  in erlps__rename__2 [ErlangCons head_4 ErlangEmptyList, body_2]
erlps__let_bind__3 [x_0, expr_1, body_2] =
  ErlangTuple [ErlangAtom "let", x_0, expr_1, body_2]
erlps__let_bind__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__let_bind__3 args =
  EXC.badarity (ErlangFun 3 erlps__let_bind__3) args

erlps__let_bind__2 :: ErlangFun
erlps__let_bind__2 [binds_0, body_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [(ErlangTuple [x_6, e_7]), rest_8] =
             erlps__let_bind__3 [x_6, e_7, rest_8]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_2, body_1, binds_0]
erlps__let_bind__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__let_bind__2 args =
  EXC.badarity (ErlangFun 2 erlps__let_bind__2) args

erlps__expr_to_fcode__2 :: ErlangFun
erlps__expr_to_fcode__2 [env_0,
                         (ErlangTuple [(ErlangAtom "typed"), _, expr_1,
                                       type_2])]
  =
  erlps__expr_to_fcode__3 [env_0, type_2, expr_1]
erlps__expr_to_fcode__2 [env_0, expr_1] =
  erlps__expr_to_fcode__3 [env_0, ErlangAtom "no_type", expr_1]
erlps__expr_to_fcode__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__expr_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__expr_to_fcode__2) args

erlps__expr_to_fcode__3 :: ErlangFun
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "int"), _, n_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "int", n_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "char"), _, n_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "int", n_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "bool"), _, b_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "bool", b_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "string"), _, s_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "string", s_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "account_pubkey"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "account_pubkey", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "contract_pubkey"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "contract_pubkey", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "oracle_pubkey"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "oracle_pubkey", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "oracle_query_id"), _, k_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "oracle_query_id", k_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "bytes"), _, b_2])]
  =
  let tup_el_4 = ErlangTuple [ErlangAtom "bytes", b_2]
  in ErlangTuple [ErlangAtom "lit", tup_el_4]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "id"), _, x_2])]
  =
  erlps__resolve_var__2 [env_0, ErlangCons x_2 ErlangEmptyList]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "qid"), ann_2, x_3])]
  =
  let case_4 = erlps__resolve_var__2 [env_0, x_3]
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "builtin_u"), b_7, ar_8]) | (((((((==)
                                                                    b_7
                                                                    (ErlangAtom
                                                                       "oracle_query")) ||
                                                                   ((==) b_7
                                                                      (ErlangAtom
                                                                         "oracle_get_question"))) ||
                                                                  ((==) b_7
                                                                     (ErlangAtom
                                                                        "oracle_get_answer"))) ||
                                                                 ((==) b_7
                                                                    (ErlangAtom
                                                                       "oracle_respond"))) ||
                                                                ((==) b_7
                                                                   (ErlangAtom
                                                                      "oracle_register"))) ||
                                                               ((==) b_7
                                                                  (ErlangAtom
                                                                     "oracle_check"))) ||
                                                              ((==) b_7
                                                                 (ErlangAtom
                                                                    "oracle_check_query")) ->
        let    otype_11 = erlps__get_oracle_type__2 [b_7, type_1]
        in let matchExpr_16 = erlps__type_to_fcode__2 [env_0, otype_11]
        in
          case matchExpr_16 of
            (ErlangTuple [(ErlangAtom "oracle"), qtype_14, rtype_15]) ->
              let   
                _ =
                  erlps__validate_oracle_type__4
                    [ann_2, otype_11, qtype_14, rtype_15]
              in let tup_el_23 = ErlangTuple [ErlangAtom "typerep", qtype_14]
              in let head_21 = ErlangTuple [ErlangAtom "lit", tup_el_23]
              in let tup_el_29 = ErlangTuple [ErlangAtom "typerep", rtype_15]
              in let head_27 = ErlangTuple [ErlangAtom "lit", tup_el_29]
              in
                ErlangTuple
                  [ErlangAtom "builtin_u", b_7, ar_8,
                   ErlangCons head_21 (ErlangCons head_27 ErlangEmptyList)]
            _ -> EXC.badmatch matchExpr_16
      (ErlangTuple [(ErlangAtom "builtin_u"),
                    b_38@(ErlangAtom "aens_resolve"), ar_39]) ->
        case type_1 of
          (ErlangTuple [(ErlangAtom "fun_t"), _, _, _, restype_40]) ->
            let    aenstype_44 = erlps__type_to_fcode__2 [env_0, restype_40]
            in let
              _ =
                erlps__validate_aens_resolve_type__3
                  [ann_2, restype_40, aenstype_44]
            in let
              tup_el_50 = ErlangTuple [ErlangAtom "typerep", aenstype_44]
            in let head_48 = ErlangTuple [ErlangAtom "lit", tup_el_50]
            in
              ErlangTuple
                [ErlangAtom "builtin_u", b_38, ar_39,
                 ErlangCons head_48 ErlangEmptyList]
          _ -> EXC.badmatch type_1
      (ErlangTuple [(ErlangAtom "builtin_u"),
                    b_59@(ErlangAtom "bytes_split"), ar_60]) ->
        case type_1 of
          (ErlangTuple [(ErlangAtom "fun_t"), _, _, _,
                        (ErlangTuple [(ErlangAtom "tuple_t"), _,
                                      (ErlangCons (ErlangTuple [(ErlangAtom "bytes_t"),
                                                                _,
                                                                n_61]) (ErlangCons _ (ErlangEmptyList)))])]) ->
            let    tup_el_69 = ErlangTuple [ErlangAtom "int", n_61]
            in let head_67 = ErlangTuple [ErlangAtom "lit", tup_el_69]
            in
              ErlangTuple
                [ErlangAtom "builtin_u", b_59, ar_60,
                 ErlangCons head_67 ErlangEmptyList]
          _ -> EXC.badmatch type_1
      other_73 -> other_73
erlps__expr_to_fcode__3 [env_0, type_1,
                         con_3@(ErlangTuple [c_2, _, _])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let   
    tup_el_9 =
      ErlangTuple [ErlangAtom "typed", ErlangEmptyList, con_3, type_1]
  in let
    arg_6 =
      ErlangTuple
        [ErlangAtom "app", ErlangEmptyList, tup_el_9, ErlangEmptyList]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_6]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _,
                                       (ErlangTuple [(ErlangAtom "typed"), _,
                                                     con_3@(ErlangTuple [c_2, _,
                                                                         _]),
                                                     _]),
                                       args_4])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let matchExpr_9 = erlps__lookup_con__2 [env_0, con_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangAtom "con_tag"), i_7, arities_8]) ->
        let    rop_12 = toErl 1
        in let arg_10 = BIF.erlang__op_plus [i_7, rop_12]
        in let
          arity_14 =
            BIF.do_remote_fun_call "Lists" "erlps__nth__2"
              [arg_10, arities_8]
        in let lop_16 = BIF.erlang__length__1 [args_4]
        in let case_15 = BIF.erlang__op_eq [lop_16, arity_14]
        in
          case case_15 of
            (ErlangAtom "true") ->
              let
                tup_el_22 =
                  flmap
                    (\ lc_25 ->
                       let lcRet_26 = erlps__expr_to_fcode__2 [env_0, lc_25]
                       in ErlangCons lcRet_26 ErlangEmptyList)
                    args_4
              in ErlangTuple [ErlangAtom "con", arities_8, i_7, tup_el_22]
            (ErlangAtom "false") ->
              let    tup_el_32 = BIF.erlang__length__1 [args_4]
              in let
                arg_29 =
                  ErlangTuple
                    [ErlangAtom "constructor_arity_mismatch", con_3, tup_el_32,
                     arity_14]
              in erlps__internal_error__1 [arg_29]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_9
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "tuple"), _, es_2])]
  =
  let
    arg_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__expr_to_fcode__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        es_2
  in erlps__make_tuple__1 [arg_3]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "proj"), _ann_2,
                                       rec_4@(ErlangTuple [(ErlangAtom "typed"),
                                                           _, _, rectype_3]),
                                       (ErlangTuple [(ErlangAtom "id"), _,
                                                     x_5])])]
  =
  case rectype_3 of
    (ErlangTuple [(ErlangAtom "con"), _, _]) | (ErlangAtom "true") ==
                                                 (falsifyErrors
                                                    (\ _ ->
                                                       let
                                                         rop_8 = toErl "address"
                                                       in
                                                         BIF.erlang__op_eq
                                                           [x_5, rop_8])) ->
      let head_12 = erlps__expr_to_fcode__2 [env_0, rec_4]
      in
        ErlangTuple
          [ErlangAtom "op", ErlangAtom "contract_to_address",
           ErlangCons head_12 ErlangEmptyList]
    (ErlangTuple [(ErlangAtom "con"), _, _]) ->
      case type_1 of
        (ErlangTuple [(ErlangAtom "fun_t"), _, _, args_16, ret_17]) ->
          let   
            fargs_25 =
              flmap
                (\ lc_21 ->
                   let lcRet_22 = erlps__type_to_fcode__2 [env_0, lc_21]
                   in ErlangCons lcRet_22 ErlangEmptyList)
                args_16
          in let tup_el_28 = erlps__type_to_fcode__2 [env_0, ret_17]
          in let tup_el_31 = erlps__expr_to_fcode__2 [env_0, rec_4]
          in let tup_el_36 = BIF.erlang__list_to_binary__1 [x_5]
          in let
            tup_el_34 = ErlangTuple [ErlangAtom "entrypoint", tup_el_36]
          in
            ErlangTuple
              [ErlangAtom "remote_u", fargs_25, tup_el_28, tup_el_31,
               tup_el_34]
        _ -> EXC.badmatch type_1
    (ErlangTuple [(ErlangAtom "record_t"),
                  (ErlangCons _ (ErlangEmptyList))]) ->
      erlps__expr_to_fcode__2 [env_0, rec_4]
    (ErlangTuple [(ErlangAtom "record_t"), _]) ->
      let    tup_el_41 = erlps__expr_to_fcode__2 [env_0, rec_4]
      in let tup_el_44 = erlps__field_index__2 [rec_4, x_5]
      in ErlangTuple [ErlangAtom "proj", tup_el_41, tup_el_44]
    something_else -> EXC.case_clause something_else
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"),
                                       (ErlangCons fieldt_1 (ErlangEmptyList))]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2,
                                       fields_3@(ErlangCons _ (ErlangEmptyList))])]
  =
  let matchExpr_7 = erlps__field_value__2 [fieldt_1, fields_3]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "set"), e_6]) ->
        erlps__expr_to_fcode__2 [env_0, e_6]
      _ -> EXC.badmatch matchExpr_7
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fieldtypes_1]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2,
                                       fields_3])]
  =
  let   
    fval_13 =
      ErlangFun 1
        (let
           lambda_4 [f_6] =
             let matchExpr_10 = erlps__field_value__2 [f_6, fields_3]
             in
               case matchExpr_10 of
                 (ErlangTuple [(ErlangAtom "set"), e_9]) ->
                   erlps__expr_to_fcode__2 [env_0, e_9]
                 _ -> EXC.badmatch matchExpr_10
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    arg_14 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [fval_13, fieldtypes_1]
  in erlps__make_tuple__1 [arg_14]
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"),
                                       (ErlangCons fieldt_1 (ErlangEmptyList))]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2, rec_3,
                                       fields_4])]
  =
  let case_5 = erlps__field_value__2 [fieldt_1, fields_4]
  in
    case case_5 of
      (ErlangAtom "false") -> erlps__expr_to_fcode__2 [env_0, rec_3]
      (ErlangTuple [(ErlangAtom "set"), e_10]) ->
        erlps__expr_to_fcode__2 [env_0, e_10]
      (ErlangTuple [(ErlangAtom "upd"), z_13, e_14]) ->
        let    tup_el_17 = erlps__expr_to_fcode__2 [env_0, rec_3]
        in let arg_21 = erlps__bind_var__2 [env_0, z_13]
        in let tup_el_20 = erlps__expr_to_fcode__2 [arg_21, e_14]
        in ErlangTuple [ErlangAtom "let", z_13, tup_el_17, tup_el_20]
      something_else -> EXC.case_clause something_else
erlps__expr_to_fcode__3 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fieldtypes_1]),
                         (ErlangTuple [(ErlangAtom "record"), _ann_2, rec_3,
                                       fields_4])]
  =
  let    x_5 = erlps__fresh_name__0 []
  in let
    proj_16 =
      ErlangFun 1
        (let
           lambda_6 [i_8] =
             let    tup_el_10 = ErlangTuple [ErlangAtom "var", x_5]
             in let rop_15 = toErl 1
             in let tup_el_13 = BIF.erlang__op_minus [i_8, rop_15]
             in ErlangTuple [ErlangAtom "proj", tup_el_10, tup_el_13]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    comp_38 =
      ErlangFun 1
        (let
           lambda_17 [(ErlangTuple [i_19, (ErlangAtom "false")])] =
             BIF.erlang__apply__2 [proj_16, ErlangCons i_19 ErlangEmptyList]
           lambda_17 [(ErlangTuple [_,
                                    (ErlangTuple [(ErlangAtom "set"), e_22])])]
             =
             erlps__expr_to_fcode__2 [env_0, e_22]
           lambda_17 [(ErlangTuple [i_25,
                                    (ErlangTuple [(ErlangAtom "upd"), z_26,
                                                  e_27])])]
             =
             let   
               tup_el_30 =
                 BIF.erlang__apply__2 [proj_16, ErlangCons i_25 ErlangEmptyList]
             in let arg_34 = erlps__bind_var__2 [env_0, z_26]
             in let tup_el_33 = erlps__expr_to_fcode__2 [arg_34, e_27]
             in ErlangTuple [ErlangAtom "let", z_26, tup_el_30, tup_el_33]
           lambda_17 [arg_18] = EXC.function_clause unit
           lambda_17 args = EXC.badarity (ErlangFun 1 lambda_17) args
         in lambda_17)
  in let
    set_74 =
      ErlangFun 2
        (let
           lambda_39 [(ErlangTuple [_, (ErlangAtom "false")]), r_42] = r_42
           lambda_39 [(ErlangTuple [i_43,
                                    (ErlangTuple [(ErlangAtom "set"), e_44])]),
                      r_45]
             =
             let    rop_50 = toErl 1
             in let tup_el_48 = BIF.erlang__op_minus [i_43, rop_50]
             in let tup_el_51 = erlps__expr_to_fcode__2 [env_0, e_44]
             in
               ErlangTuple [ErlangAtom "set_proj", r_45, tup_el_48, tup_el_51]
           lambda_39 [(ErlangTuple [i_54,
                                    (ErlangTuple [(ErlangAtom "upd"), z_55,
                                                  e_56])]),
                      r_57]
             =
             let    rop_62 = toErl 1
             in let tup_el_60 = BIF.erlang__op_minus [i_54, rop_62]
             in let
               tup_el_66 =
                 BIF.erlang__apply__2 [proj_16, ErlangCons i_54 ErlangEmptyList]
             in let arg_70 = erlps__bind_var__2 [env_0, z_55]
             in let tup_el_69 = erlps__expr_to_fcode__2 [arg_70, e_56]
             in let
               tup_el_63 =
                 ErlangTuple [ErlangAtom "let", z_55, tup_el_66, tup_el_69]
             in
               ErlangTuple [ErlangAtom "set_proj", r_57, tup_el_60, tup_el_63]
           lambda_39 [arg_40, arg_41] = EXC.function_clause unit
           lambda_39 args = EXC.badarity (ErlangFun 2 lambda_39) args
         in lambda_39)
  in let lop_75 = BIF.erlang__length__1 [fields_4]
  in let rop_77 = BIF.erlang__length__1 [fieldtypes_1]
  in let expand_79 = BIF.erlang__op_eq [lop_75, rop_77]
  in let lcSrc_80 = erlps__indexed__1 [fieldtypes_1]
  in let
    updates_90 =
      flmap
        (\ lc_84 ->
           case lc_84 of
             (ErlangTuple [i_82, ft_83]) ->
               let    tup_el_87 = erlps__field_value__2 [ft_83, fields_4]
               in let lcRet_85 = ErlangTuple [i_82, tup_el_87]
               in ErlangCons lcRet_85 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_80
  in let
    body_101 =
      case expand_79 of
        (ErlangAtom "true") ->
          let
            tup_el_93 =
              BIF.do_remote_fun_call "Lists" "erlps__map__2"
                [comp_38, updates_90]
          in ErlangTuple [ErlangAtom "tuple", tup_el_93]
        (ErlangAtom "false") ->
          let arg_97 = ErlangTuple [ErlangAtom "var", x_5]
          in
            BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
              [set_74, arg_97, updates_90]
        something_else -> EXC.case_clause something_else
  in let tup_el_104 = erlps__expr_to_fcode__2 [env_0, rec_3]
  in ErlangTuple [ErlangAtom "let", x_5, tup_el_104, body_101]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "list"), _, es_2])]
  =
  let
    arg_3 =
      ErlangFun 2
        (let
           lambda_4 [e_7, l_8] =
             let head_12 = erlps__expr_to_fcode__2 [env_0, e_7]
             in
               ErlangTuple
                 [ErlangAtom "op", ErlangAtom "::",
                  ErlangCons head_12 (ErlangCons l_8 ErlangEmptyList)]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_3, ErlangAtom "nil", es_2]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _,
                                       (ErlangTuple [(ErlangAtom ".."), _]),
                                       (ErlangCons a_2 (ErlangCons b_3 (ErlangEmptyList)))])]
  =
  let    head_6 = toErl "ListInternal"
  in let head_8 = toErl "from_to"
  in let
    matchExpr_11 =
      erlps__resolve_fun__2
        [env_0, ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList)]
  in
    case matchExpr_11 of
      (ErlangTuple [(ErlangAtom "def_u"), fromto_10, _]) ->
        let    head_15 = erlps__expr_to_fcode__2 [env_0, a_2]
        in let head_19 = erlps__expr_to_fcode__2 [env_0, b_3]
        in
          ErlangTuple
            [ErlangAtom "def", fromto_10,
             ErlangCons head_15 (ErlangCons head_19 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_11
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), _, yield_2,
                                       (ErlangEmptyList)])]
  =
  let head_6 = erlps__expr_to_fcode__2 [env_0, yield_2]
  in
    ErlangTuple
      [ErlangAtom "op", ErlangAtom "::",
       ErlangCons head_6
         (ErlangCons (ErlangAtom "nil") ErlangEmptyList)]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_bind"),
                                                                 pat_5@(ErlangTuple [(ErlangAtom "typed"),
                                                                                     _,
                                                                                     _,
                                                                                     pattype_4]),
                                                                 bindexpr_6]) rest_7)])]
  =
  let    arg_8 = erlps__fresh_name__0 []
  in let env1_11 = erlps__bind_var__2 [env_0, arg_8]
  in let tup_el_24 = ErlangTuple [ErlangAtom "id", as_2, arg_8]
  in let
    tup_el_21 =
      ErlangTuple [ErlangAtom "typed", as_2, tup_el_24, pattype_4]
  in let
    tup_el_34 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_7]
  in let
    head_30 = ErlangTuple [ErlangAtom "case", as_2, pat_5, tup_el_34]
  in let tup_el_46 = toErl "_"
  in let tup_el_43 = ErlangTuple [ErlangAtom "id", as_2, tup_el_46]
  in let
    tup_el_47 =
      ErlangTuple [ErlangAtom "list", as_2, ErlangEmptyList]
  in let
    head_40 =
      ErlangTuple [ErlangAtom "case", as_2, tup_el_43, tup_el_47]
  in let
    arg_18 =
      ErlangTuple
        [ErlangAtom "switch", as_2, tup_el_21,
         ErlangCons head_30 (ErlangCons head_40 ErlangEmptyList)]
  in let tup_el_16 = erlps__expr_to_fcode__2 [env1_11, arg_18]
  in let
    bind_52 =
      ErlangTuple
        [ErlangAtom "lam", ErlangCons arg_8 ErlangEmptyList, tup_el_16]
  in let head_55 = toErl "ListInternal"
  in let head_57 = toErl "flat_map"
  in let
    matchExpr_60 =
      erlps__resolve_fun__2
        [env_0, ErlangCons head_55 (ErlangCons head_57 ErlangEmptyList)]
  in
    case matchExpr_60 of
      (ErlangTuple [(ErlangAtom "def_u"), flatmap_59, _]) ->
        let head_66 = erlps__expr_to_fcode__2 [env_0, bindexpr_6]
        in
          ErlangTuple
            [ErlangAtom "def", flatmap_59,
             ErlangCons bind_52 (ErlangCons head_66 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_60
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_if"),
                                                                 _,
                                                                 cond_4]) rest_5)])]
  =
  let    arg_6 = erlps__expr_to_fcode__2 [env_0, cond_4]
  in let
    arg_12 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_5]
  in let arg_9 = erlps__expr_to_fcode__3 [env_0, type_1, arg_12]
  in erlps__make_if__3 [arg_6, arg_9, ErlangAtom "nil"]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons lv_4@(ErlangTuple [(ErlangAtom "letval"),
                                                                      _, _,
                                                                      _]) rest_5)])]
  =
  let   
    head_14 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_5]
  in let
    arg_8 =
      ErlangTuple
        [ErlangAtom "block", as_2,
         ErlangCons lv_4 (ErlangCons head_14 ErlangEmptyList)]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_8]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "list_comp"), as_2, yield_3,
                                       (ErlangCons lf_4@(ErlangTuple [(ErlangAtom "letfun"),
                                                                      _, _, _,
                                                                      _,
                                                                      _]) rest_5)])]
  =
  let   
    head_14 =
      ErlangTuple [ErlangAtom "list_comp", as_2, yield_3, rest_5]
  in let
    arg_8 =
      ErlangTuple
        [ErlangAtom "block", as_2,
         ErlangCons lf_4 (ErlangCons head_14 ErlangEmptyList)]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_8]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "if"), _, cond_2, then_3,
                                       else_4])]
  =
  let    arg_5 = erlps__expr_to_fcode__2 [env_0, cond_2]
  in let arg_8 = erlps__expr_to_fcode__2 [env_0, then_3]
  in let arg_11 = erlps__expr_to_fcode__2 [env_0, else_4]
  in erlps__make_if__3 [arg_5, arg_8, arg_11]
erlps__expr_to_fcode__3 [env_0, _,
                         (ErlangTuple [(ErlangAtom "switch"), _,
                                       expr_3@(ErlangTuple [(ErlangAtom "typed"),
                                                            _, e_1, type_2]),
                                       alts_4])]
  =
  let
    switch_16 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let    arg_11 = erlps__type_to_fcode__2 [env_0, type_2]
             in let
               tup_el_9 = erlps__alts_to_fcode__4 [env_0, arg_11, x_7, alts_4]
             in ErlangTuple [ErlangAtom "switch", tup_el_9]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in
    case e_1 of
      (ErlangTuple [(ErlangAtom "id"), _, x_18]) ->
        BIF.erlang__apply__2 [switch_16, ErlangCons x_18 ErlangEmptyList]
      _ ->
        let    x_21 = erlps__fresh_name__0 []
        in let tup_el_24 = erlps__expr_to_fcode__2 [env_0, expr_3]
        in let
          tup_el_27 =
            BIF.erlang__apply__2 [switch_16, ErlangCons x_21 ErlangEmptyList]
        in ErlangTuple [ErlangAtom "let", x_21, tup_el_24, tup_el_27]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "block"), _, stmts_2])]
  =
  erlps__stmts_to_fcode__2 [env_0, stmts_2]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         expr_3@(ErlangTuple [(ErlangAtom "app"), _,
                                              (ErlangTuple [op_2, _]),
                                              (ErlangCons _ (ErlangCons _ (ErlangEmptyList)))])]
  | (weakEq op_2 (ErlangAtom "&&")) ||
      (weakEq op_2 (ErlangAtom "||")) =
  let tree_6 = erlps__expr_to_decision_tree__2 [env_0, expr_3]
  in erlps__decision_tree_to_fcode__1 [tree_6]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _ann_2,
                                       (ErlangTuple [op_3, _]),
                                       (ErlangCons a_4 (ErlangCons b_5 (ErlangEmptyList)))])]
  | isEAtom op_3 =
  let    head_9 = erlps__expr_to_fcode__2 [env_0, a_4]
  in let head_13 = erlps__expr_to_fcode__2 [env_0, b_5]
  in
    ErlangTuple
      [ErlangAtom "op", op_3,
       ErlangCons head_9 (ErlangCons head_13 ErlangEmptyList)]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _ann_2,
                                       (ErlangTuple [op_3, _]),
                                       (ErlangCons a_4 (ErlangEmptyList))])]
  | isEAtom op_3 =
  case op_3 of
    (ErlangAtom "-") ->
      let    tup_el_13 = toErl 0
      in let tup_el_11 = ErlangTuple [ErlangAtom "int", tup_el_13]
      in let head_9 = ErlangTuple [ErlangAtom "lit", tup_el_11]
      in let head_15 = erlps__expr_to_fcode__2 [env_0, a_4]
      in
        ErlangTuple
          [ErlangAtom "op", ErlangAtom "-",
           ErlangCons head_9 (ErlangCons head_15 ErlangEmptyList)]
    (ErlangAtom "!") ->
      let head_22 = erlps__expr_to_fcode__2 [env_0, a_4]
      in
        ErlangTuple
          [ErlangAtom "op", ErlangAtom "!",
           ErlangCons head_22 ErlangEmptyList]
    something_else -> EXC.case_clause something_else
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "app"), _,
                                       fun_3@(ErlangTuple [(ErlangAtom "typed"),
                                                           _, _,
                                                           (ErlangTuple [(ErlangAtom "fun_t"),
                                                                         _,
                                                                         namedargst_2,
                                                                         _,
                                                                         _])]),
                                       args_4])]
  =
  let    args1_7 = erlps__get_named_args__2 [namedargst_2, args_4]
  in let
    fargs_14 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__expr_to_fcode__2 [env_0, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        args1_7
  in let case_15 = erlps__expr_to_fcode__2 [env_0, fun_3]
  in
    case case_15 of
      (ErlangTuple [(ErlangAtom "builtin_u"), b_18, _ar_19,
                    typeargs_20]) ->
        let    arg_21 = erlps__state_layout__1 [env_0]
        in let arg_24 = BIF.erlang__op_append [fargs_14, typeargs_20]
        in erlps__builtin_to_fcode__3 [arg_21, b_18, arg_24]
      (ErlangTuple [(ErlangAtom "builtin_u"), b_27, _ar_28]) ->
        let arg_29 = erlps__state_layout__1 [env_0]
        in erlps__builtin_to_fcode__3 [arg_29, b_27, fargs_14]
      (ErlangTuple [(ErlangAtom "def_u"), f_33, _ar_34]) ->
        ErlangTuple [ErlangAtom "def", f_33, fargs_14]
      (ErlangTuple [(ErlangAtom "remote_u"), argst_38, rett_39, ct_40,
                    rfun_41]) ->
        ErlangTuple
          [ErlangAtom "remote", argst_38, rett_39, ct_40, rfun_41,
           fargs_14]
      ffun_48 ->
        let
          call_67 =
            ErlangFun 1
              (let
                 lambda_49 [x_51] =
                   let    tup_el_55 = ErlangTuple [ErlangAtom "var", x_51]
                   in let tup_el_58 = toErl 0
                   in let
                     tup_el_53 =
                       ErlangTuple [ErlangAtom "proj", tup_el_55, tup_el_58]
                   in let tup_el_62 = ErlangTuple [ErlangAtom "var", x_51]
                   in let tup_el_65 = toErl 1
                   in let
                     head_60 =
                       ErlangTuple [ErlangAtom "proj", tup_el_62, tup_el_65]
                   in
                     ErlangTuple
                       [ErlangAtom "funcall", tup_el_53,
                        ErlangCons head_60 fargs_14]
                 lambda_49 [arg_50] = EXC.function_clause unit
                 lambda_49 args = EXC.badarity (ErlangFun 1 lambda_49) args
               in lambda_49)
        in
          case ffun_48 of
            (ErlangTuple [(ErlangAtom "var"), x_69]) ->
              BIF.erlang__apply__2 [call_67, ErlangCons x_69 ErlangEmptyList]
            _ ->
              let    x_72 = erlps__fresh_name__0 []
              in let
                tup_el_76 =
                  BIF.erlang__apply__2
                    [call_67, ErlangCons x_72 ErlangEmptyList]
              in ErlangTuple [ErlangAtom "let", x_72, ffun_48, tup_el_76]
erlps__expr_to_fcode__3 [_env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map"), _,
                                       (ErlangEmptyList)])]
  =
  ErlangTuple
    [ErlangAtom "builtin", ErlangAtom "map_empty", ErlangEmptyList]
erlps__expr_to_fcode__3 [env_0, type_1,
                         (ErlangTuple [(ErlangAtom "map"), ann_2, kvs_3])]
  =
  let   
    fields_18 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [k_5, v_6]) ->
               let    head_12 = ErlangTuple [ErlangAtom "map_get", ann_2, k_5]
               in let
                 lcRet_8 =
                   ErlangTuple
                     [ErlangAtom "field", ann_2,
                      ErlangCons head_12 ErlangEmptyList, v_6]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        kvs_3
  in let
    tup_el_24 =
      ErlangTuple [ErlangAtom "map", ann_2, ErlangEmptyList]
  in let
    arg_21 =
      ErlangTuple [ErlangAtom "map", ann_2, tup_el_24, fields_18]
  in erlps__expr_to_fcode__3 [env_0, type_1, arg_21]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map"), _, map_2, kvs_3])]
  =
  let    arg_4 = erlps__expr_to_fcode__2 [env_0, map_2]
  in let
    arg_7 =
      ErlangFun 1
        (let
           lambda_8 [map1_10] =
             let
               arg_11 =
                 ErlangFun 2
                   (let
                      lambda_12 [fld_15, m_16] =
                        case fld_15 of
                          (ErlangTuple [(ErlangAtom "field"), _,
                                        (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                  _,
                                                                  k_18]) (ErlangEmptyList)),
                                        v_19]) ->
                            let   
                              head_25 = erlps__expr_to_fcode__2 [env_0, k_18]
                            in let
                              head_29 = erlps__expr_to_fcode__2 [env_0, v_19]
                            in
                              ErlangTuple
                                [ErlangAtom "op", ErlangAtom "map_set",
                                 ErlangCons m_16
                                   (ErlangCons head_25
                                      (ErlangCons head_29 ErlangEmptyList))]
                          (ErlangTuple [(ErlangAtom "field_upd"), _,
                                        (ErlangCons mapget_33 (ErlangEmptyList)),
                                        (ErlangTuple [(ErlangAtom "typed"), _,
                                                      (ErlangTuple [(ErlangAtom "lam"),
                                                                    _,
                                                                    (ErlangCons (ErlangTuple [(ErlangAtom "arg"),
                                                                                              _,
                                                                                              (ErlangTuple [(ErlangAtom "id"),
                                                                                                            _,
                                                                                                            z_34]),
                                                                                              _]) (ErlangEmptyList)),
                                                                    v_35]),
                                                      _])]) | onElement
                                                                (toErl 1)
                                                                mapget_33 weakEq
                                                                (ErlangAtom
                                                                   "map_get") ->
                            let
                              matchExpr_39 =
                                BIF.erlang__tuple_to_list__1 [mapget_33]
                            in
                              case matchExpr_39 of
                                (ErlangCons (ErlangAtom "map_get") (ErlangCons _ (ErlangCons k_37 default_38))) ->
                                  let   
                                    arg_40 =
                                      erlps__expr_to_fcode__2 [env_0, k_37]
                                  in let
                                    arg_43 =
                                      ErlangFun 1
                                        (let
                                           lambda_44 [key_46] =
                                             let   
                                               z1_47 = erlps__fresh_name__0 []
                                             in let
                                               getexpr_68 =
                                                 case default_38 of
                                                   (ErlangEmptyList) ->
                                                     ErlangTuple
                                                       [ErlangAtom "op",
                                                        ErlangAtom "map_get",
                                                        ErlangCons map1_10
                                                          (ErlangCons key_46
                                                             ErlangEmptyList)]
                                                   (ErlangCons d_56 (ErlangEmptyList)) ->
                                                     let
                                                       head_64 =
                                                         erlps__expr_to_fcode__2
                                                           [env_0, d_56]
                                                     in
                                                       ErlangTuple
                                                         [ErlangAtom "op",
                                                          ErlangAtom
                                                            "map_get_d",
                                                          ErlangCons map1_10
                                                            (ErlangCons key_46
                                                               (ErlangCons
                                                                  head_64
                                                                  ErlangEmptyList))]
                                                   something_else ->
                                                     EXC.case_clause
                                                       something_else
                                             in let
                                               head_82 =
                                                 ErlangTuple [z_34, z1_47]
                                             in let
                                               arg_87 =
                                                 erlps__bind_var__2
                                                   [env_0, z_34]
                                             in let
                                               arg_86 =
                                                 erlps__expr_to_fcode__2
                                                   [arg_87, v_35]
                                             in let
                                               head_80 =
                                                 erlps__rename__2
                                                   [ErlangCons head_82
                                                      ErlangEmptyList,
                                                    arg_86]
                                             in let
                                               tup_el_72 =
                                                 ErlangTuple
                                                   [ErlangAtom "op",
                                                    ErlangAtom "map_set",
                                                    ErlangCons m_16
                                                      (ErlangCons key_46
                                                         (ErlangCons head_80
                                                            ErlangEmptyList))]
                                             in
                                               ErlangTuple
                                                 [ErlangAtom "let", z1_47,
                                                  getexpr_68, tup_el_72]
                                           lambda_44 [arg_45] =
                                             EXC.function_clause unit
                                           lambda_44 args =
                                             EXC.badarity
                                               (ErlangFun 1 lambda_44) args
                                         in lambda_44)
                                  in erlps__make_let__2 [arg_40, arg_43]
                                _ -> EXC.badmatch matchExpr_39
                          something_else -> EXC.case_clause something_else
                      lambda_12 [arg_13, arg_14] = EXC.function_clause unit
                      lambda_12 args = EXC.badarity (ErlangFun 2 lambda_12) args
                    in lambda_12)
             in
               BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
                 [arg_11, map1_10, kvs_3]
           lambda_8 [arg_9] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
         in lambda_8)
  in erlps__make_let__2 [arg_4, arg_7]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map_get"), _, map_2,
                                       key_3])]
  =
  let    head_7 = erlps__expr_to_fcode__2 [env_0, map_2]
  in let head_11 = erlps__expr_to_fcode__2 [env_0, key_3]
  in
    ErlangTuple
      [ErlangAtom "op", ErlangAtom "map_get",
       ErlangCons head_7 (ErlangCons head_11 ErlangEmptyList)]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "map_get"), _, map_2, key_3,
                                       def_4])]
  =
  let    head_8 = erlps__expr_to_fcode__2 [env_0, map_2]
  in let head_12 = erlps__expr_to_fcode__2 [env_0, key_3]
  in let head_16 = erlps__expr_to_fcode__2 [env_0, def_4]
  in
    ErlangTuple
      [ErlangAtom "op", ErlangAtom "map_get_d",
       ErlangCons head_8
         (ErlangCons head_12 (ErlangCons head_16 ErlangEmptyList))]
erlps__expr_to_fcode__3 [env_0, _type_1,
                         (ErlangTuple [(ErlangAtom "lam"), _, args_2, body_3])]
  =
  let   
    getarg_7 =
      ErlangFun 1
        (let
           lambda_4 [(ErlangTuple [(ErlangAtom "arg"), _,
                                   (ErlangTuple [(ErlangAtom "id"), _, x_6]),
                                   _])]
             =
             x_6
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    xs_10 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [getarg_7, args_2]
  in let arg_14 = erlps__bind_vars__2 [env_0, xs_10]
  in let tup_el_13 = erlps__expr_to_fcode__2 [arg_14, body_3]
  in ErlangTuple [ErlangAtom "lam", xs_10, tup_el_13]
erlps__expr_to_fcode__3 [_env_0, type_1, expr_2] =
  let    tup_el_5 = ErlangTuple [expr_2, ErlangAtom ":", type_1]
  in let arg_3 = ErlangTuple [ErlangAtom "todo", tup_el_5]
  in BIF.erlang__error__1 [arg_3]
erlps__expr_to_fcode__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__expr_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__expr_to_fcode__3) args

erlps__make_if__3 :: ErlangFun
erlps__make_if__3 [(ErlangTuple [(ErlangAtom "var"), x_0]),
                   then_1, else_2]
  =
  let   
    tup_el_11 = ErlangTuple [ErlangAtom "bool", ErlangAtom "false"]
  in let tup_el_14 = ErlangTuple [ErlangAtom "nosplit", else_2]
  in let
    head_9 = ErlangTuple [ErlangAtom "case", tup_el_11, tup_el_14]
  in let
    tup_el_20 = ErlangTuple [ErlangAtom "bool", ErlangAtom "true"]
  in let tup_el_23 = ErlangTuple [ErlangAtom "nosplit", then_1]
  in let
    head_18 = ErlangTuple [ErlangAtom "case", tup_el_20, tup_el_23]
  in let
    tup_el_4 =
      ErlangTuple
        [ErlangAtom "split", ErlangAtom "boolean", x_0,
         ErlangCons head_9 (ErlangCons head_18 ErlangEmptyList)]
  in ErlangTuple [ErlangAtom "switch", tup_el_4]
erlps__make_if__3 [cond_0, then_1, else_2] =
  let    x_3 = erlps__fresh_name__0 []
  in let arg_8 = ErlangTuple [ErlangAtom "var", x_3]
  in let tup_el_7 = erlps__make_if__3 [arg_8, then_1, else_2]
  in ErlangTuple [ErlangAtom "let", x_3, cond_0, tup_el_7]
erlps__make_if__3 [arg_13, arg_14, arg_15] =
  EXC.function_clause unit
erlps__make_if__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_if__3) args

erlps__make_tuple__1 :: ErlangFun
erlps__make_tuple__1 [(ErlangCons e_0 (ErlangEmptyList))] = e_0
erlps__make_tuple__1 [es_0] =
  ErlangTuple [ErlangAtom "tuple", es_0]
erlps__make_tuple__1 [arg_3] = EXC.function_clause unit
erlps__make_tuple__1 args =
  EXC.badarity (ErlangFun 1 erlps__make_tuple__1) args

erlps__strip_singleton_tuples__1 :: ErlangFun
erlps__strip_singleton_tuples__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                                (ErlangCons t_0 (ErlangEmptyList))])]
  =
  erlps__strip_singleton_tuples__1 [t_0]
erlps__strip_singleton_tuples__1 [t_0] = t_0
erlps__strip_singleton_tuples__1 [arg_1] =
  EXC.function_clause unit
erlps__strip_singleton_tuples__1 args =
  EXC.badarity (ErlangFun 1 erlps__strip_singleton_tuples__1) args

erlps__get_oracle_type__2 :: ErlangFun
erlps__get_oracle_type__2 [(ErlangAtom "oracle_register"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _, _,
                                         otype_0])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_query"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_get_question"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_get_answer"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_check"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_check_query"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [(ErlangAtom "oracle_respond"),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                         (ErlangCons otype_0 _), _])]
  =
  otype_0
erlps__get_oracle_type__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__get_oracle_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_oracle_type__2) args

erlps__validate_oracle_type__4 :: ErlangFun
erlps__validate_oracle_type__4 [ann_0, type_1, qtype_2, rtype_3]
  =
  let   
    arg_5 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "polymorphic",
         ErlangAtom "query", ann_0, type_1]
  in let _ = erlps__ensure_monomorphic__2 [qtype_2, arg_5]
  in let
    arg_12 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "polymorphic",
         ErlangAtom "response", ann_0, type_1]
  in let _ = erlps__ensure_monomorphic__2 [rtype_3, arg_12]
  in let
    arg_19 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "higher_order",
         ErlangAtom "query", ann_0, type_1]
  in let _ = erlps__ensure_first_order__2 [qtype_2, arg_19]
  in let
    arg_26 =
      ErlangTuple
        [ErlangAtom "invalid_oracle_type", ErlangAtom "higher_order",
         ErlangAtom "response", ann_0, type_1]
  in let _ = erlps__ensure_first_order__2 [rtype_3, arg_26]
  in ErlangAtom "ok"
erlps__validate_oracle_type__4 [arg_32, arg_33, arg_34, arg_35] =
  EXC.function_clause unit
erlps__validate_oracle_type__4 args =
  EXC.badarity (ErlangFun 4 erlps__validate_oracle_type__4) args

erlps__validate_aens_resolve_type__3 :: ErlangFun
erlps__validate_aens_resolve_type__3 [ann_0,
                                      (ErlangTuple [(ErlangAtom "app_t"), _, _,
                                                    (ErlangCons type_1 (ErlangEmptyList))]),
                                      (ErlangTuple [(ErlangAtom "variant"),
                                                    (ErlangCons (ErlangEmptyList) (ErlangCons (ErlangCons ftype_2 (ErlangEmptyList)) (ErlangEmptyList)))])]
  =
  case ftype_2 of
    (ErlangAtom "string") -> ErlangAtom "ok"
    (ErlangAtom "address") -> ErlangAtom "ok"
    (ErlangAtom "contract") -> ErlangAtom "ok"
    (ErlangTuple [(ErlangAtom "oracle"), _, _]) -> ErlangAtom "ok"
    (ErlangAtom "oracle_query") -> ErlangAtom "ok"
    _ ->
      let
        arg_4 =
          ErlangTuple
            [ErlangAtom "invalid_aens_resolve_type", ann_0, type_1]
      in erlps__fcode_error__1 [arg_4]
erlps__validate_aens_resolve_type__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__validate_aens_resolve_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__validate_aens_resolve_type__3)
    args

erlps__ensure_first_order_entrypoint__6 :: ErlangFun
erlps__ensure_first_order_entrypoint__6 [ann_0,
                                         id_2@(ErlangTuple [(ErlangAtom "id"),
                                                            _, name_1]),
                                         args_3, ret_4, fargs_5, fret_6]
  =
  let   
    lcSrc_7 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2" [args_3, fargs_5]
  in let
    _ =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangTuple [(ErlangAtom "typed"), ann1_10, x_11,
                                         t_12]),
                           (ErlangTuple [_, ft_13])]) ->
               let   
                 tup_el_22 = ErlangTuple [ErlangAtom "argument", x_11, t_12]
               in let
                 arg_17 =
                   ErlangTuple
                     [ErlangAtom "invalid_entrypoint",
                      ErlangAtom "higher_order", ann1_10, id_2, tup_el_22]
               in let lcRet_15 = erlps__ensure_first_order__2 [ft_13, arg_17]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_7
  in let rop_28 = toErl "init"
  in let cond_26 = BIF.erlang__op_neq [name_1, rop_28]
  in let
    _ =
      case cond_26 of
        (ErlangAtom "true") ->
          let    tup_el_36 = ErlangTuple [ErlangAtom "result", ret_4]
          in let
            arg_31 =
              ErlangTuple
                [ErlangAtom "invalid_entrypoint", ErlangAtom "higher_order",
                 ann_0, id_2, tup_el_36]
          in let lcRet_29 = erlps__ensure_first_order__2 [fret_6, arg_31]
          in ErlangCons lcRet_29 ErlangEmptyList
        _ -> ErlangEmptyList
  in ErlangAtom "ok"
erlps__ensure_first_order_entrypoint__6 [arg_39, arg_40, arg_41,
                                         arg_42, arg_43, arg_44]
  =
  EXC.function_clause unit
erlps__ensure_first_order_entrypoint__6 args =
  EXC.badarity
    (ErlangFun 6 erlps__ensure_first_order_entrypoint__6) args

erlps__ensure_monomorphic__2 :: ErlangFun
erlps__ensure_monomorphic__2 [type_0, err_1] =
  let case_2 = erlps__is_monomorphic__1 [type_0]
  in
    case case_2 of
      (ErlangAtom "true") -> ErlangAtom "ok"
      (ErlangAtom "false") -> erlps__fcode_error__1 [err_1]
      something_else -> EXC.case_clause something_else
erlps__ensure_monomorphic__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__ensure_monomorphic__2 args =
  EXC.badarity (ErlangFun 2 erlps__ensure_monomorphic__2) args

erlps__ensure_first_order__2 :: ErlangFun
erlps__ensure_first_order__2 [type_0, err_1] =
  let case_2 = erlps__is_first_order__1 [type_0]
  in
    case case_2 of
      (ErlangAtom "true") -> ErlangAtom "ok"
      (ErlangAtom "false") -> erlps__fcode_error__1 [err_1]
      something_else -> EXC.case_clause something_else
erlps__ensure_first_order__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__ensure_first_order__2 args =
  EXC.badarity (ErlangFun 2 erlps__ensure_first_order__2) args

erlps__is_monomorphic__1 :: ErlangFun
erlps__is_monomorphic__1 [(ErlangTuple [(ErlangAtom "tvar"), _])]
  =
  ErlangAtom "false"
erlps__is_monomorphic__1 [ts_0] | isEList ts_0 =
  let arg_1 = ErlangFun 1 erlps__is_monomorphic__1
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, ts_0]
erlps__is_monomorphic__1 [tup_0] | isETuple tup_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [tup_0]
  in erlps__is_monomorphic__1 [arg_1]
erlps__is_monomorphic__1 [_] = ErlangAtom "true"
erlps__is_monomorphic__1 [arg_0] = EXC.function_clause unit
erlps__is_monomorphic__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_monomorphic__1) args

erlps__is_first_order__1 :: ErlangFun
erlps__is_first_order__1 [(ErlangTuple [(ErlangAtom "function"),
                                        _, _])]
  =
  ErlangAtom "false"
erlps__is_first_order__1 [ts_0] | isEList ts_0 =
  let arg_1 = ErlangFun 1 erlps__is_first_order__1
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, ts_0]
erlps__is_first_order__1 [tup_0] | isETuple tup_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [tup_0]
  in erlps__is_first_order__1 [arg_1]
erlps__is_first_order__1 [_] = ErlangAtom "true"
erlps__is_first_order__1 [arg_0] = EXC.function_clause unit
erlps__is_first_order__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_first_order__1) args

erlps__alts_to_fcode__4 :: ErlangFun
erlps__alts_to_fcode__4 [env_0, type_1, x_2, alts_3] =
  let   
    falts_10 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__alt_to_fcode__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        alts_3
  in let head_13 = ErlangTuple [x_2, type_1]
  in
    erlps__split_tree__3
      [env_0, ErlangCons head_13 ErlangEmptyList, falts_10]
erlps__alts_to_fcode__4 [arg_18, arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__alts_to_fcode__4 args =
  EXC.badarity (ErlangFun 4 erlps__alts_to_fcode__4) args

erlps__split_tree__3 :: ErlangFun
erlps__split_tree__3 [_env_0, _vars_1, (ErlangEmptyList)] =
  BIF.erlang__error__1 [ErlangAtom "non_exhaustive_patterns"]
erlps__split_tree__3 [env_0, vars_1,
                      alts_4@(ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                       pats_2, body_3]) _)]
  =
  let case_5 = erlps__next_split__1 [pats_2]
  in
    case case_5 of
      (ErlangAtom "false") ->
        let   
          xs_11 =
            flmap
              (\ lc_9 ->
                 case lc_9 of
                   (ErlangTuple [x_8, _]) -> ErlangCons x_8 ErlangEmptyList
                   _ -> ErlangEmptyList)
              vars_1
        in let
          ys_16 =
            flmap
              (\ lc_14 ->
                 case lc_14 of
                   (ErlangTuple [(ErlangAtom "var"), y_13]) ->
                     ErlangCons y_13 ErlangEmptyList
                   _ -> ErlangEmptyList)
              pats_2
        in let
          lcSrc_17 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [ys_16, xs_11]
        in let
          ren_32 =
            flmap
              (\ lc_22 ->
                 case lc_22 of
                   (ErlangTuple [y_20, x_21]) ->
                     let cond_23 = BIF.erlang__op_neq [x_21, y_20]
                     in
                       case cond_23 of
                         (ErlangAtom "true") ->
                           let    rop_28 = toErl "_"
                           in let cond_26 = BIF.erlang__op_neq [y_20, rop_28]
                           in
                             case cond_26 of
                               (ErlangAtom "true") ->
                                 let lcRet_29 = ErlangTuple [y_20, x_21]
                                 in ErlangCons lcRet_29 ErlangEmptyList
                               _ -> ErlangEmptyList
                         _ -> ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_17
        in let tup_el_34 = erlps__rename__2 [ren_32, body_3]
        in ErlangTuple [ErlangAtom "nosplit", tup_el_34]
      i_37 | isEInt i_37 ->
        let    rop_40 = toErl 1
        in let arg_38 = BIF.erlang__op_minus [i_37, rop_40]
        in let
          matchExpr_46 =
            BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_38, vars_1]
        in
          case matchExpr_46 of
            (ErlangTuple [vars0_42,
                          (ErlangCons (ErlangTuple [x_43,
                                                    type_44]) vars1_45)]) ->
              let    type1_48 = erlps__strip_singleton_tuples__1 [type_44]
              in let
                arg_51 =
                  flmap
                    (\ lc_54 ->
                       let lcRet_55 = erlps__split_alt__2 [i_37, lc_54]
                       in ErlangCons lcRet_55 ErlangEmptyList)
                    alts_4
              in let salts_58 = erlps__merge_alts__3 [i_37, x_43, arg_51]
              in let
                makecase_80 =
                  ErlangFun 2
                    (let
                       lambda_59 [(ErlangTuple [(ErlangAtom "var"), z_62]),
                                  split_63]
                         =
                         let    tup_el_67 = toErl "_"
                         in let
                           tup_el_65 = ErlangTuple [ErlangAtom "var", tup_el_67]
                         in let head_70 = ErlangTuple [z_62, x_43]
                         in let
                           tup_el_68 =
                             erlps__rename_split__2
                               [ErlangCons head_70 ErlangEmptyList, split_63]
                         in
                           ErlangTuple [ErlangAtom "case", tup_el_65, tup_el_68]
                       lambda_59 [spat_75, split_76] =
                         ErlangTuple [ErlangAtom "case", spat_75, split_76]
                       lambda_59 [arg_60, arg_61] = EXC.function_clause unit
                       lambda_59 args =
                         EXC.badarity (ErlangFun 2 lambda_59) args
                     in lambda_59)
              in let
                cases_98 =
                  flmap
                    (\ lc_84 ->
                       case lc_84 of
                         (ErlangTuple [spat_82, falts_83]) ->
                           let   
                             lop_92 = erlps__split_vars__2 [spat_82, type1_48]
                           in let
                             rop_91 = BIF.erlang__op_append [lop_92, vars1_45]
                           in let
                             arg_89 = BIF.erlang__op_append [vars0_42, rop_91]
                           in let
                             arg_87 =
                               erlps__split_tree__3 [env_0, arg_89, falts_83]
                           in let
                             lcRet_85 =
                               BIF.erlang__apply__2
                                 [makecase_80,
                                  ErlangCons spat_82
                                    (ErlangCons arg_87 ErlangEmptyList)]
                           in ErlangCons lcRet_85 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    salts_58
              in ErlangTuple [ErlangAtom "split", type1_48, x_43, cases_98]
            _ -> EXC.badmatch matchExpr_46
      something_else -> EXC.case_clause something_else
erlps__split_tree__3 [arg_103, arg_104, arg_105] =
  EXC.function_clause unit
erlps__split_tree__3 args =
  EXC.badarity (ErlangFun 3 erlps__split_tree__3) args

erlps__merge_alts__3 :: ErlangFun
erlps__merge_alts__3 [i_0, x_1, alts_2] =
  erlps__merge_alts__4 [i_0, x_1, alts_2, ErlangEmptyList]
erlps__merge_alts__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__merge_alts__3 args =
  EXC.badarity (ErlangFun 3 erlps__merge_alts__3) args

erlps__merge_alts__4 :: ErlangFun
erlps__merge_alts__4 [i_0, x_1, alts_2, alts1_3] =
  let
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [a_8, as_9] = erlps__merge_alt__4 [i_0, x_1, a_8, as_9]
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_4, alts1_3, alts_2]
erlps__merge_alts__4 [arg_16, arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__merge_alts__4 args =
  EXC.badarity (ErlangFun 4 erlps__merge_alts__4) args

erlps__merge_alt__4 :: ErlangFun
erlps__merge_alt__4 [_, _, (ErlangTuple [p_0, a_1]),
                     (ErlangEmptyList)]
  =
  let head_2 = ErlangTuple [p_0, ErlangCons a_1 ErlangEmptyList]
  in ErlangCons head_2 ErlangEmptyList
erlps__merge_alt__4 [i_0, x_1, (ErlangTuple [p_2, a_3]),
                     (ErlangCons (ErlangTuple [q_4, as_5]) rest_6)]
  =
  let   
    match_18 =
      ErlangFun 2
        (let
           lambda_7 [(ErlangTuple [(ErlangAtom "var"), _]),
                     (ErlangTuple [(ErlangAtom "var"), _])]
             =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "tuple"), _]),
                     (ErlangTuple [(ErlangAtom "tuple"), _])]
             =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "bool"), b_10]),
                     (ErlangTuple [(ErlangAtom "bool"), b_11])]
             | b_11 == b_10 =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "int"), n_12]),
                     (ErlangTuple [(ErlangAtom "int"), n_13])]
             | n_13 == n_12 =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "string"), s_14]),
                     (ErlangTuple [(ErlangAtom "string"), s_15])]
             | s_15 == s_14 =
             ErlangAtom "match"
           lambda_7 [(ErlangAtom "nil"), (ErlangAtom "nil")] =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "::"), _, _]),
                     (ErlangTuple [(ErlangAtom "::"), _, _])]
             =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "con"), _, c_16, _]),
                     (ErlangTuple [(ErlangAtom "con"), _, c_17, _])]
             | c_17 == c_16 =
             ErlangAtom "match"
           lambda_7 [(ErlangTuple [(ErlangAtom "con"), _, _, _]),
                     (ErlangTuple [(ErlangAtom "con"), _, _, _])]
             =
             ErlangAtom "mismatch"
           lambda_7 [(ErlangTuple [(ErlangAtom "var"), _]), _] =
             ErlangAtom "expand"
           lambda_7 [_, (ErlangTuple [(ErlangAtom "var"), _])] =
             ErlangAtom "insert"
           lambda_7 [_, _] = ErlangAtom "mismatch"
           lambda_7 [arg_8, arg_9] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 2 lambda_7) args
         in lambda_7)
  in let
    case_19 =
      BIF.erlang__apply__2
        [match_18, ErlangCons p_2 (ErlangCons q_4 ErlangEmptyList)]
  in
    case case_19 of
      (ErlangAtom "match") ->
        let head_23 = ErlangTuple [q_4, ErlangCons a_3 as_5]
        in ErlangCons head_23 rest_6
      (ErlangAtom "mismatch") ->
        let    head_29 = ErlangTuple [q_4, as_5]
        in let arg_35 = ErlangTuple [p_2, a_3]
        in let tail_32 = erlps__merge_alt__4 [i_0, x_1, arg_35, rest_6]
        in ErlangCons head_29 tail_32
      (ErlangAtom "expand") ->
        let matchExpr_46 = erlps__expand__5 [i_0, x_1, p_2, q_4, a_3]
        in
          case matchExpr_46 of
            (ErlangTuple [before_44, after_45]) ->
              let    head_51 = ErlangTuple [q_4, as_5]
              in let
                tail_54 = erlps__merge_alts__4 [i_0, x_1, after_45, rest_6]
              in
                erlps__merge_alts__4
                  [i_0, x_1, before_44, ErlangCons head_51 tail_54]
            _ -> EXC.badmatch matchExpr_46
      (ErlangAtom "insert") ->
        let   
          head_59 = ErlangTuple [p_2, ErlangCons a_3 ErlangEmptyList]
        in let head_65 = ErlangTuple [q_4, as_5]
        in ErlangCons head_59 (ErlangCons head_65 rest_6)
      something_else -> EXC.case_clause something_else
erlps__merge_alt__4 [arg_69, arg_70, arg_71, arg_72] =
  EXC.function_clause unit
erlps__merge_alt__4 args =
  EXC.badarity (ErlangFun 4 erlps__merge_alt__4) args

erlps__expand__5 :: ErlangFun
erlps__expand__5 [i_0, x_1, p_2, q_3,
                  case_6@(ErlangTuple [(ErlangAtom "case"), ps_4, e_5])]
  =
  let    rop_9 = toErl 1
  in let arg_7 = BIF.erlang__op_minus [i_0, rop_9]
  in let
    matchExpr_14 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_7, ps_4]
  in
    case matchExpr_14 of
      (ErlangTuple [ps0_11,
                    (ErlangCons (ErlangTuple [(ErlangAtom "var"),
                                              y_12]) ps1_13)]) ->
        let    cond_16 = BIF.erlang__op_neq [y_12, x_1]
        in let
          arg_15 =
            case cond_16 of
              (ErlangAtom "true") ->
                let lcRet_19 = ErlangTuple [y_12, x_1]
                in ErlangCons lcRet_19 ErlangEmptyList
              _ -> ErlangEmptyList
        in let matchExpr_25 = erlps__rename_fpats__2 [arg_15, ps0_11]
        in
          case matchExpr_25 of
            (ErlangTuple [ps0r_23, ren1_24]) ->
              let matchExpr_30 = erlps__rename_fpats__2 [ren1_24, ps1_13]
              in
                case matchExpr_30 of
                  (ErlangTuple [ps1r_28, ren2_29]) ->
                    let    e1_33 = erlps__rename__2 [ren2_29, e_5]
                    in let
                      splice_45 =
                        ErlangFun 1
                          (let
                             lambda_34 [n_36] =
                               let    tup_el_43 = toErl "_"
                               in let
                                 arg_41 =
                                   ErlangTuple [ErlangAtom "var", tup_el_43]
                               in let
                                 lop_39 =
                                   BIF.do_remote_fun_call "Lists"
                                     "erlps__duplicate__2" [n_36, arg_41]
                               in let
                                 rop_38 =
                                   BIF.erlang__op_append [lop_39, ps1r_28]
                               in BIF.erlang__op_append [ps0r_23, rop_38]
                             lambda_34 [arg_35] = EXC.function_clause unit
                             lambda_34 args =
                               EXC.badarity (ErlangFun 1 lambda_34) args
                           in lambda_34)
                    in let
                      type_55 =
                        ErlangFun 1
                          (let
                             lambda_46 [(ErlangTuple [(ErlangAtom "tuple"),
                                                      xs_48])]
                               =
                               let tup_el_50 = BIF.erlang__length__1 [xs_48]
                               in ErlangTuple [ErlangAtom "tuple", tup_el_50]
                             lambda_46 [(ErlangTuple [(ErlangAtom "bool"), _])]
                               =
                               ErlangAtom "bool"
                             lambda_46 [(ErlangTuple [(ErlangAtom "int"), _])] =
                               ErlangAtom "int"
                             lambda_46 [(ErlangTuple [(ErlangAtom "string"),
                                                      _])]
                               =
                               ErlangAtom "string"
                             lambda_46 [(ErlangAtom "nil")] = ErlangAtom "list"
                             lambda_46 [(ErlangTuple [(ErlangAtom "::"), _, _])]
                               =
                               ErlangAtom "list"
                             lambda_46 [(ErlangTuple [(ErlangAtom "con"), as_52,
                                                      _, _])]
                               =
                               ErlangTuple [ErlangAtom "variant", as_52]
                             lambda_46 [arg_47] = EXC.function_clause unit
                             lambda_46 args =
                               EXC.badarity (ErlangFun 1 lambda_46) args
                           in lambda_46)
                    in let
                      mkcase_68 =
                        ErlangFun 2
                          (let
                             lambda_56 [pat_59, vars_60] =
                               let   
                                 tup_el_64 =
                                   BIF.erlang__apply__2
                                     [splice_45,
                                      ErlangCons vars_60 ErlangEmptyList]
                               in let
                                 tup_el_62 =
                                   ErlangTuple
                                     [ErlangAtom "case", tup_el_64, e1_33]
                               in ErlangTuple [pat_59, tup_el_62]
                             lambda_56 [arg_57, arg_58] =
                               EXC.function_clause unit
                             lambda_56 args =
                               EXC.badarity (ErlangFun 2 lambda_56) args
                           in lambda_56)
                    in let
                      case_69 =
                        BIF.erlang__apply__2
                          [type_55, ErlangCons q_3 ErlangEmptyList]
                    in
                      case case_69 of
                        (ErlangTuple [(ErlangAtom "tuple"), n_72]) ->
                          let
                            head_74 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons q_3
                                   (ErlangCons n_72 ErlangEmptyList)]
                          in
                            ErlangTuple
                              [ErlangCons head_74 ErlangEmptyList,
                               ErlangEmptyList]
                        (ErlangAtom "bool") ->
                          let
                            tup_el_80 =
                              flmap
                                (\ lc_87 ->
                                   let   
                                     arg_89 =
                                       ErlangTuple [ErlangAtom "bool", lc_87]
                                   in let arg_92 = toErl 0
                                   in let
                                     lcRet_88 =
                                       BIF.erlang__apply__2
                                         [mkcase_68,
                                          ErlangCons arg_89
                                            (ErlangCons arg_92 ErlangEmptyList)]
                                   in ErlangCons lcRet_88 ErlangEmptyList)
                                (ErlangCons (ErlangAtom "false")
                                   (ErlangCons (ErlangAtom "true")
                                      ErlangEmptyList))
                          in ErlangTuple [tup_el_80, ErlangEmptyList]
                        (ErlangAtom "int") ->
                          let    arg_98 = toErl 0
                          in let
                            head_96 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons q_3
                                   (ErlangCons arg_98 ErlangEmptyList)]
                          in let head_102 = ErlangTuple [p_2, case_6]
                          in
                            ErlangTuple
                              [ErlangCons head_96 ErlangEmptyList,
                               ErlangCons head_102 ErlangEmptyList]
                        (ErlangAtom "string") ->
                          let    arg_109 = toErl 0
                          in let
                            head_107 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons q_3
                                   (ErlangCons arg_109 ErlangEmptyList)]
                          in let head_113 = ErlangTuple [p_2, case_6]
                          in
                            ErlangTuple
                              [ErlangCons head_107 ErlangEmptyList,
                               ErlangCons head_113 ErlangEmptyList]
                        (ErlangAtom "list") ->
                          let    arg_120 = toErl 0
                          in let
                            head_118 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons (ErlangAtom "nil")
                                   (ErlangCons arg_120 ErlangEmptyList)]
                          in let tup_el_126 = erlps__fresh_name__0 []
                          in let tup_el_127 = erlps__fresh_name__0 []
                          in let
                            arg_124 =
                              ErlangTuple
                                [ErlangAtom "::", tup_el_126, tup_el_127]
                          in let arg_128 = toErl 2
                          in let
                            head_123 =
                              BIF.erlang__apply__2
                                [mkcase_68,
                                 ErlangCons arg_124
                                   (ErlangCons arg_128 ErlangEmptyList)]
                          in
                            ErlangTuple
                              [ErlangCons head_118
                                 (ErlangCons head_123 ErlangEmptyList),
                               ErlangEmptyList]
                        (ErlangTuple [(ErlangAtom "variant"), as_132]) ->
                          let    lcSrc_134 = erlps__indexed__1 [as_132]
                          in let
                            tup_el_133 =
                              flmap
                                (\ lc_138 ->
                                   case lc_138 of
                                     (ErlangTuple [c_136, ar_137]) ->
                                       let    rop_145 = toErl 1
                                       in let
                                         tup_el_143 =
                                           BIF.erlang__op_minus [c_136, rop_145]
                                       in let arg_148 = toErl 1
                                       in let
                                         lcSrc_147 =
                                           BIF.do_remote_fun_call "Lists"
                                             "erlps__seq__2" [arg_148, ar_137]
                                       in let
                                         tup_el_146 =
                                           flmap
                                             (\ lc_150 ->
                                                case lc_150 of
                                                  _ ->
                                                    let
                                                      lcRet_151 =
                                                        erlps__fresh_name__0 []
                                                    in
                                                      ErlangCons lcRet_151
                                                        ErlangEmptyList)
                                             lcSrc_147
                                       in let
                                         arg_140 =
                                           ErlangTuple
                                             [ErlangAtom "con", as_132,
                                              tup_el_143, tup_el_146]
                                       in let
                                         lcRet_139 =
                                           BIF.erlang__apply__2
                                             [mkcase_68,
                                              ErlangCons arg_140
                                                (ErlangCons ar_137
                                                   ErlangEmptyList)]
                                       in ErlangCons lcRet_139 ErlangEmptyList
                                     _ -> ErlangEmptyList)
                                lcSrc_134
                          in ErlangTuple [tup_el_133, ErlangEmptyList]
                        something_else -> EXC.case_clause something_else
                  _ -> EXC.badmatch matchExpr_30
            _ -> EXC.badmatch matchExpr_25
      _ -> EXC.badmatch matchExpr_14
erlps__expand__5 [arg_155, arg_156, arg_157, arg_158, arg_159] =
  EXC.function_clause unit
erlps__expand__5 args =
  EXC.badarity (ErlangFun 5 erlps__expand__5) args

erlps__split_alt__2 :: ErlangFun
erlps__split_alt__2 [i_0,
                     (ErlangTuple [(ErlangAtom "case"), pats_1, body_2])]
  =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [i_0, rop_5]
  in let
    matchExpr_10 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_3, pats_1]
  in
    case matchExpr_10 of
      (ErlangTuple [pats0_7, (ErlangCons pat_8 pats1_9)]) ->
        let matchExpr_14 = erlps__split_pat__1 [pat_8]
        in
          case matchExpr_14 of
            (ErlangTuple [spat_12, innerpats_13]) ->
              let    rop_20 = BIF.erlang__op_append [innerpats_13, pats1_9]
              in let tup_el_18 = BIF.erlang__op_append [pats0_7, rop_20]
              in let
                tup_el_16 = ErlangTuple [ErlangAtom "case", tup_el_18, body_2]
              in ErlangTuple [spat_12, tup_el_16]
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_10
erlps__split_alt__2 [arg_24, arg_25] = EXC.function_clause unit
erlps__split_alt__2 args =
  EXC.badarity (ErlangFun 2 erlps__split_alt__2) args

erlps__split_pat__1 :: ErlangFun
erlps__split_pat__1 [p_0@(ErlangTuple [(ErlangAtom "var"), _])] =
  let    tup_el_3 = erlps__fresh_name__0 []
  in let tup_el_1 = ErlangTuple [ErlangAtom "var", tup_el_3]
  in ErlangTuple [tup_el_1, ErlangCons p_0 ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "bool"), b_0])] =
  let tup_el_1 = ErlangTuple [ErlangAtom "bool", b_0]
  in ErlangTuple [tup_el_1, ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "int"), n_0])] =
  let tup_el_1 = ErlangTuple [ErlangAtom "int", n_0]
  in ErlangTuple [tup_el_1, ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "string"), n_0])]
  =
  let tup_el_1 = ErlangTuple [ErlangAtom "string", n_0]
  in ErlangTuple [tup_el_1, ErlangEmptyList]
erlps__split_pat__1 [(ErlangAtom "nil")] =
  ErlangTuple [ErlangAtom "nil", ErlangEmptyList]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "::"), p_0, q_1])]
  =
  let    tup_el_4 = erlps__fresh_name__0 []
  in let tup_el_5 = erlps__fresh_name__0 []
  in let
    tup_el_2 = ErlangTuple [ErlangAtom "::", tup_el_4, tup_el_5]
  in
    ErlangTuple
      [tup_el_2, ErlangCons p_0 (ErlangCons q_1 ErlangEmptyList)]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "con"), as_0, i_1,
                                   pats_2])]
  =
  let   
    xs_6 =
      flmap
        (\ lc_4 ->
           case lc_4 of
             _ ->
               let lcRet_5 = erlps__fresh_name__0 []
               in ErlangCons lcRet_5 ErlangEmptyList)
        pats_2
  in let tup_el_7 = ErlangTuple [ErlangAtom "con", as_0, i_1, xs_6]
  in ErlangTuple [tup_el_7, pats_2]
erlps__split_pat__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                   pats_0])]
  =
  let   
    xs_4 =
      flmap
        (\ lc_2 ->
           case lc_2 of
             _ ->
               let lcRet_3 = erlps__fresh_name__0 []
               in ErlangCons lcRet_3 ErlangEmptyList)
        pats_0
  in let tup_el_5 = ErlangTuple [ErlangAtom "tuple", xs_4]
  in ErlangTuple [tup_el_5, pats_0]
erlps__split_pat__1 [arg_9] = EXC.function_clause unit
erlps__split_pat__1 args =
  EXC.badarity (ErlangFun 1 erlps__split_pat__1) args

erlps__split_vars__2 :: ErlangFun
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "bool"), _]),
                      (ErlangAtom "boolean")]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "int"), _]),
                      (ErlangAtom "integer")]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "string"), _]),
                      (ErlangAtom "string")]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangAtom "nil"),
                      (ErlangTuple [(ErlangAtom "list"), _])]
  =
  ErlangEmptyList
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "::"), x_0,
                                    xs_1]),
                      (ErlangTuple [(ErlangAtom "list"), t_2])]
  =
  let    head_3 = ErlangTuple [x_0, t_2]
  in let tup_el_9 = ErlangTuple [ErlangAtom "list", t_2]
  in let head_7 = ErlangTuple [xs_1, tup_el_9]
  in ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList)
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "con"), _, i_0,
                                    xs_1]),
                      (ErlangTuple [(ErlangAtom "variant"), cons_2])]
  =
  let    rop_7 = toErl 1
  in let arg_5 = BIF.erlang__op_plus [i_0, rop_7]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_5, cons_2]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_1, arg_4]
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "tuple"), xs_0]),
                      (ErlangTuple [(ErlangAtom "tuple"), ts_1])]
  =
  BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_0, ts_1]
erlps__split_vars__2 [(ErlangTuple [(ErlangAtom "var"), x_0]),
                      t_1]
  =
  let head_2 = ErlangTuple [x_0, t_1]
  in ErlangCons head_2 ErlangEmptyList
erlps__split_vars__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__split_vars__2 args =
  EXC.badarity (ErlangFun 2 erlps__split_vars__2) args

erlps__next_split__1 :: ErlangFun
erlps__next_split__1 [pats_0] =
  let   
    isvar_3 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [(ErlangAtom "var"), _])] =
             ErlangAtom "true"
           lambda_1 [_] = ErlangAtom "false"
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let lcSrc_5 = erlps__indexed__1 [pats_0]
  in let
    case_4 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [i_7, p_8]) ->
               let   
                 op_arg_11 =
                   BIF.erlang__apply__2
                     [isvar_3, ErlangCons p_8 ErlangEmptyList]
               in let cond_10 = BIF.erlang__not__1 [op_arg_11]
               in
                 case cond_10 of
                   (ErlangAtom "true") -> ErlangCons i_7 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in
    case case_4 of
      (ErlangEmptyList) -> ErlangAtom "false"
      (ErlangCons i_15 _) -> i_15
      something_else -> EXC.case_clause something_else
erlps__next_split__1 [arg_16] = EXC.function_clause unit
erlps__next_split__1 args =
  EXC.badarity (ErlangFun 1 erlps__next_split__1) args

erlps__alt_to_fcode__2 :: ErlangFun
erlps__alt_to_fcode__2 [env_0,
                        (ErlangTuple [(ErlangAtom "case"), _, pat_1, expr_2])]
  =
  let    fpat_5 = erlps__pat_to_fcode__2 [env_0, pat_1]
  in let arg_8 = erlps__pat_vars__1 [fpat_5]
  in let arg_6 = erlps__bind_vars__2 [env_0, arg_8]
  in let fexpr_11 = erlps__expr_to_fcode__2 [arg_6, expr_2]
  in
    ErlangTuple
      [ErlangAtom "case", ErlangCons fpat_5 ErlangEmptyList, fexpr_11]
erlps__alt_to_fcode__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__alt_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__alt_to_fcode__2) args

erlps__pat_to_fcode__2 :: ErlangFun
erlps__pat_to_fcode__2 [env_0,
                        (ErlangTuple [(ErlangAtom "typed"), _, pat_1, type_2])]
  =
  erlps__pat_to_fcode__3 [env_0, type_2, pat_1]
erlps__pat_to_fcode__2 [env_0, pat_1] =
  erlps__pat_to_fcode__3 [env_0, ErlangAtom "no_type", pat_1]
erlps__pat_to_fcode__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__pat_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__pat_to_fcode__2) args

erlps__pat_to_fcode__3 :: ErlangFun
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "id"), _, x_2])]
  =
  ErlangTuple [ErlangAtom "var", x_2]
erlps__pat_to_fcode__3 [env_0, _type_1,
                        con_3@(ErlangTuple [c_2, _, _])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let matchExpr_8 = erlps__lookup_con__2 [env_0, con_3]
  in
    case matchExpr_8 of
      (ErlangTuple [(ErlangAtom "con_tag"), i_6, as_7]) ->
        ErlangTuple [ErlangAtom "con", as_7, i_6, ErlangEmptyList]
      _ -> EXC.badmatch matchExpr_8
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "app"), _,
                                      (ErlangTuple [(ErlangAtom "typed"), _,
                                                    con_3@(ErlangTuple [c_2, _,
                                                                        _]),
                                                    _]),
                                      pats_4])]
  | (weakEq c_2 (ErlangAtom "con")) ||
      (weakEq c_2 (ErlangAtom "qcon")) =
  let matchExpr_9 = erlps__lookup_con__2 [env_0, con_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangAtom "con_tag"), i_7, as_8]) ->
        let
          tup_el_13 =
            flmap
              (\ lc_16 ->
                 let lcRet_17 = erlps__pat_to_fcode__2 [env_0, lc_16]
                 in ErlangCons lcRet_17 ErlangEmptyList)
              pats_4
        in ErlangTuple [ErlangAtom "con", as_8, i_7, tup_el_13]
      _ -> EXC.badmatch matchExpr_9
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "tuple"), _, pats_2])]
  =
  let
    arg_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__pat_to_fcode__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        pats_2
  in erlps__make_tuple__1 [arg_3]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "bool"), _, b_2])]
  =
  ErlangTuple [ErlangAtom "bool", b_2]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "int"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "int", n_2]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "char"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "int", n_2]
erlps__pat_to_fcode__3 [_env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "string"), _, n_2])]
  =
  ErlangTuple [ErlangAtom "string", n_2]
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "list"), _, ps_2])]
  =
  let
    arg_3 =
      ErlangFun 2
        (let
           lambda_4 [p_7, qs_8] =
             let tup_el_10 = erlps__pat_to_fcode__2 [env_0, p_7]
             in ErlangTuple [ErlangAtom "::", tup_el_10, qs_8]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_3, ErlangAtom "nil", ps_2]
erlps__pat_to_fcode__3 [env_0, _type_1,
                        (ErlangTuple [(ErlangAtom "app"), _,
                                      (ErlangTuple [(ErlangAtom "::"), _]),
                                      (ErlangCons p_2 (ErlangCons q_3 (ErlangEmptyList)))])]
  =
  let    tup_el_5 = erlps__pat_to_fcode__2 [env_0, p_2]
  in let tup_el_8 = erlps__pat_to_fcode__2 [env_0, q_3]
  in ErlangTuple [ErlangAtom "::", tup_el_5, tup_el_8]
erlps__pat_to_fcode__3 [env_0,
                        (ErlangTuple [(ErlangAtom "record_t"), fields_1]),
                        (ErlangTuple [(ErlangAtom "record"), _, fieldpats_2])]
  =
  let   
    fieldpat_13 =
      ErlangFun 1
        (let
           lambda_3 [f_5] =
             let case_6 = erlps__field_value__2 [f_5, fieldpats_2]
             in
               case case_6 of
                 (ErlangAtom "false") ->
                   let tup_el_11 = toErl "_"
                   in ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_11]
                 (ErlangTuple [(ErlangAtom "set"), pat_12]) -> pat_12
                 something_else -> EXC.case_clause something_else
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    arg_14 =
      flmap
        (\ lc_17 ->
           let   
             arg_20 =
               BIF.erlang__apply__2
                 [fieldpat_13, ErlangCons lc_17 ErlangEmptyList]
           in let lcRet_18 = erlps__pat_to_fcode__2 [env_0, arg_20]
           in ErlangCons lcRet_18 ErlangEmptyList)
        fields_1
  in erlps__make_tuple__1 [arg_14]
erlps__pat_to_fcode__3 [_env_0, type_1, pat_2] =
  let
    arg_3 =
      ErlangTuple [ErlangAtom "todo", pat_2, ErlangAtom ":", type_1]
  in BIF.erlang__error__1 [arg_3]
erlps__pat_to_fcode__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__pat_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__pat_to_fcode__3) args

erlps__decision_op__3 :: ErlangFun
erlps__decision_op__3 [(ErlangAtom "&&"),
                       (ErlangTuple [(ErlangAtom "atom"), a_0]), b_1]
  =
  ErlangTuple [ErlangAtom "if", a_0, b_1, ErlangAtom "false"]
erlps__decision_op__3 [(ErlangAtom "&&"), (ErlangAtom "false"),
                       _]
  =
  ErlangAtom "false"
erlps__decision_op__3 [(ErlangAtom "&&"), (ErlangAtom "true"),
                       b_0]
  =
  b_0
erlps__decision_op__3 [(ErlangAtom "||"),
                       (ErlangTuple [(ErlangAtom "atom"), a_0]), b_1]
  =
  ErlangTuple [ErlangAtom "if", a_0, ErlangAtom "true", b_1]
erlps__decision_op__3 [(ErlangAtom "||"), (ErlangAtom "false"),
                       b_0]
  =
  b_0
erlps__decision_op__3 [(ErlangAtom "||"), (ErlangAtom "true"), _]
  =
  ErlangAtom "true"
erlps__decision_op__3 [op_0,
                       (ErlangTuple [(ErlangAtom "if"), a_1, then_2, else_3]),
                       b_4]
  =
  let    tup_el_7 = erlps__decision_op__3 [op_0, then_2, b_4]
  in let tup_el_11 = erlps__decision_op__3 [op_0, else_3, b_4]
  in ErlangTuple [ErlangAtom "if", a_1, tup_el_7, tup_el_11]
erlps__decision_op__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__decision_op__3 args =
  EXC.badarity (ErlangFun 3 erlps__decision_op__3) args

erlps__expr_to_decision_tree__2 :: ErlangFun
erlps__expr_to_decision_tree__2 [env_0,
                                 (ErlangTuple [(ErlangAtom "app"), _ann_1,
                                               (ErlangTuple [op_2, _]),
                                               (ErlangCons a_3 (ErlangCons b_4 (ErlangEmptyList)))])]
  | (weakEq op_2 (ErlangAtom "&&")) ||
      (weakEq op_2 (ErlangAtom "||")) =
  let    arg_6 = erlps__expr_to_decision_tree__2 [env_0, a_3]
  in let arg_9 = erlps__expr_to_decision_tree__2 [env_0, b_4]
  in erlps__decision_op__3 [op_2, arg_6, arg_9]
erlps__expr_to_decision_tree__2 [env_0,
                                 (ErlangTuple [(ErlangAtom "typed"), _, expr_1,
                                               _])]
  =
  erlps__expr_to_decision_tree__2 [env_0, expr_1]
erlps__expr_to_decision_tree__2 [env_0, expr_1] =
  let tup_el_3 = erlps__expr_to_fcode__2 [env_0, expr_1]
  in ErlangTuple [ErlangAtom "atom", tup_el_3]
erlps__expr_to_decision_tree__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__expr_to_decision_tree__2 args =
  EXC.badarity (ErlangFun 2 erlps__expr_to_decision_tree__2) args

erlps__decision_tree_to_fcode__1 :: ErlangFun
erlps__decision_tree_to_fcode__1 [(ErlangAtom "false")] =
  let
    tup_el_1 = ErlangTuple [ErlangAtom "bool", ErlangAtom "false"]
  in ErlangTuple [ErlangAtom "lit", tup_el_1]
erlps__decision_tree_to_fcode__1 [(ErlangAtom "true")] =
  let tup_el_1 = ErlangTuple [ErlangAtom "bool", ErlangAtom "true"]
  in ErlangTuple [ErlangAtom "lit", tup_el_1]
erlps__decision_tree_to_fcode__1 [(ErlangTuple [(ErlangAtom "atom"),
                                                b_0])]
  =
  b_0
erlps__decision_tree_to_fcode__1 [(ErlangTuple [(ErlangAtom "if"),
                                                a_0, then_1, else_2])]
  =
  let    x_3 = erlps__fresh_name__0 []
  in let
    tup_el_16 = ErlangTuple [ErlangAtom "bool", ErlangAtom "false"]
  in let tup_el_21 = erlps__decision_tree_to_fcode__1 [else_2]
  in let tup_el_19 = ErlangTuple [ErlangAtom "nosplit", tup_el_21]
  in let
    head_14 = ErlangTuple [ErlangAtom "case", tup_el_16, tup_el_19]
  in let
    tup_el_26 = ErlangTuple [ErlangAtom "bool", ErlangAtom "true"]
  in let tup_el_31 = erlps__decision_tree_to_fcode__1 [then_1]
  in let tup_el_29 = ErlangTuple [ErlangAtom "nosplit", tup_el_31]
  in let
    head_24 = ErlangTuple [ErlangAtom "case", tup_el_26, tup_el_29]
  in let
    tup_el_9 =
      ErlangTuple
        [ErlangAtom "split", ErlangAtom "boolean", x_3,
         ErlangCons head_14 (ErlangCons head_24 ErlangEmptyList)]
  in let tup_el_7 = ErlangTuple [ErlangAtom "switch", tup_el_9]
  in ErlangTuple [ErlangAtom "let", x_3, a_0, tup_el_7]
erlps__decision_tree_to_fcode__1 [arg_34] =
  EXC.function_clause unit
erlps__decision_tree_to_fcode__1 args =
  EXC.badarity (ErlangFun 1 erlps__decision_tree_to_fcode__1) args

erlps__stmts_to_fcode__2 :: ErlangFun
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons (ErlangTuple [(ErlangAtom "letval"), _,
                                                    (ErlangTuple [(ErlangAtom "typed"),
                                                                  _,
                                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                x_1]),
                                                                  _]),
                                                    expr_2]) stmts_3)]
  =
  let    tup_el_6 = erlps__expr_to_fcode__2 [env_0, expr_2]
  in let arg_10 = erlps__bind_var__2 [env_0, x_1]
  in let tup_el_9 = erlps__stmts_to_fcode__2 [arg_10, stmts_3]
  in ErlangTuple [ErlangAtom "let", x_1, tup_el_6, tup_el_9]
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons (ErlangTuple [(ErlangAtom "letval"),
                                                    ann_1, pat_2,
                                                    expr_3]) stmts_4)]
  =
  let   
    tup_el_15 = ErlangTuple [ErlangAtom "block", ann_1, stmts_4]
  in let
    head_11 =
      ErlangTuple [ErlangAtom "case", ann_1, pat_2, tup_el_15]
  in let
    arg_6 =
      ErlangTuple
        [ErlangAtom "switch", ann_1, expr_3,
         ErlangCons head_11 ErlangEmptyList]
  in erlps__expr_to_fcode__2 [env_0, arg_6]
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons (ErlangTuple [(ErlangAtom "letfun"),
                                                    ann_1,
                                                    (ErlangTuple [(ErlangAtom "id"),
                                                                  _, x_2]),
                                                    args_3, _type_4,
                                                    expr_5]) stmts_6)]
  =
  let   
    lamargs_22 =
      flmap
        (\ lc_9 ->
           let
             lcRet_10 =
               case lc_9 of
                 (ErlangTuple [(ErlangAtom "typed"), ann1_12, id_13, t_14]) ->
                   ErlangTuple [ErlangAtom "arg", ann1_12, id_13, t_14]
                 _ ->
                   let arg_19 = ErlangTuple [ErlangAtom "bad_arg", lc_9]
                   in erlps__internal_error__1 [arg_19]
           in ErlangCons lcRet_10 ErlangEmptyList)
        args_3
  in let
    arg_27 =
      ErlangTuple [ErlangAtom "lam", ann_1, lamargs_22, expr_5]
  in let tup_el_25 = erlps__expr_to_fcode__2 [env_0, arg_27]
  in let arg_33 = erlps__bind_var__2 [env_0, x_2]
  in let tup_el_32 = erlps__stmts_to_fcode__2 [arg_33, stmts_6]
  in ErlangTuple [ErlangAtom "let", x_2, tup_el_25, tup_el_32]
erlps__stmts_to_fcode__2 [env_0,
                          (ErlangCons expr_1 (ErlangEmptyList))]
  =
  erlps__expr_to_fcode__2 [env_0, expr_1]
erlps__stmts_to_fcode__2 [env_0, (ErlangCons expr_1 stmts_2)] =
  let    tup_el_4 = toErl "_"
  in let tup_el_5 = erlps__expr_to_fcode__2 [env_0, expr_1]
  in let tup_el_8 = erlps__stmts_to_fcode__2 [env_0, stmts_2]
  in ErlangTuple [ErlangAtom "let", tup_el_4, tup_el_5, tup_el_8]
erlps__stmts_to_fcode__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__stmts_to_fcode__2 args =
  EXC.badarity (ErlangFun 2 erlps__stmts_to_fcode__2) args

erlps__op_builtins__0 :: ErlangFun
erlps__op_builtins__0 [] =
  ErlangCons (ErlangAtom "map_from_list")
    (ErlangCons (ErlangAtom "map_to_list")
       (ErlangCons (ErlangAtom "map_delete")
          (ErlangCons (ErlangAtom "map_member")
             (ErlangCons (ErlangAtom "map_size")
                (ErlangCons (ErlangAtom "string_length")
                   (ErlangCons (ErlangAtom "string_concat")
                      (ErlangCons (ErlangAtom "string_sha3")
                         (ErlangCons (ErlangAtom "string_sha256")
                            (ErlangCons (ErlangAtom "string_blake2b")
                               (ErlangCons (ErlangAtom "bits_set")
                                  (ErlangCons (ErlangAtom "bits_clear")
                                     (ErlangCons (ErlangAtom "bits_test")
                                        (ErlangCons (ErlangAtom "bits_sum")
                                           (ErlangCons
                                              (ErlangAtom "bits_intersection")
                                              (ErlangCons
                                                 (ErlangAtom "bits_union")
                                                 (ErlangCons
                                                    (ErlangAtom
                                                       "bits_difference")
                                                    (ErlangCons
                                                       (ErlangAtom "int_to_str")
                                                       (ErlangCons
                                                          (ErlangAtom
                                                             "address_to_str")
                                                          (ErlangCons
                                                             (ErlangAtom
                                                                "crypto_verify_sig")
                                                             (ErlangCons
                                                                (ErlangAtom
                                                                   "address_to_contract")
                                                                (ErlangCons
                                                                   (ErlangAtom
                                                                      "crypto_verify_sig_secp256k1")
                                                                   (ErlangCons
                                                                      (ErlangAtom
                                                                         "crypto_sha3")
                                                                      (ErlangCons
                                                                         (ErlangAtom
                                                                            "crypto_sha256")
                                                                         (ErlangCons
                                                                            (ErlangAtom
                                                                               "crypto_blake2b")
                                                                            (ErlangCons
                                                                               (ErlangAtom
                                                                                  "crypto_ecverify_secp256k1")
                                                                               (ErlangCons
                                                                                  (ErlangAtom
                                                                                     "crypto_ecrecover_secp256k1")
                                                                                  ErlangEmptyList))))))))))))))))))))))))))
erlps__op_builtins__0 args =
  EXC.badarity (ErlangFun 0 erlps__op_builtins__0) args

erlps__set_state__2 :: ErlangFun
erlps__set_state__2 [(ErlangTuple [(ErlangAtom "reg"), r_0]),
                     val_1]
  =
  ErlangTuple [ErlangAtom "set_state", r_0, val_1]
erlps__set_state__2 [(ErlangTuple [(ErlangAtom "tuple"), ls_0]),
                     val_1]
  =
  let
    arg_3 =
      ErlangFun 1
        (let
           lambda_4 [x_6] =
             let   
               arg_7 =
                 ErlangFun 2
                   (let
                      lambda_8 [(ErlangTuple [i_11, l_12]), code_13] =
                        let    tup_el_15 = toErl "_"
                        in let rop_23 = toErl 1
                        in let tup_el_21 = BIF.erlang__op_minus [i_11, rop_23]
                        in let
                          arg_18 =
                            ErlangTuple [ErlangAtom "proj", x_6, tup_el_21]
                        in let tup_el_16 = erlps__set_state__2 [l_12, arg_18]
                        in
                          ErlangTuple
                            [ErlangAtom "let", tup_el_15, tup_el_16, code_13]
                      lambda_8 [arg_9, arg_10] = EXC.function_clause unit
                      lambda_8 args = EXC.badarity (ErlangFun 2 lambda_8) args
                    in lambda_8)
             in let arg_25 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
             in let arg_28 = erlps__indexed__1 [ls_0]
             in
               BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
                 [arg_7, arg_25, arg_28]
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in erlps__make_let__2 [val_1, arg_3]
erlps__set_state__2 [arg_30, arg_31] = EXC.function_clause unit
erlps__set_state__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_state__2) args

erlps__get_state__1 :: ErlangFun
erlps__get_state__1 [(ErlangTuple [(ErlangAtom "reg"), r_0])] =
  ErlangTuple [ErlangAtom "get_state", r_0]
erlps__get_state__1 [(ErlangTuple [(ErlangAtom "tuple"), ls_0])]
  =
  let
    tup_el_2 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = erlps__get_state__1 [lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        ls_0
  in ErlangTuple [ErlangAtom "tuple", tup_el_2]
erlps__get_state__1 [arg_8] = EXC.function_clause unit
erlps__get_state__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_state__1) args

erlps__builtin_to_fcode__3 :: ErlangFun
erlps__builtin_to_fcode__3 [layout_0, (ErlangAtom "set_state"),
                            (ErlangCons val_1 (ErlangEmptyList))]
  =
  erlps__set_state__2 [layout_0, val_1]
erlps__builtin_to_fcode__3 [layout_0, (ErlangAtom "get_state"),
                            (ErlangEmptyList)]
  =
  erlps__get_state__1 [layout_0]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "require"),
                            (ErlangCons cond_1 (ErlangCons msg_2 (ErlangEmptyList)))]
  =
  let    arg_4 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "builtin", ErlangAtom "abort",
         ErlangCons msg_2 ErlangEmptyList]
  in erlps__make_if__3 [cond_1, arg_4, arg_7]
erlps__builtin_to_fcode__3 [_layout_0,
                            (ErlangAtom "chain_event"),
                            (ErlangCons event_1 (ErlangEmptyList))]
  =
  ErlangTuple
    [ErlangAtom "def", ErlangAtom "event",
     ErlangCons event_1 ErlangEmptyList]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "map_delete"),
                            (ErlangCons key_1 (ErlangCons map_2 (ErlangEmptyList)))]
  =
  ErlangTuple
    [ErlangAtom "op", ErlangAtom "map_delete",
     ErlangCons map_2 (ErlangCons key_1 ErlangEmptyList)]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "map_member"),
                            (ErlangCons key_1 (ErlangCons map_2 (ErlangEmptyList)))]
  =
  ErlangTuple
    [ErlangAtom "op", ErlangAtom "map_member",
     ErlangCons map_2 (ErlangCons key_1 ErlangEmptyList)]
erlps__builtin_to_fcode__3 [_layout_0, (ErlangAtom "map_lookup"),
                            (ErlangCons key0_1 (ErlangCons map0_2 (ErlangEmptyList)))]
  =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [key_7] =
             let
               arg_9 =
                 ErlangFun 1
                   (let
                      lambda_10 [map_12] =
                        let   
                          arg_13 =
                            ErlangTuple
                              [ErlangAtom "op", ErlangAtom "map_member",
                               ErlangCons map_12
                                 (ErlangCons key_7 ErlangEmptyList)]
                        in let head_24 = toErl 0
                        in let head_26 = toErl 1
                        in let tup_el_28 = toErl 1
                        in let
                          head_30 =
                            ErlangTuple
                              [ErlangAtom "op", ErlangAtom "map_get",
                               ErlangCons map_12
                                 (ErlangCons key_7 ErlangEmptyList)]
                        in let
                          arg_21 =
                            ErlangTuple
                              [ErlangAtom "con",
                               ErlangCons head_24
                                 (ErlangCons head_26 ErlangEmptyList),
                               tup_el_28, ErlangCons head_30 ErlangEmptyList]
                        in let head_42 = toErl 0
                        in let head_44 = toErl 1
                        in let tup_el_46 = toErl 0
                        in let
                          arg_39 =
                            ErlangTuple
                              [ErlangAtom "con",
                               ErlangCons head_42
                                 (ErlangCons head_44 ErlangEmptyList),
                               tup_el_46, ErlangEmptyList]
                        in erlps__make_if__3 [arg_13, arg_21, arg_39]
                      lambda_10 [arg_11] = EXC.function_clause unit
                      lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
                    in lambda_10)
             in erlps__make_let__2 [map0_2, arg_9]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__make_let__2 [key0_1, arg_4]
erlps__builtin_to_fcode__3 [_layout_0,
                            (ErlangAtom "map_lookup_default"),
                            (ErlangCons key_1 (ErlangCons map_2 (ErlangCons def_3 (ErlangEmptyList))))]
  =
  ErlangTuple
    [ErlangAtom "op", ErlangAtom "map_get_d",
     ErlangCons map_2
       (ErlangCons key_1 (ErlangCons def_3 ErlangEmptyList))]
erlps__builtin_to_fcode__3 [_layout_0, builtin_1, args_2] =
  let    arg_5 = erlps__op_builtins__0 []
  in let case_3 = BIF.lists__member__2 [builtin_1, arg_5]
  in
    case case_3 of
      (ErlangAtom "true") ->
        ErlangTuple [ErlangAtom "op", builtin_1, args_2]
      (ErlangAtom "false") ->
        ErlangTuple [ErlangAtom "builtin", builtin_1, args_2]
      something_else -> EXC.case_clause something_else
erlps__builtin_to_fcode__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__builtin_to_fcode__3 args =
  EXC.badarity (ErlangFun 3 erlps__builtin_to_fcode__3) args

erlps__add_init_function__4 :: ErlangFun
erlps__add_init_function__4 [env_0, main_1, statetype_2, funs0_3]
  =
  let case_4 = erlps__is_no_code__1 [env_0]
  in
    case case_4 of
      (ErlangAtom "true") -> funs0_3
      (ErlangAtom "false") ->
        let   
          funs_10 =
            erlps__add_default_init_function__4
              [env_0, main_1, statetype_2, funs0_3]
        in let
          tup_el_12 =
            ErlangBinary (BIN.fromInts (toErl "init") (toErl 8) 1 BIN.Big)
        in let
          initname_13 = ErlangTuple [ErlangAtom "entrypoint", tup_el_12]
        in let matchExpr_18 = BIF.maps__get__2 [initname_13, funs_10]
        in
          case matchExpr_18 of
            (ErlangMap map_16) | (DM.Just initbody_17) <-
                                   (Map.lookup (ErlangAtom "body") map_16) ->
              let    val_26 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
              in let arg_30 = erlps__state_layout__1 [env_0]
              in let
                val_29 =
                  erlps__builtin_to_fcode__3
                    [arg_30, ErlangAtom "set_state",
                     ErlangCons initbody_17 ErlangEmptyList]
              in let
                mapExt_36 =
                  ErlangMap
                    (Map.fromFoldable
                       [DT.Tuple (ErlangAtom "return") val_26,
                        DT.Tuple (ErlangAtom "body") val_29])
              in let val_22 = BIF.maps__merge__2 [matchExpr_18, mapExt_36]
              in let mapExt_38 = ErlangMap (Map.singleton initname_13 val_22)
              in let funs1_40 = BIF.maps__merge__2 [funs_10, mapExt_38]
              in funs1_40
            _ -> EXC.badmatch matchExpr_18
      something_else -> EXC.case_clause something_else
erlps__add_init_function__4 [arg_41, arg_42, arg_43, arg_44] =
  EXC.function_clause unit
erlps__add_init_function__4 args =
  EXC.badarity (ErlangFun 4 erlps__add_init_function__4) args

erlps__add_default_init_function__4 :: ErlangFun
erlps__add_default_init_function__4 [_env_0, main_1, statetype_2,
                                     funs_3]
  =
  let   
    tup_el_5 =
      ErlangBinary (BIN.fromInts (toErl "init") (toErl 8) 1 BIN.Big)
  in let
    initname_6 = ErlangTuple [ErlangAtom "entrypoint", tup_el_5]
  in let
    case_7 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [initname_6, funs_3, ErlangAtom "none"]
  in
    case case_7 of
      (ErlangAtom "none") | (ErlangAtom "true") ==
                              (falsifyErrors
                                 (\ _ ->
                                    let
                                      rop_12 =
                                        ErlangTuple
                                          [ErlangAtom "tuple", ErlangEmptyList]
                                    in
                                      BIF.erlang__op_eq
                                        [statetype_2, rop_12])) ->
        let    val_24 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
        in let val_27 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
        in let
          val_17 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "attrs") ErlangEmptyList,
                  DT.Tuple (ErlangAtom "args") ErlangEmptyList,
                  DT.Tuple (ErlangAtom "return") val_24,
                  DT.Tuple (ErlangAtom "body") val_27])
        in let mapExt_30 = ErlangMap (Map.singleton initname_6 val_17)
        in BIF.maps__merge__2 [funs_3, mapExt_30]
      (ErlangAtom "none") ->
        let
          arg_32 = ErlangTuple [ErlangAtom "missing_init_function", main_1]
        in erlps__fcode_error__1 [arg_32]
      _ -> funs_3
erlps__add_default_init_function__4 [arg_35, arg_36, arg_37,
                                     arg_38]
  =
  EXC.function_clause unit
erlps__add_default_init_function__4 args =
  EXC.badarity (ErlangFun 4 erlps__add_default_init_function__4)
    args

erlps__add_event_function__3 :: ErlangFun
erlps__add_event_function__3 [_env_0, (ErlangAtom "none"),
                              funs_1]
  =
  funs_1
erlps__add_event_function__3 [env_0, eventftype_1, funs_2] =
  let    val_5 = erlps__event_function__2 [env_0, eventftype_1]
  in let
    mapExt_8 = ErlangMap (Map.singleton (ErlangAtom "event") val_5)
  in BIF.maps__merge__2 [funs_2, mapExt_8]
erlps__add_event_function__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__add_event_function__3 args =
  EXC.badarity (ErlangFun 3 erlps__add_event_function__3) args

erlps__event_function__2 :: ErlangFun
erlps__event_function__2 [_env_2@(ErlangMap map_0),
                          eventtype_4@(ErlangTuple [(ErlangAtom "variant"),
                                                    fcons_3])]
  | (DM.Just (ErlangTuple [(ErlangAtom "variant_t"),
                           eventcons_1])) <-
      (Map.lookup (ErlangAtom "event_type") map_0) =
  let    lcSrc_5 = erlps__indexed__1 [eventcons_1]
  in let
    cons_19 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [i_7,
                           (ErlangTuple [(ErlangAtom "constr_t"), ann_8,
                                         (ErlangTuple [(ErlangAtom "con"), _,
                                                       name_9]),
                                         _])]) ->
               let    rop_15 = toErl 1
               in let tup_el_13 = BIF.erlang__op_minus [i_7, rop_15]
               in let
                 tup_el_16 =
                   BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
                     [ErlangAtom "indices", ann_8]
               in let lcRet_11 = ErlangTuple [name_9, tup_el_13, tup_el_16]
               in ErlangCons lcRet_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in let
    arities_25 =
      flmap
        (\ lc_22 ->
           let lcRet_23 = BIF.erlang__length__1 [lc_22]
           in ErlangCons lcRet_23 ErlangEmptyList)
        fcons_3
  in let
    case_92 =
      ErlangFun 1
        (let
           lambda_26 [(ErlangTuple [name_28, tag_29, ixs_30])] =
             let    arg_31 = toErl 32
             in let arg_32 = BIF.erlang__list_to_binary__1 [name_28]
             in let
               matchExpr_35 =
                 BIF.do_remote_fun_call "Eblake2" "erlps__blake2b__2"
                   [arg_31, arg_32]
             in
               case matchExpr_35 of
                 (ErlangTuple [(ErlangAtom "ok"), hashvalue_34]) ->
                   let   
                     tup_el_37 = ErlangTuple [ErlangAtom "bytes", hashvalue_34]
                   in let hash_40 = ErlangTuple [ErlangAtom "lit", tup_el_37]
                   in let arg_42 = toErl 1
                   in let arg_43 = BIF.erlang__length__1 [ixs_30]
                   in let
                     lcSrc_41 =
                       BIF.do_remote_fun_call "Lists" "erlps__seq__2"
                         [arg_42, arg_43]
                   in let
                     vars_51 =
                       flmap
                         (\ lc_46 ->
                            let    lop_48 = toErl "arg"
                            in let
                              rop_49 = BIF.erlang__integer_to_list__1 [lc_46]
                            in let
                              lcRet_47 = BIF.erlang__op_append [lop_48, rop_49]
                            in ErlangCons lcRet_47 ErlangEmptyList)
                         lcSrc_41
                   in let
                     ivars_54 =
                       BIF.do_remote_fun_call "Lists" "erlps__zip__2"
                         [ixs_30, vars_51]
                   in let
                     case_55 =
                       flmap
                         (\ lc_58 ->
                            case lc_58 of
                              (ErlangTuple [(ErlangAtom "notindexed"), v_57]) ->
                                ErlangCons v_57 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         ivars_54
                   in let
                     payload_67 =
                       case case_55 of
                         (ErlangEmptyList) ->
                           let    tup_el_63 = ErlangBinary (BIN.concat [])
                           in let
                             tup_el_61 =
                               ErlangTuple [ErlangAtom "string", tup_el_63]
                           in ErlangTuple [ErlangAtom "lit", tup_el_61]
                         (ErlangCons v_64 (ErlangEmptyList)) ->
                           ErlangTuple [ErlangAtom "var", v_64]
                         something_else -> EXC.case_clause something_else
                   in let
                     indices_74 =
                       flmap
                         (\ lc_70 ->
                            case lc_70 of
                              (ErlangTuple [(ErlangAtom "indexed"), v_69]) ->
                                let
                                  lcRet_71 =
                                    ErlangTuple [ErlangAtom "var", v_69]
                                in ErlangCons lcRet_71 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         ivars_54
                   in let
                     body_82 =
                       ErlangTuple
                         [ErlangAtom "builtin", ErlangAtom "chain_event",
                          ErlangCons payload_67 (ErlangCons hash_40 indices_74)]
                   in let
                     tup_el_84 =
                       ErlangTuple
                         [ErlangAtom "con", arities_25, tag_29, vars_51]
                   in let
                     tup_el_89 = ErlangTuple [ErlangAtom "nosplit", body_82]
                   in ErlangTuple [ErlangAtom "case", tup_el_84, tup_el_89]
                 _ -> EXC.badmatch matchExpr_35
           lambda_26 [arg_27] = EXC.function_clause unit
           lambda_26 args = EXC.badarity (ErlangFun 1 lambda_26) args
         in lambda_26)
  in let tup_el_102 = toErl "e"
  in let head_101 = ErlangTuple [tup_el_102, eventtype_4]
  in let
    val_105 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
  in let tup_el_113 = toErl "e"
  in let
    tup_el_114 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [case_92, cons_19]
  in let
    tup_el_110 =
      ErlangTuple
        [ErlangAtom "split", eventtype_4, tup_el_113, tup_el_114]
  in let val_108 = ErlangTuple [ErlangAtom "switch", tup_el_110]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "attrs")
            (ErlangCons (ErlangAtom "private") ErlangEmptyList),
          DT.Tuple (ErlangAtom "args")
            (ErlangCons head_101 ErlangEmptyList),
          DT.Tuple (ErlangAtom "return") val_105,
          DT.Tuple (ErlangAtom "body") val_108])
erlps__event_function__2 [arg_117, arg_118] =
  EXC.function_clause unit
erlps__event_function__2 args =
  EXC.badarity (ErlangFun 2 erlps__event_function__2) args

erlps__lambda_lift__1 :: ErlangFun
erlps__lambda_lift__1 [fcode_3@(ErlangMap map_0)]
  | (DM.Just statelayout_2) <-
      (Map.lookup (ErlangAtom "state_layout") map_0)
  , (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    _ = erlps__init_lambda_funs__0 []
  in let
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [_, body_8] =
             erlps__lambda_lift_fun__2 [statelayout_2, body_8]
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let
    funs1_12 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_4, funs_1]
  in let newfuns_13 = erlps__get_lambda_funs__0 []
  in let val_16 = BIF.maps__merge__2 [funs1_12, newfuns_13]
  in let
    mapExt_19 =
      ErlangMap (Map.singleton (ErlangAtom "functions") val_16)
  in
    case findMissingKey fcode_3 [ErlangAtom "functions"] of
      (DM.Nothing) -> BIF.maps__merge__2 [fcode_3, mapExt_19]
      (DM.Just missing_21) -> EXC.badkey missing_21
erlps__lambda_lift__1 [arg_22] = EXC.function_clause unit
erlps__lambda_lift__1 args =
  EXC.badarity (ErlangFun 1 erlps__lambda_lift__1) args

erlps__init_lambda_funs__0 :: ErlangFun
erlps__init_lambda_funs__0 [] =
  let arg_1 = ErlangMap Map.empty
  in BIF.erlang__put__2 [ErlangAtom "%lambdalifted", arg_1]
erlps__init_lambda_funs__0 args =
  EXC.badarity (ErlangFun 0 erlps__init_lambda_funs__0) args

erlps__get_lambda_funs__0 :: ErlangFun
erlps__get_lambda_funs__0 [] =
  BIF.erlang__erase__1 [ErlangAtom "%lambdalifted"]
erlps__get_lambda_funs__0 args =
  EXC.badarity (ErlangFun 0 erlps__get_lambda_funs__0) args

erlps__add_lambda_fun__1 :: ErlangFun
erlps__add_lambda_fun__1 [def_0] =
  let    name_1 = erlps__fresh_fun__0 []
  in let funs_3 = BIF.erlang__get__1 [ErlangAtom "%lambdalifted"]
  in let mapExt_9 = ErlangMap (Map.singleton name_1 def_0)
  in let arg_5 = BIF.maps__merge__2 [funs_3, mapExt_9]
  in let _ = BIF.erlang__put__2 [ErlangAtom "%lambdalifted", arg_5]
  in name_1
erlps__add_lambda_fun__1 [arg_11] = EXC.function_clause unit
erlps__add_lambda_fun__1 args =
  EXC.badarity (ErlangFun 1 erlps__add_lambda_fun__1) args

erlps__lambda_lift_fun__2 :: ErlangFun
erlps__lambda_lift_fun__2 [layout_0, def_3@(ErlangMap map_1)]
  | (DM.Just body_2) <- (Map.lookup (ErlangAtom "body") map_1) =
  let    val_6 = erlps__lambda_lift_expr__2 [layout_0, body_2]
  in let
    mapExt_9 = ErlangMap (Map.singleton (ErlangAtom "body") val_6)
  in
    case findMissingKey def_3 [ErlangAtom "body"] of
      (DM.Nothing) -> BIF.maps__merge__2 [def_3, mapExt_9]
      (DM.Just missing_11) -> EXC.badkey missing_11
erlps__lambda_lift_fun__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__lambda_lift_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__lambda_lift_fun__2) args

erlps__lifted_fun__3 :: ErlangFun
erlps__lifted_fun__3 [(ErlangCons z_0 (ErlangEmptyList)), xs_1,
                      body_2]
  =
  let    head_11 = ErlangTuple [z_0, ErlangAtom "any"]
  in let
    tail_14 =
      flmap
        (\ lc_17 ->
           let lcRet_18 = ErlangTuple [lc_17, ErlangAtom "any"]
           in ErlangCons lcRet_18 ErlangEmptyList)
        xs_1
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "attrs")
            (ErlangCons (ErlangAtom "private") ErlangEmptyList),
          DT.Tuple (ErlangAtom "args") (ErlangCons head_11 tail_14),
          DT.Tuple (ErlangAtom "return") (ErlangAtom "any"),
          DT.Tuple (ErlangAtom "body") body_2])
erlps__lifted_fun__3 [fvs_0, xs_1, body_2] =
  let    z_3 = toErl "%env"
  in let
    proj_21 =
      ErlangFun 2
        (let
           lambda_4 [(ErlangTuple [i_7, y_8]), e_9] =
             let    tup_el_14 = ErlangTuple [ErlangAtom "var", z_3]
             in let rop_19 = toErl 1
             in let tup_el_17 = BIF.erlang__op_minus [i_7, rop_19]
             in let
               tup_el_12 = ErlangTuple [ErlangAtom "proj", tup_el_14, tup_el_17]
             in ErlangTuple [ErlangAtom "let", y_8, tup_el_12, e_9]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in let head_30 = ErlangTuple [z_3, ErlangAtom "any"]
  in let
    tail_33 =
      flmap
        (\ lc_36 ->
           let lcRet_37 = ErlangTuple [lc_36, ErlangAtom "any"]
           in ErlangCons lcRet_37 ErlangEmptyList)
        xs_1
  in let arg_44 = erlps__indexed__1 [fvs_0]
  in let
    val_41 =
      BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
        [proj_21, body_2, arg_44]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "attrs")
            (ErlangCons (ErlangAtom "private") ErlangEmptyList),
          DT.Tuple (ErlangAtom "args") (ErlangCons head_30 tail_33),
          DT.Tuple (ErlangAtom "return") (ErlangAtom "any"),
          DT.Tuple (ErlangAtom "body") val_41])
erlps__lifted_fun__3 [arg_46, arg_47, arg_48] =
  EXC.function_clause unit
erlps__lifted_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__lifted_fun__3) args

erlps__make_closure__3 :: ErlangFun
erlps__make_closure__3 [fvs_0, xs_1, body_2] =
  let    arg_3 = erlps__lifted_fun__3 [fvs_0, xs_1, body_2]
  in let fun_7 = erlps__add_lambda_fun__1 [arg_3]
  in let
    tup_14 =
      ErlangFun 1
        (let
           lambda_8 [(ErlangCons y_10 (ErlangEmptyList))] = y_10
           lambda_8 [ys_11] = ErlangTuple [ErlangAtom "tuple", ys_11]
           lambda_8 [arg_9] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
         in lambda_8)
  in let
    arg_18 =
      flmap
        (\ lc_21 ->
           let lcRet_22 = ErlangTuple [ErlangAtom "var", lc_21]
           in ErlangCons lcRet_22 ErlangEmptyList)
        fvs_0
  in let
    tup_el_17 =
      BIF.erlang__apply__2 [tup_14, ErlangCons arg_18 ErlangEmptyList]
  in ErlangTuple [ErlangAtom "closure", fun_7, tup_el_17]
erlps__make_closure__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__make_closure__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_closure__3) args

erlps__lambda_lift_expr__2 :: ErlangFun
erlps__lambda_lift_expr__2 [layout_0,
                            (ErlangTuple [(ErlangAtom "lam"), xs_1, body_2])]
  =
  let    arg_3 = ErlangTuple [ErlangAtom "lam", xs_1, body_2]
  in let fvs_7 = erlps__free_vars__1 [arg_3]
  in let arg_10 = erlps__lambda_lift_expr__2 [layout_0, body_2]
  in erlps__make_closure__3 [fvs_7, xs_1, arg_10]
erlps__lambda_lift_expr__2 [layout_0, uexpr_1]
  | (onElement (toErl 1) uexpr_1 weakEq (ErlangAtom "def_u")) ||
      (onElement (toErl 1) uexpr_1 weakEq (ErlangAtom "builtin_u")) =
  let matchExpr_6 = BIF.erlang__tuple_to_list__1 [uexpr_1]
  in
    case matchExpr_6 of
      (ErlangCons tag_3 (ErlangCons f_4 (ErlangCons ar_5 _))) ->
        let   
          extraargs_9 =
            case uexpr_1 of
              (ErlangTuple [(ErlangAtom "builtin_u"), _, _, typeargs_8]) ->
                typeargs_8
              _ -> ErlangEmptyList
        in let arg_11 = toErl 1
        in let
          lcSrc_10 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_11, ar_5]
        in let
          xs_21 =
            flmap
              (\ lc_14 ->
                 let    head_17 = toErl "arg"
                 in let
                   lcRet_15 =
                     BIF.do_remote_fun_call "Lists" "erlps__concat__1"
                       [ErlangCons head_17 (ErlangCons lc_14 ErlangEmptyList)]
                 in ErlangCons lcRet_15 ErlangEmptyList)
              lcSrc_10
        in let
          lop_22 =
            flmap
              (\ lc_25 ->
                 let lcRet_26 = ErlangTuple [ErlangAtom "var", lc_25]
                 in ErlangCons lcRet_26 ErlangEmptyList)
              xs_21
        in let args_30 = BIF.erlang__op_append [lop_22, extraargs_9]
        in let
          body_38 =
            case tag_3 of
              (ErlangAtom "builtin_u") ->
                erlps__builtin_to_fcode__3 [layout_0, f_4, args_30]
              (ErlangAtom "def_u") ->
                ErlangTuple [ErlangAtom "def", f_4, args_30]
              something_else -> EXC.case_clause something_else
        in erlps__make_closure__3 [ErlangEmptyList, xs_21, body_38]
      _ -> EXC.badmatch matchExpr_6
erlps__lambda_lift_expr__2 [layout_0,
                            (ErlangTuple [(ErlangAtom "remote_u"), argst_1,
                                          rett_2, ct_3, f_4])]
  =
  let    fvs_6 = erlps__free_vars__1 [ct_3]
  in let ct1_9 = erlps__lambda_lift_expr__2 [layout_0, ct_3]
  in let gasandvalueargs_10 = toErl 2
  in let arg_12 = toErl 1
  in let lop_14 = BIF.erlang__length__1 [argst_1]
  in let arg_13 = BIF.erlang__op_plus [lop_14, gasandvalueargs_10]
  in let
    lcSrc_11 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_12, arg_13]
  in let
    xs_25 =
      flmap
        (\ lc_18 ->
           let    head_21 = toErl "arg"
           in let
             lcRet_19 =
               BIF.do_remote_fun_call "Lists" "erlps__concat__1"
                 [ErlangCons head_21 (ErlangCons lc_18 ErlangEmptyList)]
           in ErlangCons lcRet_19 ErlangEmptyList)
        lcSrc_11
  in let
    args_32 =
      flmap
        (\ lc_28 ->
           let lcRet_29 = ErlangTuple [ErlangAtom "var", lc_28]
           in ErlangCons lcRet_29 ErlangEmptyList)
        xs_25
  in let
    arg_35 =
      ErlangTuple
        [ErlangAtom "remote", argst_1, rett_2, ct1_9, f_4, args_32]
  in erlps__make_closure__3 [fvs_6, xs_25, arg_35]
erlps__lambda_lift_expr__2 [layout_0, expr_1] =
  case expr_1 of
    (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_1
    (ErlangAtom "nil") -> expr_1
    (ErlangTuple [(ErlangAtom "var"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "closure"), _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "def"), d_3, as_4]) ->
      let tup_el_7 = erlps__lambda_lift_exprs__2 [layout_0, as_4]
      in ErlangTuple [ErlangAtom "def", d_3, tup_el_7]
    (ErlangTuple [(ErlangAtom "builtin"), b_10, as_11]) ->
      let tup_el_14 = erlps__lambda_lift_exprs__2 [layout_0, as_11]
      in ErlangTuple [ErlangAtom "builtin", b_10, tup_el_14]
    (ErlangTuple [(ErlangAtom "remote"), argst_17, rett_18, ct_19,
                  f_20, as_21]) ->
      let    tup_el_25 = erlps__lambda_lift_expr__2 [layout_0, ct_19]
      in let tup_el_29 = erlps__lambda_lift_exprs__2 [layout_0, as_21]
      in
        ErlangTuple
          [ErlangAtom "remote", argst_17, rett_18, tup_el_25, f_20,
           tup_el_29]
    (ErlangTuple [(ErlangAtom "con"), ar_32, c_33, as_34]) ->
      let tup_el_38 = erlps__lambda_lift_exprs__2 [layout_0, as_34]
      in ErlangTuple [ErlangAtom "con", ar_32, c_33, tup_el_38]
    (ErlangTuple [(ErlangAtom "tuple"), as_41]) ->
      let tup_el_43 = erlps__lambda_lift_exprs__2 [layout_0, as_41]
      in ErlangTuple [ErlangAtom "tuple", tup_el_43]
    (ErlangTuple [(ErlangAtom "proj"), a_46, i_47]) ->
      let tup_el_49 = erlps__lambda_lift_expr__2 [layout_0, a_46]
      in ErlangTuple [ErlangAtom "proj", tup_el_49, i_47]
    (ErlangTuple [(ErlangAtom "set_proj"), a_53, i_54, b_55]) ->
      let    tup_el_57 = erlps__lambda_lift_expr__2 [layout_0, a_53]
      in let tup_el_61 = erlps__lambda_lift_expr__2 [layout_0, b_55]
      in
        ErlangTuple [ErlangAtom "set_proj", tup_el_57, i_54, tup_el_61]
    (ErlangTuple [(ErlangAtom "op"), op_64, as_65]) ->
      let tup_el_68 = erlps__lambda_lift_exprs__2 [layout_0, as_65]
      in ErlangTuple [ErlangAtom "op", op_64, tup_el_68]
    (ErlangTuple [(ErlangAtom "let"), x_71, a_72, b_73]) ->
      let    tup_el_76 = erlps__lambda_lift_expr__2 [layout_0, a_72]
      in let tup_el_79 = erlps__lambda_lift_expr__2 [layout_0, b_73]
      in ErlangTuple [ErlangAtom "let", x_71, tup_el_76, tup_el_79]
    (ErlangTuple [(ErlangAtom "funcall"), a_82, bs_83]) ->
      let    tup_el_85 = erlps__lambda_lift_expr__2 [layout_0, a_82]
      in let tup_el_88 = erlps__lambda_lift_exprs__2 [layout_0, bs_83]
      in ErlangTuple [ErlangAtom "funcall", tup_el_85, tup_el_88]
    (ErlangTuple [(ErlangAtom "set_state"), r_91, a_92]) ->
      let tup_el_95 = erlps__lambda_lift_expr__2 [layout_0, a_92]
      in ErlangTuple [ErlangAtom "set_state", r_91, tup_el_95]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "switch"), s_98]) ->
      let tup_el_100 = erlps__lambda_lift_expr__2 [layout_0, s_98]
      in ErlangTuple [ErlangAtom "switch", tup_el_100]
    (ErlangTuple [(ErlangAtom "split"), type_103, x_104,
                  alts_105]) ->
      let tup_el_109 = erlps__lambda_lift_exprs__2 [layout_0, alts_105]
      in ErlangTuple [ErlangAtom "split", type_103, x_104, tup_el_109]
    (ErlangTuple [(ErlangAtom "nosplit"), a_112]) ->
      let tup_el_114 = erlps__lambda_lift_expr__2 [layout_0, a_112]
      in ErlangTuple [ErlangAtom "nosplit", tup_el_114]
    (ErlangTuple [(ErlangAtom "case"), p_117, s_118]) ->
      let tup_el_121 = erlps__lambda_lift_expr__2 [layout_0, s_118]
      in ErlangTuple [ErlangAtom "case", p_117, tup_el_121]
    something_else -> EXC.case_clause something_else
erlps__lambda_lift_expr__2 [arg_124, arg_125] =
  EXC.function_clause unit
erlps__lambda_lift_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__lambda_lift_expr__2) args

erlps__lambda_lift_exprs__2 :: ErlangFun
erlps__lambda_lift_exprs__2 [layout_0, as_1] =
  flmap
    (\ lc_4 ->
       let lcRet_5 = erlps__lambda_lift_expr__2 [layout_0, lc_4]
       in ErlangCons lcRet_5 ErlangEmptyList)
    as_1
erlps__lambda_lift_exprs__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__lambda_lift_exprs__2 args =
  EXC.badarity (ErlangFun 2 erlps__lambda_lift_exprs__2) args

erlps__optimize_fcode__1 :: ErlangFun
erlps__optimize_fcode__1 [code_2@(ErlangMap map_0)]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let   
    arg_6 =
      ErlangFun 2
        (let
           lambda_7 [name_10, def_11] =
             erlps__optimize_fun__3 [code_2, name_10, def_11]
           lambda_7 [arg_8, arg_9] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 2 lambda_7) args
         in lambda_7)
  in let
    val_5 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_6, funs_1]
  in let
    mapExt_16 =
      ErlangMap (Map.singleton (ErlangAtom "functions") val_5)
  in let
    code1_19 =
      case findMissingKey code_2 [ErlangAtom "functions"] of
        (DM.Nothing) -> BIF.maps__merge__2 [code_2, mapExt_16]
        (DM.Just missing_18) -> EXC.badkey missing_18
  in erlps__eliminate_dead_code__1 [code1_19]
erlps__optimize_fcode__1 [arg_21] = EXC.function_clause unit
erlps__optimize_fcode__1 args =
  EXC.badarity (ErlangFun 1 erlps__optimize_fcode__1) args

erlps__optimize_fun__3 :: ErlangFun
erlps__optimize_fun__3 [fcode_0, fun_1, def_4@(ErlangMap map_2)]
  | (DM.Just body_3) <- (Map.lookup (ErlangAtom "body") map_2) =
  let    arg_12 = erlps__inliner__3 [fcode_0, fun_1, body_3]
  in let arg_11 = erlps__inline_local_functions__1 [arg_12]
  in let arg_10 = erlps__bind_subexpressions__1 [arg_11]
  in let arg_9 = erlps__let_floating__1 [arg_10]
  in let arg_8 = erlps__simplifier__1 [arg_9]
  in let val_7 = erlps__drop_unused_lets__1 [arg_8]
  in let
    mapExt_16 = ErlangMap (Map.singleton (ErlangAtom "body") val_7)
  in
    case findMissingKey def_4 [ErlangAtom "body"] of
      (DM.Nothing) -> BIF.maps__merge__2 [def_4, mapExt_16]
      (DM.Just missing_18) -> EXC.badkey missing_18
erlps__optimize_fun__3 [arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__optimize_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__optimize_fun__3) args

erlps__inliner__3 :: ErlangFun
erlps__inliner__3 [fcode_0, fun_1,
                   e_4@(ErlangTuple [(ErlangAtom "def"), fun1_2, args_3])]
  | weakNEq fun1_2 fun_1 =
  let case_5 = erlps__should_inline__2 [fcode_0, fun1_2]
  in
    case case_5 of
      (ErlangAtom "false") -> e_4
      (ErlangAtom "true") -> erlps__inline__3 [fcode_0, fun1_2, args_3]
      something_else -> EXC.case_clause something_else
erlps__inliner__3 [_fcode_0, _fun_1, e_2] = e_2
erlps__inliner__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__inliner__3 args =
  EXC.badarity (ErlangFun 3 erlps__inliner__3) args

erlps__should_inline__2 :: ErlangFun
erlps__should_inline__2 [_fcode_0, _fun1_1] =
  let    arg_4 = toErl "true"
  in let rop_3 = BIF.erlang__list_to_atom__1 [arg_4]
  in BIF.erlang__op_eq [ErlangAtom "false", rop_3]
erlps__should_inline__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__should_inline__2 args =
  EXC.badarity (ErlangFun 2 erlps__should_inline__2) args

erlps__inline__3 :: ErlangFun
erlps__inline__3 [_fcode_0, fun_1, args_2] =
  ErlangTuple [ErlangAtom "def", fun_1, args_2]
erlps__inline__3 [arg_6, arg_7, arg_8] = EXC.function_clause unit
erlps__inline__3 args =
  EXC.badarity (ErlangFun 3 erlps__inline__3) args

erlps__bind_subexpressions__1 :: ErlangFun
erlps__bind_subexpressions__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__bind_subexpressions__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__bind_subexpressions__1 [arg_3] = EXC.function_clause unit
erlps__bind_subexpressions__1 args =
  EXC.badarity (ErlangFun 1 erlps__bind_subexpressions__1) args

erlps__bind_subexpressions__2 :: ErlangFun
erlps__bind_subexpressions__2 [_,
                               (ErlangTuple [(ErlangAtom "tuple"), es_0])]
  =
  let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [xs_5] = ErlangTuple [ErlangAtom "tuple", xs_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in erlps__make_lets__2 [es_0, arg_2]
erlps__bind_subexpressions__2 [_,
                               (ErlangTuple [(ErlangAtom "set_proj"), a_0, i_1,
                                             b_2])]
  =
  let
    arg_8 =
      ErlangFun 1
        (let
           lambda_9 [(ErlangCons x_11 (ErlangCons y_12 (ErlangEmptyList)))]
             =
             ErlangTuple [ErlangAtom "set_proj", x_11, i_1, y_12]
           lambda_9 [arg_10] = EXC.function_clause unit
           lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
         in lambda_9)
  in
    erlps__make_lets__2
      [ErlangCons a_0 (ErlangCons b_2 ErlangEmptyList), arg_8]
erlps__bind_subexpressions__2 [_, e_0] = e_0
erlps__bind_subexpressions__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__bind_subexpressions__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_subexpressions__2) args

erlps__make_lets__2 :: ErlangFun
erlps__make_lets__2 [es_0, body_1] =
  erlps__make_lets__3 [es_0, ErlangEmptyList, body_1]
erlps__make_lets__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__make_lets__2 args =
  EXC.badarity (ErlangFun 2 erlps__make_lets__2) args

erlps__make_lets__3 :: ErlangFun
erlps__make_lets__3 [(ErlangEmptyList), xs_0, body_1] =
  let
    arg_2 = BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [xs_0]
  in
    BIF.erlang__apply__2 [body_1, ErlangCons arg_2 ErlangEmptyList]
erlps__make_lets__3 [(ErlangCons e_0@(ErlangTuple [(ErlangAtom "var"),
                                                   _]) es_1),
                     xs_2, body_3]
  =
  erlps__make_lets__3 [es_1, ErlangCons e_0 xs_2, body_3]
erlps__make_lets__3 [(ErlangCons e_0@(ErlangTuple [(ErlangAtom "lit"),
                                                   _]) es_1),
                     xs_2, body_3]
  =
  erlps__make_lets__3 [es_1, ErlangCons e_0 xs_2, body_3]
erlps__make_lets__3 [(ErlangCons e_0 es_1), xs_2, body_3] =
  let
    arg_5 =
      ErlangFun 1
        (let
           lambda_6 [x_8] =
             erlps__make_lets__3 [es_1, ErlangCons x_8 xs_2, body_3]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in erlps__make_let__2 [e_0, arg_5]
erlps__make_lets__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__make_lets__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_lets__3) args

erlps__inline_local_functions__1 :: ErlangFun
erlps__inline_local_functions__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__inline_local_functions__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__inline_local_functions__1 [arg_3] =
  EXC.function_clause unit
erlps__inline_local_functions__1 args =
  EXC.badarity (ErlangFun 1 erlps__inline_local_functions__1) args

erlps__inline_local_functions__2 :: ErlangFun
erlps__inline_local_functions__2 [env_0,
                                  expr_6@(ErlangTuple [(ErlangAtom "funcall"),
                                                       (ErlangTuple [(ErlangAtom "proj"),
                                                                     (ErlangTuple [(ErlangAtom "var"),
                                                                                   y_1]),
                                                                     (ErlangInt num_2)]),
                                                       (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                                                 (ErlangTuple [(ErlangAtom "var"),
                                                                                               y_3]),
                                                                                 (ErlangInt num_4)]) args_5)])]
  | (ErlangInt num_2) == (toErl 0)
  , (ErlangInt num_4) == (toErl 1)
  , y_3 == y_1 =
  let
    case_7 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [y_1, env_0, ErlangAtom "free"]
  in
    case case_7 of
      (ErlangTuple [(ErlangAtom "lam"), xs_11, body_12]) ->
        let
          arg_13 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_11, args_5]
        in erlps__let_bind__2 [arg_13, body_12]
      _ -> expr_6
erlps__inline_local_functions__2 [_, expr_0] = expr_0
erlps__inline_local_functions__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__inline_local_functions__2 args =
  EXC.badarity (ErlangFun 2 erlps__inline_local_functions__2) args

erlps__let_floating__1 :: ErlangFun
erlps__let_floating__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__let_float__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__let_floating__1 [arg_3] = EXC.function_clause unit
erlps__let_floating__1 args =
  EXC.badarity (ErlangFun 1 erlps__let_floating__1) args

erlps__let_float__2 :: ErlangFun
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "let"), x_0, e_1, body_2])]
  =
  let    tup_el_6 = ErlangTuple [ErlangAtom "here", e_1]
  in let
    arg_3 = ErlangTuple [ErlangAtom "let", x_0, tup_el_6, body_2]
  in erlps__pull_out_let__1 [arg_3]
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "proj"), e_0, i_1])]
  =
  let    tup_el_4 = ErlangTuple [ErlangAtom "here", e_0]
  in let arg_2 = ErlangTuple [ErlangAtom "proj", tup_el_4, i_1]
  in erlps__pull_out_let__1 [arg_2]
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "set_proj"), e_0, i_1, v_2])]
  =
  let    tup_el_5 = ErlangTuple [ErlangAtom "here", e_0]
  in let tup_el_9 = ErlangTuple [ErlangAtom "here", v_2]
  in let
    arg_3 =
      ErlangTuple [ErlangAtom "set_proj", tup_el_5, i_1, tup_el_9]
  in erlps__pull_out_let__1 [arg_3]
erlps__let_float__2 [_,
                     (ErlangTuple [(ErlangAtom "op"), op_0, es_1])]
  =
  let   
    arg_2 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = ErlangTuple [ErlangAtom "here", lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        es_1
  in let matchExpr_11 = erlps__pull_out_let__1 [arg_2]
  in
    case matchExpr_11 of
      (ErlangTuple [lets_9, es1_10]) ->
        let arg_13 = ErlangTuple [ErlangAtom "op", op_0, es1_10]
        in erlps__let_bind__2 [lets_9, arg_13]
      _ -> EXC.badmatch matchExpr_11
erlps__let_float__2 [_, e_0] = e_0
erlps__let_float__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__let_float__2 args =
  EXC.badarity (ErlangFun 2 erlps__let_float__2) args

erlps__pull_out_let__1 :: ErlangFun
erlps__pull_out_let__1 [expr_0] | isETuple expr_0 =
  let    arg_1 = BIF.erlang__tuple_to_list__1 [expr_0]
  in let matchExpr_5 = erlps__pull_out_let__1 [arg_1]
  in
    case matchExpr_5 of
      (ErlangTuple [lets_3, es_4]) ->
        let inner_7 = BIF.erlang__list_to_tuple__1 [es_4]
        in erlps__let_bind__2 [lets_3, inner_7]
      _ -> EXC.badmatch matchExpr_5
erlps__pull_out_let__1 [es_0] | isEList es_0 =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "here"), _])] =
             ErlangAtom "false"
           lambda_3 [_] = ErlangAtom "true"
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    case_1 =
      BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
        [arg_2, es_0]
  in
    case case_1 of
      (ErlangTuple [es0_6,
                    (ErlangCons (ErlangTuple [(ErlangAtom "here"),
                                              e_7]) es1_8)]) ->
        let case_9 = erlps__let_view__1 [e_7]
        in
          case case_9 of
            (ErlangTuple [(ErlangEmptyList), _]) ->
              let matchExpr_14 = erlps__pull_out_let__1 [es1_8]
              in
                case matchExpr_14 of
                  (ErlangTuple [lets_12, es2_13]) ->
                    let   
                      rop_18 =
                        BIF.erlang__op_append
                          [ErlangCons e_7 ErlangEmptyList, es2_13]
                    in let tup_el_16 = BIF.erlang__op_append [es0_6, rop_18]
                    in ErlangTuple [lets_12, tup_el_16]
                  _ -> EXC.badmatch matchExpr_14
            (ErlangTuple [lets_23, e1_24]) ->
              let matchExpr_28 = erlps__pull_out_let__1 [es1_8]
              in
                case matchExpr_28 of
                  (ErlangTuple [lets1_26, es2_27]) ->
                    let    tup_el_29 = BIF.erlang__op_append [lets_23, lets1_26]
                    in let
                      rop_34 =
                        BIF.erlang__op_append
                          [ErlangCons e1_24 ErlangEmptyList, es2_27]
                    in let tup_el_32 = BIF.erlang__op_append [es0_6, rop_34]
                    in ErlangTuple [tup_el_29, tup_el_32]
                  _ -> EXC.badmatch matchExpr_28
            something_else -> EXC.case_clause something_else
      (ErlangTuple [_, (ErlangEmptyList)]) ->
        ErlangTuple [ErlangEmptyList, es_0]
      something_else -> EXC.case_clause something_else
erlps__pull_out_let__1 [arg_41] = EXC.function_clause unit
erlps__pull_out_let__1 args =
  EXC.badarity (ErlangFun 1 erlps__pull_out_let__1) args

erlps__let_view__1 :: ErlangFun
erlps__let_view__1 [e_0] =
  erlps__let_view__3 [e_0, ErlangEmptyList, ErlangEmptyList]
erlps__let_view__1 [arg_4] = EXC.function_clause unit
erlps__let_view__1 args =
  EXC.badarity (ErlangFun 1 erlps__let_view__1) args

erlps__let_view__3 :: ErlangFun
erlps__let_view__3 [(ErlangTuple [(ErlangAtom "let"), x_0, e_1,
                                  rest_2]),
                    ren_3, lets_4]
  =
  let    z_5 = erlps__fresh_name__0 []
  in let head_8 = ErlangTuple [x_0, z_5]
  in let tup_el_15 = erlps__rename__2 [ren_3, e_1]
  in let head_13 = ErlangTuple [z_5, tup_el_15]
  in
    erlps__let_view__3
      [rest_2, ErlangCons head_8 ren_3, ErlangCons head_13 lets_4]
erlps__let_view__3 [e_0, ren_1, lets_2] =
  let   
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [lets_2]
  in let tup_el_5 = erlps__rename__2 [ren_1, e_0]
  in ErlangTuple [tup_el_3, tup_el_5]
erlps__let_view__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__let_view__3 args =
  EXC.badarity (ErlangFun 3 erlps__let_view__3) args

erlps__simplifier__1 :: ErlangFun
erlps__simplifier__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__simplify__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__simplifier__1 [arg_3] = EXC.function_clause unit
erlps__simplifier__1 args =
  EXC.badarity (ErlangFun 1 erlps__simplifier__1) args

erlps__simplify__2 :: ErlangFun
erlps__simplify__2 [_env_0,
                    (ErlangTuple [(ErlangAtom "proj"),
                                  (ErlangTuple [(ErlangAtom "tuple"), es_1]),
                                  i_2])]
  =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_plus [i_2, rop_5]
  in let
    it_7 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_3, es_1]
  in let x_8 = erlps__fresh_name__0 []
  in let dup_10 = erlps__safe_to_duplicate__1 [it_7]
  in let
    val_13 =
      case ErlangAtom "true" of
        _ | (==) (ErlangAtom "true") dup_10 -> it_7
        _ -> ErlangTuple [ErlangAtom "var", x_8]
  in let
    arg_14 =
      ErlangFun 2
        (let
           lambda_15 [(ErlangTuple [j_18, e_19]), rest_20]
             | weakEq i_2 j_18 =
             case dup_10 of
               (ErlangAtom "true") -> rest_20
               (ErlangAtom "false") ->
                 ErlangTuple [ErlangAtom "let", x_8, e_19, rest_20]
               something_else -> EXC.case_clause something_else
           lambda_15 [(ErlangTuple [_, e_26]), rest_27] =
             let case_28 = erlps__read_only__1 [e_26]
             in
               case case_28 of
                 (ErlangAtom "true") -> rest_27
                 (ErlangAtom "false") ->
                   let tup_el_31 = toErl "_"
                   in ErlangTuple [ErlangAtom "let", tup_el_31, e_26, rest_27]
                 something_else -> EXC.case_clause something_else
           lambda_15 [arg_16, arg_17] = EXC.function_clause unit
           lambda_15 args = EXC.badarity (ErlangFun 2 lambda_15) args
         in lambda_15)
  in let arg_35 = erlps__indexed__1 [es_1]
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_14, val_13, arg_35]
erlps__simplify__2 [env_0,
                    expr_3@(ErlangTuple [(ErlangAtom "proj"),
                                         (ErlangTuple [(ErlangAtom "var"),
                                                       x_1]),
                                         i_2])]
  =
  let    arg_7 = ErlangTuple [ErlangAtom "var", x_1]
  in let case_4 = erlps__simpl_proj__3 [env_0, i_2, arg_7]
  in
    case case_4 of
      (ErlangAtom "false") -> expr_3
      e_10 -> e_10
erlps__simplify__2 [env_0,
                    (ErlangTuple [(ErlangAtom "switch"), split_1])]
  =
  let
    case_2 = erlps__simpl_switch__3 [env_0, ErlangEmptyList, split_1]
  in
    case case_2 of
      (ErlangAtom "nomatch") ->
        let   
          tup_el_13 =
            ErlangBinary
              (BIN.fromInts (toErl "Incomplete patterns") (toErl 8) 1 BIN.Big)
        in let tup_el_11 = ErlangTuple [ErlangAtom "string", tup_el_13]
        in let head_9 = ErlangTuple [ErlangAtom "lit", tup_el_11]
        in
          ErlangTuple
            [ErlangAtom "builtin", ErlangAtom "abort",
             ErlangCons head_9 ErlangEmptyList]
      (ErlangAtom "stuck") ->
        ErlangTuple [ErlangAtom "switch", split_1]
      expr_17 -> expr_17
erlps__simplify__2 [_, e_0] = e_0
erlps__simplify__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__simplify__2 args =
  EXC.badarity (ErlangFun 2 erlps__simplify__2) args

erlps__simpl_proj__3 :: ErlangFun
erlps__simpl_proj__3 [env_0, i_1, expr_2] =
  let
    ifsafe_8 =
      ErlangFun 1
        (let
           lambda_3 [e_5] =
             let case_6 = erlps__safe_to_duplicate__1 [e_5]
             in
               case case_6 of
                 (ErlangAtom "true") -> e_5
                 (ErlangAtom "false") -> ErlangAtom "false"
                 something_else -> EXC.case_clause something_else
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in
    case expr_2 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "var"), x_10]) ->
        let
          arg_13 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [x_10, env_0, ErlangAtom "false"]
        in erlps__simpl_proj__3 [env_0, i_1, arg_13]
      (ErlangTuple [(ErlangAtom "tuple"), es_17]) ->
        let    rop_21 = toErl 1
        in let arg_19 = BIF.erlang__op_plus [i_1, rop_21]
        in let
          arg_18 =
            BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_19, es_17]
        in
          BIF.erlang__apply__2
            [ifsafe_8, ErlangCons arg_18 ErlangEmptyList]
      (ErlangTuple [(ErlangAtom "set_proj"), _, i_24,
                    val_25]) | i_24 == i_1 ->
        BIF.erlang__apply__2
          [ifsafe_8, ErlangCons val_25 ErlangEmptyList]
      (ErlangTuple [(ErlangAtom "set_proj"), e_28, _, _]) ->
        erlps__simpl_proj__3 [env_0, i_1, e_28]
      (ErlangTuple [(ErlangAtom "proj"), e_32, j_33]) ->
        let arg_36 = erlps__simpl_proj__3 [env_0, j_33, e_32]
        in erlps__simpl_proj__3 [env_0, i_1, arg_36]
      _ -> ErlangAtom "false"
erlps__simpl_proj__3 [arg_40, arg_41, arg_42] =
  EXC.function_clause unit
erlps__simpl_proj__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_proj__3) args

erlps__get_catchalls__1 :: ErlangFun
erlps__get_catchalls__1 [alts_0] =
  flmap
    (\ lc_3 ->
       case lc_3 of
         c_2@(ErlangTuple [(ErlangAtom "case"),
                           (ErlangTuple [(ErlangAtom "var"), _]), _]) ->
           ErlangCons c_2 ErlangEmptyList
         _ -> ErlangEmptyList)
    alts_0
erlps__get_catchalls__1 [arg_5] = EXC.function_clause unit
erlps__get_catchalls__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_catchalls__1) args

erlps__add_catchalls__2 :: ErlangFun
erlps__add_catchalls__2 [alts_0, (ErlangEmptyList)] = alts_0
erlps__add_catchalls__2 [alts_0, catchalls_1] =
  let   
    arg_3 =
      ErlangFun 1
        (let
           lambda_4 [(ErlangTuple [(ErlangAtom "case"),
                                   (ErlangTuple [(ErlangAtom "var"), _]), _])]
             =
             ErlangAtom "false"
           lambda_4 [_] = ErlangAtom "true"
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    case_2 =
      BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
        [arg_3, alts_0]
  in
    case case_2 of
      (ErlangTuple [alts1_7, (ErlangCons c_8 (ErlangEmptyList))]) ->
        let
          head_11 = erlps__nest_catchalls__1 [ErlangCons c_8 catchalls_1]
        in
          BIF.erlang__op_append
            [alts1_7, ErlangCons head_11 ErlangEmptyList]
      (ErlangTuple [_, (ErlangEmptyList)]) ->
        let head_18 = erlps__nest_catchalls__1 [catchalls_1]
        in
          BIF.erlang__op_append
            [alts_0, ErlangCons head_18 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__add_catchalls__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__add_catchalls__2 args =
  EXC.badarity (ErlangFun 2 erlps__add_catchalls__2) args

erlps__nest_catchalls__1 :: ErlangFun
erlps__nest_catchalls__1 [(ErlangCons c_0@(ErlangTuple [(ErlangAtom "case"),
                                                        (ErlangTuple [(ErlangAtom "var"),
                                                                      _]),
                                                        (ErlangTuple [(ErlangAtom "nosplit"),
                                                                      _])]) _)]
  =
  c_0
erlps__nest_catchalls__1 [(ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                    p_0@(ErlangTuple [(ErlangAtom "var"),
                                                                      _]),
                                                    (ErlangTuple [(ErlangAtom "split"),
                                                                  type_1, x_2,
                                                                  alts_3])]) catchalls_4)]
  =
  let    tup_el_11 = erlps__add_catchalls__2 [alts_3, catchalls_4]
  in let
    tup_el_7 =
      ErlangTuple [ErlangAtom "split", type_1, x_2, tup_el_11]
  in ErlangTuple [ErlangAtom "case", p_0, tup_el_7]
erlps__nest_catchalls__1 [arg_14] = EXC.function_clause unit
erlps__nest_catchalls__1 args =
  EXC.badarity (ErlangFun 1 erlps__nest_catchalls__1) args

erlps__simpl_switch__3 :: ErlangFun
erlps__simpl_switch__3 [_env_0, _,
                        (ErlangTuple [(ErlangAtom "nosplit"), e_1])]
  =
  e_1
erlps__simpl_switch__3 [env_0, catchalls_1,
                        (ErlangTuple [(ErlangAtom "split"), type_2, x_3,
                                      alts_4])]
  =
  let    alts1_7 = erlps__add_catchalls__2 [alts_4, catchalls_1]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "split", type_2, x_3, alts1_7]
  in let stuck_14 = ErlangTuple [ErlangAtom "switch", tup_el_9]
  in let arg_17 = ErlangTuple [ErlangAtom "var", x_3]
  in let case_15 = erlps__constructor_form__2 [env_0, arg_17]
  in
    case case_15 of
      (ErlangAtom "false") -> stuck_14
      e_20 ->
        let case_21 = erlps__simpl_case__3 [env_0, e_20, alts1_7]
        in
          case case_21 of
            (ErlangAtom "stuck") -> stuck_14
            res_25 -> res_25
erlps__simpl_switch__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__simpl_switch__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_switch__3) args

erlps__simpl_case__3 :: ErlangFun
erlps__simpl_case__3 [_, _, (ErlangEmptyList)] =
  ErlangAtom "nomatch"
erlps__simpl_case__3 [env_0, e_1,
                      (ErlangCons (ErlangTuple [(ErlangAtom "case"), pat_2,
                                                body_3]) alts_4)]
  =
  let case_5 = erlps__match_pat__2 [pat_2, e_1]
  in
    case case_5 of
      (ErlangAtom "false") -> erlps__simpl_case__3 [env_0, e_1, alts_4]
      binds_11 ->
        let    arg_13 = BIF.maps__from_list__1 [binds_11]
        in let env1_15 = BIF.maps__merge__2 [env_0, arg_13]
        in let arg_18 = erlps__get_catchalls__1 [alts_4]
        in let case_16 = erlps__simpl_switch__3 [env1_15, arg_18, body_3]
        in
          case case_16 of
            (ErlangAtom "nomatch") ->
              erlps__simpl_case__3 [env_0, e_1, alts_4]
            (ErlangAtom "stuck") -> ErlangAtom "stuck"
            body1_24 -> erlps__let_bind__2 [binds_11, body1_24]
erlps__simpl_case__3 [arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__simpl_case__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_case__3) args

erlps__match_pat__2 :: ErlangFun
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "tuple"), xs_0]),
                     (ErlangTuple [(ErlangAtom "tuple"), es_1])]
  =
  BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_0, es_1]
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "con"), _, c_0,
                                   xs_1]),
                     (ErlangTuple [(ErlangAtom "con"), _, c_2, es_3])]
  | c_2 == c_0 =
  BIF.do_remote_fun_call "Lists" "erlps__zip__2" [xs_1, es_3]
erlps__match_pat__2 [l_0,
                     (ErlangTuple [(ErlangAtom "lit"), l_1])]
  | l_1 == l_0 =
  ErlangEmptyList
erlps__match_pat__2 [(ErlangAtom "nil"), (ErlangAtom "nil")] =
  ErlangEmptyList
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "::"), x_0, y_1]),
                     (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "::"),
                                   (ErlangCons a_2 (ErlangCons b_3 (ErlangEmptyList)))])]
  =
  let    head_4 = ErlangTuple [x_0, a_2]
  in let head_8 = ErlangTuple [y_1, b_3]
  in ErlangCons head_4 (ErlangCons head_8 ErlangEmptyList)
erlps__match_pat__2 [(ErlangTuple [(ErlangAtom "var"), x_0]),
                     e_1]
  =
  let head_2 = ErlangTuple [x_0, e_1]
  in ErlangCons head_2 ErlangEmptyList
erlps__match_pat__2 [_, _] = ErlangAtom "false"
erlps__match_pat__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__match_pat__2 args =
  EXC.badarity (ErlangFun 2 erlps__match_pat__2) args

erlps__constructor_form__2 :: ErlangFun
erlps__constructor_form__2 [env_0, expr_1] =
  case expr_1 of
    (ErlangTuple [(ErlangAtom "var"), x_3]) ->
      let
        case_4 =
          BIF.do_remote_fun_call "Maps" "erlps__get__3"
            [x_3, env_0, ErlangAtom "free"]
      in
        case case_4 of
          (ErlangAtom "free") -> ErlangAtom "false"
          e_8 -> erlps__constructor_form__2 [env_0, e_8]
    (ErlangTuple [(ErlangAtom "set_proj"), e_11, i_12, v_13]) ->
      let case_14 = erlps__constructor_form__2 [env_0, e_11]
      in
        case case_14 of
          (ErlangTuple [(ErlangAtom "tuple"), es_17]) ->
            let    rop_22 = toErl 1
            in let arg_20 = BIF.erlang__op_plus [i_12, rop_22]
            in let tup_el_19 = erlps__setnth__3 [arg_20, v_13, es_17]
            in ErlangTuple [ErlangAtom "tuple", tup_el_19]
          _ -> ErlangAtom "false"
    (ErlangTuple [(ErlangAtom "proj"), e_25, i_26]) ->
      let case_27 = erlps__constructor_form__2 [env_0, e_25]
      in
        case case_27 of
          (ErlangTuple [(ErlangAtom "tuple"), es_30]) ->
            let    rop_35 = toErl 1
            in let arg_33 = BIF.erlang__op_plus [i_26, rop_35]
            in let
              arg_32 =
                BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_33, es_30]
            in erlps__constructor_form__2 [env_0, arg_32]
          _ -> ErlangAtom "false"
    (ErlangTuple [(ErlangAtom "con"), _, _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "tuple"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_1
    (ErlangAtom "nil") -> expr_1
    (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "::"), _]) -> expr_1
    _ -> ErlangAtom "false"
erlps__constructor_form__2 [arg_37, arg_38] =
  EXC.function_clause unit
erlps__constructor_form__2 args =
  EXC.badarity (ErlangFun 2 erlps__constructor_form__2) args

erlps__drop_unused_lets__1 :: ErlangFun
erlps__drop_unused_lets__1 [expr_0] =
  let arg_1 = ErlangFun 2 erlps__drop_unused_lets__2
  in erlps__bottom_up__2 [arg_1, expr_0]
erlps__drop_unused_lets__1 [arg_3] = EXC.function_clause unit
erlps__drop_unused_lets__1 args =
  EXC.badarity (ErlangFun 1 erlps__drop_unused_lets__1) args

erlps__drop_unused_lets__2 :: ErlangFun
erlps__drop_unused_lets__2 [_,
                            expr_3@(ErlangTuple [(ErlangAtom "let"), x_0, e_1,
                                                 body_2])]
  =
  let    tup_el_5 = erlps__read_only__1 [e_1]
  in let arg_10 = erlps__free_vars__1 [body_2]
  in let op_arg_8 = BIF.lists__member__2 [x_0, arg_10]
  in let tup_el_7 = BIF.erlang__not__1 [op_arg_8]
  in let case_4 = ErlangTuple [tup_el_5, tup_el_7]
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "true"), (ErlangAtom "true")]) ->
        body_2
      (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "true")]) ->
        let tup_el_13 = toErl "_"
        in ErlangTuple [ErlangAtom "let", tup_el_13, e_1, body_2]
      _ -> expr_3
erlps__drop_unused_lets__2 [_, expr_0] = expr_0
erlps__drop_unused_lets__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__drop_unused_lets__2 args =
  EXC.badarity (ErlangFun 2 erlps__drop_unused_lets__2) args

erlps__safe_to_duplicate__1 :: ErlangFun
erlps__safe_to_duplicate__1 [(ErlangTuple [(ErlangAtom "lit"),
                                           _])]
  =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [(ErlangTuple [(ErlangAtom "var"),
                                           _])]
  =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [(ErlangAtom "nil")] =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                           (ErlangEmptyList)])]
  =
  ErlangAtom "true"
erlps__safe_to_duplicate__1 [_] = ErlangAtom "false"
erlps__safe_to_duplicate__1 [arg_0] = EXC.function_clause unit
erlps__safe_to_duplicate__1 args =
  EXC.badarity (ErlangFun 1 erlps__safe_to_duplicate__1) args

erlps__read_only__1 :: ErlangFun
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "lit"), _])] =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "var"), _])] =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangAtom "nil")] = ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "con"), _, _,
                                   es_0])]
  =
  erlps__read_only__1 [es_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "tuple"), es_0])]
  =
  erlps__read_only__1 [es_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "proj"), e_0, _])]
  =
  erlps__read_only__1 [e_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "set_proj"), a_0,
                                   _, b_1])]
  =
  erlps__read_only__1
    [ErlangCons a_0 (ErlangCons b_1 ErlangEmptyList)]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "op"), _, es_0])]
  =
  erlps__read_only__1 [es_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "get_state"), _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "set_state"), _,
                                   _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "def_u"), _, _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "remote_u"), _, _,
                                   _, _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "builtin_u"), _,
                                   _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "builtin_u"), _,
                                   _, _])]
  =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "lam"), _, _])] =
  ErlangAtom "true"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "def"), _, _])] =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "remote"), _, _,
                                   _, _, _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "builtin"), _,
                                   _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "switch"),
                                   split_0])]
  =
  erlps__read_only__1 [split_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "split"), _, _,
                                   cases_0])]
  =
  erlps__read_only__1 [cases_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "nosplit"), e_0])]
  =
  erlps__read_only__1 [e_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "case"), _,
                                   split_0])]
  =
  erlps__read_only__1 [split_0]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "let"), _, a_0,
                                   b_1])]
  =
  erlps__read_only__1
    [ErlangCons a_0 (ErlangCons b_1 ErlangEmptyList)]
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "funcall"), _,
                                   _])]
  =
  ErlangAtom "false"
erlps__read_only__1 [(ErlangTuple [(ErlangAtom "closure"), _,
                                   _])]
  =
  erlps__internal_error__1 [ErlangAtom "no_closures_here"]
erlps__read_only__1 [es_0] | isEList es_0 =
  let arg_1 = ErlangFun 1 erlps__read_only__1
  in BIF.do_remote_fun_call "Lists" "erlps__all__2" [arg_1, es_0]
erlps__read_only__1 [arg_3] = EXC.function_clause unit
erlps__read_only__1 args =
  EXC.badarity (ErlangFun 1 erlps__read_only__1) args

erlps__eliminate_dead_code__1 :: ErlangFun
erlps__eliminate_dead_code__1 [code_2@(ErlangMap map_0)]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    usedfuns_4 = erlps__used_functions__1 [funs_1]
  in let
    arg_8 =
      ErlangFun 2
        (let
           lambda_9 [name_12, _] = BIF.maps__is_key__2 [name_12, usedfuns_4]
           lambda_9 [arg_10, arg_11] = EXC.function_clause unit
           lambda_9 args = EXC.badarity (ErlangFun 2 lambda_9) args
         in lambda_9)
  in let
    val_7 =
      BIF.do_remote_fun_call "Maps" "erlps__filter__2" [arg_8, funs_1]
  in let
    mapExt_16 =
      ErlangMap (Map.singleton (ErlangAtom "functions") val_7)
  in
    case findMissingKey code_2 [ErlangAtom "functions"] of
      (DM.Nothing) -> BIF.maps__merge__2 [code_2, mapExt_16]
      (DM.Just missing_18) -> EXC.badkey missing_18
erlps__eliminate_dead_code__1 [arg_19] = EXC.function_clause unit
erlps__eliminate_dead_code__1 args =
  EXC.badarity (ErlangFun 1 erlps__eliminate_dead_code__1) args

erlps__used_functions__1 :: ErlangFun
erlps__used_functions__1 [funs_0] =
  let    lcSrc_1 = BIF.maps__to_list__1 [funs_0]
  in let
    exported_12 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [fun_3, (ErlangMap map_4)]) | (DM.Just attrs_5) <-
                                                          (Map.lookup
                                                             (ErlangAtom
                                                                "attrs")
                                                             map_4) ->
               let   
                 op_arg_8 = BIF.lists__member__2 [ErlangAtom "private", attrs_5]
               in let cond_7 = BIF.erlang__not__1 [op_arg_8]
               in
                 case cond_7 of
                   (ErlangAtom "true") -> ErlangCons fun_3 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_1
  in let arg_13 = ErlangMap Map.empty
  in erlps__used_functions__3 [arg_13, exported_12, funs_0]
erlps__used_functions__1 [arg_16] = EXC.function_clause unit
erlps__used_functions__1 args =
  EXC.badarity (ErlangFun 1 erlps__used_functions__1) args

erlps__used_functions__3 :: ErlangFun
erlps__used_functions__3 [used_0, (ErlangEmptyList), _] = used_0
erlps__used_functions__3 [used_0, (ErlangCons name_1 rest_2),
                          defs_3]
  =
  let case_4 = BIF.maps__is_key__2 [name_1, used_0]
  in
    case case_4 of
      (ErlangAtom "true") ->
        erlps__used_functions__3 [used_0, rest_2, defs_3]
      (ErlangAtom "false") ->
        let   
          case_10 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [name_1, defs_3, ErlangAtom "undef"]
        in let
          new_17 =
            case case_10 of
              (ErlangAtom "undef") -> ErlangEmptyList
              (ErlangMap map_14) | (DM.Just body_15) <-
                                     (Map.lookup (ErlangAtom "body") map_14) ->
                erlps__used_defs__1 [body_15]
              something_else -> EXC.case_clause something_else
        in let
          mapExt_22 = ErlangMap (Map.singleton name_1 (ErlangAtom "true"))
        in let arg_18 = BIF.maps__merge__2 [used_0, mapExt_22]
        in let arg_24 = BIF.erlang__op_append [new_17, rest_2]
        in erlps__used_functions__3 [arg_18, arg_24, defs_3]
      something_else -> EXC.case_clause something_else
erlps__used_functions__3 [arg_28, arg_29, arg_30] =
  EXC.function_clause unit
erlps__used_functions__3 args =
  EXC.badarity (ErlangFun 3 erlps__used_functions__3) args

erlps__lookup_type__3 :: ErlangFun
erlps__lookup_type__3 [env_0,
                       (ErlangTuple [(ErlangAtom "id"), _, name_1]), args_2]
  =
  erlps__lookup_type__3
    [env_0, ErlangCons name_1 ErlangEmptyList, args_2]
erlps__lookup_type__3 [env_0,
                       (ErlangTuple [(ErlangAtom "qid"), _, name_1]), args_2]
  =
  erlps__lookup_type__3 [env_0, name_1, args_2]
erlps__lookup_type__3 [env_0, name_1, args_2] =
  let
    case_3 =
      erlps__lookup_type__4
        [env_0, name_1, args_2, ErlangAtom "not_found"]
  in
    case case_3 of
      (ErlangAtom "not_found") ->
        let arg_8 = ErlangTuple [ErlangAtom "unknown_type", name_1]
        in erlps__internal_error__1 [arg_8]
      type_11 -> type_11
erlps__lookup_type__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__lookup_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__lookup_type__3) args

erlps__lookup_type__4 :: ErlangFun
erlps__lookup_type__4 [(ErlangMap map_0), name_2, args_3,
                       default_4]
  | (DM.Just typeenv_1) <-
      (Map.lookup (ErlangAtom "type_env") map_0) =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_2, typeenv_1, ErlangAtom "false"]
  in
    case case_5 of
      (ErlangAtom "false") -> default_4
      fun_9 ->
        BIF.erlang__apply__2 [fun_9, ErlangCons args_3 ErlangEmptyList]
erlps__lookup_type__4 [arg_12, arg_13, arg_14, arg_15] =
  EXC.function_clause unit
erlps__lookup_type__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_type__4) args

erlps__bind_type__3 :: ErlangFun
erlps__bind_type__3 [env_2@(ErlangMap map_0), q_3, fdef_4]
  | (DM.Just tenv_1) <-
      (Map.lookup (ErlangAtom "type_env") map_0) =
  let    mapExt_11 = ErlangMap (Map.singleton q_3 fdef_4)
  in let val_7 = BIF.maps__merge__2 [tenv_1, mapExt_11]
  in let
    mapExt_13 =
      ErlangMap (Map.singleton (ErlangAtom "type_env") val_7)
  in
    case findMissingKey env_2 [ErlangAtom "type_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_13]
      (DM.Just missing_15) -> EXC.badkey missing_15
erlps__bind_type__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__bind_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_type__3) args

erlps__bind_constructors__2 :: ErlangFun
erlps__bind_constructors__2 [env_2@(ErlangMap map_0), newcons_3]
  | (DM.Just conenv_1) <-
      (Map.lookup (ErlangAtom "con_env") map_0) =
  let    val_6 = BIF.maps__merge__2 [conenv_1, newcons_3]
  in let
    mapExt_9 = ErlangMap (Map.singleton (ErlangAtom "con_env") val_6)
  in
    case findMissingKey env_2 [ErlangAtom "con_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_9]
      (DM.Just missing_11) -> EXC.badkey missing_11
erlps__bind_constructors__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__bind_constructors__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_constructors__2) args

erlps__add_fun_env__2 :: ErlangFun
erlps__add_fun_env__2 [env_1@(ErlangMap map_0), _]
  | (DM.Just (ErlangTuple [(ErlangAtom "abstract_contract"),
                           _])) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  env_1
erlps__add_fun_env__2 [env_2@(ErlangMap map_0), decls_3]
  | (DM.Just funenv_1) <-
      (Map.lookup (ErlangAtom "fun_env") map_0) =
  let   
    entry_36 =
      ErlangFun 1
        (let
           lambda_4 [(ErlangTuple [(ErlangAtom "letfun"), ann_6,
                                   (ErlangTuple [(ErlangAtom "id"), _, name_7]),
                                   args_8, _, _])]
             =
             let    tup_el_10 = erlps__qname__2 [env_2, name_7]
             in let tup_el_14 = erlps__make_fun_name__3 [env_2, ann_6, name_7]
             in let tup_el_18 = BIF.erlang__length__1 [args_8]
             in let tup_el_13 = ErlangTuple [tup_el_14, tup_el_18]
             in let head_9 = ErlangTuple [tup_el_10, tup_el_13]
             in ErlangCons head_9 ErlangEmptyList
           lambda_4 [(ErlangTuple [(ErlangAtom "fun_decl"), ann_21,
                                   (ErlangTuple [(ErlangAtom "id"), _,
                                                 name_22]),
                                   (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                                 argtypes_23, _])])]
             =
             let    tup_el_25 = erlps__qname__2 [env_2, name_22]
             in let
               tup_el_29 = erlps__make_fun_name__3 [env_2, ann_21, name_22]
             in let tup_el_33 = BIF.erlang__length__1 [argtypes_23]
             in let tup_el_28 = ErlangTuple [tup_el_29, tup_el_33]
             in let head_24 = ErlangTuple [tup_el_25, tup_el_28]
             in ErlangCons head_24 ErlangEmptyList
           lambda_4 [_] = ErlangEmptyList
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    arg_37 =
      BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
        [entry_36, decls_3]
  in let funenv1_40 = BIF.maps__from_list__1 [arg_37]
  in let val_43 = BIF.maps__merge__2 [funenv_1, funenv1_40]
  in let
    mapExt_46 =
      ErlangMap (Map.singleton (ErlangAtom "fun_env") val_43)
  in
    case findMissingKey env_2 [ErlangAtom "fun_env"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_46]
      (DM.Just missing_48) -> EXC.badkey missing_48
erlps__add_fun_env__2 [arg_49, arg_50] = EXC.function_clause unit
erlps__add_fun_env__2 args =
  EXC.badarity (ErlangFun 2 erlps__add_fun_env__2) args

erlps__make_fun_name__3 :: ErlangFun
erlps__make_fun_name__3 [(ErlangMap map_0), ann_2, name_3]
  | (DM.Just context_1) <-
      (Map.lookup (ErlangAtom "context") map_0) =
  let
    entrypoint_7 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "entrypoint", ann_2, ErlangAtom "false"]
  in
    case context_1 of
      (ErlangTuple [(ErlangAtom "main_contract"), main_9]) ->
        case ErlangAtom "true" of
          _ | (==) (ErlangAtom "true") entrypoint_7 ->
            let tup_el_11 = BIF.erlang__list_to_binary__1 [name_3]
            in ErlangTuple [ErlangAtom "entrypoint", tup_el_11]
          _ ->
            ErlangTuple
              [ErlangAtom "local_fun",
               ErlangCons main_9 (ErlangCons name_3 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "namespace"), lib_19]) ->
        ErlangTuple
          [ErlangAtom "local_fun",
           ErlangCons lib_19 (ErlangCons name_3 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__make_fun_name__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__make_fun_name__3 args =
  EXC.badarity (ErlangFun 3 erlps__make_fun_name__3) args

erlps__current_namespace__1 :: ErlangFun
erlps__current_namespace__1 [(ErlangMap map_0)]
  | (DM.Just cxt_1) <- (Map.lookup (ErlangAtom "context") map_0) =
  case cxt_1 of
    (ErlangTuple [(ErlangAtom "abstract_contract"), con_3]) -> con_3
    (ErlangTuple [(ErlangAtom "main_contract"), con_4]) -> con_4
    (ErlangTuple [(ErlangAtom "namespace"), ns_5]) -> ns_5
    something_else -> EXC.case_clause something_else
erlps__current_namespace__1 [arg_6] = EXC.function_clause unit
erlps__current_namespace__1 args =
  EXC.badarity (ErlangFun 1 erlps__current_namespace__1) args

erlps__qname__2 :: ErlangFun
erlps__qname__2 [env_0, name_1] =
  let head_2 = erlps__current_namespace__1 [env_0]
  in ErlangCons head_2 (ErlangCons name_1 ErlangEmptyList)
erlps__qname__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__qname__2 args =
  EXC.badarity (ErlangFun 2 erlps__qname__2) args

erlps__lookup_fun__2 :: ErlangFun
erlps__lookup_fun__2 [(ErlangMap map_0), name_2]
  | (DM.Just funenv_1) <-
      (Map.lookup (ErlangAtom "fun_env") map_0) =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_2, funenv_1, ErlangAtom "false"]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_7 = ErlangTuple [ErlangAtom "unbound_name", name_2]
        in BIF.erlang__error__1 [arg_7]
      (ErlangTuple [fname_10, _]) -> fname_10
      something_else -> EXC.case_clause something_else
erlps__lookup_fun__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lookup_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_fun__2) args

erlps__lookup_con__2 :: ErlangFun
erlps__lookup_con__2 [env_0,
                      (ErlangTuple [(ErlangAtom "con"), _, con_1])]
  =
  erlps__lookup_con__2 [env_0, ErlangCons con_1 ErlangEmptyList]
erlps__lookup_con__2 [env_0,
                      (ErlangTuple [(ErlangAtom "qcon"), _, con_1])]
  =
  erlps__lookup_con__2 [env_0, con_1]
erlps__lookup_con__2 [(ErlangMap map_0), con_2]
  | (DM.Just conenv_1) <-
      (Map.lookup (ErlangAtom "con_env") map_0) =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [con_2, conenv_1, ErlangAtom "false"]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_7 = ErlangTuple [ErlangAtom "unbound_constructor", con_2]
        in BIF.erlang__error__1 [arg_7]
      tag_10 -> tag_10
erlps__lookup_con__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lookup_con__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_con__2) args

erlps__bind_vars__2 :: ErlangFun
erlps__bind_vars__2 [env_0, xs_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [x_6, e_7] = erlps__bind_var__2 [e_7, x_6]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_2, env_0, xs_1]
erlps__bind_vars__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__bind_vars__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_vars__2) args

erlps__bind_var__2 :: ErlangFun
erlps__bind_var__2 [env_2@(ErlangMap map_0), x_3]
  | (DM.Just vars_1) <- (Map.lookup (ErlangAtom "vars") map_0) =
  let
    mapExt_9 =
      ErlangMap
        (Map.singleton (ErlangAtom "vars") (ErlangCons x_3 vars_1))
  in
    case findMissingKey env_2 [ErlangAtom "vars"] of
      (DM.Nothing) -> BIF.maps__merge__2 [env_2, mapExt_9]
      (DM.Just missing_11) -> EXC.badkey missing_11
erlps__bind_var__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__bind_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_var__2) args

erlps__resolve_var__2 :: ErlangFun
erlps__resolve_var__2 [env_2@(ErlangMap map_0),
                       (ErlangCons x_3 (ErlangEmptyList))]
  | (DM.Just vars_1) <- (Map.lookup (ErlangAtom "vars") map_0) =
  let case_4 = BIF.lists__member__2 [x_3, vars_1]
  in
    case case_4 of
      (ErlangAtom "true") -> ErlangTuple [ErlangAtom "var", x_3]
      (ErlangAtom "false") ->
        erlps__resolve_fun__2 [env_2, ErlangCons x_3 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__resolve_var__2 [env_0, q_1] =
  erlps__resolve_fun__2 [env_0, q_1]
erlps__resolve_var__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__resolve_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__resolve_var__2) args

erlps__resolve_fun__2 :: ErlangFun
erlps__resolve_fun__2 [env_3@(ErlangMap map_0), q_4]
  | (DM.Just builtin_2) <-
      (Map.lookup (ErlangAtom "builtins") map_0)
  , (DM.Just funs_1) <- (Map.lookup (ErlangAtom "fun_env") map_0) =
  let   
    tup_el_6 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [q_4, funs_1, ErlangAtom "not_found"]
  in let
    tup_el_10 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [q_4, builtin_2, ErlangAtom "not_found"]
  in let case_5 = ErlangTuple [tup_el_6, tup_el_10]
  in
    case case_5 of
      (ErlangTuple [(ErlangAtom "not_found"),
                    (ErlangAtom "not_found")]) ->
        let arg_14 = ErlangTuple [ErlangAtom "unbound_variable", q_4]
        in erlps__internal_error__1 [arg_14]
      (ErlangTuple [_, (ErlangTuple [b_17, (ErlangAtom "none")])]) ->
        let arg_18 = erlps__state_layout__1 [env_3]
        in erlps__builtin_to_fcode__3 [arg_18, b_17, ErlangEmptyList]
      (ErlangTuple [_, (ErlangTuple [b_22, ar_23])]) ->
        ErlangTuple [ErlangAtom "builtin_u", b_22, ar_23]
      (ErlangTuple [(ErlangTuple [fun_27, ar_28]), _]) ->
        ErlangTuple [ErlangAtom "def_u", fun_27, ar_28]
      something_else -> EXC.case_clause something_else
erlps__resolve_fun__2 [arg_32, arg_33] = EXC.function_clause unit
erlps__resolve_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__resolve_fun__2) args

erlps__init_fresh_names__0 :: ErlangFun
erlps__init_fresh_names__0 [] =
  let arg_1 = toErl 0
  in BIF.erlang__put__2 [ErlangAtom "%fresh", arg_1]
erlps__init_fresh_names__0 args =
  EXC.badarity (ErlangFun 0 erlps__init_fresh_names__0) args

erlps__clear_fresh_names__0 :: ErlangFun
erlps__clear_fresh_names__0 [] =
  BIF.erlang__erase__1 [ErlangAtom "%fresh"]
erlps__clear_fresh_names__0 args =
  EXC.badarity (ErlangFun 0 erlps__clear_fresh_names__0) args

erlps__fresh_name__0 :: ErlangFun
erlps__fresh_name__0 [] =
  let arg_0 = toErl "%"
  in erlps__fresh_name__1 [arg_0]
erlps__fresh_name__0 args =
  EXC.badarity (ErlangFun 0 erlps__fresh_name__0) args

erlps__fresh_fun__0 :: ErlangFun
erlps__fresh_fun__0 [] =
  let    arg_3 = toErl "^"
  in let head_2 = erlps__fresh_name__1 [arg_3]
  in
    ErlangTuple
      [ErlangAtom "local_fun", ErlangCons head_2 ErlangEmptyList]
erlps__fresh_fun__0 args =
  EXC.badarity (ErlangFun 0 erlps__fresh_fun__0) args

erlps__fresh_name__1 :: ErlangFun
erlps__fresh_name__1 [prefix_0] =
  let    n_2 = BIF.erlang__get__1 [ErlangAtom "%fresh"]
  in let rop_6 = toErl 1
  in let arg_4 = BIF.erlang__op_plus [n_2, rop_6]
  in let _ = BIF.erlang__put__2 [ErlangAtom "%fresh", arg_4]
  in
    BIF.do_remote_fun_call "Lists" "erlps__concat__1"
      [ErlangCons prefix_0 (ErlangCons n_2 ErlangEmptyList)]
erlps__fresh_name__1 [arg_12] = EXC.function_clause unit
erlps__fresh_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__fresh_name__1) args

erlps__pat_vars__1 :: ErlangFun
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "var"), x_0])] =
  let    rop_3 = toErl "_"
  in let cond_1 = BIF.erlang__op_neq [x_0, rop_3]
  in
    case cond_1 of
      (ErlangAtom "true") -> ErlangCons x_0 ErlangEmptyList
      _ -> ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "bool"), _])] =
  ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "int"), _])] =
  ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "string"), _])] =
  ErlangEmptyList
erlps__pat_vars__1 [(ErlangAtom "nil")] = ErlangEmptyList
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "::"), p_0, q_1])]
  =
  let    lop_2 = erlps__pat_vars__1 [p_0]
  in let rop_4 = erlps__pat_vars__1 [q_1]
  in BIF.erlang__op_append [lop_2, rop_4]
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "tuple"), ps_0])] =
  erlps__pat_vars__1 [ps_0]
erlps__pat_vars__1 [(ErlangTuple [(ErlangAtom "con"), _, _,
                                  ps_0])]
  =
  erlps__pat_vars__1 [ps_0]
erlps__pat_vars__1 [ps_0] | isEList ps_0 =
  flmap
    (\ lc_3 ->
       let lcSrc_4 = erlps__pat_vars__1 [lc_3]
       in flmap (\ lc_7 -> ErlangCons lc_7 ErlangEmptyList) lcSrc_4)
    ps_0
erlps__pat_vars__1 [arg_9] = EXC.function_clause unit
erlps__pat_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__pat_vars__1) args

erlps__fsplit_pat_vars__1 :: ErlangFun
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "var"),
                                         x_0])]
  =
  let    rop_3 = toErl "_"
  in let cond_1 = BIF.erlang__op_neq [x_0, rop_3]
  in
    case cond_1 of
      (ErlangAtom "true") -> ErlangCons x_0 ErlangEmptyList
      _ -> ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "bool"),
                                         _])]
  =
  ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "int"), _])]
  =
  ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "string"),
                                         _])]
  =
  ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangAtom "nil")] = ErlangEmptyList
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "::"), p_0,
                                         q_1])]
  =
  ErlangCons p_0 (ErlangCons q_1 ErlangEmptyList)
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                         ps_0])]
  =
  ps_0
erlps__fsplit_pat_vars__1 [(ErlangTuple [(ErlangAtom "con"), _,
                                         _, ps_0])]
  =
  ps_0
erlps__fsplit_pat_vars__1 [arg_1] = EXC.function_clause unit
erlps__fsplit_pat_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__fsplit_pat_vars__1) args

erlps__free_vars__1 :: ErlangFun
erlps__free_vars__1 [xs_0] | isEList xs_0 =
  let
    arg_1 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__free_vars__1 [lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        xs_0
  in BIF.do_remote_fun_call "Lists" "erlps__umerge__1" [arg_1]
erlps__free_vars__1 [expr_0] =
  case expr_0 of
    (ErlangTuple [(ErlangAtom "var"), x_2]) ->
      ErlangCons x_2 ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lit"), _]) -> ErlangEmptyList
    (ErlangAtom "nil") -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "def"), _, as_5]) ->
      erlps__free_vars__1 [as_5]
    (ErlangTuple [(ErlangAtom "def_u"), _, _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "remote"), _, _, ct_7, _, as_8]) ->
      erlps__free_vars__1 [ErlangCons ct_7 as_8]
    (ErlangTuple [(ErlangAtom "remote_u"), _, _, ct_12, _]) ->
      erlps__free_vars__1 [ct_12]
    (ErlangTuple [(ErlangAtom "builtin"), _, as_14]) ->
      erlps__free_vars__1 [as_14]
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) ->
      ErlangEmptyList
    (ErlangTuple [(ErlangAtom "con"), _, _, as_16]) ->
      erlps__free_vars__1 [as_16]
    (ErlangTuple [(ErlangAtom "tuple"), as_18]) ->
      erlps__free_vars__1 [as_18]
    (ErlangTuple [(ErlangAtom "proj"), a_20, _]) ->
      erlps__free_vars__1 [a_20]
    (ErlangTuple [(ErlangAtom "set_proj"), a_22, _, b_23]) ->
      erlps__free_vars__1
        [ErlangCons a_22 (ErlangCons b_23 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "op"), _, as_29]) ->
      erlps__free_vars__1 [as_29]
    (ErlangTuple [(ErlangAtom "let"), x_31, a_32, b_33]) ->
      let
        head_37 =
          ErlangTuple
            [ErlangAtom "lam", ErlangCons x_31 ErlangEmptyList, b_33]
      in
        erlps__free_vars__1
          [ErlangCons a_32 (ErlangCons head_37 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "funcall"), a_44, bs_45]) ->
      erlps__free_vars__1 [ErlangCons a_44 bs_45]
    (ErlangTuple [(ErlangAtom "set_state"), _, a_49]) ->
      erlps__free_vars__1 [a_49]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lam"), xs_51, b_52]) ->
      let    lop_53 = erlps__free_vars__1 [b_52]
      in let
        rop_55 = BIF.do_remote_fun_call "Lists" "erlps__sort__1" [xs_51]
      in BIF.erlang__op_unAppend [lop_53, rop_55]
    (ErlangTuple [(ErlangAtom "closure"), _, a_57]) ->
      erlps__free_vars__1 [a_57]
    (ErlangTuple [(ErlangAtom "switch"), a_59]) ->
      erlps__free_vars__1 [a_59]
    (ErlangTuple [(ErlangAtom "split"), _, x_61, as_62]) ->
      let head_64 = ErlangTuple [ErlangAtom "var", x_61]
      in erlps__free_vars__1 [ErlangCons head_64 as_62]
    (ErlangTuple [(ErlangAtom "nosplit"), a_68]) ->
      erlps__free_vars__1 [a_68]
    (ErlangTuple [(ErlangAtom "case"), p_70, a_71]) ->
      let    lop_72 = erlps__free_vars__1 [a_71]
      in let arg_75 = erlps__fsplit_pat_vars__1 [p_70]
      in let
        rop_74 = BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_75]
      in BIF.erlang__op_unAppend [lop_72, rop_74]
    something_else -> EXC.case_clause something_else
erlps__free_vars__1 [arg_77] = EXC.function_clause unit
erlps__free_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__free_vars__1) args

erlps__used_defs__1 :: ErlangFun
erlps__used_defs__1 [xs_0] | isEList xs_0 =
  let
    arg_1 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__used_defs__1 [lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        xs_0
  in BIF.do_remote_fun_call "Lists" "erlps__umerge__1" [arg_1]
erlps__used_defs__1 [expr_0] =
  case expr_0 of
    (ErlangTuple [(ErlangAtom "var"), _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lit"), _]) -> ErlangEmptyList
    (ErlangAtom "nil") -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "def"), f_2, as_3]) ->
      let arg_7 = erlps__used_defs__1 [as_3]
      in
        BIF.do_remote_fun_call "Lists" "erlps__umerge__2"
          [ErlangCons f_2 ErlangEmptyList, arg_7]
    (ErlangTuple [(ErlangAtom "def_u"), f_9, _]) ->
      ErlangCons f_9 ErlangEmptyList
    (ErlangTuple [(ErlangAtom "remote"), _, _, ct_12, _, as_13]) ->
      erlps__used_defs__1 [ErlangCons ct_12 as_13]
    (ErlangTuple [(ErlangAtom "remote_u"), _, _, ct_17, _]) ->
      erlps__used_defs__1 [ct_17]
    (ErlangTuple [(ErlangAtom "builtin"), _, as_19]) ->
      erlps__used_defs__1 [as_19]
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) ->
      ErlangEmptyList
    (ErlangTuple [(ErlangAtom "con"), _, _, as_21]) ->
      erlps__used_defs__1 [as_21]
    (ErlangTuple [(ErlangAtom "tuple"), as_23]) ->
      erlps__used_defs__1 [as_23]
    (ErlangTuple [(ErlangAtom "proj"), a_25, _]) ->
      erlps__used_defs__1 [a_25]
    (ErlangTuple [(ErlangAtom "set_proj"), a_27, _, b_28]) ->
      erlps__used_defs__1
        [ErlangCons a_27 (ErlangCons b_28 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "op"), _, as_34]) ->
      erlps__used_defs__1 [as_34]
    (ErlangTuple [(ErlangAtom "let"), _, a_36, b_37]) ->
      erlps__used_defs__1
        [ErlangCons a_36 (ErlangCons b_37 ErlangEmptyList)]
    (ErlangTuple [(ErlangAtom "funcall"), a_43, bs_44]) ->
      erlps__used_defs__1 [ErlangCons a_43 bs_44]
    (ErlangTuple [(ErlangAtom "set_state"), _, a_48]) ->
      erlps__used_defs__1 [a_48]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> ErlangEmptyList
    (ErlangTuple [(ErlangAtom "lam"), _, b_50]) ->
      erlps__used_defs__1 [b_50]
    (ErlangTuple [(ErlangAtom "closure"), f_52, a_53]) ->
      let arg_57 = erlps__used_defs__1 [a_53]
      in
        BIF.do_remote_fun_call "Lists" "erlps__umerge__2"
          [ErlangCons f_52 ErlangEmptyList, arg_57]
    (ErlangTuple [(ErlangAtom "switch"), a_59]) ->
      erlps__used_defs__1 [a_59]
    (ErlangTuple [(ErlangAtom "split"), _, _, as_61]) ->
      erlps__used_defs__1 [as_61]
    (ErlangTuple [(ErlangAtom "nosplit"), a_63]) ->
      erlps__used_defs__1 [a_63]
    (ErlangTuple [(ErlangAtom "case"), _, a_65]) ->
      erlps__used_defs__1 [a_65]
    something_else -> EXC.case_clause something_else
erlps__used_defs__1 [arg_67] = EXC.function_clause unit
erlps__used_defs__1 args =
  EXC.badarity (ErlangFun 1 erlps__used_defs__1) args

erlps__bottom_up__2 :: ErlangFun
erlps__bottom_up__2 [f_0, expr_1] =
  let arg_3 = ErlangMap Map.empty
  in erlps__bottom_up__3 [f_0, arg_3, expr_1]
erlps__bottom_up__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__bottom_up__2 args =
  EXC.badarity (ErlangFun 2 erlps__bottom_up__2) args

erlps__bottom_up__3 :: ErlangFun
erlps__bottom_up__3 [f_0, env_1, expr_2] =
  let
    arg_4 =
      case expr_2 of
        (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_2
        (ErlangAtom "nil") -> expr_2
        (ErlangTuple [(ErlangAtom "var"), _]) -> expr_2
        (ErlangTuple [(ErlangAtom "def"), d_6, es_7]) ->
          let
            tup_el_10 =
              flmap
                (\ lc_13 ->
                   let lcRet_14 = erlps__bottom_up__3 [f_0, env_1, lc_13]
                   in ErlangCons lcRet_14 ErlangEmptyList)
                es_7
          in ErlangTuple [ErlangAtom "def", d_6, tup_el_10]
        (ErlangTuple [(ErlangAtom "def_u"), _, _]) -> expr_2
        (ErlangTuple [(ErlangAtom "builtin"), b_18, es_19]) ->
          let
            tup_el_22 =
              flmap
                (\ lc_25 ->
                   let lcRet_26 = erlps__bottom_up__3 [f_0, env_1, lc_25]
                   in ErlangCons lcRet_26 ErlangEmptyList)
                es_19
          in ErlangTuple [ErlangAtom "builtin", b_18, tup_el_22]
        (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> expr_2
        (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) -> expr_2
        (ErlangTuple [(ErlangAtom "remote"), argst_30, rett_31, ct_32,
                      fun_33, es_34]) ->
          let    tup_el_38 = erlps__bottom_up__3 [f_0, env_1, ct_32]
          in let
            tup_el_43 =
              flmap
                (\ lc_46 ->
                   let lcRet_47 = erlps__bottom_up__3 [f_0, env_1, lc_46]
                   in ErlangCons lcRet_47 ErlangEmptyList)
                es_34
          in
            ErlangTuple
              [ErlangAtom "remote", argst_30, rett_31, tup_el_38, fun_33,
               tup_el_43]
        (ErlangTuple [(ErlangAtom "remote_u"), argst_51, rett_52, ct_53,
                      fun_54]) ->
          let tup_el_58 = erlps__bottom_up__3 [f_0, env_1, ct_53]
          in
            ErlangTuple
              [ErlangAtom "remote_u", argst_51, rett_52, tup_el_58, fun_54]
        (ErlangTuple [(ErlangAtom "con"), ar_63, i_64, es_65]) ->
          let
            tup_el_69 =
              flmap
                (\ lc_72 ->
                   let lcRet_73 = erlps__bottom_up__3 [f_0, env_1, lc_72]
                   in ErlangCons lcRet_73 ErlangEmptyList)
                es_65
          in ErlangTuple [ErlangAtom "con", ar_63, i_64, tup_el_69]
        (ErlangTuple [(ErlangAtom "tuple"), es_77]) ->
          let
            tup_el_79 =
              flmap
                (\ lc_82 ->
                   let lcRet_83 = erlps__bottom_up__3 [f_0, env_1, lc_82]
                   in ErlangCons lcRet_83 ErlangEmptyList)
                es_77
          in ErlangTuple [ErlangAtom "tuple", tup_el_79]
        (ErlangTuple [(ErlangAtom "proj"), e_87, i_88]) ->
          let tup_el_90 = erlps__bottom_up__3 [f_0, env_1, e_87]
          in ErlangTuple [ErlangAtom "proj", tup_el_90, i_88]
        (ErlangTuple [(ErlangAtom "set_proj"), r_95, i_96, e_97]) ->
          let    tup_el_99 = erlps__bottom_up__3 [f_0, env_1, r_95]
          in let tup_el_104 = erlps__bottom_up__3 [f_0, env_1, e_97]
          in
            ErlangTuple [ErlangAtom "set_proj", tup_el_99, i_96, tup_el_104]
        (ErlangTuple [(ErlangAtom "op"), op_108, es_109]) ->
          let
            tup_el_112 =
              flmap
                (\ lc_115 ->
                   let lcRet_116 = erlps__bottom_up__3 [f_0, env_1, lc_115]
                   in ErlangCons lcRet_116 ErlangEmptyList)
                es_109
          in ErlangTuple [ErlangAtom "op", op_108, tup_el_112]
        (ErlangTuple [(ErlangAtom "funcall"), fun_120, es_121]) ->
          let    tup_el_123 = erlps__bottom_up__3 [f_0, env_1, fun_120]
          in let
            tup_el_127 =
              flmap
                (\ lc_130 ->
                   let lcRet_131 = erlps__bottom_up__3 [f_0, env_1, lc_130]
                   in ErlangCons lcRet_131 ErlangEmptyList)
                es_121
          in ErlangTuple [ErlangAtom "funcall", tup_el_123, tup_el_127]
        (ErlangTuple [(ErlangAtom "set_state"), r_135, e_136]) ->
          let tup_el_139 = erlps__bottom_up__3 [f_0, env_1, e_136]
          in ErlangTuple [ErlangAtom "set_state", r_135, tup_el_139]
        (ErlangTuple [(ErlangAtom "get_state"), _]) -> expr_2
        (ErlangTuple [(ErlangAtom "closure"), f_143,
                      cenv_144]) | f_143 == f_0 ->
          let tup_el_147 = erlps__bottom_up__3 [f_0, env_1, cenv_144]
          in ErlangTuple [ErlangAtom "closure", f_0, tup_el_147]
        (ErlangTuple [(ErlangAtom "switch"), split_151]) ->
          let tup_el_153 = erlps__bottom_up__3 [f_0, env_1, split_151]
          in ErlangTuple [ErlangAtom "switch", tup_el_153]
        (ErlangTuple [(ErlangAtom "lam"), xs_157, b_158]) ->
          let tup_el_161 = erlps__bottom_up__3 [f_0, env_1, b_158]
          in ErlangTuple [ErlangAtom "lam", xs_157, tup_el_161]
        (ErlangTuple [(ErlangAtom "let"), x_165, e_166, body_167]) ->
          let    e1_171 = erlps__bottom_up__3 [f_0, env_1, e_166]
          in let
            shouldfreshen_178 =
              ErlangFun 1
                (let
                   lambda_172 [y_175@(ErlangCons (ErlangInt num_174) _)]
                     | (ErlangInt num_174) == (toErl 37) =
                     BIF.maps__is_key__2 [y_175, env_1]
                   lambda_172 [_] = ErlangAtom "true"
                   lambda_172 [arg_173] = EXC.function_clause unit
                   lambda_172 args = EXC.badarity (ErlangFun 1 lambda_172) args
                 in lambda_172)
          in let
            case_179 =
              BIF.erlang__apply__2
                [shouldfreshen_178, ErlangCons x_165 ErlangEmptyList]
          in
            case case_179 of
              (ErlangAtom "true") ->
                let    z_182 = erlps__fresh_name__0 []
                in let mapExt_186 = ErlangMap (Map.singleton z_182 e1_171)
                in let env1_188 = BIF.maps__merge__2 [env_1, mapExt_186]
                in let head_197 = ErlangTuple [x_165, z_182]
                in let
                  arg_195 =
                    erlps__rename__2
                      [ErlangCons head_197 ErlangEmptyList, body_167]
                in let tup_el_192 = erlps__bottom_up__3 [f_0, env1_188, arg_195]
                in ErlangTuple [ErlangAtom "let", z_182, e1_171, tup_el_192]
              (ErlangAtom "false") ->
                let    mapExt_205 = ErlangMap (Map.singleton x_165 e1_171)
                in let env1_207 = BIF.maps__merge__2 [env_1, mapExt_205]
                in let
                  tup_el_211 = erlps__bottom_up__3 [f_0, env1_207, body_167]
                in ErlangTuple [ErlangAtom "let", x_165, e1_171, tup_el_211]
              something_else -> EXC.case_clause something_else
        (ErlangTuple [(ErlangAtom "split"), type_215, x_216,
                      cases_217]) ->
          let
            tup_el_221 =
              flmap
                (\ lc_224 ->
                   let lcRet_225 = erlps__bottom_up__3 [f_0, env_1, lc_224]
                   in ErlangCons lcRet_225 ErlangEmptyList)
                cases_217
          in ErlangTuple [ErlangAtom "split", type_215, x_216, tup_el_221]
        (ErlangTuple [(ErlangAtom "nosplit"), e_229]) ->
          let tup_el_231 = erlps__bottom_up__3 [f_0, env_1, e_229]
          in ErlangTuple [ErlangAtom "nosplit", tup_el_231]
        (ErlangTuple [(ErlangAtom "case"), pat_235, split_236]) ->
          let tup_el_239 = erlps__bottom_up__3 [f_0, env_1, split_236]
          in ErlangTuple [ErlangAtom "case", pat_235, tup_el_239]
        something_else -> EXC.case_clause something_else
  in
    BIF.erlang__apply__2
      [f_0, ErlangCons env_1 (ErlangCons arg_4 ErlangEmptyList)]
erlps__bottom_up__3 [arg_244, arg_245, arg_246] =
  EXC.function_clause unit
erlps__bottom_up__3 args =
  EXC.badarity (ErlangFun 3 erlps__bottom_up__3) args

erlps__get_named_args__2 :: ErlangFun
erlps__get_named_args__2 [namedargst_0, args_1] =
  let   
    isnamed_4 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "named_arg"), _, _, _])] =
             ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    matchExpr_9 =
      BIF.do_remote_fun_call "Lists" "erlps__partition__2"
        [isnamed_4, args_1]
  in
    case matchExpr_9 of
      (ErlangTuple [named_7, notnamed_8]) ->
        let
          namedargs_16 =
            flmap
              (\ lc_12 ->
                 let lcRet_13 = erlps__get_named_arg__2 [lc_12, named_7]
                 in ErlangCons lcRet_13 ErlangEmptyList)
              namedargst_0
        in BIF.erlang__op_append [namedargs_16, notnamed_8]
      _ -> EXC.badmatch matchExpr_9
erlps__get_named_args__2 [arg_19, arg_20] =
  EXC.function_clause unit
erlps__get_named_args__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_named_args__2) args

erlps__get_named_arg__2 :: ErlangFun
erlps__get_named_arg__2 [(ErlangTuple [(ErlangAtom "named_arg_t"),
                                       _,
                                       (ErlangTuple [(ErlangAtom "id"), _,
                                                     name_0]),
                                       _, default_1]),
                         args_2]
  =
  let
    case_3 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [(ErlangAtom "named_arg"), _,
                           (ErlangTuple [(ErlangAtom "id"), _, x_5]), val_6]) ->
               let cond_8 = BIF.erlang__op_eq [x_5, name_0]
               in
                 case cond_8 of
                   (ErlangAtom "true") -> ErlangCons val_6 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        args_2
  in
    case case_3 of
      (ErlangCons val_12 (ErlangEmptyList)) -> val_12
      (ErlangEmptyList) -> default_1
      something_else -> EXC.case_clause something_else
erlps__get_named_arg__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__get_named_arg__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_named_arg__2) args

erlps__rename__2 :: ErlangFun
erlps__rename__2 [ren_0, expr_1] =
  case expr_1 of
    (ErlangTuple [(ErlangAtom "lit"), _]) -> expr_1
    (ErlangAtom "nil") -> ErlangAtom "nil"
    (ErlangTuple [(ErlangAtom "var"), x_3]) ->
      let tup_el_5 = erlps__rename_var__2 [ren_0, x_3]
      in ErlangTuple [ErlangAtom "var", tup_el_5]
    (ErlangTuple [(ErlangAtom "def"), d_8, es_9]) ->
      let
        tup_el_12 =
          flmap
            (\ lc_15 ->
               let lcRet_16 = erlps__rename__2 [ren_0, lc_15]
               in ErlangCons lcRet_16 ErlangEmptyList)
            es_9
      in ErlangTuple [ErlangAtom "def", d_8, tup_el_12]
    (ErlangTuple [(ErlangAtom "def_u"), _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "builtin"), b_19, es_20]) ->
      let
        tup_el_23 =
          flmap
            (\ lc_26 ->
               let lcRet_27 = erlps__rename__2 [ren_0, lc_26]
               in ErlangCons lcRet_27 ErlangEmptyList)
            es_20
      in ErlangTuple [ErlangAtom "builtin", b_19, tup_el_23]
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "builtin_u"), _, _, _]) -> expr_1
    (ErlangTuple [(ErlangAtom "remote"), argst_30, rett_31, ct_32,
                  f_33, es_34]) ->
      let    tup_el_38 = erlps__rename__2 [ren_0, ct_32]
      in let
        tup_el_42 =
          flmap
            (\ lc_45 ->
               let lcRet_46 = erlps__rename__2 [ren_0, lc_45]
               in ErlangCons lcRet_46 ErlangEmptyList)
            es_34
      in
        ErlangTuple
          [ErlangAtom "remote", argst_30, rett_31, tup_el_38, f_33,
           tup_el_42]
    (ErlangTuple [(ErlangAtom "remote_u"), argst_49, rett_50, ct_51,
                  f_52]) ->
      let tup_el_56 = erlps__rename__2 [ren_0, ct_51]
      in
        ErlangTuple
          [ErlangAtom "remote_u", argst_49, rett_50, tup_el_56, f_52]
    (ErlangTuple [(ErlangAtom "con"), ar_60, i_61, es_62]) ->
      let
        tup_el_66 =
          flmap
            (\ lc_69 ->
               let lcRet_70 = erlps__rename__2 [ren_0, lc_69]
               in ErlangCons lcRet_70 ErlangEmptyList)
            es_62
      in ErlangTuple [ErlangAtom "con", ar_60, i_61, tup_el_66]
    (ErlangTuple [(ErlangAtom "tuple"), es_73]) ->
      let
        tup_el_75 =
          flmap
            (\ lc_78 ->
               let lcRet_79 = erlps__rename__2 [ren_0, lc_78]
               in ErlangCons lcRet_79 ErlangEmptyList)
            es_73
      in ErlangTuple [ErlangAtom "tuple", tup_el_75]
    (ErlangTuple [(ErlangAtom "proj"), e_82, i_83]) ->
      let tup_el_85 = erlps__rename__2 [ren_0, e_82]
      in ErlangTuple [ErlangAtom "proj", tup_el_85, i_83]
    (ErlangTuple [(ErlangAtom "set_proj"), r_89, i_90, e_91]) ->
      let    tup_el_93 = erlps__rename__2 [ren_0, r_89]
      in let tup_el_97 = erlps__rename__2 [ren_0, e_91]
      in
        ErlangTuple [ErlangAtom "set_proj", tup_el_93, i_90, tup_el_97]
    (ErlangTuple [(ErlangAtom "op"), op_100, es_101]) ->
      let
        tup_el_104 =
          flmap
            (\ lc_107 ->
               let lcRet_108 = erlps__rename__2 [ren_0, lc_107]
               in ErlangCons lcRet_108 ErlangEmptyList)
            es_101
      in ErlangTuple [ErlangAtom "op", op_100, tup_el_104]
    (ErlangTuple [(ErlangAtom "funcall"), fun_111, es_112]) ->
      let    tup_el_114 = erlps__rename__2 [ren_0, fun_111]
      in let
        tup_el_117 =
          flmap
            (\ lc_120 ->
               let lcRet_121 = erlps__rename__2 [ren_0, lc_120]
               in ErlangCons lcRet_121 ErlangEmptyList)
            es_112
      in ErlangTuple [ErlangAtom "funcall", tup_el_114, tup_el_117]
    (ErlangTuple [(ErlangAtom "set_state"), r_124, e_125]) ->
      let tup_el_128 = erlps__rename__2 [ren_0, e_125]
      in ErlangTuple [ErlangAtom "set_state", r_124, tup_el_128]
    (ErlangTuple [(ErlangAtom "get_state"), _]) -> expr_1
    (ErlangTuple [(ErlangAtom "closure"), f_131, env_132]) ->
      let tup_el_135 = erlps__rename__2 [ren_0, env_132]
      in ErlangTuple [ErlangAtom "closure", f_131, tup_el_135]
    (ErlangTuple [(ErlangAtom "switch"), split_138]) ->
      let tup_el_140 = erlps__rename_split__2 [ren_0, split_138]
      in ErlangTuple [ErlangAtom "switch", tup_el_140]
    (ErlangTuple [(ErlangAtom "lam"), xs_143, b_144]) ->
      let matchExpr_149 = erlps__rename_bindings__2 [ren_0, xs_143]
      in
        case matchExpr_149 of
          (ErlangTuple [zs_147, ren1_148]) ->
            let tup_el_152 = erlps__rename__2 [ren1_148, b_144]
            in ErlangTuple [ErlangAtom "lam", zs_147, tup_el_152]
          _ -> EXC.badmatch matchExpr_149
    (ErlangTuple [(ErlangAtom "let"), x_155, e_156, body_157]) ->
      let matchExpr_162 = erlps__rename_binding__2 [ren_0, x_155]
      in
        case matchExpr_162 of
          (ErlangTuple [z_160, ren1_161]) ->
            let    tup_el_165 = erlps__rename__2 [ren_0, e_156]
            in let tup_el_168 = erlps__rename__2 [ren1_161, body_157]
            in ErlangTuple [ErlangAtom "let", z_160, tup_el_165, tup_el_168]
          _ -> EXC.badmatch matchExpr_162
    something_else -> EXC.case_clause something_else
erlps__rename__2 [arg_171, arg_172] = EXC.function_clause unit
erlps__rename__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename__2) args

erlps__rename_var__2 :: ErlangFun
erlps__rename_var__2 [ren_0, x_1] =
  BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
    [x_1, ren_0, x_1]
erlps__rename_var__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__rename_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_var__2) args

erlps__rename_binding__2 :: ErlangFun
erlps__rename_binding__2 [ren_0, x_1] =
  let    arg_3 = toErl 1
  in let
    ren1_5 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [x_1, arg_3, ren_0]
  in let arg_8 = toErl 2
  in let case_6 = BIF.lists__keymember__3 [x_1, arg_8, ren_0]
  in
    case case_6 of
      (ErlangAtom "false") -> ErlangTuple [x_1, ren1_5]
      (ErlangAtom "true") ->
        let    z_12 = erlps__fresh_name__0 []
        in let head_15 = ErlangTuple [x_1, z_12]
        in ErlangTuple [z_12, ErlangCons head_15 ren1_5]
      something_else -> EXC.case_clause something_else
erlps__rename_binding__2 [arg_19, arg_20] =
  EXC.function_clause unit
erlps__rename_binding__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_binding__2) args

erlps__rename_bindings__2 :: ErlangFun
erlps__rename_bindings__2 [ren_0, (ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, ren_0]
erlps__rename_bindings__2 [ren_0, (ErlangCons x_1 xs_2)] =
  let matchExpr_7 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_7 of
      (ErlangTuple [z_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_bindings__2 [ren1_6, xs_2]
        in
          case matchExpr_12 of
            (ErlangTuple [zs_10, ren2_11]) ->
              ErlangTuple [ErlangCons z_5 zs_10, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_bindings__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__rename_bindings__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_bindings__2) args

erlps__rename_fpats__2 :: ErlangFun
erlps__rename_fpats__2 [ren_0, (ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, ren_0]
erlps__rename_fpats__2 [ren_0, (ErlangCons p_1 ps_2)] =
  let matchExpr_7 = erlps__rename_fpat__2 [ren_0, p_1]
  in
    case matchExpr_7 of
      (ErlangTuple [q_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_fpats__2 [ren1_6, ps_2]
        in
          case matchExpr_12 of
            (ErlangTuple [qs_10, ren2_11]) ->
              ErlangTuple [ErlangCons q_5 qs_10, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_fpats__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__rename_fpats__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_fpats__2) args

erlps__rename_fpat__2 :: ErlangFun
erlps__rename_fpat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "bool"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "int"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "string"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0, p_1@(ErlangAtom "nil")] =
  ErlangTuple [p_1, ren_0]
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "::"), p_1, q_2])]
  =
  let matchExpr_7 = erlps__rename_fpat__2 [ren_0, p_1]
  in
    case matchExpr_7 of
      (ErlangTuple [p1_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_fpat__2 [ren1_6, q_2]
        in
          case matchExpr_12 of
            (ErlangTuple [q1_10, ren2_11]) ->
              let tup_el_13 = ErlangTuple [ErlangAtom "::", p1_5, q1_10]
              in ErlangTuple [tup_el_13, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let matchExpr_6 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_6 of
      (ErlangTuple [z_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "var", z_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "con"), ar_1, c_2, ps_3])]
  =
  let matchExpr_8 = erlps__rename_fpats__2 [ren_0, ps_3]
  in
    case matchExpr_8 of
      (ErlangTuple [ps1_6, ren1_7]) ->
        let tup_el_9 = ErlangTuple [ErlangAtom "con", ar_1, c_2, ps1_6]
        in ErlangTuple [tup_el_9, ren1_7]
      _ -> EXC.badmatch matchExpr_8
erlps__rename_fpat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "tuple"), ps_1])]
  =
  let matchExpr_6 = erlps__rename_fpats__2 [ren_0, ps_1]
  in
    case matchExpr_6 of
      (ErlangTuple [ps1_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "tuple", ps1_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_fpat__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__rename_fpat__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_fpat__2) args

erlps__rename_spat__2 :: ErlangFun
erlps__rename_spat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "bool"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "int"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0,
                       p_1@(ErlangTuple [(ErlangAtom "string"), _])]
  =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0, p_1@(ErlangAtom "nil")] =
  ErlangTuple [p_1, ren_0]
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "::"), x_1, y_2])]
  =
  let matchExpr_7 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_7 of
      (ErlangTuple [x1_5, ren1_6]) ->
        let matchExpr_12 = erlps__rename_binding__2 [ren1_6, y_2]
        in
          case matchExpr_12 of
            (ErlangTuple [y1_10, ren2_11]) ->
              let tup_el_13 = ErlangTuple [ErlangAtom "::", x1_5, y1_10]
              in ErlangTuple [tup_el_13, ren2_11]
            _ -> EXC.badmatch matchExpr_12
      _ -> EXC.badmatch matchExpr_7
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let matchExpr_6 = erlps__rename_binding__2 [ren_0, x_1]
  in
    case matchExpr_6 of
      (ErlangTuple [z_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "var", z_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "con"), ar_1, c_2, xs_3])]
  =
  let matchExpr_8 = erlps__rename_bindings__2 [ren_0, xs_3]
  in
    case matchExpr_8 of
      (ErlangTuple [zs_6, ren1_7]) ->
        let tup_el_9 = ErlangTuple [ErlangAtom "con", ar_1, c_2, zs_6]
        in ErlangTuple [tup_el_9, ren1_7]
      _ -> EXC.badmatch matchExpr_8
erlps__rename_spat__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "tuple"), xs_1])]
  =
  let matchExpr_6 = erlps__rename_bindings__2 [ren_0, xs_1]
  in
    case matchExpr_6 of
      (ErlangTuple [zs_4, ren1_5]) ->
        let tup_el_7 = ErlangTuple [ErlangAtom "tuple", zs_4]
        in ErlangTuple [tup_el_7, ren1_5]
      _ -> EXC.badmatch matchExpr_6
erlps__rename_spat__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__rename_spat__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_spat__2) args

erlps__rename_split__2 :: ErlangFun
erlps__rename_split__2 [ren_0,
                        (ErlangTuple [(ErlangAtom "split"), type_1, x_2,
                                      cases_3])]
  =
  let    tup_el_6 = erlps__rename_var__2 [ren_0, x_2]
  in let
    tup_el_9 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__rename_case__2 [ren_0, lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        cases_3
  in ErlangTuple [ErlangAtom "split", type_1, tup_el_6, tup_el_9]
erlps__rename_split__2 [ren_0,
                        (ErlangTuple [(ErlangAtom "nosplit"), e_1])]
  =
  let tup_el_3 = erlps__rename__2 [ren_0, e_1]
  in ErlangTuple [ErlangAtom "nosplit", tup_el_3]
erlps__rename_split__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__rename_split__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_split__2) args

erlps__rename_case__2 :: ErlangFun
erlps__rename_case__2 [ren_0,
                       (ErlangTuple [(ErlangAtom "case"), pat_1, split_2])]
  =
  let matchExpr_7 = erlps__rename_spat__2 [ren_0, pat_1]
  in
    case matchExpr_7 of
      (ErlangTuple [pat1_5, ren1_6]) ->
        let tup_el_10 = erlps__rename_split__2 [ren1_6, split_2]
        in ErlangTuple [ErlangAtom "case", pat1_5, tup_el_10]
      _ -> EXC.badmatch matchExpr_7
erlps__rename_case__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__rename_case__2 args =
  EXC.badarity (ErlangFun 2 erlps__rename_case__2) args

erlps__field_index__2 :: ErlangFun
erlps__field_index__2 [(ErlangTuple [(ErlangAtom "typed"), _, _,
                                     recty_0]),
                       x_1]
  =
  erlps__field_index__2 [recty_0, x_1]
erlps__field_index__2 [(ErlangTuple [(ErlangAtom "record_t"),
                                     fields_0]),
                       x_1]
  =
  let   
    isx_7 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_t"), _,
                                   (ErlangTuple [(ErlangAtom "id"), _, y_4]),
                                   _])]
             =
             BIF.erlang__op_eq [x_1, y_4]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let lcSrc_8 = erlps__indexed__1 [fields_0]
  in let
    matchExpr_18 =
      flmap
        (\ lc_12 ->
           case lc_12 of
             (ErlangTuple [i_10, field_11]) ->
               let
                 cond_13 =
                   BIF.erlang__apply__2
                     [isx_7, ErlangCons field_11 ErlangEmptyList]
               in
                 case cond_13 of
                   (ErlangAtom "true") -> ErlangCons i_10 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_8
  in
    case matchExpr_18 of
      (ErlangCons i_17 (ErlangEmptyList)) ->
        let rop_20 = toErl 1
        in BIF.erlang__op_minus [i_17, rop_20]
      _ -> EXC.badmatch matchExpr_18
erlps__field_index__2 [arg_21, arg_22] = EXC.function_clause unit
erlps__field_index__2 args =
  EXC.badarity (ErlangFun 2 erlps__field_index__2) args

erlps__field_value__2 :: ErlangFun
erlps__field_value__2 [(ErlangTuple [(ErlangAtom "field_t"), _,
                                     (ErlangTuple [(ErlangAtom "id"), _, x_0]),
                                     _]),
                       fields_1]
  =
  let   
    view_18 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field"), _,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                             _,
                                                             (ErlangTuple [(ErlangAtom "id"),
                                                                           _,
                                                                           y_4])]) (ErlangEmptyList)),
                                   e_5])]
             =
             let tup_el_7 = ErlangTuple [ErlangAtom "set", e_5]
             in ErlangTuple [y_4, tup_el_7]
           lambda_2 [(ErlangTuple [(ErlangAtom "field_upd"), _,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                             _,
                                                             (ErlangTuple [(ErlangAtom "id"),
                                                                           _,
                                                                           y_10])]) (ErlangEmptyList)),
                                   (ErlangTuple [(ErlangAtom "typed"), _,
                                                 (ErlangTuple [(ErlangAtom "lam"),
                                                               _,
                                                               (ErlangCons (ErlangTuple [(ErlangAtom "arg"),
                                                                                         _,
                                                                                         (ErlangTuple [(ErlangAtom "id"),
                                                                                                       _,
                                                                                                       z_11]),
                                                                                         _]) (ErlangEmptyList)),
                                                               e_12]),
                                                 _])])]
             =
             let tup_el_14 = ErlangTuple [ErlangAtom "upd", z_11, e_12]
             in ErlangTuple [y_10, tup_el_14]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    lcSrc_20 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [view_18, fields_1]
  in let
    case_19 =
      flmap
        (\ lc_25 ->
           case lc_25 of
             (ErlangTuple [y_23, upd_24]) ->
               let cond_26 = BIF.erlang__op_eq [x_0, y_23]
               in
                 case cond_26 of
                   (ErlangAtom "true") -> ErlangCons upd_24 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_20
  in
    case case_19 of
      (ErlangCons upd_30 (ErlangEmptyList)) -> upd_30
      (ErlangEmptyList) -> ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__field_value__2 [arg_31, arg_32] = EXC.function_clause unit
erlps__field_value__2 args =
  EXC.badarity (ErlangFun 2 erlps__field_value__2) args

erlps__get_attributes__1 :: ErlangFun
erlps__get_attributes__1 [ann_0] =
  let   
    cond_2 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "stateful", ann_0, ErlangAtom "false"]
  in let
    lop_1 =
      case cond_2 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "stateful") ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    cond_9 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "payable", ann_0, ErlangAtom "false"]
  in let
    lop_8 =
      case cond_9 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "payable") ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    op_arg_16 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "entrypoint", ann_0, ErlangAtom "false"]
  in let cond_15 = BIF.erlang__not__1 [op_arg_16]
  in let
    rop_14 =
      case cond_15 of
        (ErlangAtom "true") ->
          ErlangCons (ErlangAtom "private") ErlangEmptyList
        _ -> ErlangEmptyList
  in let rop_7 = BIF.erlang__op_append [lop_8, rop_14]
  in BIF.erlang__op_append [lop_1, rop_7]
erlps__get_attributes__1 [arg_21] = EXC.function_clause unit
erlps__get_attributes__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_attributes__1) args

erlps__indexed__1 :: ErlangFun
erlps__indexed__1 [xs_0] =
  let    arg_2 = toErl 1
  in let arg_3 = BIF.erlang__length__1 [xs_0]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_1, xs_0]
erlps__indexed__1 [arg_6] = EXC.function_clause unit
erlps__indexed__1 args =
  EXC.badarity (ErlangFun 1 erlps__indexed__1) args

erlps__setnth__3 :: ErlangFun
erlps__setnth__3 [i_0, x_1, xs_2] =
  let    rop_5 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [i_0, rop_5]
  in let
    matchExpr_9 =
      BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_3, xs_2]
  in
    case matchExpr_9 of
      (ErlangTuple [ys_7, (ErlangCons _ zs_8)]) ->
        let
          rop_11 =
            BIF.erlang__op_append [ErlangCons x_1 ErlangEmptyList, zs_8]
        in BIF.erlang__op_append [ys_7, rop_11]
      _ -> EXC.badmatch matchExpr_9
erlps__setnth__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__setnth__3 args =
  EXC.badarity (ErlangFun 3 erlps__setnth__3) args

erlps__fcode_error__1 :: ErlangFun
erlps__fcode_error__1 [error_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Code.Errors" "erlps__format__1"
        [error_0]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_1]
erlps__fcode_error__1 [arg_3] = EXC.function_clause unit
erlps__fcode_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__fcode_error__1) args

erlps__internal_error__1 :: ErlangFun
erlps__internal_error__1 [error_0] =
  let    arg_2 = toErl "~p\n"
  in let
    arg_1 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons error_0 ErlangEmptyList]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_1]
  in let arg_10 = toErl 0
  in let arg_11 = toErl 0
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__2"
        [arg_10, arg_11]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__3"
        [ErlangAtom "internal_error", arg_9, msg_6]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_7]
erlps__internal_error__1 [arg_13] = EXC.function_clause unit
erlps__internal_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__internal_error__1) args

erlps__format_fcode__1 :: ErlangFun
erlps__format_fcode__1 [(ErlangMap map_0)]
  | (DM.Just funs_1) <-
      (Map.lookup (ErlangAtom "functions") map_0) =
  let    lcSrc_4 = BIF.maps__to_list__1 [funs_1]
  in let
    arg_3 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [name_6, def_7]) ->
               let lcRet_9 = erlps__pp_fun__2 [name_6, def_7]
               in ErlangCons lcRet_9 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_4
  in let arg_2 = erlps__pp_above__1 [arg_3]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_2]
erlps__format_fcode__1 [arg_12] = EXC.function_clause unit
erlps__format_fcode__1 args =
  EXC.badarity (ErlangFun 1 erlps__format_fcode__1) args

erlps__format_fexpr__1 :: ErlangFun
erlps__format_fexpr__1 [e_0] =
  let arg_1 = erlps__pp_fexpr__1 [e_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_1]
erlps__format_fexpr__1 [arg_3] = EXC.function_clause unit
erlps__format_fexpr__1 args =
  EXC.badarity (ErlangFun 1 erlps__format_fexpr__1) args

erlps__pp_fun__2 :: ErlangFun
erlps__pp_fun__2 [name_0, (ErlangMap map_1)]
  | (DM.Just body_4) <- (Map.lookup (ErlangAtom "body") map_1)
  , (DM.Just return_3) <- (Map.lookup (ErlangAtom "return") map_1)
  , (DM.Just args_2) <- (Map.lookup (ErlangAtom "args") map_1) =
  let   
    pparg_19 =
      ErlangFun 1
        (let
           lambda_5 [(ErlangTuple [x_7, t_8])] =
             let    head_10 = erlps__pp_text__1 [x_7]
             in let arg_14 = toErl " : "
             in let head_13 = erlps__pp_text__1 [arg_14]
             in let head_16 = erlps__pp_ftype__1 [t_8]
             in
               erlps__pp_beside__1
                 [ErlangCons head_10
                    (ErlangCons head_13 (ErlangCons head_16 ErlangEmptyList))]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in let arg_23 = toErl "function "
  in let head_22 = erlps__pp_text__1 [arg_23]
  in let head_25 = erlps__pp_fun_name__1 [name_0]
  in let arg_32 = toErl ","
  in let arg_31 = erlps__pp_text__1 [arg_32]
  in let
    arg_33 =
      flmap
        (\ lc_36 ->
           let
             lcRet_37 =
               BIF.erlang__apply__2 [pparg_19, ErlangCons lc_36 ErlangEmptyList]
           in ErlangCons lcRet_37 ErlangEmptyList)
        args_2
  in let arg_30 = erlps__pp_punctuate__2 [arg_31, arg_33]
  in let arg_29 = erlps__pp_par__1 [arg_30]
  in let head_28 = erlps__pp_parens__1 [arg_29]
  in let arg_42 = toErl " : "
  in let head_41 = erlps__pp_text__1 [arg_42]
  in let head_44 = erlps__pp_ftype__1 [return_3]
  in let arg_48 = toErl " ="
  in let head_47 = erlps__pp_text__1 [arg_48]
  in let
    arg_20 =
      erlps__pp_beside__1
        [ErlangCons head_22
           (ErlangCons head_25
              (ErlangCons head_28
                 (ErlangCons head_41
                    (ErlangCons head_44
                       (ErlangCons head_47 ErlangEmptyList)))))]
  in let arg_51 = toErl 2
  in let arg_52 = erlps__pp_fexpr__1 [body_4]
  in let
    arg_50 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_51, arg_52]
  in erlps__pp_above__2 [arg_20, arg_50]
erlps__pp_fun__2 [arg_54, arg_55] = EXC.function_clause unit
erlps__pp_fun__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_fun__2) args

erlps__pp_fun_name__1 :: ErlangFun
erlps__pp_fun_name__1 [(ErlangAtom "event")] =
  erlps__pp_text__1 [ErlangAtom "event"]
erlps__pp_fun_name__1 [(ErlangTuple [(ErlangAtom "entrypoint"),
                                     e_0])]
  =
  let arg_1 = BIF.erlang__binary_to_list__1 [e_0]
  in erlps__pp_text__1 [arg_1]
erlps__pp_fun_name__1 [(ErlangTuple [(ErlangAtom "local_fun"),
                                     q_0])]
  =
  let    arg_3 = toErl "."
  in let
    arg_1 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [q_0, arg_3]
  in erlps__pp_text__1 [arg_1]
erlps__pp_fun_name__1 [arg_4] = EXC.function_clause unit
erlps__pp_fun_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_fun_name__1) args

erlps__pp_text__1 :: ErlangFun
erlps__pp_text__1 [(ErlangBinary binEnd_0)]
  | BIN.empty binEnd_0 =
  let arg_1 = toErl "\"\""
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [bin_0] | isEBinary bin_0 =
  let    arg_3 = toErl "~p"
  in let head_5 = BIF.erlang__binary_to_list__1 [bin_0]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons head_5 ErlangEmptyList]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_2]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [s_0] | isEList s_0 =
  let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__concat__1"
        [ErlangCons s_0 ErlangEmptyList]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [a_0] | isEAtom a_0 =
  let arg_1 = BIF.erlang__atom_to_list__1 [a_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [n_0] | isEInt n_0 =
  let arg_1 = BIF.erlang__integer_to_list__1 [n_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_text__1 [arg_3] = EXC.function_clause unit
erlps__pp_text__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_text__1) args

erlps__pp_int__1 :: ErlangFun
erlps__pp_int__1 [i_0] =
  let arg_1 = BIF.erlang__integer_to_list__1 [i_0]
  in BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_1]
erlps__pp_int__1 [arg_3] = EXC.function_clause unit
erlps__pp_int__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_int__1) args

erlps__pp_beside__1 :: ErlangFun
erlps__pp_beside__1 [(ErlangEmptyList)] =
  BIF.do_remote_fun_call "Prettypr" "erlps__empty__0" []
erlps__pp_beside__1 [(ErlangCons x_0 (ErlangEmptyList))] = x_0
erlps__pp_beside__1 [(ErlangCons x_0 xs_1)] =
  let arg_3 = erlps__pp_beside__1 [xs_1]
  in erlps__pp_beside__2 [x_0, arg_3]
erlps__pp_beside__1 [arg_5] = EXC.function_clause unit
erlps__pp_beside__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_beside__1) args

erlps__pp_beside__2 :: ErlangFun
erlps__pp_beside__2 [a_0, b_1] =
  BIF.do_remote_fun_call "Prettypr" "erlps__beside__2" [a_0, b_1]
erlps__pp_beside__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__pp_beside__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_beside__2) args

erlps__pp_above__1 :: ErlangFun
erlps__pp_above__1 [(ErlangEmptyList)] =
  BIF.do_remote_fun_call "Prettypr" "erlps__empty__0" []
erlps__pp_above__1 [(ErlangCons x_0 (ErlangEmptyList))] = x_0
erlps__pp_above__1 [(ErlangCons x_0 xs_1)] =
  let arg_3 = erlps__pp_above__1 [xs_1]
  in erlps__pp_above__2 [x_0, arg_3]
erlps__pp_above__1 [arg_5] = EXC.function_clause unit
erlps__pp_above__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_above__1) args

erlps__pp_above__2 :: ErlangFun
erlps__pp_above__2 [a_0, b_1] =
  BIF.do_remote_fun_call "Prettypr" "erlps__above__2" [a_0, b_1]
erlps__pp_above__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__pp_above__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_above__2) args

erlps__pp_parens__1 :: ErlangFun
erlps__pp_parens__1 [doc_0] =
  let    arg_3 = toErl "("
  in let head_2 = erlps__pp_text__1 [arg_3]
  in let arg_8 = toErl ")"
  in let head_7 = erlps__pp_text__1 [arg_8]
  in
    erlps__pp_beside__1
      [ErlangCons head_2
         (ErlangCons doc_0 (ErlangCons head_7 ErlangEmptyList))]
erlps__pp_parens__1 [arg_10] = EXC.function_clause unit
erlps__pp_parens__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_parens__1) args

erlps__pp_braces__1 :: ErlangFun
erlps__pp_braces__1 [doc_0] =
  let    arg_3 = toErl "{"
  in let head_2 = erlps__pp_text__1 [arg_3]
  in let arg_8 = toErl "}"
  in let head_7 = erlps__pp_text__1 [arg_8]
  in
    erlps__pp_beside__1
      [ErlangCons head_2
         (ErlangCons doc_0 (ErlangCons head_7 ErlangEmptyList))]
erlps__pp_braces__1 [arg_10] = EXC.function_clause unit
erlps__pp_braces__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_braces__1) args

erlps__pp_punctuate__2 :: ErlangFun
erlps__pp_punctuate__2 [_sep_0, (ErlangEmptyList)] =
  ErlangEmptyList
erlps__pp_punctuate__2 [_sep_0,
                        (ErlangCons x_1 (ErlangEmptyList))]
  =
  ErlangCons x_1 ErlangEmptyList
erlps__pp_punctuate__2 [sep_0, (ErlangCons x_1 xs_2)] =
  let    head_3 = erlps__pp_beside__2 [x_1, sep_0]
  in let tail_6 = erlps__pp_punctuate__2 [sep_0, xs_2]
  in ErlangCons head_3 tail_6
erlps__pp_punctuate__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__pp_punctuate__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_punctuate__2) args

erlps__pp_par__1 :: ErlangFun
erlps__pp_par__1 [(ErlangEmptyList)] =
  BIF.do_remote_fun_call "Prettypr" "erlps__empty__0" []
erlps__pp_par__1 [xs_0] =
  BIF.do_remote_fun_call "Prettypr" "erlps__par__1" [xs_0]
erlps__pp_par__1 [arg_2] = EXC.function_clause unit
erlps__pp_par__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_par__1) args

erlps__pp_fexpr__1 :: ErlangFun
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "lit"),
                                  (ErlangTuple [(ErlangAtom "typerep"), t_0])])]
  =
  erlps__pp_ftype__1 [t_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "lit"),
                                  (ErlangTuple [tag_0, lit_1])])]
  =
  let arg_2 = ErlangTuple [tag_0, ErlangEmptyList, lit_1]
  in BIF.do_remote_fun_call "Aeso.Pretty" "erlps__expr__1" [arg_2]
erlps__pp_fexpr__1 [(ErlangAtom "nil")] =
  let arg_0 = toErl "[]"
  in erlps__pp_text__1 [arg_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "var"), x_0])] =
  erlps__pp_text__1 [x_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "def"), fun_0])] =
  erlps__pp_fun_name__1 [fun_0]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "def_u"), fun_0,
                                  ar_1])]
  =
  let    head_3 = erlps__pp_fun_name__1 [fun_0]
  in let arg_7 = toErl "/"
  in let head_6 = erlps__pp_text__1 [arg_7]
  in let head_9 = erlps__pp_int__1 [ar_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_3
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "def"), fun_0,
                                  args_1])]
  =
  let arg_2 = erlps__pp_fun_name__1 [fun_0]
  in erlps__pp_call__2 [arg_2, args_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "con"), _, i_0,
                                  (ErlangEmptyList)])]
  =
  let    arg_2 = toErl "C"
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let arg_3 = erlps__pp_int__1 [i_0]
  in erlps__pp_beside__2 [arg_1, arg_3]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "con"), _, i_0,
                                  es_1])]
  =
  let   
    arg_3 =
      ErlangTuple
        [ErlangAtom "con", ErlangEmptyList, i_0, ErlangEmptyList]
  in let arg_2 = erlps__pp_fexpr__1 [arg_3]
  in let arg_9 = ErlangTuple [ErlangAtom "tuple", es_1]
  in let arg_8 = erlps__pp_fexpr__1 [arg_9]
  in erlps__pp_beside__2 [arg_2, arg_8]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "tuple"), es_0])] =
  let    arg_4 = toErl ","
  in let arg_3 = erlps__pp_text__1 [arg_4]
  in let
    arg_5 =
      flmap
        (\ lc_8 ->
           let lcRet_9 = erlps__pp_fexpr__1 [lc_8]
           in ErlangCons lcRet_9 ErlangEmptyList)
        es_0
  in let arg_2 = erlps__pp_punctuate__2 [arg_3, arg_5]
  in let arg_1 = erlps__pp_par__1 [arg_2]
  in erlps__pp_parens__1 [arg_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "proj"), e_0,
                                  i_1])]
  =
  let    head_3 = erlps__pp_fexpr__1 [e_0]
  in let arg_7 = toErl "."
  in let head_6 = erlps__pp_text__1 [arg_7]
  in let head_9 = erlps__pp_int__1 [i_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_3
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "lam"), xs_0,
                                  a_1])]
  =
  let   
    tup_el_6 =
      flmap
        (\ lc_9 ->
           let lcRet_10 = ErlangTuple [ErlangAtom "var", lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        xs_0
  in let arg_4 = ErlangTuple [ErlangAtom "tuple", tup_el_6]
  in let head_3 = erlps__pp_fexpr__1 [arg_4]
  in let arg_15 = toErl "=>"
  in let head_14 = erlps__pp_text__1 [arg_15]
  in let arg_18 = toErl 2
  in let arg_19 = erlps__pp_fexpr__1 [a_1]
  in let
    head_17 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_18, arg_19]
  in
    erlps__pp_par__1
      [ErlangCons head_3
         (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "closure"), fun_0,
                                  clenv_1])]
  =
  let   
    fvs_6 =
      case clenv_1 of
        (ErlangTuple [(ErlangAtom "tuple"), xs_3]) -> xs_3
        (ErlangTuple [(ErlangAtom "var"), _]) ->
          ErlangCons clenv_1 ErlangEmptyList
        something_else -> EXC.case_clause something_else
  in let arg_8 = toErl "__CLOSURE__"
  in let arg_7 = erlps__pp_text__1 [arg_8]
  in let head_10 = ErlangTuple [ErlangAtom "def", fun_0]
  in erlps__pp_call__2 [arg_7, ErlangCons head_10 fvs_6]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "set_proj"), e_0,
                                  i_1, a_2])]
  =
  let    arg_3 = erlps__pp_fexpr__1 [e_0]
  in let head_8 = erlps__pp_int__1 [i_1]
  in let arg_12 = toErl " = "
  in let head_11 = erlps__pp_text__1 [arg_12]
  in let head_14 = erlps__pp_fexpr__1 [a_2]
  in let
    arg_6 =
      erlps__pp_beside__1
        [ErlangCons head_8
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_5 = erlps__pp_braces__1 [arg_6]
  in erlps__pp_beside__2 [arg_3, arg_5]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "op"), op_0,
                                  args_3@(ErlangCons a_1 (ErlangCons b_2 (ErlangEmptyList)))])]
  =
  let case_4 = erlps__is_infix__1 [op_0]
  in
    case case_4 of
      (ErlangAtom "false") ->
        let arg_6 = erlps__pp_text__1 [op_0]
        in erlps__pp_call__2 [arg_6, args_3]
      (ErlangAtom "true") ->
        let    head_11 = erlps__pp_fexpr__1 [a_1]
        in let head_14 = erlps__pp_text__1 [op_0]
        in let head_17 = erlps__pp_fexpr__1 [b_2]
        in let
          arg_9 =
            erlps__pp_par__1
              [ErlangCons head_11
                 (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))]
        in erlps__pp_parens__1 [arg_9]
      something_else -> EXC.case_clause something_else
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "op"), op_0,
                                  args_2@(ErlangCons a_1 (ErlangEmptyList))])]
  =
  let case_3 = erlps__is_infix__1 [op_0]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let arg_5 = erlps__pp_text__1 [op_0]
        in erlps__pp_call__2 [arg_5, args_2]
      (ErlangAtom "true") ->
        let    head_10 = erlps__pp_text__1 [op_0]
        in let head_13 = erlps__pp_fexpr__1 [a_1]
        in let
          arg_8 =
            erlps__pp_par__1
              [ErlangCons head_10 (ErlangCons head_13 ErlangEmptyList)]
        in erlps__pp_parens__1 [arg_8]
      something_else -> EXC.case_clause something_else
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "op"), op_0,
                                  as_1])]
  =
  let    arg_2 = erlps__pp_text__1 [op_0]
  in let arg_5 = ErlangTuple [ErlangAtom "tuple", as_1]
  in let arg_4 = erlps__pp_fexpr__1 [arg_5]
  in erlps__pp_beside__2 [arg_2, arg_4]
erlps__pp_fexpr__1 [expr_0@(ErlangTuple [(ErlangAtom "let"), _,
                                         _, _])]
  =
  let   
    lets_20 =
      ErlangFun 1
        (let
           lets_1 [(ErlangTuple [(ErlangAtom "let"), y_3, c_4, d_5])] =
             let matchExpr_10 = lets_1 [d_5]
             in
               case matchExpr_10 of
                 (ErlangTuple [ls_8, e_9]) ->
                   let head_12 = ErlangTuple [y_3, c_4]
                   in ErlangTuple [ErlangCons head_12 ls_8, e_9]
                 _ -> EXC.badmatch matchExpr_10
           lets_1 [e_17] = ErlangTuple [ErlangEmptyList, e_17]
           lets_1 [arg_2] = EXC.function_clause unit
           lets_1 args = EXC.badarity (ErlangFun 1 lets_1) args
         in lets_1)
  in let
    matchExpr_25 =
      BIF.erlang__apply__2 [lets_20, ErlangCons expr_0 ErlangEmptyList]
  in
    case matchExpr_25 of
      (ErlangTuple [ls_23, body_24]) ->
        let    arg_31 = toErl "let "
        in let head_30 = erlps__pp_text__1 [arg_31]
        in let
          arg_34 =
            flmap
              (\ lc_38 ->
                 case lc_38 of
                   (ErlangTuple [x_36, a_37]) ->
                     let    head_41 = erlps__pp_text__1 [x_36]
                     in let arg_45 = toErl "="
                     in let head_44 = erlps__pp_text__1 [arg_45]
                     in let arg_48 = toErl 2
                     in let arg_49 = erlps__pp_fexpr__1 [a_37]
                     in let
                       head_47 =
                         BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
                           [arg_48, arg_49]
                     in let
                       lcRet_39 =
                         erlps__pp_par__1
                           [ErlangCons head_41
                              (ErlangCons head_44
                                 (ErlangCons head_47 ErlangEmptyList))]
                     in ErlangCons lcRet_39 ErlangEmptyList
                   _ -> ErlangEmptyList)
              ls_23
        in let head_33 = erlps__pp_above__1 [arg_34]
        in let arg_54 = toErl " in "
        in let head_53 = erlps__pp_text__1 [arg_54]
        in let
          head_28 =
            erlps__pp_beside__1
              [ErlangCons head_30
                 (ErlangCons head_33 (ErlangCons head_53 ErlangEmptyList))]
        in let head_57 = erlps__pp_fexpr__1 [body_24]
        in let
          arg_26 =
            erlps__pp_par__1
              [ErlangCons head_28 (ErlangCons head_57 ErlangEmptyList)]
        in erlps__pp_parens__1 [arg_26]
      _ -> EXC.badmatch matchExpr_25
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "builtin_u"), b_0,
                                  n_1])]
  =
  let    head_3 = erlps__pp_text__1 [b_0]
  in let arg_7 = toErl "/"
  in let head_6 = erlps__pp_text__1 [arg_7]
  in let head_9 = erlps__pp_text__1 [n_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_3
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "builtin_u"), b_0,
                                  n_1, typeargs_2])]
  =
  let    head_4 = erlps__pp_text__1 [b_0]
  in let arg_8 = toErl "@"
  in let head_7 = erlps__pp_text__1 [arg_8]
  in let arg_11 = ErlangTuple [ErlangAtom "tuple", typeargs_2]
  in let head_10 = erlps__pp_fexpr__1 [arg_11]
  in let arg_16 = toErl "/"
  in let head_15 = erlps__pp_text__1 [arg_16]
  in let head_18 = erlps__pp_text__1 [n_1]
  in
    erlps__pp_beside__1
      [ErlangCons head_4
         (ErlangCons head_7
            (ErlangCons head_10
               (ErlangCons head_15 (ErlangCons head_18 ErlangEmptyList))))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "builtin"), b_0,
                                  as_1])]
  =
  let arg_2 = erlps__pp_text__1 [b_0]
  in erlps__pp_call__2 [arg_2, as_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "remote_u"),
                                  argst_0, rett_1, ct_2, fun_3])]
  =
  let    head_5 = erlps__pp_fexpr__1 [ct_2]
  in let arg_9 = toErl "."
  in let head_8 = erlps__pp_text__1 [arg_9]
  in let head_11 = erlps__pp_fun_name__1 [fun_3]
  in let arg_15 = toErl " : "
  in let head_14 = erlps__pp_text__1 [arg_15]
  in let
    arg_18 = ErlangTuple [ErlangAtom "function", argst_0, rett_1]
  in let head_17 = erlps__pp_ftype__1 [arg_18]
  in
    erlps__pp_beside__1
      [ErlangCons head_5
         (ErlangCons head_8
            (ErlangCons head_11
               (ErlangCons head_14 (ErlangCons head_17 ErlangEmptyList))))]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "remote"), argst_0,
                                  rett_1, ct_2, fun_3, as_4])]
  =
  let    head_8 = erlps__pp_fexpr__1 [ct_2]
  in let arg_12 = toErl "."
  in let head_11 = erlps__pp_text__1 [arg_12]
  in let head_14 = erlps__pp_fun_name__1 [fun_3]
  in let arg_18 = toErl " : "
  in let head_17 = erlps__pp_text__1 [arg_18]
  in let
    arg_21 = ErlangTuple [ErlangAtom "function", argst_0, rett_1]
  in let head_20 = erlps__pp_ftype__1 [arg_21]
  in let
    arg_6 =
      erlps__pp_beside__1
        [ErlangCons head_8
           (ErlangCons head_11
              (ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_20 ErlangEmptyList))))]
  in let arg_5 = erlps__pp_parens__1 [arg_6]
  in erlps__pp_call__2 [arg_5, as_4]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "funcall"), fun_0,
                                  as_1])]
  =
  let arg_2 = erlps__pp_fexpr__1 [fun_0]
  in erlps__pp_call__2 [arg_2, as_1]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "set_state"), r_0,
                                  a_1])]
  =
  let    arg_3 = toErl "set_state"
  in let arg_2 = erlps__pp_text__1 [arg_3]
  in let tup_el_7 = ErlangTuple [ErlangAtom "int", r_0]
  in let head_5 = ErlangTuple [ErlangAtom "lit", tup_el_7]
  in
    erlps__pp_call__2
      [arg_2, ErlangCons head_5 (ErlangCons a_1 ErlangEmptyList)]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "get_state"),
                                  r_0])]
  =
  let    arg_2 = toErl "get_state"
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let tup_el_6 = ErlangTuple [ErlangAtom "int", r_0]
  in let head_4 = ErlangTuple [ErlangAtom "lit", tup_el_6]
  in erlps__pp_call__2 [arg_1, ErlangCons head_4 ErlangEmptyList]
erlps__pp_fexpr__1 [(ErlangTuple [(ErlangAtom "switch"),
                                  split_0])]
  =
  erlps__pp_split__1 [split_0]
erlps__pp_fexpr__1 [arg_2] = EXC.function_clause unit
erlps__pp_fexpr__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_fexpr__1) args

erlps__pp_call__2 :: ErlangFun
erlps__pp_call__2 [fun_0, args_1] =
  let    arg_4 = ErlangTuple [ErlangAtom "tuple", args_1]
  in let arg_3 = erlps__pp_fexpr__1 [arg_4]
  in erlps__pp_beside__2 [fun_0, arg_3]
erlps__pp_call__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__pp_call__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_call__2) args

erlps__pp_call_t__2 :: ErlangFun
erlps__pp_call_t__2 [fun_0, args_1] =
  let    arg_2 = erlps__pp_text__1 [fun_0]
  in let arg_5 = ErlangTuple [ErlangAtom "tuple", args_1]
  in let arg_4 = erlps__pp_ftype__1 [arg_5]
  in erlps__pp_beside__2 [arg_2, arg_4]
erlps__pp_call_t__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__pp_call_t__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_call_t__2) args

erlps__pp_ftype__1 :: ErlangFun
erlps__pp_ftype__1 [t_0] | isEAtom t_0 = erlps__pp_text__1 [t_0]
erlps__pp_ftype__1 [(ErlangAtom "any")] =
  let arg_0 = toErl "_"
  in erlps__pp_text__1 [arg_0]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "tvar"), x_0])] =
  erlps__pp_text__1 [x_0]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "bytes"), n_0])] =
  let    arg_2 = toErl "bytes"
  in let arg_1 = erlps__pp_text__1 [arg_2]
  in let tup_el_6 = ErlangTuple [ErlangAtom "int", n_0]
  in let head_4 = ErlangTuple [ErlangAtom "lit", tup_el_6]
  in erlps__pp_call__2 [arg_1, ErlangCons head_4 ErlangEmptyList]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "oracle"), q_0,
                                  r_1])]
  =
  let arg_2 = toErl "oracle"
  in
    erlps__pp_call_t__2
      [arg_2, ErlangCons q_0 (ErlangCons r_1 ErlangEmptyList)]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "tuple"), ts_0])] =
  let    arg_4 = toErl " *"
  in let arg_3 = erlps__pp_text__1 [arg_4]
  in let
    arg_5 =
      flmap
        (\ lc_8 ->
           let lcRet_9 = erlps__pp_ftype__1 [lc_8]
           in ErlangCons lcRet_9 ErlangEmptyList)
        ts_0
  in let arg_2 = erlps__pp_punctuate__2 [arg_3, arg_5]
  in let arg_1 = erlps__pp_par__1 [arg_2]
  in erlps__pp_parens__1 [arg_1]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "list"), t_0])] =
  let arg_1 = toErl "list"
  in erlps__pp_call_t__2 [arg_1, ErlangCons t_0 ErlangEmptyList]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "function"),
                                  args_0, res_1])]
  =
  let    arg_4 = ErlangTuple [ErlangAtom "tuple", args_0]
  in let head_3 = erlps__pp_ftype__1 [arg_4]
  in let arg_9 = toErl "=>"
  in let head_8 = erlps__pp_text__1 [arg_9]
  in let head_11 = erlps__pp_ftype__1 [res_1]
  in
    erlps__pp_par__1
      [ErlangCons head_3
         (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "map"), key_0,
                                  val_1])]
  =
  let arg_2 = toErl "map"
  in
    erlps__pp_call_t__2
      [arg_2, ErlangCons key_0 (ErlangCons val_1 ErlangEmptyList)]
erlps__pp_ftype__1 [(ErlangTuple [(ErlangAtom "variant"),
                                  cons_0])]
  =
  let    arg_3 = toErl " |"
  in let arg_2 = erlps__pp_text__1 [arg_3]
  in let lcSrc_5 = erlps__indexed__1 [cons_0]
  in let
    arg_4 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [i_7, args_8]) ->
               let
                 lcRet_10 =
                   case args_8 of
                     (ErlangEmptyList) ->
                       let    rop_17 = toErl 1
                       in let tup_el_15 = BIF.erlang__op_minus [i_7, rop_17]
                       in let
                         arg_12 =
                           ErlangTuple
                             [ErlangAtom "con", ErlangEmptyList, tup_el_15,
                              ErlangEmptyList]
                       in erlps__pp_fexpr__1 [arg_12]
                     _ ->
                       let    rop_25 = toErl 1
                       in let tup_el_23 = BIF.erlang__op_minus [i_7, rop_25]
                       in let
                         arg_20 =
                           ErlangTuple
                             [ErlangAtom "con", ErlangEmptyList, tup_el_23,
                              ErlangEmptyList]
                       in let arg_19 = erlps__pp_fexpr__1 [arg_20]
                       in let arg_28 = ErlangTuple [ErlangAtom "tuple", args_8]
                       in let arg_27 = erlps__pp_ftype__1 [arg_28]
                       in erlps__pp_beside__2 [arg_19, arg_27]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_5
  in let arg_1 = erlps__pp_punctuate__2 [arg_2, arg_4]
  in erlps__pp_par__1 [arg_1]
erlps__pp_ftype__1 [arg_31] = EXC.function_clause unit
erlps__pp_ftype__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_ftype__1) args

erlps__pp_split__1 :: ErlangFun
erlps__pp_split__1 [(ErlangTuple [(ErlangAtom "nosplit"), e_0])]
  =
  erlps__pp_fexpr__1 [e_0]
erlps__pp_split__1 [(ErlangTuple [(ErlangAtom "split"), type_0,
                                  x_1, alts_2])]
  =
  let    arg_8 = toErl "switch("
  in let head_7 = erlps__pp_text__1 [arg_8]
  in let head_10 = erlps__pp_text__1 [x_1]
  in let arg_14 = toErl " : "
  in let head_13 = erlps__pp_text__1 [arg_14]
  in let head_16 = erlps__pp_ftype__1 [type_0]
  in let arg_20 = toErl ")"
  in let head_19 = erlps__pp_text__1 [arg_20]
  in let
    head_5 =
      erlps__pp_beside__1
        [ErlangCons head_7
           (ErlangCons head_10
              (ErlangCons head_13
                 (ErlangCons head_16 (ErlangCons head_19 ErlangEmptyList))))]
  in let
    rop_23 =
      flmap
        (\ lc_26 ->
           let    arg_28 = toErl 2
           in let arg_29 = erlps__pp_case__1 [lc_26]
           in let
             lcRet_27 =
               BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
                 [arg_28, arg_29]
           in ErlangCons lcRet_27 ErlangEmptyList)
        alts_2
  in let
    arg_3 =
      BIF.erlang__op_append [ErlangCons head_5 ErlangEmptyList, rop_23]
  in erlps__pp_above__1 [arg_3]
erlps__pp_split__1 [arg_31] = EXC.function_clause unit
erlps__pp_split__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_split__1) args

erlps__pp_case__1 :: ErlangFun
erlps__pp_case__1 [(ErlangTuple [(ErlangAtom "case"), pat_0,
                                 split_1])]
  =
  let    arg_4 = erlps__pp_pat__1 [pat_0]
  in let arg_7 = toErl " =>"
  in let arg_6 = erlps__pp_text__1 [arg_7]
  in let head_3 = erlps__pp_beside__2 [arg_4, arg_6]
  in let arg_10 = toErl 2
  in let arg_11 = erlps__pp_split__1 [split_1]
  in let
    head_9 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_10, arg_11]
  in
    BIF.do_remote_fun_call "Prettypr" "erlps__sep__1"
      [ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList)]
erlps__pp_case__1 [arg_14] = EXC.function_clause unit
erlps__pp_case__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_case__1) args

erlps__pp_pat__1 :: ErlangFun
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "tuple"), xs_0])] =
  let   
    tup_el_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = ErlangTuple [ErlangAtom "var", lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        xs_0
  in let arg_1 = ErlangTuple [ErlangAtom "tuple", tup_el_3]
  in erlps__pp_fexpr__1 [arg_1]
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "::"), x_0, xs_1])] =
  let    head_6 = ErlangTuple [ErlangAtom "var", x_0]
  in let head_10 = ErlangTuple [ErlangAtom "var", xs_1]
  in let
    arg_2 =
      ErlangTuple
        [ErlangAtom "op", ErlangAtom "::",
         ErlangCons head_6 (ErlangCons head_10 ErlangEmptyList)]
  in erlps__pp_fexpr__1 [arg_2]
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "con"), as_0, i_1,
                                xs_2])]
  =
  let   
    tup_el_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = ErlangTuple [ErlangAtom "var", lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        xs_2
  in let
    arg_3 = ErlangTuple [ErlangAtom "con", as_0, i_1, tup_el_7]
  in erlps__pp_fexpr__1 [arg_3]
erlps__pp_pat__1 [(ErlangTuple [(ErlangAtom "var"), x_0])] =
  let arg_1 = ErlangTuple [ErlangAtom "var", x_0]
  in erlps__pp_fexpr__1 [arg_1]
erlps__pp_pat__1 [p_1@(ErlangTuple [tag_0, _])]
  | ((weakEq tag_0 (ErlangAtom "bool")) ||
       (weakEq tag_0 (ErlangAtom "int"))) ||
      (weakEq tag_0 (ErlangAtom "string")) =
  let arg_2 = ErlangTuple [ErlangAtom "lit", p_1]
  in erlps__pp_fexpr__1 [arg_2]
erlps__pp_pat__1 [pat_0] = erlps__pp_fexpr__1 [pat_0]
erlps__pp_pat__1 [arg_2] = EXC.function_clause unit
erlps__pp_pat__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_pat__1) args

erlps__is_infix__1 :: ErlangFun
erlps__is_infix__1 [op_0] =
  let    arg_1 = BIF.erlang__atom_to_list__1 [op_0]
  in let c_3 = BIF.erlang__hd__1 [arg_1]
  in let rop_6 = toErl 97
  in let lop_4 = BIF.erlang__op_lesser [c_3, rop_6]
  in
    case lop_4 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") ->
        let rop_8 = toErl 122
        in BIF.erlang__op_greater [c_3, rop_8]
      _ -> EXC.badarg1 lop_4
erlps__is_infix__1 [arg_9] = EXC.function_clause unit
erlps__is_infix__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_infix__1) args