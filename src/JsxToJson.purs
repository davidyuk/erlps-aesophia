module Jsx.To.Json(erlps__to_json__2, erlps__format__2,
                   erlps__init__1, erlps__handle_event__2, erlps__start_json__0,
                   erlps__start_json__1, erlps__start_object__1,
                   erlps__start_array__1, erlps__finish__1, erlps__insert__2,
                   erlps__get_key__1, erlps__get_value__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__to_json__2 :: ErlangFun
erlps__to_json__2 [source_0, config_1] | isEList config_1 =
  let   
    arg_7 =
      BIF.erlang__op_append
        [config_1,
         ErlangCons (ErlangAtom "escaped_strings") ErlangEmptyList]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__extract_config__1"
        [arg_7]
  in let
    fun_3 =
      BIF.do_remote_fun_call "Jsx" "erlps__encoder__3"
        [ErlangAtom "jsx_to_json", config_1, arg_6]
  in
    BIF.erlang__apply__2 [fun_3, ErlangCons source_0 ErlangEmptyList]
erlps__to_json__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__to_json__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__format__2 :: ErlangFun
erlps__format__2 [source_0, config_1]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let lop_12 = BIF.erlang__is_binary__1 [source_0]
             in
               case lop_12 of
                 (ErlangAtom "false") -> ErlangAtom "false"
                 (ErlangAtom "true") -> BIF.erlang__is_list__1 [config_1]
                 _ -> EXC.badarg1 lop_12))) =
  let   
    arg_7 =
      BIF.erlang__op_append
        [config_1,
         ErlangCons (ErlangAtom "escaped_strings") ErlangEmptyList]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__extract_config__1"
        [arg_7]
  in let
    fun_3 =
      BIF.do_remote_fun_call "Jsx" "erlps__decoder__3"
        [ErlangAtom "jsx_to_json", config_1, arg_6]
  in
    BIF.erlang__apply__2 [fun_3, ErlangCons source_0 ErlangEmptyList]
erlps__format__2 [_, _] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__format__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__format__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_config__1 :: ErlangFun
erlps__parse_config__1 [config_0] =
  let    tup_el_4 = toErl 0
  in let tup_el_5 = toErl 0
  in let tup_el_6 = toErl 0
  in let
    arg_2 =
      ErlangTuple [ErlangAtom "config", tup_el_4, tup_el_5, tup_el_6]
  in erlps__parse_config__2 [config_0, arg_2]
erlps__parse_config__1 [arg_7] = EXC.function_clause unit
erlps__parse_config__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_config__2 :: ErlangFun
erlps__parse_config__2 [(ErlangCons (ErlangTuple [(ErlangAtom "space"),
                                                  val_0]) rest_1),
                        config_2]
  | ((isEInt val_0) && (weakGt val_0 (toErl 0))) =
  let
    arg_4 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), space_7, indent_8,
                      depth_9]) ->
          ErlangTuple [ErlangAtom "config", val_0, indent_8, depth_9]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_1, arg_4]
erlps__parse_config__2 [(ErlangCons (ErlangAtom "space") rest_0),
                        config_1]
  =
  let    record_updt_5 = toErl 1
  in let
    arg_3 =
      case config_1 of
        (ErlangTuple [(ErlangAtom "config"), space_6, indent_7,
                      depth_8]) ->
          ErlangTuple
            [ErlangAtom "config", record_updt_5, indent_7, depth_8]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_0, arg_3]
erlps__parse_config__2 [(ErlangCons (ErlangTuple [(ErlangAtom "indent"),
                                                  val_0]) rest_1),
                        config_2]
  | ((isEInt val_0) && (weakGt val_0 (toErl 0))) =
  let
    arg_4 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), space_7, indent_8,
                      depth_9]) ->
          ErlangTuple [ErlangAtom "config", space_7, val_0, depth_9]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_1, arg_4]
erlps__parse_config__2 [(ErlangCons (ErlangAtom "indent") rest_0),
                        config_1]
  =
  let    record_updt_5 = toErl 1
  in let
    arg_3 =
      case config_1 of
        (ErlangTuple [(ErlangAtom "config"), space_6, indent_7,
                      depth_8]) ->
          ErlangTuple
            [ErlangAtom "config", space_6, record_updt_5, depth_8]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_0, arg_3]
erlps__parse_config__2 [options_2@(ErlangCons (ErlangTuple [k_0,
                                                            _]) rest_1),
                        config_3]
  =
  let   
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__valid_flags__0" []
  in let case_4 = BIF.lists__member__2 [k_0, arg_6]
  in
    case case_4 of
      (ErlangAtom "true") -> erlps__parse_config__2 [rest_1, config_3]
      (ErlangAtom "false") ->
        BIF.erlang__error__2
          [ErlangAtom "badarg",
           ErlangCons options_2 (ErlangCons config_3 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__parse_config__2 [options_2@(ErlangCons k_0 rest_1),
                        config_3]
  =
  let   
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__valid_flags__0" []
  in let case_4 = BIF.lists__member__2 [k_0, arg_6]
  in
    case case_4 of
      (ErlangAtom "true") -> erlps__parse_config__2 [rest_1, config_3]
      (ErlangAtom "false") ->
        BIF.erlang__error__2
          [ErlangAtom "badarg",
           ErlangCons options_2 (ErlangCons config_3 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__parse_config__2 [(ErlangEmptyList), config_0] = config_0
erlps__parse_config__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__parse_config__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__init__1 :: ErlangFun
erlps__init__1 [config_0] =
  let tup_el_2 = erlps__parse_config__1 [config_0]
  in ErlangTuple [ErlangEmptyList, tup_el_2]
erlps__init__1 [arg_4] = EXC.function_clause unit
erlps__init__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__handle_event__2 :: ErlangFun
erlps__handle_event__2 [(ErlangAtom "end_json"), state_0] =
  erlps__get_value__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "start_object"), state_0] =
  erlps__start_object__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "end_object"), state_0] =
  erlps__finish__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "start_array"), state_0] =
  erlps__start_array__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "end_array"), state_0] =
  erlps__finish__1 [state_0]
erlps__handle_event__2 [(ErlangTuple [type_0, event_1]),
                        state_3@(ErlangTuple [_, config_2])]
  =
  let arg_4 = erlps__encode__3 [type_0, event_1, config_2]
  in erlps__insert__2 [arg_4, state_3]
erlps__handle_event__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__handle_event__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__encode__3 :: ErlangFun
erlps__encode__3 [(ErlangAtom "string"), string_0, _config_1] =
  let    bin_el_3 = toErl 34
  in let
    head_2 = ErlangBinary (BIN.fromInt bin_el_3 (toErl 8) 1 BIN.Big)
  in let bin_el_8 = toErl 34
  in let
    head_7 = ErlangBinary (BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big)
  in
    ErlangCons head_2
      (ErlangCons string_0 (ErlangCons head_7 ErlangEmptyList))
erlps__encode__3 [(ErlangAtom "key"), key_0, _config_1] =
  let    bin_el_3 = toErl 34
  in let
    head_2 = ErlangBinary (BIN.fromInt bin_el_3 (toErl 8) 1 BIN.Big)
  in let bin_el_8 = toErl 34
  in let
    head_7 = ErlangBinary (BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big)
  in
    ErlangCons head_2
      (ErlangCons key_0 (ErlangCons head_7 ErlangEmptyList))
erlps__encode__3 [(ErlangAtom "literal"), literal_0, _config_1] =
  BIF.erlang__atom_to_list__1 [literal_0]
erlps__encode__3 [(ErlangAtom "integer"), integer_0, _config_1] =
  BIF.erlang__integer_to_list__1 [integer_0]
erlps__encode__3 [(ErlangAtom "float"), float_0, _config_1] =
  let arg_2 = toErl "~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_2, ErlangCons float_0 ErlangEmptyList]
erlps__encode__3 [arg_6, arg_7, arg_8] = EXC.function_clause unit
erlps__encode__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__space__1 :: ErlangFun
erlps__space__1 [config_0] =
  let
    case_1 =
      case config_0 of
        (ErlangTuple arr_4) | (DM.Just field_3) <- ((arr_4 DA.!! 1)) ->
          field_3
        _ -> EXC.badrecord (ErlangAtom "config")
  in
    case case_1 of
      (ErlangInt num_5) | ((ErlangInt num_5) == (toErl 0)) ->
        ErlangBinary (BIN.concat [])
      x_6 | weakGt x_6 (toErl 0) ->
        let    bin_el_8 = toErl 32
        in let
          arg_7 = ErlangBinary (BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big)
        in BIF.binary__copy__2 [arg_7, x_6]
      something_else -> EXC.case_clause something_else
erlps__space__1 [arg_10] = EXC.function_clause unit
erlps__space__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__indent__1 :: ErlangFun
erlps__indent__1 [config_0] =
  let
    case_1 =
      case config_0 of
        (ErlangTuple arr_4) | (DM.Just field_3) <- ((arr_4 DA.!! 2)) ->
          field_3
        _ -> EXC.badrecord (ErlangAtom "config")
  in
    case case_1 of
      (ErlangInt num_5) | ((ErlangInt num_5) == (toErl 0)) ->
        ErlangBinary (BIN.concat [])
      x_6 | weakGt x_6 (toErl 0) ->
        let    bin_el_8 = toErl 10
        in let
          bin_el_7 =
            ErlangBinary (BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big)
        in let bin_el_11 = toErl 32
        in let
          arg_10 = ErlangBinary (BIN.fromInt bin_el_11 (toErl 8) 1 BIN.Big)
        in let
          rop_14 =
            case config_0 of
              (ErlangTuple arr_17) | (DM.Just field_16) <-
                                       ((arr_17 DA.!! 3)) ->
                field_16
              _ -> EXC.badrecord (ErlangAtom "config")
        in let arg_12 = BIF.erlang__op_mult [x_6, rop_14]
        in let bin_el_9 = BIF.binary__copy__2 [arg_10, arg_12]
        in
          ErlangBinary
            (BIN.concat
               [BIN.binPrefix bin_el_7 (BIN.packedSize bin_el_7) 8,
                BIN.binPrefix bin_el_9 (BIN.packedSize bin_el_9) 8])
      something_else -> EXC.case_clause something_else
erlps__indent__1 [arg_18] = EXC.function_clause unit
erlps__indent__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__indent_or_space__1 :: ErlangFun
erlps__indent_or_space__1 [config_0] =
  let   
    lop_2 =
      case config_0 of
        (ErlangTuple arr_5) | (DM.Just field_4) <- ((arr_5 DA.!! 2)) ->
          field_4
        _ -> EXC.badrecord (ErlangAtom "config")
  in let rop_6 = toErl 0
  in let case_1 = BIF.erlang__op_greater [lop_2, rop_6]
  in
    case case_1 of
      (ErlangAtom "true") -> erlps__indent__1 [config_0]
      (ErlangAtom "false") -> erlps__space__1 [config_0]
      something_else -> EXC.case_clause something_else
erlps__indent_or_space__1 [arg_9] = EXC.function_clause unit
erlps__indent_or_space__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__start_json__0 :: ErlangFun
erlps__start_json__0 [] =
  let    tup_el_3 = toErl 0
  in let tup_el_4 = toErl 0
  in let tup_el_5 = toErl 0
  in let
    tup_el_1 =
      ErlangTuple [ErlangAtom "config", tup_el_3, tup_el_4, tup_el_5]
  in ErlangTuple [ErlangEmptyList, tup_el_1]
erlps__start_json__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__start_json__1 :: ErlangFun
erlps__start_json__1 [config_0] | isEList config_0 =
  let tup_el_2 = erlps__parse_config__1 [config_0]
  in ErlangTuple [ErlangEmptyList, tup_el_2]
erlps__start_json__1 [arg_4] = EXC.function_clause unit
erlps__start_json__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__start_object__1 :: ErlangFun
erlps__start_object__1 [(ErlangTuple [stack_0,
                                      config_2@(ErlangTuple [(ErlangAtom "config"),
                                                             _, _, depth_1])])]
  =
  let    bin_el_8 = toErl 123
  in let
    tup_el_7 =
      ErlangBinary (BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big)
  in let head_5 = ErlangTuple [ErlangAtom "object", tup_el_7]
  in let
    tup_el_3 =
      BIF.erlang__op_append
        [ErlangCons head_5 ErlangEmptyList, stack_0]
  in let rop_15 = toErl 1
  in let record_updt_13 = BIF.erlang__op_plus [depth_1, rop_15]
  in let
    tup_el_11 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), space_16, indent_17,
                      depth_18]) ->
          ErlangTuple
            [ErlangAtom "config", space_16, indent_17, record_updt_13]
        _ -> EXC.badrecord (ErlangAtom "config")
  in ErlangTuple [tup_el_3, tup_el_11]
erlps__start_object__1 [arg_19] = EXC.function_clause unit
erlps__start_object__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__start_array__1 :: ErlangFun
erlps__start_array__1 [(ErlangTuple [stack_0,
                                     config_2@(ErlangTuple [(ErlangAtom "config"),
                                                            _, _, depth_1])])]
  =
  let    bin_el_8 = toErl 91
  in let
    tup_el_7 =
      ErlangBinary (BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big)
  in let head_5 = ErlangTuple [ErlangAtom "array", tup_el_7]
  in let
    tup_el_3 =
      BIF.erlang__op_append
        [ErlangCons head_5 ErlangEmptyList, stack_0]
  in let rop_15 = toErl 1
  in let record_updt_13 = BIF.erlang__op_plus [depth_1, rop_15]
  in let
    tup_el_11 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), space_16, indent_17,
                      depth_18]) ->
          ErlangTuple
            [ErlangAtom "config", space_16, indent_17, record_updt_13]
        _ -> EXC.badrecord (ErlangAtom "config")
  in ErlangTuple [tup_el_3, tup_el_11]
erlps__start_array__1 [arg_19] = EXC.function_clause unit
erlps__start_array__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__finish__1 :: ErlangFun
erlps__finish__1 [(ErlangTuple [stack_0,
                                config_2@(ErlangTuple [(ErlangAtom "config"), _,
                                                       _, depth_1])])]
  =
  let    rop_6 = toErl 1
  in let record_updt_4 = BIF.erlang__op_minus [depth_1, rop_6]
  in let
    newconfig_10 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), space_7, indent_8,
                      depth_9]) ->
          ErlangTuple
            [ErlangAtom "config", space_7, indent_8, record_updt_4]
        _ -> EXC.badrecord (ErlangAtom "config")
  in let arg_11 = ErlangTuple [stack_0, newconfig_10]
  in erlps__finish___1 [arg_11]
erlps__finish__1 [arg_14] = EXC.function_clause unit
erlps__finish__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__finish___1 :: ErlangFun
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                           (ErlangBinary binSeg_0)]) (ErlangEmptyList)),
                                 config_4])]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 123))
  , BIN.empty bin_2 =
  let    bin_el_6 = toErl 123
  in let bin_el_7 = toErl 125
  in let
    tup_el_5 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big])
  in ErlangTuple [tup_el_5, config_4]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                           (ErlangBinary binSeg_0)]) (ErlangEmptyList)),
                                 config_4])]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 91))
  , BIN.empty bin_2 =
  let    bin_el_6 = toErl 91
  in let bin_el_7 = toErl 93
  in let
    tup_el_5 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big])
  in ErlangTuple [tup_el_5, config_4]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                           (ErlangBinary binSeg_0)]) rest_4),
                                 config_5])]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 123))
  , BIN.empty bin_2 =
  let    bin_el_7 = toErl 123
  in let bin_el_8 = toErl 125
  in let
    arg_6 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big])
  in let arg_9 = ErlangTuple [rest_4, config_5]
  in erlps__insert__2 [arg_6, arg_9]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                           (ErlangBinary binSeg_0)]) rest_4),
                                 config_5])]
  | (ErlangInt size_1) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_3) bin_2) <-
      (BIN.chopInt binSeg_0 size_1 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_3) == (toErl 91))
  , BIN.empty bin_2 =
  let    bin_el_7 = toErl 91
  in let bin_el_8 = toErl 93
  in let
    arg_6 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big])
  in let arg_9 = ErlangTuple [rest_4, config_5]
  in erlps__insert__2 [arg_6, arg_9]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                           object_0]) (ErlangEmptyList)),
                                 config_1])]
  =
  let    head_5 = erlps__indent__1 [config_1]
  in let bin_el_9 = toErl 125
  in let
    head_8 = ErlangBinary (BIN.fromInt bin_el_9 (toErl 8) 1 BIN.Big)
  in
    ErlangTuple
      [ErlangCons object_0
         (ErlangCons head_5 (ErlangCons head_8 ErlangEmptyList)),
       config_1]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                           object_0]) rest_1),
                                 config_2])]
  =
  let    head_6 = erlps__indent__1 [config_2]
  in let bin_el_10 = toErl 125
  in let
    head_9 = ErlangBinary (BIN.fromInt bin_el_10 (toErl 8) 1 BIN.Big)
  in let arg_12 = ErlangTuple [rest_1, config_2]
  in
    erlps__insert__2
      [ErlangCons object_0
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList)),
       arg_12]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                           array_0]) (ErlangEmptyList)),
                                 config_1])]
  =
  let    head_5 = erlps__indent__1 [config_1]
  in let bin_el_9 = toErl 93
  in let
    head_8 = ErlangBinary (BIN.fromInt bin_el_9 (toErl 8) 1 BIN.Big)
  in
    ErlangTuple
      [ErlangCons array_0
         (ErlangCons head_5 (ErlangCons head_8 ErlangEmptyList)),
       config_1]
erlps__finish___1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                           array_0]) rest_1),
                                 config_2])]
  =
  let    head_6 = erlps__indent__1 [config_2]
  in let bin_el_10 = toErl 93
  in let
    head_9 = ErlangBinary (BIN.fromInt bin_el_10 (toErl 8) 1 BIN.Big)
  in let arg_12 = ErlangTuple [rest_1, config_2]
  in
    erlps__insert__2
      [ErlangCons array_0
         (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList)),
       arg_12]
erlps__finish___1 [_] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__finish___1 [arg_1] = EXC.function_clause unit
erlps__finish___1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__insert__2 :: ErlangFun
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangEmptyList), config_1])]
  =
  ErlangTuple [value_0, config_1]
erlps__insert__2 [key_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          object_1]) rest_2),
                                config_3])]
  =
  let   
    head_6 = ErlangTuple [ErlangAtom "object", key_0, object_1]
  in let
    tup_el_4 =
      BIF.erlang__op_append [ErlangCons head_6 ErlangEmptyList, rest_2]
  in ErlangTuple [tup_el_4, config_3]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          key_1,
                                                          (ErlangBinary binSeg_2)]) rest_6),
                                config_7])]
  | (ErlangInt size_3) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_5) bin_4) <-
      (BIN.chopInt binSeg_2 size_3 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_5) == (toErl 123))
  , BIN.empty bin_4 =
  let    bin_el_14 = toErl 123
  in let
    head_13 =
      ErlangBinary (BIN.fromInt bin_el_14 (toErl 8) 1 BIN.Big)
  in let head_16 = erlps__indent__1 [config_7]
  in let bin_el_22 = toErl 58
  in let
    head_21 =
      ErlangBinary (BIN.fromInt bin_el_22 (toErl 8) 1 BIN.Big)
  in let head_24 = erlps__space__1 [config_7]
  in let
    head_10 =
      ErlangTuple
        [ErlangAtom "object",
         ErlangCons head_13
           (ErlangCons head_16
              (ErlangCons key_1
                 (ErlangCons head_21
                    (ErlangCons head_24
                       (ErlangCons value_0 ErlangEmptyList)))))]
  in let
    tup_el_8 =
      BIF.erlang__op_append
        [ErlangCons head_10 ErlangEmptyList, rest_6]
  in ErlangTuple [tup_el_8, config_7]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          key_1,
                                                          object_2]) rest_3),
                                config_4])]
  =
  let    bin_el_13 = toErl 44
  in let
    head_12 =
      ErlangBinary (BIN.fromInt bin_el_13 (toErl 8) 1 BIN.Big)
  in let head_15 = erlps__indent_or_space__1 [config_4]
  in let bin_el_21 = toErl 58
  in let
    head_20 =
      ErlangBinary (BIN.fromInt bin_el_21 (toErl 8) 1 BIN.Big)
  in let head_23 = erlps__space__1 [config_4]
  in let
    head_7 =
      ErlangTuple
        [ErlangAtom "object",
         ErlangCons object_2
           (ErlangCons head_12
              (ErlangCons head_15
                 (ErlangCons key_1
                    (ErlangCons head_20
                       (ErlangCons head_23
                          (ErlangCons value_0 ErlangEmptyList))))))]
  in let
    tup_el_5 =
      BIF.erlang__op_append [ErlangCons head_7 ErlangEmptyList, rest_3]
  in ErlangTuple [tup_el_5, config_4]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                          (ErlangBinary binSeg_1)]) rest_5),
                                config_6])]
  | (ErlangInt size_2) <- (toErl 8)
  , (BIN.Ok (ErlangInt num_4) bin_3) <-
      (BIN.chopInt binSeg_1 size_2 1 BIN.Big BIN.Unsigned)
  , ((ErlangInt num_4) == (toErl 91))
  , BIN.empty bin_3 =
  let    bin_el_13 = toErl 91
  in let
    head_12 =
      ErlangBinary (BIN.fromInt bin_el_13 (toErl 8) 1 BIN.Big)
  in let head_15 = erlps__indent__1 [config_6]
  in let
    head_9 =
      ErlangTuple
        [ErlangAtom "array",
         ErlangCons head_12
           (ErlangCons head_15 (ErlangCons value_0 ErlangEmptyList))]
  in let
    tup_el_7 =
      BIF.erlang__op_append [ErlangCons head_9 ErlangEmptyList, rest_5]
  in ErlangTuple [tup_el_7, config_6]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                          array_1]) rest_2),
                                config_3])]
  =
  let    bin_el_12 = toErl 44
  in let
    head_11 =
      ErlangBinary (BIN.fromInt bin_el_12 (toErl 8) 1 BIN.Big)
  in let head_14 = erlps__indent_or_space__1 [config_3]
  in let
    head_6 =
      ErlangTuple
        [ErlangAtom "array",
         ErlangCons array_1
           (ErlangCons head_11
              (ErlangCons head_14 (ErlangCons value_0 ErlangEmptyList)))]
  in let
    tup_el_4 =
      BIF.erlang__op_append [ErlangCons head_6 ErlangEmptyList, rest_2]
  in ErlangTuple [tup_el_4, config_3]
erlps__insert__2 [_, _] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__insert__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__insert__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_key__1 :: ErlangFun
erlps__get_key__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                           key_0, _]) _),
                                 _])]
  =
  key_0
erlps__get_key__1 [_] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__get_key__1 [arg_1] = EXC.function_clause unit
erlps__get_key__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_value__1 :: ErlangFun
erlps__get_value__1 [(ErlangTuple [value_0, _config_1])] =
  EXC.tryCatch
    (\ _ ->
       BIF.do_remote_fun_call "Erlang.Unicode"
         "erlps__characters_to_binary__1" [value_0])
    (\ ex_4 ->
       case ex_4 of
         (ErlangTuple [(ErlangAtom "error"), _, _]) ->
           BIF.erlang__error__1 [ErlangAtom "badarg"]
         ex_5 -> EXC.raise ex_5)
erlps__get_value__1 [_] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__get_value__1 [arg_1] = EXC.function_clause unit
erlps__get_value__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args