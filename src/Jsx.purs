module Jsx(erlps__encode__1, erlps__encode__2, erlps__decode__1,
           erlps__decode__2, erlps__is_json__1, erlps__is_json__2,
           erlps__is_term__1, erlps__is_term__2, erlps__format__1,
           erlps__format__2, erlps__minify__1, erlps__prettify__1,
           erlps__consult__1, erlps__consult__2, erlps__encoder__3,
           erlps__decoder__3, erlps__parser__3, erlps__resume__3,
           erlps__maps_support__0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__encode__1 :: ErlangFun
erlps__encode__1 [source_0] =
  erlps__encode__2 [source_0, ErlangEmptyList]
erlps__encode__1 [arg_3] = EXC.function_clause unit
erlps__encode__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode__1) args

erlps__encode__2 :: ErlangFun
erlps__encode__2 [source_0, config_1] =
  BIF.do_remote_fun_call "Jsx.To.Json" "erlps__to_json__2"
    [source_0, config_1]
erlps__encode__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__encode__2 args =
  EXC.badarity (ErlangFun 2 erlps__encode__2) args

erlps__decode__1 :: ErlangFun
erlps__decode__1 [source_0] =
  erlps__decode__2 [source_0, ErlangEmptyList]
erlps__decode__1 [arg_3] = EXC.function_clause unit
erlps__decode__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode__1) args

erlps__decode__2 :: ErlangFun
erlps__decode__2 [source_0, config_1] =
  BIF.do_remote_fun_call "Jsx.To.Term" "erlps__to_term__2"
    [source_0, config_1]
erlps__decode__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__decode__2 args =
  EXC.badarity (ErlangFun 2 erlps__decode__2) args

erlps__format__1 :: ErlangFun
erlps__format__1 [source_0] =
  erlps__format__2 [source_0, ErlangEmptyList]
erlps__format__1 [arg_3] = EXC.function_clause unit
erlps__format__1 args =
  EXC.badarity (ErlangFun 1 erlps__format__1) args

erlps__format__2 :: ErlangFun
erlps__format__2 [source_0, config_1] =
  BIF.do_remote_fun_call "Jsx.To.Json" "erlps__format__2"
    [source_0, config_1]
erlps__format__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__format__2 args =
  EXC.badarity (ErlangFun 2 erlps__format__2) args

erlps__minify__1 :: ErlangFun
erlps__minify__1 [source_0] =
  erlps__format__2 [source_0, ErlangEmptyList]
erlps__minify__1 [arg_3] = EXC.function_clause unit
erlps__minify__1 args =
  EXC.badarity (ErlangFun 1 erlps__minify__1) args

erlps__prettify__1 :: ErlangFun
erlps__prettify__1 [source_0] =
  let    tup_el_7 = toErl 2
  in let head_5 = ErlangTuple [ErlangAtom "indent", tup_el_7]
  in
    erlps__format__2
      [source_0,
       ErlangCons (ErlangAtom "space")
         (ErlangCons head_5 ErlangEmptyList)]
erlps__prettify__1 [arg_9] = EXC.function_clause unit
erlps__prettify__1 args =
  EXC.badarity (ErlangFun 1 erlps__prettify__1) args

erlps__is_json__1 :: ErlangFun
erlps__is_json__1 [source_0] =
  erlps__is_json__2 [source_0, ErlangEmptyList]
erlps__is_json__1 [arg_3] = EXC.function_clause unit
erlps__is_json__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_json__1) args

erlps__is_json__2 :: ErlangFun
erlps__is_json__2 [source_0, config_1] =
  BIF.do_remote_fun_call "Jsx.Verify" "erlps__is_json__2"
    [source_0, config_1]
erlps__is_json__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__is_json__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_json__2) args

erlps__is_term__1 :: ErlangFun
erlps__is_term__1 [source_0] =
  erlps__is_term__2 [source_0, ErlangEmptyList]
erlps__is_term__1 [arg_3] = EXC.function_clause unit
erlps__is_term__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_term__1) args

erlps__is_term__2 :: ErlangFun
erlps__is_term__2 [source_0, config_1] =
  BIF.do_remote_fun_call "Jsx.Verify" "erlps__is_term__2"
    [source_0, config_1]
erlps__is_term__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__is_term__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_term__2) args

erlps__consult__1 :: ErlangFun
erlps__consult__1 [file_0] =
  erlps__consult__2 [file_0, ErlangEmptyList]
erlps__consult__1 [arg_3] = EXC.function_clause unit
erlps__consult__1 args =
  EXC.badarity (ErlangFun 1 erlps__consult__1) args

erlps__consult__2 :: ErlangFun
erlps__consult__2 [file_0, config_1] =
  BIF.do_remote_fun_call "Jsx.Consult" "erlps__consult__2"
    [file_0, config_1]
erlps__consult__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__consult__2 args =
  EXC.badarity (ErlangFun 2 erlps__consult__2) args

erlps__decoder__3 :: ErlangFun
erlps__decoder__3 [handler_0, state_1, config_2] =
  BIF.do_remote_fun_call "Jsx.Decoder" "erlps__decoder__3"
    [handler_0, state_1, config_2]
erlps__decoder__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__decoder__3 args =
  EXC.badarity (ErlangFun 3 erlps__decoder__3) args

erlps__encoder__3 :: ErlangFun
erlps__encoder__3 [handler_0, state_1, config_2] =
  BIF.do_remote_fun_call "Jsx.Encoder" "erlps__encoder__3"
    [handler_0, state_1, config_2]
erlps__encoder__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__encoder__3 args =
  EXC.badarity (ErlangFun 3 erlps__encoder__3) args

erlps__parser__3 :: ErlangFun
erlps__parser__3 [handler_0, state_1, config_2] =
  BIF.do_remote_fun_call "Jsx.Parser" "erlps__parser__3"
    [handler_0, state_1, config_2]
erlps__parser__3 [arg_6, arg_7, arg_8] = EXC.function_clause unit
erlps__parser__3 args =
  EXC.badarity (ErlangFun 3 erlps__parser__3) args

erlps__resume__3 :: ErlangFun
erlps__resume__3 [term_0,
                  (ErlangTuple [(ErlangAtom "decoder"), state_1, handler_2,
                                acc_3, stack_4]),
                  config_5]
  =
  let
    arg_11 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__parse_config__1"
        [config_5]
  in
    BIF.do_remote_fun_call "Jsx.Decoder" "erlps__resume__6"
      [term_0, state_1, handler_2, acc_3, stack_4, arg_11]
erlps__resume__3 [term_0,
                  (ErlangTuple [(ErlangAtom "parser"), state_1, handler_2,
                                stack_3]),
                  config_4]
  =
  let
    arg_9 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__parse_config__1"
        [config_4]
  in
    BIF.do_remote_fun_call "Jsx.Parser" "erlps__resume__5"
      [term_0, state_1, handler_2, stack_3, arg_9]
erlps__resume__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__resume__3 args =
  EXC.badarity (ErlangFun 3 erlps__resume__3) args

erlps__maps_support__0 :: ErlangFun
erlps__maps_support__0 [] = ErlangAtom "true"
erlps__maps_support__0 args =
  EXC.badarity (ErlangFun 0 erlps__maps_support__0) args