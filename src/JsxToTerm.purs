module Jsx.To.Term(erlps__to_term__2, erlps__init__1,
                   erlps__handle_event__2, erlps__start_term__1,
                   erlps__start_object__1, erlps__start_array__1,
                   erlps__finish__1, erlps__insert__2, erlps__get_key__1,
                   erlps__get_value__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__to_term__2 :: ErlangFun
erlps__to_term__2 [source_0, config_1] | isEList config_1 =
  let   
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__extract_config__1"
        [config_1]
  in let
    fun_3 =
      BIF.do_remote_fun_call "Jsx" "erlps__decoder__3"
        [ErlangAtom "jsx_to_term", config_1, arg_6]
  in
    BIF.erlang__apply__2 [fun_3, ErlangCons source_0 ErlangEmptyList]
erlps__to_term__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__to_term__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_term__2) args

erlps__parse_config__1 :: ErlangFun
erlps__parse_config__1 [config_0] =
  let
    arg_2 =
      ErlangTuple
        [ErlangAtom "config", ErlangAtom "binary", ErlangAtom "false"]
  in erlps__parse_config__2 [config_0, arg_2]
erlps__parse_config__1 [arg_6] = EXC.function_clause unit
erlps__parse_config__1 args =
  EXC.badarity (ErlangFun 1 erlps__parse_config__1) args

erlps__parse_config__2 :: ErlangFun
erlps__parse_config__2 [(ErlangCons (ErlangTuple [(ErlangAtom "labels"),
                                                  val_0]) rest_1),
                        config_2]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_11 = BIF.erlang__op_eq [val_0, ErlangAtom "binary"]
            in let
              lop_10 =
                case lop_11 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [val_0, ErlangAtom "atom"]
                  _ -> EXC.badarg1 lop_11
            in let
              lop_9 =
                case lop_10 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [val_0, ErlangAtom "existing_atom"]
                  _ -> EXC.badarg1 lop_10
            in
              case lop_9 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [val_0, ErlangAtom "attempt_atom"]
                _ -> EXC.badarg1 lop_9)) =
  let
    arg_4 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), labels_7, return_maps_8]) ->
          ErlangTuple [ErlangAtom "config", val_0, return_maps_8]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_1, arg_4]
erlps__parse_config__2 [(ErlangCons (ErlangAtom "labels") rest_0),
                        config_1]
  =
  let
    arg_3 =
      case config_1 of
        (ErlangTuple [(ErlangAtom "config"), labels_6, return_maps_7]) ->
          ErlangTuple
            [ErlangAtom "config", ErlangAtom "binary", return_maps_7]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_0, arg_3]
erlps__parse_config__2 [(ErlangCons (ErlangTuple [(ErlangAtom "return_maps"),
                                                  val_0]) rest_1),
                        config_2]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_9 = BIF.erlang__op_eq [val_0, ErlangAtom "true"]
            in
              case lop_9 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [val_0, ErlangAtom "false"]
                _ -> EXC.badarg1 lop_9)) =
  let
    arg_4 =
      case config_2 of
        (ErlangTuple [(ErlangAtom "config"), labels_7, return_maps_8]) ->
          ErlangTuple [ErlangAtom "config", labels_7, ErlangAtom "true"]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_1, arg_4]
erlps__parse_config__2 [(ErlangCons (ErlangAtom "return_maps") rest_0),
                        config_1]
  =
  let
    arg_3 =
      case config_1 of
        (ErlangTuple [(ErlangAtom "config"), labels_6, return_maps_7]) ->
          ErlangTuple [ErlangAtom "config", labels_6, ErlangAtom "true"]
        _ -> EXC.badrecord (ErlangAtom "config")
  in erlps__parse_config__2 [rest_0, arg_3]
erlps__parse_config__2 [options_2@(ErlangCons (ErlangTuple [k_0,
                                                            _]) rest_1),
                        config_3]
  =
  let   
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__valid_flags__0" []
  in let case_4 = BIF.lists__member__2 [k_0, arg_6]
  in
    case case_4 of
      (ErlangAtom "true") -> erlps__parse_config__2 [rest_1, config_3]
      (ErlangAtom "false") ->
        BIF.erlang__error__2
          [ErlangAtom "badarg",
           ErlangCons options_2 (ErlangCons config_3 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__parse_config__2 [options_2@(ErlangCons k_0 rest_1),
                        config_3]
  =
  let   
    arg_6 =
      BIF.do_remote_fun_call "Jsx.Config" "erlps__valid_flags__0" []
  in let case_4 = BIF.lists__member__2 [k_0, arg_6]
  in
    case case_4 of
      (ErlangAtom "true") -> erlps__parse_config__2 [rest_1, config_3]
      (ErlangAtom "false") ->
        BIF.erlang__error__2
          [ErlangAtom "badarg",
           ErlangCons options_2 (ErlangCons config_3 ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__parse_config__2 [(ErlangEmptyList), config_0] = config_0
erlps__parse_config__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__parse_config__2 args =
  EXC.badarity (ErlangFun 2 erlps__parse_config__2) args

erlps__init__1 :: ErlangFun
erlps__init__1 [config_0] = erlps__start_term__1 [config_0]
erlps__init__1 [arg_2] = EXC.function_clause unit
erlps__init__1 args =
  EXC.badarity (ErlangFun 1 erlps__init__1) args

erlps__handle_event__2 :: ErlangFun
erlps__handle_event__2 [(ErlangAtom "end_json"), state_0] =
  erlps__get_value__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "start_object"), state_0] =
  erlps__start_object__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "end_object"), state_0] =
  erlps__finish__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "start_array"), state_0] =
  erlps__start_array__1 [state_0]
erlps__handle_event__2 [(ErlangAtom "end_array"), state_0] =
  erlps__finish__1 [state_0]
erlps__handle_event__2 [(ErlangTuple [(ErlangAtom "key"),
                                      key_0]),
                        state_2@(ErlangTuple [_, config_1])]
  =
  let arg_3 = erlps__format_key__2 [key_0, config_1]
  in erlps__insert__2 [arg_3, state_2]
erlps__handle_event__2 [(ErlangTuple [_, event_0]), state_1] =
  erlps__insert__2 [event_0, state_1]
erlps__handle_event__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__handle_event__2 args =
  EXC.badarity (ErlangFun 2 erlps__handle_event__2) args

erlps__format_key__2 :: ErlangFun
erlps__format_key__2 [key_0, config_1] =
  let
    case_2 =
      case config_1 of
        (ErlangTuple arr_5) | (DM.Just field_4) <- (arr_5 DA.!! 1) ->
          field_4
        _ -> EXC.badrecord (ErlangAtom "config")
  in
    case case_2 of
      (ErlangAtom "binary") -> key_0
      (ErlangAtom "atom") ->
        BIF.erlang__binary_to_atom__2 [key_0, ErlangAtom "utf8"]
      (ErlangAtom "existing_atom") ->
        BIF.erlang__binary_to_existing_atom__2 [key_0, ErlangAtom "utf8"]
      (ErlangAtom "attempt_atom") ->
        EXC.tryOfCatch
          (\ _ ->
             BIF.erlang__binary_to_existing_atom__2
               [key_0, ErlangAtom "utf8"])
          (\ of_12 -> of_12)
          (\ ex_13 ->
             case ex_13 of
               (ErlangTuple [(ErlangAtom "error"), (ErlangAtom "badarg"), _]) ->
                 key_0
               ex_14 -> EXC.raise ex_14)
      something_else -> EXC.case_clause something_else
erlps__format_key__2 [arg_16, arg_17] = EXC.function_clause unit
erlps__format_key__2 args =
  EXC.badarity (ErlangFun 2 erlps__format_key__2) args

erlps__start_term__1 :: ErlangFun
erlps__start_term__1 [config_0] | isEList config_0 =
  let tup_el_2 = erlps__parse_config__1 [config_0]
  in ErlangTuple [ErlangEmptyList, tup_el_2]
erlps__start_term__1 [arg_4] = EXC.function_clause unit
erlps__start_term__1 args =
  EXC.badarity (ErlangFun 1 erlps__start_term__1) args

erlps__start_object__1 :: ErlangFun
erlps__start_object__1 [(ErlangTuple [stack_0,
                                      config_1@(ErlangTuple [(ErlangAtom "config"),
                                                             _,
                                                             (ErlangAtom "true")])])]
  =
  let    tup_el_6 = ErlangMap Map.empty
  in let head_4 = ErlangTuple [ErlangAtom "object", tup_el_6]
  in let
    tup_el_2 =
      BIF.erlang__op_append
        [ErlangCons head_4 ErlangEmptyList, stack_0]
  in ErlangTuple [tup_el_2, config_1]
erlps__start_object__1 [(ErlangTuple [stack_0, config_1])] =
  let   
    head_4 = ErlangTuple [ErlangAtom "object", ErlangEmptyList]
  in let
    tup_el_2 =
      BIF.erlang__op_append
        [ErlangCons head_4 ErlangEmptyList, stack_0]
  in ErlangTuple [tup_el_2, config_1]
erlps__start_object__1 [arg_10] = EXC.function_clause unit
erlps__start_object__1 args =
  EXC.badarity (ErlangFun 1 erlps__start_object__1) args

erlps__start_array__1 :: ErlangFun
erlps__start_array__1 [(ErlangTuple [stack_0, config_1])] =
  let    head_4 = ErlangTuple [ErlangAtom "array", ErlangEmptyList]
  in let
    tup_el_2 =
      BIF.erlang__op_append
        [ErlangCons head_4 ErlangEmptyList, stack_0]
  in ErlangTuple [tup_el_2, config_1]
erlps__start_array__1 [arg_10] = EXC.function_clause unit
erlps__start_array__1 args =
  EXC.badarity (ErlangFun 1 erlps__start_array__1) args

erlps__finish__1 :: ErlangFun
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          map_0]) (ErlangEmptyList)),
                                config_1@(ErlangTuple [(ErlangAtom "config"), _,
                                                       (ErlangAtom "true")])])]
  =
  ErlangTuple [map_0, config_1]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          map_0]) rest_1),
                                config_2@(ErlangTuple [(ErlangAtom "config"), _,
                                                       (ErlangAtom "true")])])]
  =
  let arg_4 = ErlangTuple [rest_1, config_2]
  in erlps__insert__2 [map_0, arg_4]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          (ErlangEmptyList)]) (ErlangEmptyList)),
                                config_0])]
  =
  let head_2 = ErlangTuple []
  in ErlangTuple [ErlangCons head_2 ErlangEmptyList, config_0]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          (ErlangEmptyList)]) rest_0),
                                config_1])]
  =
  let    head_3 = ErlangTuple []
  in let arg_5 = ErlangTuple [rest_0, config_1]
  in erlps__insert__2 [ErlangCons head_3 ErlangEmptyList, arg_5]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          pairs_0]) (ErlangEmptyList)),
                                config_1])]
  =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [pairs_0]
  in ErlangTuple [tup_el_2, config_1]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          pairs_0]) rest_1),
                                config_2])]
  =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [pairs_0]
  in let arg_5 = ErlangTuple [rest_1, config_2]
  in erlps__insert__2 [arg_3, arg_5]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                          values_0]) (ErlangEmptyList)),
                                config_1])]
  =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [values_0]
  in ErlangTuple [tup_el_2, config_1]
erlps__finish__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                          values_0]) rest_1),
                                config_2])]
  =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [values_0]
  in let arg_5 = ErlangTuple [rest_1, config_2]
  in erlps__insert__2 [arg_3, arg_5]
erlps__finish__1 [_] = BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__finish__1 [arg_1] = EXC.function_clause unit
erlps__finish__1 args =
  EXC.badarity (ErlangFun 1 erlps__finish__1) args

erlps__insert__2 :: ErlangFun
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangEmptyList), config_1])]
  =
  ErlangTuple [value_0, config_1]
erlps__insert__2 [key_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          map_1]) rest_2),
                                config_3@(ErlangTuple [(ErlangAtom "config"), _,
                                                       (ErlangAtom "true")])])]
  =
  let    head_6 = ErlangTuple [ErlangAtom "object", key_0, map_1]
  in let
    tup_el_4 =
      BIF.erlang__op_append [ErlangCons head_6 ErlangEmptyList, rest_2]
  in ErlangTuple [tup_el_4, config_3]
erlps__insert__2 [key_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          pairs_1]) rest_2),
                                config_3])]
  =
  let    head_6 = ErlangTuple [ErlangAtom "object", key_0, pairs_1]
  in let
    tup_el_4 =
      BIF.erlang__op_append [ErlangCons head_6 ErlangEmptyList, rest_2]
  in ErlangTuple [tup_el_4, config_3]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          key_1,
                                                          map_2]) rest_3),
                                config_4@(ErlangTuple [(ErlangAtom "config"), _,
                                                       (ErlangAtom "true")])])]
  =
  let    tup_el_9 = BIF.maps__put__3 [key_1, value_0, map_2]
  in let head_7 = ErlangTuple [ErlangAtom "object", tup_el_9]
  in let
    tup_el_5 =
      BIF.erlang__op_append [ErlangCons head_7 ErlangEmptyList, rest_3]
  in ErlangTuple [tup_el_5, config_4]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                          key_1,
                                                          pairs_2]) rest_3),
                                config_4])]
  =
  let    head_11 = ErlangTuple [key_1, value_0]
  in let
    tup_el_9 =
      BIF.erlang__op_append
        [ErlangCons head_11 ErlangEmptyList, pairs_2]
  in let head_7 = ErlangTuple [ErlangAtom "object", tup_el_9]
  in let
    tup_el_5 =
      BIF.erlang__op_append [ErlangCons head_7 ErlangEmptyList, rest_3]
  in ErlangTuple [tup_el_5, config_4]
erlps__insert__2 [value_0,
                  (ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "array"),
                                                          values_1]) rest_2),
                                config_3])]
  =
  let   
    tup_el_8 =
      BIF.erlang__op_append
        [ErlangCons value_0 ErlangEmptyList, values_1]
  in let head_6 = ErlangTuple [ErlangAtom "array", tup_el_8]
  in let
    tup_el_4 =
      BIF.erlang__op_append [ErlangCons head_6 ErlangEmptyList, rest_2]
  in ErlangTuple [tup_el_4, config_3]
erlps__insert__2 [_, _] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__insert__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__insert__2 args =
  EXC.badarity (ErlangFun 2 erlps__insert__2) args

erlps__get_key__1 :: ErlangFun
erlps__get_key__1 [(ErlangTuple [(ErlangCons (ErlangTuple [(ErlangAtom "object"),
                                                           key_0, _]) _),
                                 _])]
  =
  key_0
erlps__get_key__1 [_] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__get_key__1 [arg_1] = EXC.function_clause unit
erlps__get_key__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_key__1) args

erlps__get_value__1 :: ErlangFun
erlps__get_value__1 [(ErlangTuple [value_0, _config_1])] =
  value_0
erlps__get_value__1 [_] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__get_value__1 [arg_1] = EXC.function_clause unit
erlps__get_value__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_value__1) args