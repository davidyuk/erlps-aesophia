module Aeso.Fcode.To.Fate(erlps__compile__2, erlps__compile__3,
                          erlps__term_to_fate__1, erlps__term_to_fate__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__is_debug__2 :: ErlangFun
erlps__is_debug__2 [tag_0, options_1] =
  let   
    tags_5 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "debug", options_1, ErlangEmptyList]
  in let lop_6 = BIF.erlang__op_eq [tags_5, ErlangAtom "all"]
  in
    case lop_6 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> BIF.lists__member__2 [tag_0, tags_5]
      _ -> EXC.badarg1 lop_6
erlps__is_debug__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__is_debug__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_debug__2) args

erlps__debug__3 :: ErlangFun
erlps__debug__3 [tag_0, options_1, fun_2] =
  let case_3 = erlps__is_debug__2 [tag_0, options_1]
  in
    case case_3 of
      (ErlangAtom "true") ->
        BIF.erlang__apply__2 [fun_2, ErlangEmptyList]
      (ErlangAtom "false") -> ErlangAtom "ok"
      something_else -> EXC.case_clause something_else
erlps__debug__3 [arg_7, arg_8, arg_9] = EXC.function_clause unit
erlps__debug__3 args =
  EXC.badarity (ErlangFun 3 erlps__debug__3) args

erlps__code_error__1 :: ErlangFun
erlps__code_error__1 [err_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Code.Errors" "erlps__format__1"
        [err_0]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_1]
erlps__code_error__1 [arg_3] = EXC.function_clause unit
erlps__code_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__code_error__1) args

erlps__compile__2 :: ErlangFun
erlps__compile__2 [fcode_0, options_1] =
  let arg_2 = ErlangMap Map.empty
  in erlps__compile__3 [arg_2, fcode_0, options_1]
erlps__compile__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__compile__2 args =
  EXC.badarity (ErlangFun 2 erlps__compile__2) args

erlps__compile__3 :: ErlangFun
erlps__compile__3 [childcontracts_0, fcode_1, options_2] =
  case fcode_1 of
    (ErlangMap map_3) | (DM.Just functions_5) <-
                          (Map.lookup (ErlangAtom "functions") map_3)
                      , (DM.Just contractname_4) <-
                          (Map.lookup (ErlangAtom "contract_name") map_3) ->
      let   
        sfuns_11 =
          erlps__functions_to_scode__4
            [childcontracts_0, contractname_4, functions_5, options_2]
      in let sfuns1_14 = erlps__optimize_scode__2 [sfuns_11, options_2]
      in let fatecode_16 = erlps__to_basic_blocks__1 [sfuns1_14]
      in let
        arg_19 =
          ErlangFun 0
            (let
               lambda_20 [] =
                 let    arg_21 = toErl "~s\n"
                 in let
                   head_23 =
                     BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__pp__1"
                       [fatecode_16]
                 in
                   BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                     [arg_21, ErlangCons head_23 ErlangEmptyList]
               lambda_20 [] = EXC.function_clause unit
               lambda_20 args = EXC.badarity (ErlangFun 0 lambda_20) args
             in lambda_20)
      in let
        _ = erlps__debug__3 [ErlangAtom "compile", options_2, arg_19]
      in fatecode_16
    _ -> EXC.badmatch fcode_1
erlps__compile__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__compile__3 args =
  EXC.badarity (ErlangFun 3 erlps__compile__3) args

erlps__make_function_id__1 :: ErlangFun
erlps__make_function_id__1 [x_0] =
  let arg_1 = erlps__make_function_name__1 [x_0]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Code"
      "erlps__symbol_identifier__1" [arg_1]
erlps__make_function_id__1 [arg_3] = EXC.function_clause unit
erlps__make_function_id__1 args =
  EXC.badarity (ErlangFun 1 erlps__make_function_id__1) args

erlps__make_function_name__1 :: ErlangFun
erlps__make_function_name__1 [(ErlangAtom "event")] =
  ErlangBinary
    (BIN.fromInts (toErl "Chain.event") (toErl 8) 1 BIN.Big)
erlps__make_function_name__1 [(ErlangTuple [(ErlangAtom "entrypoint"),
                                            name_0])]
  =
  name_0
erlps__make_function_name__1 [(ErlangTuple [(ErlangAtom "local_fun"),
                                            xs_0])]
  =
  let    lop_2 = toErl "."
  in let arg_5 = toErl "."
  in let
    rop_3 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [xs_0, arg_5]
  in let arg_1 = BIF.erlang__op_append [lop_2, rop_3]
  in BIF.erlang__list_to_binary__1 [arg_1]
erlps__make_function_name__1 [arg_6] = EXC.function_clause unit
erlps__make_function_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__make_function_name__1) args

erlps__functions_to_scode__4 :: ErlangFun
erlps__functions_to_scode__4 [childcontracts_0, contractname_1,
                              functions_2, options_3]
  =
  let    funnames_5 = BIF.maps__keys__1 [functions_2]
  in let lcSrc_7 = BIF.maps__to_list__1 [functions_2]
  in let
    arg_6 =
      flmap
        (\ lc_15 ->
           case lc_15 of
             (ErlangTuple [name_9, (ErlangMap map_10)]) | (DM.Just type_14) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "return")
                                                               map_10)
                                                        , (DM.Just attrs_13) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "attrs")
                                                               map_10)
                                                        , (DM.Just body_12) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "body")
                                                               map_10)
                                                        , (DM.Just args_11) <-
                                                            (Map.lookup
                                                               (ErlangAtom
                                                                  "args")
                                                               map_10) ->
               let    tup_el_17 = erlps__make_function_name__1 [name_9]
               in let
                 tup_el_19 =
                   erlps__function_to_scode__9
                     [childcontracts_0, contractname_1, funnames_5, name_9,
                      attrs_13, args_11, body_12, type_14, options_3]
               in let lcRet_16 = ErlangTuple [tup_el_17, tup_el_19]
               in ErlangCons lcRet_16 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_7
  in BIF.maps__from_list__1 [arg_6]
erlps__functions_to_scode__4 [arg_29, arg_30, arg_31, arg_32] =
  EXC.function_clause unit
erlps__functions_to_scode__4 args =
  EXC.badarity (ErlangFun 4 erlps__functions_to_scode__4) args

erlps__function_to_scode__9 :: ErlangFun
erlps__function_to_scode__9 [childcontracts_0, contractname_1,
                             functions_2, name_3, attrs0_4, args_5, body_6,
                             restype_7, options_8]
  =
  let matchExpr_13 = erlps__typesig_to_scode__2 [args_5, restype_7]
  in
    case matchExpr_13 of
      (ErlangTuple [argtypes_11, restype1_12]) ->
        let   
          attrs_18 =
            BIF.erlang__op_unAppend
              [attrs0_4, ErlangCons (ErlangAtom "stateful") ErlangEmptyList]
        in let
          env_25 =
            erlps__init_env__6
              [childcontracts_0, contractname_1, functions_2, name_3, args_5,
               options_8]
        in let scode_28 = erlps__to_scode__2 [env_25, body_6]
        in let tup_el_30 = ErlangTuple [argtypes_11, restype1_12]
        in ErlangTuple [attrs_18, tup_el_30, scode_28]
      _ -> EXC.badmatch matchExpr_13
erlps__function_to_scode__9 [arg_34, arg_35, arg_36, arg_37,
                             arg_38, arg_39, arg_40, arg_41, arg_42]
  =
  EXC.function_clause unit
erlps__function_to_scode__9 args =
  EXC.badarity (ErlangFun 9 erlps__function_to_scode__9) args

erlps__typesig_to_scode__2 :: ErlangFun
erlps__typesig_to_scode__2 [args_0, res_1] =
  let    tup_el_4 = toErl 0
  in let tup_el_5 = ErlangMap Map.empty
  in let arg_3 = ErlangTuple [tup_el_4, tup_el_5]
  in let _ = BIF.erlang__put__2 [ErlangAtom "$tvars", arg_3]
  in let
    tup_el_6 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [_, t_8]) ->
               let lcRet_10 = erlps__type_to_scode__1 [t_8]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_0
  in let tup_el_12 = erlps__type_to_scode__1 [res_1]
  in let r_14 = ErlangTuple [tup_el_6, tup_el_12]
  in let _ = BIF.erlang__erase__1 [ErlangAtom "$tvars"]
  in r_14
erlps__typesig_to_scode__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__typesig_to_scode__2 args =
  EXC.badarity (ErlangFun 2 erlps__typesig_to_scode__2) args

erlps__type_to_scode__1 :: ErlangFun
erlps__type_to_scode__1 [(ErlangAtom "integer")] =
  ErlangAtom "integer"
erlps__type_to_scode__1 [(ErlangAtom "boolean")] =
  ErlangAtom "boolean"
erlps__type_to_scode__1 [(ErlangAtom "string")] =
  ErlangAtom "string"
erlps__type_to_scode__1 [(ErlangAtom "address")] =
  ErlangAtom "address"
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "bytes"),
                                       n_0])]
  =
  ErlangTuple [ErlangAtom "bytes", n_0]
erlps__type_to_scode__1 [(ErlangAtom "contract")] =
  ErlangAtom "contract"
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "oracle"), _,
                                       _])]
  =
  ErlangAtom "oracle"
erlps__type_to_scode__1 [(ErlangAtom "oracle_query")] =
  ErlangAtom "oracle_query"
erlps__type_to_scode__1 [(ErlangAtom "name")] = ErlangAtom "name"
erlps__type_to_scode__1 [(ErlangAtom "channel")] =
  ErlangAtom "channel"
erlps__type_to_scode__1 [(ErlangAtom "bits")] = ErlangAtom "bits"
erlps__type_to_scode__1 [(ErlangAtom "any")] = ErlangAtom "any"
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "variant"),
                                       cons_0])]
  =
  let
    tup_el_2 =
      flmap
        (\ lc_5 ->
           let    tup_el_8 = erlps__types_to_scode__1 [lc_5]
           in let lcRet_6 = ErlangTuple [ErlangAtom "tuple", tup_el_8]
           in ErlangCons lcRet_6 ErlangEmptyList)
        cons_0
  in ErlangTuple [ErlangAtom "variant", tup_el_2]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "list"),
                                       type_0])]
  =
  let tup_el_2 = erlps__type_to_scode__1 [type_0]
  in ErlangTuple [ErlangAtom "list", tup_el_2]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                       (ErlangCons type_0 (ErlangEmptyList))])]
  =
  erlps__type_to_scode__1 [type_0]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                       types_0])]
  =
  let tup_el_2 = erlps__types_to_scode__1 [types_0]
  in ErlangTuple [ErlangAtom "tuple", tup_el_2]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "map"), key_0,
                                       val_1])]
  =
  let    tup_el_3 = erlps__type_to_scode__1 [key_0]
  in let tup_el_5 = erlps__type_to_scode__1 [val_1]
  in ErlangTuple [ErlangAtom "map", tup_el_3, tup_el_5]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "function"),
                                       _args_0, _res_1])]
  =
  ErlangTuple
    [ErlangAtom "tuple",
     ErlangCons (ErlangAtom "string")
       (ErlangCons (ErlangAtom "any") ErlangEmptyList)]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "tvar"),
                                       x_0])]
  =
  let matchExpr_4 = BIF.erlang__get__1 [ErlangAtom "$tvars"]
  in
    case matchExpr_4 of
      (ErlangTuple [i_2, vars_3]) ->
        let
          case_5 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [x_0, vars_3, ErlangAtom "false"]
        in
          case case_5 of
            (ErlangAtom "false") ->
              let    rop_13 = toErl 1
              in let tup_el_11 = BIF.erlang__op_plus [i_2, rop_13]
              in let mapExt_18 = ErlangMap (Map.singleton x_0 i_2)
              in let tup_el_14 = BIF.maps__merge__2 [vars_3, mapExt_18]
              in let arg_10 = ErlangTuple [tup_el_11, tup_el_14]
              in let _ = BIF.erlang__put__2 [ErlangAtom "$tvars", arg_10]
              in ErlangTuple [ErlangAtom "tvar", i_2]
            j_22 -> ErlangTuple [ErlangAtom "tvar", j_22]
      _ -> EXC.badmatch matchExpr_4
erlps__type_to_scode__1 [l_0] | isEList l_0 =
  let tup_el_2 = erlps__types_to_scode__1 [l_0]
  in ErlangTuple [ErlangAtom "tuple", tup_el_2]
erlps__type_to_scode__1 [arg_4] = EXC.function_clause unit
erlps__type_to_scode__1 args =
  EXC.badarity (ErlangFun 1 erlps__type_to_scode__1) args

erlps__types_to_scode__1 :: ErlangFun
erlps__types_to_scode__1 [ts_0] =
  let arg_1 = ErlangFun 1 erlps__type_to_scode__1
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_1, ts_0]
erlps__types_to_scode__1 [arg_3] = EXC.function_clause unit
erlps__types_to_scode__1 args =
  EXC.badarity (ErlangFun 1 erlps__types_to_scode__1) args

erlps__init_env__6 :: ErlangFun
erlps__init_env__6 [childcontracts_0, contractname_1, funnames_2,
                    name_3, args_4, options_5]
  =
  let    lcSrc_9 = erlps__with_ixs__1 [args_4]
  in let
    tup_el_8 =
      flmap
        (\ lc_13 ->
           case lc_13 of
             (ErlangTuple [i_11, (ErlangTuple [x_12, _])]) ->
               let    tup_el_16 = ErlangTuple [ErlangAtom "arg", i_11]
               in let lcRet_14 = ErlangTuple [x_12, tup_el_16]
               in ErlangCons lcRet_14 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_9
  in
    ErlangTuple
      [ErlangAtom "env", contractname_1, tup_el_8, funnames_2, name_3,
       ErlangAtom "true", childcontracts_0, options_5]
erlps__init_env__6 [arg_24, arg_25, arg_26, arg_27, arg_28,
                    arg_29]
  =
  EXC.function_clause unit
erlps__init_env__6 args =
  EXC.badarity (ErlangFun 6 erlps__init_env__6) args

erlps__next_var__1 :: ErlangFun
erlps__next_var__1 [(ErlangTuple [(ErlangAtom "env"), _, vars_0,
                                  _, _, _, _, _])]
  =
  let    lop_1 = toErl 1
  in let op_arg_5 = toErl 1
  in let head_4 = BIF.erlang__op_neg [op_arg_5]
  in let
    tail_6 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [_, (ErlangTuple [(ErlangAtom "var"), j_8])]) ->
               ErlangCons j_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        vars_0
  in let
    rop_2 =
      BIF.do_remote_fun_call "Lists" "erlps__max__1"
        [ErlangCons head_4 tail_6]
  in BIF.erlang__op_plus [lop_1, rop_2]
erlps__next_var__1 [arg_11] = EXC.function_clause unit
erlps__next_var__1 args =
  EXC.badarity (ErlangFun 1 erlps__next_var__1) args

erlps__bind_var__3 :: ErlangFun
erlps__bind_var__3 [name_0, var_1,
                    env_3@(ErlangTuple [(ErlangAtom "env"), _, vars_2, _, _, _,
                                        _, _])]
  =
  let head_6 = ErlangTuple [name_0, var_1]
  in
    case env_3 of
      (ErlangTuple [(ErlangAtom "env"), contract_10, vars_11,
                    locals_12, current_function_13, tailpos_14,
                    child_contracts_15, options_16]) ->
        ErlangTuple
          [ErlangAtom "env", contract_10, ErlangCons head_6 vars_2,
           locals_12, current_function_13, tailpos_14, child_contracts_15,
           options_16]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_var__3 [arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__bind_var__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_var__3) args

erlps__bind_local__2 :: ErlangFun
erlps__bind_local__2 [name_0, env_1] =
  let    i_3 = erlps__next_var__1 [env_1]
  in let arg_7 = ErlangTuple [ErlangAtom "var", i_3]
  in let tup_el_5 = erlps__bind_var__3 [name_0, arg_7, env_1]
  in ErlangTuple [i_3, tup_el_5]
erlps__bind_local__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__bind_local__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_local__2) args

erlps__notail__1 :: ErlangFun
erlps__notail__1 [env_0] =
  case env_0 of
    (ErlangTuple [(ErlangAtom "env"), contract_3, vars_4, locals_5,
                  current_function_6, tailpos_7, child_contracts_8,
                  options_9]) ->
      ErlangTuple
        [ErlangAtom "env", contract_3, vars_4, locals_5,
         current_function_6, ErlangAtom "false", child_contracts_8,
         options_9]
    _ -> EXC.badrecord (ErlangAtom "env")
erlps__notail__1 [arg_10] = EXC.function_clause unit
erlps__notail__1 args =
  EXC.badarity (ErlangFun 1 erlps__notail__1) args

erlps__lookup_var__2 :: ErlangFun
erlps__lookup_var__2 [(ErlangTuple [(ErlangAtom "env"), _,
                                    vars_0, _, _, _, _, _]),
                      x_1]
  =
  let    arg_4 = toErl 1
  in let case_2 = BIF.lists__keyfind__3 [x_1, arg_4, vars_0]
  in
    case case_2 of
      (ErlangTuple [_, var_6]) -> var_6
      (ErlangAtom "false") ->
        let
          arg_7 = ErlangTuple [ErlangAtom "unbound_variable", x_1, vars_0]
        in erlps__code_error__1 [arg_7]
      something_else -> EXC.case_clause something_else
erlps__lookup_var__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lookup_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_var__2) args

erlps__lit_to_fate__2 :: ErlangFun
erlps__lit_to_fate__2 [env_0, l_1] =
  case l_1 of
    (ErlangTuple [(ErlangAtom "int"), n_3]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_integer__1"
        [n_3]
    (ErlangTuple [(ErlangAtom "string"), s_5]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
        [s_5]
    (ErlangTuple [(ErlangAtom "bytes"), b_7]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_bytes__1"
        [b_7]
    (ErlangTuple [(ErlangAtom "bool"), b_9]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_boolean__1"
        [b_9]
    (ErlangTuple [(ErlangAtom "account_pubkey"), k_11]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_address__1"
        [k_11]
    (ErlangTuple [(ErlangAtom "contract_pubkey"), k_13]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_contract__1"
        [k_13]
    (ErlangTuple [(ErlangAtom "oracle_pubkey"), k_15]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_oracle__1"
        [k_15]
    (ErlangTuple [(ErlangAtom "oracle_query_id"), h_17]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data"
        "erlps__make_oracle_query__1" [h_17]
    (ErlangTuple [(ErlangAtom "contract_code"), c_19]) ->
      let   
        options_23 =
          case env_0 of
            (ErlangTuple arr_22) | (DM.Just field_21) <- (arr_22 DA.!! 7) ->
              field_21
            _ -> EXC.badrecord (ErlangAtom "env")
      in let
        arg_25 =
          case env_0 of
            (ErlangTuple arr_28) | (DM.Just field_27) <- (arr_28 DA.!! 6) ->
              field_27
            _ -> EXC.badrecord (ErlangAtom "env")
      in let fcode_29 = BIF.maps__get__2 [c_19, arg_25]
      in let
        arg_30 =
          case env_0 of
            (ErlangTuple arr_33) | (DM.Just field_32) <- (arr_33 DA.!! 6) ->
              field_32
            _ -> EXC.badrecord (ErlangAtom "env")
      in let
        fatecode_36 = erlps__compile__3 [arg_30, fcode_29, options_23]
      in let
        bytecode_39 =
          BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__serialize__2"
            [fatecode_36, ErlangEmptyList]
      in let
        matchExpr_41 =
          BIF.do_remote_fun_call "Aeso.Compiler" "erlps__version__0" []
      in
        case matchExpr_41 of
          (ErlangTuple [(ErlangAtom "ok"), version_40]) ->
            let    arg_44 = toErl ""
            in let
              originalsourcecode_45 =
                BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
                  [ErlangAtom "original_src", options_23, arg_44]
            in let head_60 = toErl 0
            in let
              rop_58 =
                BIF.erlang__op_append [ErlangCons head_60 ErlangEmptyList, c_19]
            in let
              arg_56 = BIF.erlang__op_append [originalsourcecode_45, rop_58]
            in let
              val_54 =
                BIF.do_remote_fun_call "Crypto" "erlps__hash__2"
                  [ErlangAtom "sha256", arg_56]
            in let
              val_64 =
                BIF.do_remote_fun_call "Aeb.Fate.Abi" "erlps__abi_version__0" []
            in let val_65 = BIF.maps__get__2 [ErlangAtom "payable", fcode_29]
            in let
              code_68 =
                ErlangMap
                  (Map.fromFoldable
                     [DT.Tuple (ErlangAtom "byte_code") bytecode_39,
                      DT.Tuple (ErlangAtom "compiler_version") version_40,
                      DT.Tuple (ErlangAtom "source_hash") val_54,
                      DT.Tuple (ErlangAtom "type_info") ErlangEmptyList,
                      DT.Tuple (ErlangAtom "abi_version") val_64,
                      DT.Tuple (ErlangAtom "payable") val_65])
            in let
              serialized_70 =
                BIF.do_remote_fun_call "Aeser.Contract.Code"
                  "erlps__serialize__1" [code_68]
            in
              BIF.do_remote_fun_call "Aeb.Fate.Data"
                "erlps__make_contract_bytearray__1" [serialized_70]
          _ -> EXC.badmatch matchExpr_41
    (ErlangTuple [(ErlangAtom "typerep"), t_72]) ->
      let arg_73 = erlps__type_to_scode__1 [t_72]
      in
        BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
          [arg_73]
    something_else -> EXC.case_clause something_else
erlps__lit_to_fate__2 [arg_75, arg_76] = EXC.function_clause unit
erlps__lit_to_fate__2 args =
  EXC.badarity (ErlangFun 2 erlps__lit_to_fate__2) args

erlps__term_to_fate__1 :: ErlangFun
erlps__term_to_fate__1 [e_0] =
  let    tup_el_8 = ErlangMap Map.empty
  in let
    arg_1 =
      ErlangTuple
        [ErlangAtom "env", ErlangAtom "undefined", ErlangEmptyList,
         ErlangEmptyList, ErlangAtom "undefined", ErlangAtom "true",
         tup_el_8, ErlangEmptyList]
  in let arg_10 = ErlangMap Map.empty
  in erlps__term_to_fate__3 [arg_1, arg_10, e_0]
erlps__term_to_fate__1 [arg_12] = EXC.function_clause unit
erlps__term_to_fate__1 args =
  EXC.badarity (ErlangFun 1 erlps__term_to_fate__1) args

erlps__term_to_fate__2 :: ErlangFun
erlps__term_to_fate__2 [globenv_0, e_1] =
  let arg_3 = ErlangMap Map.empty
  in erlps__term_to_fate__3 [globenv_0, arg_3, e_1]
erlps__term_to_fate__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__term_to_fate__2 args =
  EXC.badarity (ErlangFun 2 erlps__term_to_fate__2) args

erlps__term_to_fate__3 :: ErlangFun
erlps__term_to_fate__3 [globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "lit"), l_2])]
  =
  erlps__lit_to_fate__2 [globenv_0, l_2]
erlps__term_to_fate__3 [_globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "-"),
                                      (ErlangCons (ErlangTuple [(ErlangAtom "lit"),
                                                                (ErlangTuple [(ErlangAtom "int"),
                                                                              (ErlangInt num_2)])]) (ErlangCons (ErlangTuple [(ErlangAtom "lit"),
                                                                                                                              (ErlangTuple [(ErlangAtom "int"),
                                                                                                                                            n_3])]) (ErlangEmptyList)))])]
  | (ErlangInt num_2) == (toErl 0) =
  let arg_4 = BIF.erlang__op_neg [n_3]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_integer__1"
      [arg_4]
erlps__term_to_fate__3 [_globenv_0, _env_1, (ErlangAtom "nil")] =
  BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_list__1"
    [ErlangEmptyList]
erlps__term_to_fate__3 [globenv_0, env_1,
                        (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "::"),
                                      (ErlangCons hd_2 (ErlangCons tl_3 (ErlangEmptyList)))])]
  =
  let    head_4 = erlps__term_to_fate__3 [globenv_0, env_1, hd_2]
  in let tail_8 = erlps__term_to_fate__3 [globenv_0, env_1, tl_3]
  in ErlangCons head_4 tail_8
erlps__term_to_fate__3 [globenv_0, env_1,
                        (ErlangTuple [(ErlangAtom "tuple"), as_2])]
  =
  let   
    arg_4 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__term_to_fate__3 [globenv_0, env_1, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        as_2
  in let arg_3 = BIF.erlang__list_to_tuple__1 [arg_4]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_tuple__1"
      [arg_3]
erlps__term_to_fate__3 [globenv_0, env_1,
                        (ErlangTuple [(ErlangAtom "con"), ar_2, i_3, as_4])]
  =
  let   
    fateas_12 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__term_to_fate__3 [globenv_0, env_1, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        as_4
  in let arg_15 = BIF.erlang__list_to_tuple__1 [fateas_12]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_variant__3"
      [ar_2, i_3, arg_15]
erlps__term_to_fate__3 [_globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "builtin"),
                                      (ErlangAtom "bits_all"),
                                      (ErlangEmptyList)])]
  =
  let    op_arg_3 = toErl 1
  in let arg_2 = BIF.erlang__op_neg [op_arg_3]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_bits__1"
      [arg_2]
erlps__term_to_fate__3 [_globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "builtin"),
                                      (ErlangAtom "bits_none"),
                                      (ErlangEmptyList)])]
  =
  let arg_2 = toErl 0
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_bits__1"
      [arg_2]
erlps__term_to_fate__3 [globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "op"),
                                      (ErlangAtom "bits_set"),
                                      (ErlangCons b_2 (ErlangCons i_3 (ErlangEmptyList)))])]
  =
  let matchExpr_7 = erlps__term_to_fate__2 [globenv_0, b_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "bits"), n_6]) ->
        let    j_10 = erlps__term_to_fate__2 [globenv_0, i_3]
        in let lop_15 = toErl 1
        in let rop_14 = BIF.erlang__bsl__2 [lop_15, j_10]
        in let tup_el_12 = BIF.erlang__bor__2 [n_6, rop_14]
        in ErlangTuple [ErlangAtom "bits", tup_el_12]
      _ -> EXC.badmatch matchExpr_7
erlps__term_to_fate__3 [globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "op"),
                                      (ErlangAtom "bits_clear"),
                                      (ErlangCons b_2 (ErlangCons i_3 (ErlangEmptyList)))])]
  =
  let matchExpr_7 = erlps__term_to_fate__2 [globenv_0, b_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "bits"), n_6]) ->
        let    j_10 = erlps__term_to_fate__2 [globenv_0, i_3]
        in let lop_16 = toErl 1
        in let op_arg_15 = BIF.erlang__bsl__2 [lop_16, j_10]
        in let rop_14 = BIF.erlang__bnot__1 [op_arg_15]
        in let tup_el_12 = BIF.erlang__band__2 [n_6, rop_14]
        in ErlangTuple [ErlangAtom "bits", tup_el_12]
      _ -> EXC.badmatch matchExpr_7
erlps__term_to_fate__3 [globenv_0, env_1,
                        (ErlangTuple [(ErlangAtom "let"), x_2, e_3, body_4])]
  =
  let    val_7 = erlps__term_to_fate__3 [globenv_0, env_1, e_3]
  in let mapExt_11 = ErlangMap (Map.singleton x_2 val_7)
  in let env1_13 = BIF.maps__merge__2 [env_1, mapExt_11]
  in erlps__term_to_fate__3 [globenv_0, env1_13, body_4]
erlps__term_to_fate__3 [_globenv_0, env_1,
                        (ErlangTuple [(ErlangAtom "var"), x_2])]
  =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [x_2, env_1, ErlangAtom "undefined"]
  in
    case case_3 of
      (ErlangAtom "undefined") ->
        BIF.erlang__throw__1 [ErlangAtom "not_a_fate_value"]
      v_8 -> v_8
erlps__term_to_fate__3 [_globenv_0, _env_1,
                        (ErlangTuple [(ErlangAtom "builtin"),
                                      (ErlangAtom "map_empty"),
                                      (ErlangEmptyList)])]
  =
  let arg_2 = ErlangMap Map.empty
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_map__1"
      [arg_2]
erlps__term_to_fate__3 [globenv_0, env_1,
                        (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "map_set"),
                                      (ErlangCons m_2 (ErlangCons k_3 (ErlangCons v_4 (ErlangEmptyList))))])]
  =
  let    map_8 = erlps__term_to_fate__3 [globenv_0, env_1, m_2]
  in let key_10 = erlps__term_to_fate__3 [globenv_0, env_1, k_3]
  in let val_14 = erlps__term_to_fate__3 [globenv_0, env_1, v_4]
  in let mapExt_18 = ErlangMap (Map.singleton key_10 val_14)
  in BIF.maps__merge__2 [map_8, mapExt_18]
erlps__term_to_fate__3 [_globenv_0, _env_1, _] =
  BIF.erlang__throw__1 [ErlangAtom "not_a_fate_value"]
erlps__term_to_fate__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__term_to_fate__3 args =
  EXC.badarity (ErlangFun 3 erlps__term_to_fate__3) args

erlps__to_scode__2 :: ErlangFun
erlps__to_scode__2 [env_0, t_1] =
  EXC.tryOfCatch (\ _ -> erlps__term_to_fate__2 [env_0, t_1])
    (\ of_4 ->
       let    arg_9 = ErlangTuple [ErlangAtom "immediate", of_4]
       in let head_8 = erlps__push__1 [arg_9]
       in ErlangCons head_8 ErlangEmptyList)
    (\ ex_5 ->
       case ex_5 of
         (ErlangTuple [(ErlangAtom "throw"),
                       (ErlangAtom "not_a_fate_value"), _]) ->
           erlps__to_scode1__2 [env_0, t_1]
         ex_6 -> EXC.raise ex_6)
erlps__to_scode__2 [arg_15, arg_16] = EXC.function_clause unit
erlps__to_scode__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_scode__2) args

erlps__to_scode1__2 :: ErlangFun
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "lit"), l_1])]
  =
  let    tup_el_5 = erlps__lit_to_fate__2 [env_0, l_1]
  in let arg_3 = ErlangTuple [ErlangAtom "immediate", tup_el_5]
  in let head_2 = erlps__push__1 [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__to_scode1__2 [_env_0, (ErlangAtom "nil")] =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__nil__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let    arg_3 = erlps__lookup_var__2 [env_0, x_1]
  in let head_2 = erlps__push__1 [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "con"), ar_1, i_2, as_3])]
  =
  let    n_5 = BIF.erlang__length__1 [as_3]
  in let
    head_6 =
      flmap
        (\ lc_9 ->
           let    arg_11 = erlps__notail__1 [env_0]
           in let lcRet_10 = erlps__to_scode__2 [arg_11, lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        as_3
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let arg_19 = ErlangTuple [ErlangAtom "immediate", ar_1]
  in let arg_22 = ErlangTuple [ErlangAtom "immediate", i_2]
  in let arg_25 = ErlangTuple [ErlangAtom "immediate", n_5]
  in let
    head_15 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__variant__4"
        [arg_16, arg_19, arg_22, arg_25]
  in ErlangCons head_6 (ErlangCons head_15 ErlangEmptyList)
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "tuple"), as_1])]
  =
  let    n_3 = BIF.erlang__length__1 [as_1]
  in let
    head_4 =
      flmap
        (\ lc_7 ->
           let    arg_9 = erlps__notail__1 [env_0]
           in let lcRet_8 = erlps__to_scode__2 [arg_9, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        as_1
  in let head_13 = erlps__tuple__1 [n_3]
  in ErlangCons head_4 (ErlangCons head_13 ErlangEmptyList)
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "proj"), e_1, i_2])]
  =
  let    arg_4 = erlps__notail__1 [env_0]
  in let head_3 = erlps__to_scode__2 [arg_4, e_1]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in let arg_12 = ErlangTuple [ErlangAtom "immediate", i_2]
  in let tup_el_17 = toErl 0
  in let arg_15 = ErlangTuple [ErlangAtom "stack", tup_el_17]
  in let
    head_8 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__element_op__3"
        [arg_9, arg_12, arg_15]
  in ErlangCons head_3 (ErlangCons head_8 ErlangEmptyList)
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "set_proj"), r_1, i_2, e_3])]
  =
  let    arg_5 = erlps__notail__1 [env_0]
  in let head_4 = erlps__to_scode__2 [arg_5, e_3]
  in let arg_10 = erlps__notail__1 [env_0]
  in let head_9 = erlps__to_scode__2 [arg_10, r_1]
  in let tup_el_17 = toErl 0
  in let arg_15 = ErlangTuple [ErlangAtom "stack", tup_el_17]
  in let arg_18 = ErlangTuple [ErlangAtom "immediate", i_2]
  in let tup_el_23 = toErl 0
  in let arg_21 = ErlangTuple [ErlangAtom "stack", tup_el_23]
  in let tup_el_26 = toErl 0
  in let arg_24 = ErlangTuple [ErlangAtom "stack", tup_el_26]
  in let
    head_14 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__setelement__4"
        [arg_15, arg_18, arg_21, arg_24]
  in
    ErlangCons head_4
      (ErlangCons head_9 (ErlangCons head_14 ErlangEmptyList))
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "op"), op_1, args_2])]
  =
  let arg_4 = erlps__op_to_scode__1 [op_1]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "let"), x_1,
                                   (ErlangTuple [(ErlangAtom "var"), y_2]),
                                   body_3])]
  =
  let    arg_5 = erlps__lookup_var__2 [env_0, y_2]
  in let env1_9 = erlps__bind_var__3 [x_1, arg_5, env_0]
  in erlps__to_scode__2 [env1_9, body_3]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "let"), x_1, expr_2, body_3])]
  =
  let matchExpr_8 = erlps__bind_local__2 [x_1, env_0]
  in
    case matchExpr_8 of
      (ErlangTuple [i_6, env1_7]) ->
        let    arg_10 = erlps__notail__1 [env_0]
        in let head_9 = erlps__to_scode__2 [arg_10, expr_2]
        in let arg_15 = ErlangTuple [ErlangAtom "var", i_6]
        in let tup_el_20 = toErl 0
        in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
        in let
          head_14 =
            BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__store__2"
              [arg_15, arg_18]
        in let head_22 = erlps__to_scode__2 [env1_7, body_3]
        in
          ErlangCons head_9
            (ErlangCons head_14 (ErlangCons head_22 ErlangEmptyList))
      _ -> EXC.badmatch matchExpr_8
erlps__to_scode1__2 [env_1@(ErlangTuple [(ErlangAtom "env"), _,
                                         _, _, fun_0, (ErlangAtom "true"), _,
                                         _]),
                     (ErlangTuple [(ErlangAtom "def"), fun_2, args_3])]
  | fun_2 == fun_0 =
  let   
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [arg_8, (ErlangTuple [is_9, acc_10, env1_11])] =
             let    arg_12 = toErl "_"
             in let matchExpr_16 = erlps__bind_local__2 [arg_12, env1_11]
             in
               case matchExpr_16 of
                 (ErlangTuple [i_14, env2_15]) ->
                   let    arg_17 = erlps__notail__1 [env2_15]
                   in let argcode_20 = erlps__to_scode__2 [arg_17, arg_8]
                   in let arg_26 = ErlangTuple [ErlangAtom "var", i_14]
                   in let tup_el_31 = toErl 0
                   in let arg_29 = ErlangTuple [ErlangAtom "stack", tup_el_31]
                   in let
                     head_25 =
                       BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__store__2"
                         [arg_26, arg_29]
                   in
                     ErlangTuple
                       [ErlangCons i_14 is_9,
                        ErlangCons acc_10
                          (ErlangCons argcode_20
                             (ErlangCons head_25 ErlangEmptyList)),
                        env2_15]
                 _ -> EXC.badmatch matchExpr_16
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let
    arg_39 = ErlangTuple [ErlangEmptyList, ErlangEmptyList, env_1]
  in let
    matchExpr_47 =
      BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
        [arg_4, arg_39, args_3]
  in
    case matchExpr_47 of
      (ErlangTuple [vars_44, code_45, _env_46]) ->
        let    arg_53 = toErl 0
        in let lop_55 = BIF.erlang__length__1 [vars_44]
        in let rop_57 = toErl 1
        in let arg_54 = BIF.erlang__op_minus [lop_55, rop_57]
        in let
          arg_52 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_53, arg_54]
        in let
          arg_58 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [vars_44]
        in let
          lcSrc_51 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_52, arg_58]
        in let
          head_50 =
            flmap
              (\ lc_62 ->
                 case lc_62 of
                   (ErlangTuple [i_60, j_61]) ->
                     let    arg_64 = ErlangTuple [ErlangAtom "arg", i_60]
                     in let arg_67 = ErlangTuple [ErlangAtom "var", j_61]
                     in let
                       lcRet_63 =
                         BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__store__2"
                           [arg_64, arg_67]
                     in ErlangCons lcRet_63 ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_51
        in
          ErlangCons code_45
            (ErlangCons head_50
               (ErlangCons (ErlangAtom "loop") ErlangEmptyList))
      _ -> EXC.badmatch matchExpr_47
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "def"), fun_1, args_2])]
  =
  let    fname_4 = erlps__make_function_id__1 [fun_1]
  in let
    lbl_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
        [fname_4]
  in let arg_10 = ErlangTuple [ErlangAtom "immediate", lbl_6]
  in let arg_8 = erlps__local_call__2 [env_0, arg_10]
  in erlps__call_to_scode__3 [env_0, arg_8, args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "funcall"), fun_1, args_2])]
  =
  let    head_5 = erlps__to_scode__2 [env_0, fun_1]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let head_9 = erlps__local_call__2 [env_0, arg_11]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_5 (ErlangCons head_9 ErlangEmptyList),
       args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "builtin"), b_1, args_2])]
  =
  erlps__builtin_to_scode__3 [env_0, b_1, args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "remote"), argst_1, rett_2, ct_3,
                                   fun_4,
                                   (ErlangCons gas_5 (ErlangCons value_6 (ErlangCons protected_7 args_8)))])]
  =
  let    lbl_10 = erlps__make_function_id__1 [fun_4]
  in let
    arg_11 =
      flmap
        (\ lc_14 ->
           let    tup_el_16 = toErl "_"
           in let lcRet_15 = ErlangTuple [tup_el_16, lc_14]
           in ErlangCons lcRet_15 ErlangEmptyList)
        argst_1
  in let matchExpr_21 = erlps__typesig_to_scode__2 [arg_11, rett_2]
  in
    case matchExpr_21 of
      (ErlangTuple [argtypes_19, rettype0_20]) ->
        let    arg_24 = ErlangTuple [ErlangAtom "tuple", argtypes_19]
        in let
          tup_el_23 =
            BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
              [arg_24]
        in let
          argtype_27 = ErlangTuple [ErlangAtom "immediate", tup_el_23]
        in let
          tup_el_29 =
            BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
              [rettype0_20]
        in let
          rettype_31 = ErlangTuple [ErlangAtom "immediate", tup_el_29]
        in
          case protected_7 of
            (ErlangTuple [(ErlangAtom "lit"),
                          (ErlangTuple [(ErlangAtom "bool"),
                                        (ErlangAtom "false")])]) ->
              case gas_5 of
                (ErlangTuple [(ErlangAtom "builtin"),
                              (ErlangAtom "call_gas_left"), _]) ->
                  let    tup_el_36 = toErl 0
                  in let arg_34 = ErlangTuple [ErlangAtom "stack", tup_el_36]
                  in let tup_el_42 = toErl 0
                  in let arg_40 = ErlangTuple [ErlangAtom "stack", tup_el_42]
                  in let
                    call_43 =
                      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_r__5"
                        [arg_34, lbl_10, argtype_27, rettype_31, arg_40]
                  in
                    erlps__call_to_scode__3
                      [env_0, call_43,
                       ErlangCons ct_3 (ErlangCons value_6 args_8)]
                _ ->
                  let    tup_el_53 = toErl 0
                  in let arg_51 = ErlangTuple [ErlangAtom "stack", tup_el_53]
                  in let tup_el_59 = toErl 0
                  in let arg_57 = ErlangTuple [ErlangAtom "stack", tup_el_59]
                  in let tup_el_62 = toErl 0
                  in let arg_60 = ErlangTuple [ErlangAtom "stack", tup_el_62]
                  in let
                    call_63 =
                      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_gr__6"
                        [arg_51, lbl_10, argtype_27, rettype_31, arg_57, arg_60]
                  in
                    erlps__call_to_scode__3
                      [env_0, call_63,
                       ErlangCons ct_3
                         (ErlangCons value_6 (ErlangCons gas_5 args_8))]
            (ErlangTuple [(ErlangAtom "lit"),
                          (ErlangTuple [(ErlangAtom "bool"),
                                        (ErlangAtom "true")])]) ->
              let    tup_el_75 = toErl 0
              in let arg_73 = ErlangTuple [ErlangAtom "stack", tup_el_75]
              in let tup_el_81 = toErl 0
              in let arg_79 = ErlangTuple [ErlangAtom "stack", tup_el_81]
              in let tup_el_84 = toErl 0
              in let arg_82 = ErlangTuple [ErlangAtom "stack", tup_el_84]
              in let
                arg_85 = ErlangTuple [ErlangAtom "immediate", ErlangAtom "true"]
              in let
                call_88 =
                  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_pgr__7"
                    [arg_73, lbl_10, argtype_27, rettype_31, arg_79, arg_82,
                     arg_85]
              in
                erlps__call_to_scode__3
                  [env_0, call_88,
                   ErlangCons ct_3
                     (ErlangCons value_6 (ErlangCons gas_5 args_8))]
            _ ->
              let    tup_el_100 = toErl 0
              in let arg_98 = ErlangTuple [ErlangAtom "stack", tup_el_100]
              in let tup_el_106 = toErl 0
              in let arg_104 = ErlangTuple [ErlangAtom "stack", tup_el_106]
              in let tup_el_109 = toErl 0
              in let arg_107 = ErlangTuple [ErlangAtom "stack", tup_el_109]
              in let tup_el_112 = toErl 0
              in let arg_110 = ErlangTuple [ErlangAtom "stack", tup_el_112]
              in let
                call_113 =
                  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_pgr__7"
                    [arg_98, lbl_10, argtype_27, rettype_31, arg_104, arg_107,
                     arg_110]
              in
                erlps__call_to_scode__3
                  [env_0, call_113,
                   ErlangCons ct_3
                     (ErlangCons value_6
                        (ErlangCons gas_5 (ErlangCons protected_7 args_8)))]
      _ -> EXC.badmatch matchExpr_21
erlps__to_scode1__2 [_env_0,
                     (ErlangTuple [(ErlangAtom "get_state"), reg_1])]
  =
  let    arg_3 = ErlangTuple [ErlangAtom "store", reg_1]
  in let head_2 = erlps__push__1 [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "set_state"), reg_1, val_2])]
  =
  let    tup_el_7 = ErlangTuple [ErlangAtom "store", reg_1]
  in let tup_el_12 = toErl 0
  in let tup_el_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    head_5 = ErlangTuple [ErlangAtom "STORE", tup_el_7, tup_el_10]
  in let arg_15 = toErl 0
  in let head_14 = erlps__tuple__1 [arg_15]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_5 (ErlangCons head_14 ErlangEmptyList),
       ErlangCons val_2 ErlangEmptyList]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "closure"), fun_1, fvs_2])]
  =
  let    tup_el_11 = erlps__make_function_id__1 [fun_1]
  in let tup_el_9 = ErlangTuple [ErlangAtom "string", tup_el_11]
  in let head_7 = ErlangTuple [ErlangAtom "lit", tup_el_9]
  in let
    arg_4 =
      ErlangTuple
        [ErlangAtom "tuple",
         ErlangCons head_7 (ErlangCons fvs_2 ErlangEmptyList)]
  in erlps__to_scode__2 [env_0, arg_4]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "switch"), case_1])]
  =
  erlps__split_to_scode__2 [env_0, case_1]
erlps__to_scode1__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__to_scode1__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_scode1__2) args

erlps__local_call__2 :: ErlangFun
erlps__local_call__2 [env_0, fun_1]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            case env_0 of
              (ErlangTuple arr_5) | (DM.Just field_4) <- (arr_5 DA.!! 5) ->
                field_4
              _ -> EXC.badrecord (ErlangAtom "env"))) =
  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_t__1" [fun_1]
erlps__local_call__2 [_env_0, fun_1] =
  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call__1" [fun_1]
erlps__local_call__2 [arg_3, arg_4] = EXC.function_clause unit
erlps__local_call__2 args =
  EXC.badarity (ErlangFun 2 erlps__local_call__2) args

erlps__split_to_scode__2 :: ErlangFun
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "nosplit"), expr_1])]
  =
  let head_4 = erlps__to_scode__2 [env_0, expr_1]
  in
    ErlangCons (ErlangAtom "switch_body")
      (ErlangCons head_4 ErlangEmptyList)
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangTuple [(ErlangAtom "tuple"), _]),
                                        x_1, alts_2])]
  =
  let
    matchExpr_8 = erlps__catchall_to_scode__3 [env_0, x_1, alts_2]
  in
    case matchExpr_8 of
      (ErlangTuple [def_6, alts1_7]) ->
        let    arg_11 = erlps__lookup_var__2 [env_0, x_1]
        in let
          case_12 =
            flmap
              (\ lc_16 ->
                 case lc_16 of
                   (ErlangTuple [(ErlangAtom "case"),
                                 (ErlangTuple [(ErlangAtom "tuple"), xs_14]),
                                 split_15]) ->
                     let lcRet_17 = ErlangTuple [xs_14, split_15]
                     in ErlangCons lcRet_17 ErlangEmptyList
                   _ -> ErlangEmptyList)
              alts1_7
        in let
          alt_34 =
            case case_12 of
              (ErlangEmptyList) -> ErlangAtom "missing"
              (ErlangCons (ErlangTuple [xs_20, s_21]) _) ->
                let matchExpr_27 = erlps__match_tuple__3 [env_0, arg_11, xs_20]
                in
                  case matchExpr_27 of
                    (ErlangTuple [code_25, env1_26]) ->
                      let head_30 = erlps__split_to_scode__2 [env1_26, s_21]
                      in ErlangCons code_25 (ErlangCons head_30 ErlangEmptyList)
                    _ -> EXC.badmatch matchExpr_27
              something_else -> EXC.case_clause something_else
        in let lop_36 = BIF.erlang__op_eq [def_6, ErlangAtom "missing"]
        in let
          case_35 =
            case lop_36 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") ->
                BIF.erlang__op_neq [alt_34, ErlangAtom "missing"]
              _ -> EXC.badarg1 lop_36
        in
          case case_35 of
            (ErlangAtom "true") -> alt_34
            (ErlangAtom "false") ->
              let
                head_41 =
                  ErlangTuple
                    [ErlangAtom "switch", arg_11, ErlangAtom "tuple",
                     ErlangCons alt_34 ErlangEmptyList, def_6]
              in ErlangCons head_41 ErlangEmptyList
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_8
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangAtom "boolean"), x_1, alts_2])]
  =
  let
    matchExpr_8 = erlps__catchall_to_scode__3 [env_0, x_1, alts_2]
  in
    case matchExpr_8 of
      (ErlangTuple [def_6, alts1_7]) ->
        let   
          getalt_21 =
            ErlangFun 1
              (let
                 lambda_9 [b_11] =
                   let    arg_13 = ErlangTuple [ErlangAtom "bool", b_11]
                   in let arg_16 = toErl 2
                   in let
                     case_12 = BIF.lists__keyfind__3 [arg_13, arg_16, alts1_7]
                   in
                     case case_12 of
                       (ErlangAtom "false") -> ErlangAtom "missing"
                       (ErlangTuple [(ErlangAtom "case"), _, s_18]) ->
                         erlps__split_to_scode__2 [env_0, s_18]
                       something_else -> EXC.case_clause something_else
                 lambda_9 [arg_10] = EXC.function_clause unit
                 lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
               in lambda_9)
        in let
          head_22 =
            BIF.erlang__apply__2
              [getalt_21, ErlangCons (ErlangAtom "false") ErlangEmptyList]
        in let
          head_26 =
            BIF.erlang__apply__2
              [getalt_21, ErlangCons (ErlangAtom "true") ErlangEmptyList]
        in let arg_33 = erlps__lookup_var__2 [env_0, x_1]
        in let
          head_34 =
            ErlangTuple
              [ErlangAtom "switch", arg_33, ErlangAtom "boolean",
               ErlangCons head_22 (ErlangCons head_26 ErlangEmptyList), def_6]
        in ErlangCons head_34 ErlangEmptyList
      _ -> EXC.badmatch matchExpr_8
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangTuple [(ErlangAtom "list"), _]),
                                        x_1, alts_2])]
  =
  let
    matchExpr_8 = erlps__catchall_to_scode__3 [env_0, x_1, alts_2]
  in
    case matchExpr_8 of
      (ErlangTuple [def_6, alts1_7]) ->
        let    arg_11 = erlps__lookup_var__2 [env_0, x_1]
        in let
          getalt_63 =
            ErlangFun 1
              (let
                 lambda_12 [p_14] =
                   let
                     case_15 =
                       flmap
                         (\ lc_19 ->
                            case lc_19 of
                              c_18@(ErlangTuple [(ErlangAtom "case"), pat_17,
                                                 _]) ->
                                let    lop_21 = BIF.erlang__op_eq [pat_17, p_14]
                                in let
                                  cond_20 =
                                    case lop_21 of
                                      (ErlangAtom "true") -> ErlangAtom "true"
                                      (ErlangAtom "false") ->
                                        let
                                          lop_24 =
                                            BIF.erlang__is_tuple__1 [pat_17]
                                        in
                                          case lop_24 of
                                            (ErlangAtom "false") ->
                                              ErlangAtom "false"
                                            (ErlangAtom "true") ->
                                              let    arg_27 = toErl 1
                                              in let
                                                lop_26 =
                                                  BIF.erlang__element__2
                                                    [arg_27, pat_17]
                                              in
                                                BIF.erlang__op_eq [lop_26, p_14]
                                            _ -> EXC.badarg1 lop_24
                                      _ -> EXC.badarg1 lop_21
                                in
                                  case cond_20 of
                                    (ErlangAtom "true") ->
                                      ErlangCons c_18 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              _ -> ErlangEmptyList)
                         alts1_7
                   in
                     case case_15 of
                       (ErlangEmptyList) -> ErlangAtom "missing"
                       (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                 (ErlangAtom "nil"),
                                                 s_31]) _) ->
                         erlps__split_to_scode__2 [env_0, s_31]
                       (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                 (ErlangTuple [(ErlangAtom "::"),
                                                               y_34, z_35]),
                                                 s_36]) _) ->
                         let matchExpr_41 = erlps__bind_local__2 [y_34, env_0]
                         in
                           case matchExpr_41 of
                             (ErlangTuple [i_39, env1_40]) ->
                               let
                                 matchExpr_46 =
                                   erlps__bind_local__2 [z_35, env1_40]
                               in
                                 case matchExpr_46 of
                                   (ErlangTuple [j_44, env2_45]) ->
                                     let   
                                       arg_48 =
                                         ErlangTuple [ErlangAtom "var", i_39]
                                     in let
                                       head_47 =
                                         BIF.do_remote_fun_call "Aeb.Fate.Ops"
                                           "erlps__hd__2" [arg_48, arg_11]
                                     in let
                                       arg_54 =
                                         ErlangTuple [ErlangAtom "var", j_44]
                                     in let
                                       head_53 =
                                         BIF.do_remote_fun_call "Aeb.Fate.Ops"
                                           "erlps__tl__2" [arg_54, arg_11]
                                     in let
                                       head_59 =
                                         erlps__split_to_scode__2
                                           [env2_45, s_36]
                                     in
                                       ErlangCons head_47
                                         (ErlangCons head_53
                                            (ErlangCons head_59
                                               ErlangEmptyList))
                                   _ -> EXC.badmatch matchExpr_46
                             _ -> EXC.badmatch matchExpr_41
                       something_else -> EXC.case_clause something_else
                 lambda_12 [arg_13] = EXC.function_clause unit
                 lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
               in lambda_12)
        in let
          head_64 =
            BIF.erlang__apply__2
              [getalt_63, ErlangCons (ErlangAtom "::") ErlangEmptyList]
        in let
          head_68 =
            BIF.erlang__apply__2
              [getalt_63, ErlangCons (ErlangAtom "nil") ErlangEmptyList]
        in let tup_el_76 = toErl 0
        in let arg_74 = ErlangTuple [ErlangAtom "stack", tup_el_76]
        in let
          head_73 =
            BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_nil__2"
              [arg_74, arg_11]
        in let tup_el_83 = toErl 0
        in let tup_el_81 = ErlangTuple [ErlangAtom "stack", tup_el_83]
        in let
          head_79 =
            ErlangTuple
              [ErlangAtom "switch", tup_el_81, ErlangAtom "boolean",
               ErlangCons head_64 (ErlangCons head_68 ErlangEmptyList), def_6]
        in ErlangCons head_73 (ErlangCons head_79 ErlangEmptyList)
      _ -> EXC.badmatch matchExpr_8
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"), type_1, x_2,
                                        alts_3])]
  | (weakEq type_1 (ErlangAtom "integer")) ||
      (weakEq type_1 (ErlangAtom "string")) =
  let
    matchExpr_9 = erlps__catchall_to_scode__3 [env_0, x_2, alts_3]
  in
    case matchExpr_9 of
      (ErlangTuple [def_7, alts1_8]) ->
        let arg_12 = erlps__lookup_var__2 [env_0, x_2]
        in
          erlps__literal_split_to_scode__5
            [env_0, type_1, arg_12, alts1_8, def_7]
      _ -> EXC.badmatch matchExpr_9
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangTuple [(ErlangAtom "variant"),
                                                      cons_1]),
                                        x_2, alts_3])]
  =
  let
    matchExpr_9 = erlps__catchall_to_scode__3 [env_0, x_2, alts_3]
  in
    case matchExpr_9 of
      (ErlangTuple [def_7, alts1_8]) ->
        let    arg_12 = erlps__lookup_var__2 [env_0, x_2]
        in let
          getalt_42 =
            ErlangFun 1
              (let
                 lambda_13 [i_15] =
                   let
                     case_16 =
                       flmap
                         (\ lc_21 ->
                            case lc_21 of
                              (ErlangTuple [(ErlangAtom "case"),
                                            (ErlangTuple [(ErlangAtom "con"), _,
                                                          j_18, xs_19]),
                                            s_20]) ->
                                let cond_22 = BIF.erlang__op_eq [i_15, j_18]
                                in
                                  case cond_22 of
                                    (ErlangAtom "true") ->
                                      let lcRet_25 = ErlangTuple [xs_19, s_20]
                                      in ErlangCons lcRet_25 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              _ -> ErlangEmptyList)
                         alts1_8
                   in
                     case case_16 of
                       (ErlangEmptyList) -> ErlangAtom "missing"
                       (ErlangCons (ErlangTuple [xs_28, s_29]) _) ->
                         let
                           matchExpr_35 =
                             erlps__match_variant__3 [env_0, arg_12, xs_28]
                         in
                           case matchExpr_35 of
                             (ErlangTuple [code_33, env1_34]) ->
                               let
                                 head_38 =
                                   erlps__split_to_scode__2 [env1_34, s_29]
                               in
                                 ErlangCons code_33
                                   (ErlangCons head_38 ErlangEmptyList)
                             _ -> EXC.badmatch matchExpr_35
                       something_else -> EXC.case_clause something_else
                 lambda_13 [arg_14] = EXC.function_clause unit
                 lambda_13 args = EXC.badarity (ErlangFun 1 lambda_13) args
               in lambda_13)
        in let
          tup_el_44 =
            flmap
              (\ lc_47 ->
                 let lcRet_48 = BIF.erlang__length__1 [lc_47]
                 in ErlangCons lcRet_48 ErlangEmptyList)
              cons_1
        in let stype_50 = ErlangTuple [ErlangAtom "variant", tup_el_44]
        in let arg_54 = toErl 0
        in let lop_56 = BIF.erlang__length__1 [cons_1]
        in let rop_58 = toErl 1
        in let arg_55 = BIF.erlang__op_minus [lop_56, rop_58]
        in let
          lcSrc_53 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_54, arg_55]
        in let
          tup_el_52 =
            flmap
              (\ lc_60 ->
                 let
                   lcRet_61 =
                     BIF.erlang__apply__2
                       [getalt_42, ErlangCons lc_60 ErlangEmptyList]
                 in ErlangCons lcRet_61 ErlangEmptyList)
              lcSrc_53
        in let case_51 = ErlangTuple [tup_el_52, def_7]
        in
          case case_51 of
            (ErlangTuple [(ErlangCons salt_65 (ErlangEmptyList)),
                          (ErlangAtom "missing")]) | weakNEq salt_65
                                                       (ErlangAtom "missing") ->
              salt_65
            (ErlangTuple [salts_66, _]) ->
              let
                head_67 =
                  ErlangTuple
                    [ErlangAtom "switch", arg_12, stype_50, salts_66, def_7]
              in ErlangCons head_67 ErlangEmptyList
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_9
erlps__split_to_scode__2 [arg_74, arg_75] =
  EXC.function_clause unit
erlps__split_to_scode__2 args =
  EXC.badarity (ErlangFun 2 erlps__split_to_scode__2) args

erlps__literal_split_to_scode__5 :: ErlangFun
erlps__literal_split_to_scode__5 [_env_0, _type_1, arg_2,
                                  (ErlangEmptyList), def_3]
  =
  ErlangTuple
    [ErlangAtom "switch", arg_2, ErlangAtom "boolean",
     ErlangCons (ErlangAtom "missing")
       (ErlangCons (ErlangAtom "missing") ErlangEmptyList),
     def_3]
erlps__literal_split_to_scode__5 [env_0, type_1, arg_2,
                                  (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                            lit_3,
                                                            body_4]) alts_5),
                                  def_6]
  | (weakEq type_1 (ErlangAtom "integer")) ||
      (weakEq type_1 (ErlangAtom "string")) =
  let    true_9 = erlps__split_to_scode__2 [env_0, body_4]
  in let
    false_16 =
      case alts_5 of
        (ErlangEmptyList) -> ErlangAtom "missing"
        _ ->
          erlps__literal_split_to_scode__5
            [env_0, type_1, arg_2, alts_5, ErlangAtom "missing"]
  in let
    slit_21 =
      case lit_3 of
        (ErlangTuple [(ErlangAtom "int"), n_18]) -> n_18
        (ErlangTuple [(ErlangAtom "string"), s_19]) ->
          BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
            [s_19]
        something_else -> EXC.case_clause something_else
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let arg_27 = ErlangTuple [ErlangAtom "immediate", slit_21]
  in let
    head_22 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__eq__3"
        [arg_23, arg_2, arg_27]
  in let tup_el_35 = toErl 0
  in let tup_el_33 = ErlangTuple [ErlangAtom "stack", tup_el_35]
  in let
    head_31 =
      ErlangTuple
        [ErlangAtom "switch", tup_el_33, ErlangAtom "boolean",
         ErlangCons false_16 (ErlangCons true_9 ErlangEmptyList), def_6]
  in ErlangCons head_22 (ErlangCons head_31 ErlangEmptyList)
erlps__literal_split_to_scode__5 [arg_44, arg_45, arg_46, arg_47,
                                  arg_48]
  =
  EXC.function_clause unit
erlps__literal_split_to_scode__5 args =
  EXC.badarity (ErlangFun 5 erlps__literal_split_to_scode__5) args

erlps__catchall_to_scode__3 :: ErlangFun
erlps__catchall_to_scode__3 [env_0, x_1, alts_2] =
  erlps__catchall_to_scode__4 [env_0, x_1, alts_2, ErlangEmptyList]
erlps__catchall_to_scode__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__catchall_to_scode__3 args =
  EXC.badarity (ErlangFun 3 erlps__catchall_to_scode__3) args

erlps__catchall_to_scode__4 :: ErlangFun
erlps__catchall_to_scode__4 [env_0, x_1,
                             (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                       (ErlangTuple [(ErlangAtom "var"),
                                                                     y_2]),
                                                       split_3]) _),
                             acc_4]
  =
  let    arg_6 = erlps__lookup_var__2 [env_0, x_1]
  in let env1_10 = erlps__bind_var__3 [y_2, arg_6, env_0]
  in let tup_el_11 = erlps__split_to_scode__2 [env1_10, split_3]
  in let
    tup_el_14 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_4]
  in ErlangTuple [tup_el_11, tup_el_14]
erlps__catchall_to_scode__4 [env_0, x_1,
                             (ErlangCons alt_2 alts_3), acc_4]
  =
  erlps__catchall_to_scode__4
    [env_0, x_1, alts_3, ErlangCons alt_2 acc_4]
erlps__catchall_to_scode__4 [_, _, (ErlangEmptyList), acc_0] =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
  in ErlangTuple [ErlangAtom "missing", tup_el_2]
erlps__catchall_to_scode__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__catchall_to_scode__4 args =
  EXC.badarity (ErlangFun 4 erlps__catchall_to_scode__4) args

erlps__match_tuple__3 :: ErlangFun
erlps__match_tuple__3 [env_0, arg_1, xs_2] =
  let    arg_4 = toErl 0
  in let arg_8 = toErl 3
  in let
    arg_5 =
      BIF.erlang__make_fun__3
        [ErlangAtom "aeb_fate_ops", ErlangAtom "element_op", arg_8]
  in erlps__match_tuple__5 [env_0, arg_4, arg_5, arg_1, xs_2]
erlps__match_tuple__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__match_tuple__3 args =
  EXC.badarity (ErlangFun 3 erlps__match_tuple__3) args

erlps__match_variant__3 :: ErlangFun
erlps__match_variant__3 [env_0, arg_1, xs_2] =
  let   
    elem_13 =
      ErlangFun 3
        (let
           lambda_3 [dst_7, i_8, val_9] =
             BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__variant_element__3"
               [dst_7, val_9, i_8]
           lambda_3 [arg_4, arg_5, arg_6] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 3 lambda_3) args
         in lambda_3)
  in let arg_15 = toErl 0
  in erlps__match_tuple__5 [env_0, arg_15, elem_13, arg_1, xs_2]
erlps__match_variant__3 [arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__match_variant__3 args =
  EXC.badarity (ErlangFun 3 erlps__match_variant__3) args

erlps__match_tuple__5 :: ErlangFun
erlps__match_tuple__5 [env_0, i_1, elem_2, arg_3,
                       (ErlangCons (ErlangCons (ErlangInt num_4) (ErlangEmptyList)) xs_5)]
  | (ErlangInt num_4) == (toErl 95) =
  let    rop_9 = toErl 1
  in let arg_7 = BIF.erlang__op_plus [i_1, rop_9]
  in erlps__match_tuple__5 [env_0, arg_7, elem_2, arg_3, xs_5]
erlps__match_tuple__5 [env_0, i_1, elem_2, arg_3,
                       (ErlangCons x_4 xs_5)]
  =
  let matchExpr_10 = erlps__bind_local__2 [x_4, env_0]
  in
    case matchExpr_10 of
      (ErlangTuple [j_8, env1_9]) ->
        let    rop_14 = toErl 1
        in let arg_12 = BIF.erlang__op_plus [i_1, rop_14]
        in let
          matchExpr_20 =
            erlps__match_tuple__5 [env1_9, arg_12, elem_2, arg_3, xs_5]
        in
          case matchExpr_20 of
            (ErlangTuple [code_18, env2_19]) ->
              let    arg_23 = ErlangTuple [ErlangAtom "var", j_8]
              in let arg_26 = ErlangTuple [ErlangAtom "immediate", i_1]
              in let
                head_22 =
                  BIF.erlang__apply__2
                    [elem_2,
                     ErlangCons arg_23
                       (ErlangCons arg_26 (ErlangCons arg_3 ErlangEmptyList))]
              in
                ErlangTuple
                  [ErlangCons head_22 (ErlangCons code_18 ErlangEmptyList),
                   env2_19]
            _ -> EXC.badmatch matchExpr_20
      _ -> EXC.badmatch matchExpr_10
erlps__match_tuple__5 [env_0, _, _, _, (ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, env_0]
erlps__match_tuple__5 [arg_3, arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__match_tuple__5 args =
  EXC.badarity (ErlangFun 5 erlps__match_tuple__5) args

erlps__call_to_scode__3 :: ErlangFun
erlps__call_to_scode__3 [env_0, callcode_1, args_2] =
  let   
    lcSrc_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [args_2]
  in let
    head_3 =
      flmap
        (\ lc_7 ->
           let    arg_9 = erlps__notail__1 [env_0]
           in let lcRet_8 = erlps__to_scode__2 [arg_9, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        lcSrc_4
  in ErlangCons head_3 (ErlangCons callcode_1 ErlangEmptyList)
erlps__call_to_scode__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__call_to_scode__3 args =
  EXC.badarity (ErlangFun 3 erlps__call_to_scode__3) args

erlps__builtin_to_scode__3 :: ErlangFun
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_event"),
                            args_1]
  =
  let    arg_8 = BIF.erlang__length__1 [args_1]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
        [arg_8, arg_10]
  in let
    head_4 =
      BIF.erlang__apply__3
        [ErlangAtom "aeb_fate_ops", ErlangAtom "log", arg_7]
  in let arg_15 = toErl 0
  in let head_14 = erlps__tuple__1 [arg_15]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_4 (ErlangCons head_14 ErlangEmptyList),
       args_1]
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "map_empty"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_empty__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "bits_none"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_none__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "bits_all"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_all__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_to_int"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_to_int__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_to_str"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_to_str__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_concat"),
                            args_1@(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_concat__3"
        [arg_4, arg_7, arg_10]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_split"),
                            args_1@(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_split__3"
        [arg_4, arg_7, arg_10]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "abort"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__abort__1" [arg_4]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_spend"),
                            args_1@(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    head_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__spend__2"
        [arg_5, arg_8]
  in let arg_13 = toErl 0
  in let head_12 = erlps__tuple__1 [arg_13]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_4 (ErlangCons head_12 ErlangEmptyList),
       args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_balance"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__balance_other__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "chain_block_hash"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__blockhash__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_coinbase"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__beneficiary__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_timestamp"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__timestamp__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_block_height"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__generation__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_difficulty"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__difficulty__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_gas_limit"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gaslimit__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "contract_balance"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__balance__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "contract_address"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__address__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "contract_creator"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__contract_creator__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_origin"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__origin__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_caller"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__caller__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_value"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_value__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "call_gas_price"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gasprice__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_fee"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__fee__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_gas_left"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gas__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_register"),
                            args_7@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _qfee_3 (ErlangCons _ttl_4 (ErlangCons _qtype_5 (ErlangCons _rtype_6 (ErlangEmptyList)))))))]
  =
  let    tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let tup_el_21 = toErl 0
  in let arg_19 = ErlangTuple [ErlangAtom "stack", tup_el_21]
  in let tup_el_24 = toErl 0
  in let arg_22 = ErlangTuple [ErlangAtom "stack", tup_el_24]
  in let tup_el_27 = toErl 0
  in let arg_25 = ErlangTuple [ErlangAtom "stack", tup_el_27]
  in let tup_el_30 = toErl 0
  in let arg_28 = ErlangTuple [ErlangAtom "stack", tup_el_30]
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_register__7"
        [arg_10, arg_13, arg_16, arg_19, arg_22, arg_25, arg_28]
  in erlps__call_to_scode__3 [env_0, arg_9, args_7]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_expiry"),
                            args_2@(ErlangCons _oracle_1 (ErlangEmptyList))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_expiry__2"
        [arg_5, arg_8]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_query_fee"),
                            args_2@(ErlangCons _oracle_1 (ErlangEmptyList))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_query_fee__2" [arg_5, arg_8]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_query"),
                            args_8@(ErlangCons _oracle_1 (ErlangCons _question_2 (ErlangCons _qfee_3 (ErlangCons _qttl_4 (ErlangCons _rttl_5 (ErlangCons _qtype_6 (ErlangCons _rtype_7 (ErlangEmptyList))))))))]
  =
  let    tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let tup_el_28 = toErl 0
  in let arg_26 = ErlangTuple [ErlangAtom "stack", tup_el_28]
  in let tup_el_31 = toErl 0
  in let arg_29 = ErlangTuple [ErlangAtom "stack", tup_el_31]
  in let tup_el_34 = toErl 0
  in let arg_32 = ErlangTuple [ErlangAtom "stack", tup_el_34]
  in let
    arg_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_query__8"
        [arg_11, arg_14, arg_17, arg_20, arg_23, arg_26, arg_29, arg_32]
  in erlps__call_to_scode__3 [env_0, arg_10, args_8]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_get_question"),
                            args_5@(ErlangCons _oracle_1 (ErlangCons _queryid_2 (ErlangCons _qtype_3 (ErlangCons _rtype_4 (ErlangEmptyList)))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_get_question__5"
        [arg_8, arg_11, arg_14, arg_17, arg_20]
  in erlps__call_to_scode__3 [env_0, arg_7, args_5]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_respond"),
                            args_7@(ErlangCons _sign_1 (ErlangCons _oracle_2 (ErlangCons _queryid_3 (ErlangCons _response_4 (ErlangCons _qtype_5 (ErlangCons _rtype_6 (ErlangEmptyList)))))))]
  =
  let    tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let tup_el_28 = toErl 0
  in let arg_26 = ErlangTuple [ErlangAtom "stack", tup_el_28]
  in let
    head_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_respond__6"
        [arg_11, arg_14, arg_17, arg_20, arg_23, arg_26]
  in let arg_31 = toErl 0
  in let head_30 = erlps__tuple__1 [arg_31]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_10 (ErlangCons head_30 ErlangEmptyList),
       args_7]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_extend"),
                            args_4@(ErlangCons _sign_1 (ErlangCons _oracle_2 (ErlangCons _ttl_3 (ErlangEmptyList))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_extend__3"
        [arg_8, arg_11, arg_14]
  in let arg_19 = toErl 0
  in let head_18 = erlps__tuple__1 [arg_19]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_7 (ErlangCons head_18 ErlangEmptyList),
       args_4]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_get_answer"),
                            args_5@(ErlangCons _oracle_1 (ErlangCons _queryid_2 (ErlangCons _qtype_3 (ErlangCons _rtype_4 (ErlangEmptyList)))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_get_answer__5"
        [arg_8, arg_11, arg_14, arg_17, arg_20]
  in erlps__call_to_scode__3 [env_0, arg_7, args_5]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_check"),
                            args_4@(ErlangCons _oracle_1 (ErlangCons _qtype_2 (ErlangCons _rtype_3 (ErlangEmptyList))))]
  =
  let    tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_check__4"
        [arg_7, arg_10, arg_13, arg_16]
  in erlps__call_to_scode__3 [env_0, arg_6, args_4]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_check_query"),
                            args_5@(ErlangCons _oracle_1 (ErlangCons _query_2 (ErlangCons _qtype_3 (ErlangCons _rtype_4 (ErlangEmptyList)))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_check_query__5"
        [arg_8, arg_11, arg_14, arg_17, arg_20]
  in erlps__call_to_scode__3 [env_0, arg_7, args_5]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "address_is_oracle"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_oracle__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "address_is_contract"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_contract__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "address_is_payable"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_payable__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_resolve"),
                            args_4@(ErlangCons _name_1 (ErlangCons _key_2 (ErlangCons _type_3 (ErlangEmptyList))))]
  =
  let    tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_resolve__4"
        [arg_7, arg_10, arg_13, arg_16]
  in erlps__call_to_scode__3 [env_0, arg_6, args_4]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_preclaim"),
                            args_4@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _hash_3 (ErlangEmptyList))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_preclaim__3"
        [arg_8, arg_11, arg_14]
  in let arg_19 = toErl 0
  in let head_18 = erlps__tuple__1 [arg_19]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_7 (ErlangCons head_18 ErlangEmptyList),
       args_4]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_claim"),
                            args_6@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _namestring_3 (ErlangCons _salt_4 (ErlangCons _namefee_5 (ErlangEmptyList))))))]
  =
  let    tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let tup_el_21 = toErl 0
  in let arg_19 = ErlangTuple [ErlangAtom "stack", tup_el_21]
  in let tup_el_24 = toErl 0
  in let arg_22 = ErlangTuple [ErlangAtom "stack", tup_el_24]
  in let
    head_9 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_claim__5"
        [arg_10, arg_13, arg_16, arg_19, arg_22]
  in let arg_27 = toErl 0
  in let head_26 = erlps__tuple__1 [arg_27]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_9 (ErlangCons head_26 ErlangEmptyList),
       args_6]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_transfer"),
                            args_5@(ErlangCons _sign_1 (ErlangCons _from_2 (ErlangCons _to_3 (ErlangCons _name_4 (ErlangEmptyList)))))]
  =
  let    tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in let tup_el_14 = toErl 0
  in let arg_12 = ErlangTuple [ErlangAtom "stack", tup_el_14]
  in let tup_el_17 = toErl 0
  in let arg_15 = ErlangTuple [ErlangAtom "stack", tup_el_17]
  in let tup_el_20 = toErl 0
  in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
  in let
    head_8 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_transfer__4"
        [arg_9, arg_12, arg_15, arg_18]
  in let arg_23 = toErl 0
  in let head_22 = erlps__tuple__1 [arg_23]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_8 (ErlangCons head_22 ErlangEmptyList),
       args_5]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_revoke"),
                            args_4@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _name_3 (ErlangEmptyList))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_revoke__3"
        [arg_8, arg_11, arg_14]
  in let arg_19 = toErl 0
  in let head_18 = erlps__tuple__1 [arg_19]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_7 (ErlangCons head_18 ErlangEmptyList),
       args_4]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_update"),
                            args_7@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _namestring_3 (ErlangCons _ttl_4 (ErlangCons _clientttl_5 (ErlangCons _pointers_6 (ErlangEmptyList)))))))]
  =
  let    tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let tup_el_28 = toErl 0
  in let arg_26 = ErlangTuple [ErlangAtom "stack", tup_el_28]
  in let
    head_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_update__6"
        [arg_11, arg_14, arg_17, arg_20, arg_23, arg_26]
  in let arg_31 = toErl 0
  in let head_30 = erlps__tuple__1 [arg_31]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_10 (ErlangCons head_30 ErlangEmptyList),
       args_7]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_lookup"),
                            args_2@(ErlangCons _name_1 (ErlangEmptyList))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_lookup__2"
        [arg_5, arg_8]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "auth_tx_hash"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__auth_tx_hash__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "auth_tx"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__auth_tx__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "chain_bytecode_hash"),
                            args_2@(ErlangCons _addr_1 (ErlangEmptyList))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytecode_hash__2"
        [arg_5, arg_8]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_clone"),
                            (ErlangCons initargst_1 (ErlangCons gascap_2 (ErlangCons value_3 (ErlangCons prot_4 (ErlangCons contract_5 initargs_6)))))]
  =
  case gascap_2 of
    (ErlangTuple [(ErlangAtom "builtin"),
                  (ErlangAtom "call_gas_left"), _]) ->
      let    tup_el_12 = toErl 0
      in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
      in let tup_el_15 = toErl 0
      in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
      in let tup_el_18 = toErl 0
      in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
      in let tup_el_21 = toErl 0
      in let arg_19 = ErlangTuple [ErlangAtom "stack", tup_el_21]
      in let
        arg_9 =
          BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__clone__4"
            [arg_10, arg_13, arg_16, arg_19]
      in
        erlps__call_to_scode__3
          [env_0, arg_9,
           ErlangCons contract_5
             (ErlangCons initargst_1
                (ErlangCons value_3 (ErlangCons prot_4 initargs_6)))]
    _ ->
      let    tup_el_35 = toErl 0
      in let arg_33 = ErlangTuple [ErlangAtom "stack", tup_el_35]
      in let tup_el_38 = toErl 0
      in let arg_36 = ErlangTuple [ErlangAtom "stack", tup_el_38]
      in let tup_el_41 = toErl 0
      in let arg_39 = ErlangTuple [ErlangAtom "stack", tup_el_41]
      in let tup_el_44 = toErl 0
      in let arg_42 = ErlangTuple [ErlangAtom "stack", tup_el_44]
      in let tup_el_47 = toErl 0
      in let arg_45 = ErlangTuple [ErlangAtom "stack", tup_el_47]
      in let
        arg_32 =
          BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__clone_g__5"
            [arg_33, arg_36, arg_39, arg_42, arg_45]
      in
        erlps__call_to_scode__3
          [env_0, arg_32,
           ErlangCons contract_5
             (ErlangCons initargst_1
                (ErlangCons value_3
                   (ErlangCons gascap_2 (ErlangCons prot_4 initargs_6))))]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_create"),
                            (ErlangCons code_1 (ErlangCons initargst_2 (ErlangCons value_3 initargs_4)))]
  =
  let    tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__create__3"
        [arg_7, arg_10, arg_13]
  in
    erlps__call_to_scode__3
      [env_0, arg_6,
       ErlangCons code_1
         (ErlangCons initargst_2 (ErlangCons value_3 initargs_4))]
erlps__builtin_to_scode__3 [arg_23, arg_24, arg_25] =
  EXC.function_clause unit
erlps__builtin_to_scode__3 args =
  EXC.badarity (ErlangFun 3 erlps__builtin_to_scode__3) args

erlps__op_to_scode__1 :: ErlangFun
erlps__op_to_scode__1 [(ErlangAtom "+")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__add__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "-")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sub__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "*")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__mul__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "/")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__divide__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mod")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__modulo__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "^")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__pow__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "++")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__append__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "::")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__cons__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "<")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__lt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom ">")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "=<")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__elt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom ">=")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__egt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "==")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__eq__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "!=")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__neq__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "!")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__not_op__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "map_get")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_lookup__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "map_get_d")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_lookup__4"
      [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "map_set")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_update__4"
      [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "map_from_list")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_from_list__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "map_to_list")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_to_list__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "map_delete")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_delete__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "map_member")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_member__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "map_size")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_size___2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_length")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_length__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_concat")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_join__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_to_list")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_to_list__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_from_list")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_from_list__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_to_lower")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_to_lower__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_to_upper")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_to_upper__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "char_to_int")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__char_to_int__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "char_from_int")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__char_from_int__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "bits_set")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_set__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_clear")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_clear__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_test")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_test__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_sum")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_sum__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "bits_intersection")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_and__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_union")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_or__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_difference")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_diff__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "address_to_str")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__addr_to_str__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "int_to_str")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__int_to_str__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "contract_to_address")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__contract_to_address__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "address_to_contract")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__address_to_contract__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "crypto_verify_sig")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__verify_sig__4"
      [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "crypto_verify_sig_secp256k1")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__verify_sig_secp256k1__4" [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "crypto_ecverify_secp256k1")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__ecverify_secp256k1__4" [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "crypto_ecrecover_secp256k1")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__ecrecover_secp256k1__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "crypto_sha3")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha3__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "crypto_sha256")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha256__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "crypto_blake2b")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__blake2b__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_sha3")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha3__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_sha256")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha256__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "stringinternal_blake2b")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__blake2b__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g1_neg")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g1_neg__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g1_norm")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g1_norm__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g1_valid")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g1_valid__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g1_is_zero")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g1_is_zero__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g1_add")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g1_add__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g1_mul")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g1_mul__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g2_neg")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g2_neg__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g2_norm")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g2_norm__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g2_valid")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g2_valid__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g2_is_zero")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g2_is_zero__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g2_add")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g2_add__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_g2_mul")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_g2_mul__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_gt_inv")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_gt_inv__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_gt_add")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_gt_add__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_gt_mul")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_gt_mul__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_gt_pow")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_gt_pow__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_gt_is_one")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_gt_is_one__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_pairing")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_pairing__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_miller_loop")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_miller_loop__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_final_exp")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_final_exp__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_int_to_fr")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_int_to_fr__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_int_to_fp")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_int_to_fp__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_fr_to_int")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_fr_to_int__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "mcl_bls12_381_fp_to_int")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__bls12_381_fp_to_int__2" [arg_0, arg_3]
erlps__op_to_scode__1 [arg_6] = EXC.function_clause unit
erlps__op_to_scode__1 args =
  EXC.badarity (ErlangFun 1 erlps__op_to_scode__1) args

erlps__push__1 :: ErlangFun
erlps__push__1 [a_0] =
  let    tup_el_4 = toErl 0
  in let tup_el_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in ErlangTuple [ErlangAtom "STORE", tup_el_2, a_0]
erlps__push__1 [arg_6] = EXC.function_clause unit
erlps__push__1 args =
  EXC.badarity (ErlangFun 1 erlps__push__1) args

erlps__tuple__1 :: ErlangFun
erlps__tuple__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 0) =
  let    tup_el_5 = ErlangTuple []
  in let tup_el_3 = ErlangTuple [ErlangAtom "tuple", tup_el_5]
  in let arg_1 = ErlangTuple [ErlangAtom "immediate", tup_el_3]
  in erlps__push__1 [arg_1]
erlps__tuple__1 [n_0] =
  let    tup_el_3 = toErl 0
  in let arg_1 = ErlangTuple [ErlangAtom "stack", tup_el_3]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__tuple__2"
      [arg_1, n_0]
erlps__tuple__1 [arg_5] = EXC.function_clause unit
erlps__tuple__1 args =
  EXC.badarity (ErlangFun 1 erlps__tuple__1) args

erlps__optimize_scode__2 :: ErlangFun
erlps__optimize_scode__2 [funs_0, options_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [name_6, def_7] =
             erlps__optimize_fun__4 [funs_0, name_6, def_7, options_1]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_2, funs_0]
erlps__optimize_scode__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__optimize_scode__2 args =
  EXC.badarity (ErlangFun 2 erlps__optimize_scode__2) args

erlps__flatten__1 :: ErlangFun
erlps__flatten__1 [(ErlangAtom "missing")] = ErlangAtom "missing"
erlps__flatten__1 [code_0] =
  let    arg_1 = ErlangFun 1 erlps__flatten_s__1
  in let
    arg_2 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [code_0]
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_1, arg_2]
erlps__flatten__1 [arg_4] = EXC.function_clause unit
erlps__flatten__1 args =
  EXC.badarity (ErlangFun 1 erlps__flatten__1) args

erlps__flatten_s__1 :: ErlangFun
erlps__flatten_s__1 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                   type_1, alts_2, catch_3])]
  =
  let   
    tup_el_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__flatten__1 [lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        alts_2
  in let tup_el_13 = erlps__flatten__1 [catch_3]
  in
    ErlangTuple
      [ErlangAtom "switch", arg_0, type_1, tup_el_7, tup_el_13]
erlps__flatten_s__1 [i_0] = i_0
erlps__flatten_s__1 [arg_1] = EXC.function_clause unit
erlps__flatten_s__1 args =
  EXC.badarity (ErlangFun 1 erlps__flatten_s__1) args

erlps__optimize_fun__4 :: ErlangFun
erlps__optimize_fun__4 [_funs_0, name_1,
                        (ErlangTuple [attrs_2, sig_3, code_4]), options_5]
  =
  let    code0_7 = erlps__flatten__1 [code_4]
  in let
    arg_10 =
      ErlangFun 0
        (let
           lambda_11 [] =
             let arg_12 = toErl "Optimizing ~s\n"
             in
               BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                 [arg_12, ErlangCons name_1 ErlangEmptyList]
           lambda_11 [] = EXC.function_clause unit
           lambda_11 args = EXC.badarity (ErlangFun 0 lambda_11) args
         in lambda_11)
  in let _ = erlps__debug__3 [ErlangAtom "opt", options_5, arg_10]
  in let arg_16 = toErl 0
  in let
    code1_19 = erlps__simpl_loop__3 [arg_16, code0_7, options_5]
  in let code2_21 = erlps__desugar__1 [code1_19]
  in ErlangTuple [attrs_2, sig_3, code2_21]
erlps__optimize_fun__4 [arg_25, arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__optimize_fun__4 args =
  EXC.badarity (ErlangFun 4 erlps__optimize_fun__4) args

erlps__simpl_loop__3 :: ErlangFun
erlps__simpl_loop__3 [n_0, code_1, options_2]
  | weakGeq n_0 (toErl 10) =
  let   
    arg_5 =
      ErlangFun 0
        (let
           lambda_6 [] =
             let
               arg_7 =
                 toErl "  No simpl_loop fixed_point after ~p iterations.\n\n"
             in
               BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                 [arg_7, ErlangCons n_0 ErlangEmptyList]
           lambda_6 [] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 0 lambda_6) args
         in lambda_6)
  in let _ = erlps__debug__3 [ErlangAtom "opt", options_2, arg_5]
  in code_1
erlps__simpl_loop__3 [n_0, code_1, options_2] =
  let    acode_4 = erlps__annotate_code__1 [code_1]
  in let rop_7 = toErl 0
  in let cond_5 = BIF.erlang__op_eq [n_0, rop_7]
  in let
    _ =
      case cond_5 of
        (ErlangAtom "true") ->
          let   
            arg_11 =
              ErlangFun 0
                (let
                   lambda_12 [] =
                     let    arg_13 = toErl "  annotated:\n~s\n"
                     in let arg_16 = toErl "    "
                     in let head_15 = erlps__pp_ann__2 [arg_16, acode_4]
                     in
                       BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                         [arg_13, ErlangCons head_15 ErlangEmptyList]
                   lambda_12 [] = EXC.function_clause unit
                   lambda_12 args = EXC.badarity (ErlangFun 0 lambda_12) args
                 in lambda_12)
          in let
            lcRet_8 = erlps__debug__3 [ErlangAtom "opt", options_2, arg_11]
          in ErlangCons lcRet_8 ErlangEmptyList
        _ -> ErlangEmptyList
  in let code1_21 = erlps__simplify__2 [acode_4, options_2]
  in let cond_22 = BIF.erlang__op_neq [code1_21, acode_4]
  in let
    _ =
      case cond_22 of
        (ErlangAtom "true") ->
          let   
            arg_28 =
              ErlangFun 0
                (let
                   lambda_29 [] =
                     let    arg_30 = toErl "  optimized:\n~s\n"
                     in let arg_33 = toErl "    "
                     in let head_32 = erlps__pp_ann__2 [arg_33, code1_21]
                     in
                       BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                         [arg_30, ErlangCons head_32 ErlangEmptyList]
                   lambda_29 [] = EXC.function_clause unit
                   lambda_29 args = EXC.badarity (ErlangFun 0 lambda_29) args
                 in lambda_29)
          in let
            lcRet_25 = erlps__debug__3 [ErlangAtom "opt", options_2, arg_28]
          in ErlangCons lcRet_25 ErlangEmptyList
        _ -> ErlangEmptyList
  in let code2_37 = erlps__unannotate__1 [code1_21]
  in let case_38 = BIF.erlang__op_eq [code_1, code2_37]
  in
    case case_38 of
      (ErlangAtom "true") ->
        let   
          arg_43 =
            ErlangFun 0
              (let
                 lambda_44 [] =
                   let   
                     arg_45 =
                       toErl
                         "  Reached simpl_loop fixed point after ~p iteration~s.\n\n"
                   in let
                     head_49 =
                       case ErlangAtom "true" of
                         _ | weakNEq n_0 (toErl 1) -> toErl "s"
                         _ -> toErl ""
                   in
                     BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                       [arg_45,
                        ErlangCons n_0 (ErlangCons head_49 ErlangEmptyList)]
                 lambda_44 [] = EXC.function_clause unit
                 lambda_44 args = EXC.badarity (ErlangFun 0 lambda_44) args
               in lambda_44)
        in let _ = erlps__debug__3 [ErlangAtom "opt", options_2, arg_43]
        in code2_37
      (ErlangAtom "false") ->
        let    rop_53 = toErl 1
        in let arg_51 = BIF.erlang__op_plus [n_0, rop_53]
        in erlps__simpl_loop__3 [arg_51, code2_37, options_2]
      something_else -> EXC.case_clause something_else
erlps__simpl_loop__3 [arg_56, arg_57, arg_58] =
  EXC.function_clause unit
erlps__simpl_loop__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_loop__3) args

erlps__pp_ann__2 :: ErlangFun
erlps__pp_ann__2 [ind_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "switch"), arg_1,
                                            type_2, alts_3, def_4]) code_5)]
  =
  let   
    tags_26 =
      case type_2 of
        (ErlangAtom "boolean") ->
          let    head_7 = toErl "FALSE"
          in let head_9 = toErl "TRUE"
          in ErlangCons head_7 (ErlangCons head_9 ErlangEmptyList)
        (ErlangAtom "tuple") ->
          let head_11 = toErl "(_)"
          in ErlangCons head_11 ErlangEmptyList
        (ErlangTuple [(ErlangAtom "variant"), ar_13]) ->
          let    arg_15 = toErl 0
          in let lop_17 = BIF.erlang__length__1 [ar_13]
          in let rop_19 = toErl 1
          in let arg_16 = BIF.erlang__op_minus [lop_17, rop_19]
          in let
            lcSrc_14 =
              BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_15, arg_16]
          in
            flmap
              (\ lc_21 ->
                 let    lop_23 = toErl "C"
                 in let rop_24 = BIF.erlang__integer_to_list__1 [lc_21]
                 in let lcRet_22 = BIF.erlang__op_append [lop_23, rop_24]
                 in ErlangCons lcRet_22 ErlangEmptyList)
              lcSrc_14
        something_else -> EXC.case_clause something_else
  in let lop_27 = toErl "  "
  in let ind1_29 = BIF.erlang__op_append [lop_27, ind_0]
  in let lop_30 = toErl "  "
  in let ind2_32 = BIF.erlang__op_append [lop_30, ind1_29]
  in let head_35 = toErl "SWITCH "
  in let head_37 = erlps__pp_arg__1 [arg_1]
  in let head_40 = toErl "\n"
  in let
    lcSrc_43 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2" [tags_26, alts_3]
  in let
    head_42 =
      flmap
        (\ lc_48 ->
           case lc_48 of
             (ErlangTuple [tag_46, alt_47]) ->
               let cond_49 = BIF.erlang__op_neq [alt_47, ErlangAtom "missing"]
               in
                 case cond_49 of
                   (ErlangAtom "true") ->
                     let    head_57 = toErl " =>\n"
                     in let head_59 = erlps__pp_ann__2 [ind2_32, alt_47]
                     in
                       ErlangCons
                         (ErlangCons ind1_29
                            (ErlangCons tag_46
                               (ErlangCons head_57
                                  (ErlangCons head_59 ErlangEmptyList))))
                         ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_43
  in let cond_65 = BIF.erlang__op_neq [def_4, ErlangAtom "missing"]
  in let
    head_64 =
      case cond_65 of
        (ErlangAtom "true") ->
          let    head_71 = toErl "_ =>\n"
          in let head_73 = erlps__pp_ann__2 [ind2_32, def_4]
          in
            ErlangCons
              (ErlangCons ind1_29
                 (ErlangCons head_71 (ErlangCons head_73 ErlangEmptyList)))
              ErlangEmptyList
        _ -> ErlangEmptyList
  in let head_78 = erlps__pp_ann__2 [ind_0, code_5]
  in
    ErlangCons ind_0
      (ErlangCons head_35
         (ErlangCons head_37
            (ErlangCons head_40
               (ErlangCons head_42
                  (ErlangCons head_64 (ErlangCons head_78 ErlangEmptyList))))))
erlps__pp_ann__2 [ind_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "i"), (ErlangMap map_1),
                                            i_4]) code_5)]
  | (DM.Just out_3) <- (Map.lookup (ErlangAtom "live_out") map_1)
  , (DM.Just in_2) <- (Map.lookup (ErlangAtom "live_in") map_1) =
  let   
    fmt_17 =
      ErlangFun 1
        (let
           lambda_6 [(ErlangEmptyList)] = toErl "()"
           lambda_6 [xs_8] =
             let   
               arg_9 =
                 flmap
                   (\ lc_12 ->
                      let    arg_14 = erlps__pp_arg__1 [lc_12]
                      in let
                        lcRet_13 =
                          BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
                            [arg_14]
                      in ErlangCons lcRet_13 ErlangEmptyList)
                   xs_8
             in let arg_16 = toErl " "
             in
               BIF.do_remote_fun_call "String" "erlps__join__2" [arg_9, arg_16]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let arg_21 = erlps__desugar_args__1 [i_4]
  in let head_20 = erlps__pp_op__1 [arg_21]
  in let lop_26 = BIF.erlang__op_append [in_2, out_3]
  in let cond_25 = BIF.erlang__op_neq [lop_26, ErlangEmptyList]
  in let
    ann_43 =
      case cond_25 of
        (ErlangAtom "true") ->
          let    head_31 = toErl "   % "
          in let
            head_33 =
              BIF.erlang__apply__2 [fmt_17, ErlangCons in_2 ErlangEmptyList]
          in let head_37 = toErl " -> "
          in let
            head_39 =
              BIF.erlang__apply__2 [fmt_17, ErlangCons out_3 ErlangEmptyList]
          in
            ErlangCons
              (ErlangCons head_31
                 (ErlangCons head_33
                    (ErlangCons head_37 (ErlangCons head_39 ErlangEmptyList))))
              ErlangEmptyList
        _ -> ErlangEmptyList
  in let arg_45 = toErl "~-40s~s\n"
  in let
    head_44 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_45,
         ErlangCons
           (ErlangCons ind_0 (ErlangCons head_20 ErlangEmptyList))
           (ErlangCons ann_43 ErlangEmptyList)]
  in let head_52 = erlps__pp_ann__2 [ind_0, code_5]
  in ErlangCons head_44 (ErlangCons head_52 ErlangEmptyList)
erlps__pp_ann__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__pp_ann__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__pp_ann__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_ann__2) args

erlps__pp_op__1 :: ErlangFun
erlps__pp_op__1 [(ErlangAtom "switch_body")] =
  toErl "SWITCH-BODY"
erlps__pp_op__1 [(ErlangAtom "loop")] = toErl "LOOP"
erlps__pp_op__1 [i_0] =
  let arg_2 = ErlangMap Map.empty
  in
    BIF.do_remote_fun_call "Aeb.Fate.Pp" "erlps__format_op__2"
      [i_0, arg_2]
erlps__pp_op__1 [arg_3] = EXC.function_clause unit
erlps__pp_op__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_op__1) args

erlps__pp_arg__1 :: ErlangFun
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "immediate"), i_0])]
  =
  let arg_1 = toErl "~w"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons i_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "arg"), n_0])] =
  let arg_1 = toErl "arg~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons n_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "store"), n_0])] =
  let arg_1 = toErl "store~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons n_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "var"), n_0])] =
  let arg_1 = toErl "var~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons n_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "stack"),
                                (ErlangInt num_0)])]
  | (ErlangInt num_0) == (toErl 0) =
  toErl "a"
erlps__pp_arg__1 [arg_1] = EXC.function_clause unit
erlps__pp_arg__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_arg__1) args

erlps__annotate_code__1 :: ErlangFun
erlps__annotate_code__1 [code_0] =
  let arg_1 = toErl 5
  in erlps__annotate_code__3 [arg_1, ErlangEmptyList, code_0]
erlps__annotate_code__1 [arg_4] = EXC.function_clause unit
erlps__annotate_code__1 args =
  EXC.badarity (ErlangFun 1 erlps__annotate_code__1) args

erlps__annotate_code__3 :: ErlangFun
erlps__annotate_code__3 [fuel_0, livetop_1, code_2] =
  let
    matchExpr_8 =
      erlps__ann_live__3 [livetop_1, code_2, ErlangEmptyList]
  in
    case matchExpr_8 of
      (ErlangTuple [code1_6, livein_7]) ->
        let case_9 = BIF.erlang__op_eq [livein_7, livetop_1]
        in
          case case_9 of
            (ErlangAtom "true") -> code1_6
            (ErlangAtom "false") | weakLeq fuel_0 (toErl 0) ->
              erlps__code_error__1 [ErlangAtom "liveness_analysis_out_of_fuel"]
            (ErlangAtom "false") ->
              let    rop_15 = toErl 1
              in let arg_13 = BIF.erlang__op_minus [fuel_0, rop_15]
              in erlps__annotate_code__3 [arg_13, livein_7, code_2]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_8
erlps__annotate_code__3 [arg_18, arg_19, arg_20] =
  EXC.function_clause unit
erlps__annotate_code__3 args =
  EXC.badarity (ErlangFun 3 erlps__annotate_code__3) args

erlps__ann_live__3 :: ErlangFun
erlps__ann_live__3 [_livetop_0, (ErlangAtom "missing"),
                    _liveout_1]
  =
  ErlangTuple [ErlangAtom "missing", ErlangEmptyList]
erlps__ann_live__3 [_livetop_0, (ErlangEmptyList), liveout_1] =
  ErlangTuple [ErlangEmptyList, liveout_1]
erlps__ann_live__3 [livetop_0, (ErlangCons i_1 is_2), liveout_3]
  =
  let matchExpr_9 = erlps__ann_live__3 [livetop_0, is_2, liveout_3]
  in
    case matchExpr_9 of
      (ErlangTuple [is1_7, livemid_8]) ->
        let
          matchExpr_15 = erlps__ann_live1__3 [livetop_0, i_1, livemid_8]
        in
          case matchExpr_15 of
            (ErlangTuple [i1_13, livein_14]) ->
              ErlangTuple [ErlangCons i1_13 is1_7, livein_14]
            _ -> EXC.badmatch matchExpr_15
      _ -> EXC.badmatch matchExpr_9
erlps__ann_live__3 [arg_20, arg_21, arg_22] =
  EXC.function_clause unit
erlps__ann_live__3 args =
  EXC.badarity (ErlangFun 3 erlps__ann_live__3) args

erlps__ann_live1__3 :: ErlangFun
erlps__ann_live1__3 [_livetop_0, (ErlangAtom "switch_body"),
                     liveout_1]
  =
  let   
    ann_6 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "live_in") liveout_1,
            DT.Tuple (ErlangAtom "live_out") liveout_1])
  in let
    tup_el_7 =
      ErlangTuple [ErlangAtom "i", ann_6, ErlangAtom "switch_body"]
  in ErlangTuple [tup_el_7, liveout_1]
erlps__ann_live1__3 [livetop_0, (ErlangAtom "loop"), _liveout_1]
  =
  let   
    ann_6 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "live_in") livetop_0,
            DT.Tuple (ErlangAtom "live_out") ErlangEmptyList])
  in let
    tup_el_7 = ErlangTuple [ErlangAtom "i", ann_6, ErlangAtom "loop"]
  in ErlangTuple [tup_el_7, livetop_0]
erlps__ann_live1__3 [livetop_0,
                     (ErlangTuple [(ErlangAtom "switch"), arg_1, type_2, alts_3,
                                   def_4]),
                     liveout_5]
  =
  let    cond_6 = erlps__is_reg__1 [arg_1]
  in let
    read_9 =
      case cond_6 of
        (ErlangAtom "true") -> ErlangCons arg_1 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    arg_10 =
      flmap
        (\ lc_13 ->
           let lcRet_14 = erlps__ann_live__3 [livetop_0, lc_13, liveout_5]
           in ErlangCons lcRet_14 ErlangEmptyList)
        alts_3
  in let
    matchExpr_20 =
      BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_10]
  in
    case matchExpr_20 of
      (ErlangTuple [alts1_18, livealts_19]) ->
        let
          matchExpr_26 = erlps__ann_live__3 [livetop_0, def_4, liveout_5]
        in
          case matchExpr_26 of
            (ErlangTuple [def1_24, livedef_25]) ->
              let   
                livein_32 =
                  BIF.do_remote_fun_call "Ordsets" "erlps__union__1"
                    [ErlangCons read_9 (ErlangCons livedef_25 livealts_19)]
              in let
                tup_el_33 =
                  ErlangTuple
                    [ErlangAtom "switch", arg_1, type_2, alts1_18, def1_24]
              in ErlangTuple [tup_el_33, livein_32]
            _ -> EXC.badmatch matchExpr_26
      _ -> EXC.badmatch matchExpr_20
erlps__ann_live1__3 [_livetop_0, i_1, liveout_2] =
  let matchExpr_7 = erlps__attributes__1 [i_1]
  in
    case matchExpr_7 of
      (ErlangMap map_4) | (DM.Just w_6) <-
                            (Map.lookup (ErlangAtom "write") map_4)
                        , (DM.Just reads0_5) <-
                            (Map.lookup (ErlangAtom "read") map_4) ->
        let    arg_8 = ErlangFun 1 erlps__is_reg__1
        in let
          reads_10 =
            BIF.do_remote_fun_call "Lists" "erlps__filter__2"
              [arg_8, reads0_5]
        in let
          arg_11 =
            BIF.erlang__op_unAppend
              [liveout_2, ErlangCons w_6 ErlangEmptyList]
        in let
          livein_17 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__2"
              [arg_11, reads_10]
        in let
          ann_22 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "live_in") livein_17,
                  DT.Tuple (ErlangAtom "live_out") liveout_2])
        in let tup_el_23 = ErlangTuple [ErlangAtom "i", ann_22, i_1]
        in ErlangTuple [tup_el_23, livein_17]
      _ -> EXC.badmatch matchExpr_7
erlps__ann_live1__3 [arg_28, arg_29, arg_30] =
  EXC.function_clause unit
erlps__ann_live1__3 args =
  EXC.badarity (ErlangFun 3 erlps__ann_live1__3) args

erlps__is_reg__1 :: ErlangFun
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "stack"),
                                (ErlangInt num_0)])]
  | (ErlangInt num_0) == (toErl 0) =
  ErlangAtom "false"
erlps__is_reg__1 [(ErlangAtom "none")] = ErlangAtom "false"
erlps__is_reg__1 [(ErlangAtom "pc")] = ErlangAtom "false"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "immediate"), _])] =
  ErlangAtom "false"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "arg"), _])] =
  ErlangAtom "true"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "store"), _])] =
  ErlangAtom "true"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "var"), _])] =
  ErlangAtom "true"
erlps__is_reg__1 [arg_0] = EXC.function_clause unit
erlps__is_reg__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_reg__1) args

erlps__attributes__1 :: ErlangFun
erlps__attributes__1 [i_0] =
  let   
    set_9 =
      ErlangFun 1
        (let
           lambda_1 [l_3] | isEList l_3 =
             BIF.do_remote_fun_call "Ordsets" "erlps__from_list__1" [l_3]
           lambda_1 [x_5] =
             BIF.do_remote_fun_call "Ordsets" "erlps__from_list__1"
               [ErlangCons x_5 ErlangEmptyList]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let
    attr_25 =
      ErlangFun 3
        (let
           lambda_10 [w_14, r_15, p_16] =
             let
               val_20 =
                 BIF.erlang__apply__2 [set_9, ErlangCons r_15 ErlangEmptyList]
             in
               ErlangMap
                 (Map.fromFoldable
                    [DT.Tuple (ErlangAtom "read") val_20,
                     DT.Tuple (ErlangAtom "write") w_14,
                     DT.Tuple (ErlangAtom "pure") p_16])
           lambda_10 [arg_11, arg_12, arg_13] = EXC.function_clause unit
           lambda_10 args = EXC.badarity (ErlangFun 3 lambda_10) args
         in lambda_10)
  in let
    pure_35 =
      ErlangFun 2
        (let
           lambda_26 [w_29, r_30] =
             BIF.erlang__apply__2
               [attr_25,
                ErlangCons w_29
                  (ErlangCons r_30
                     (ErlangCons (ErlangAtom "true") ErlangEmptyList))]
           lambda_26 [arg_27, arg_28] = EXC.function_clause unit
           lambda_26 args = EXC.badarity (ErlangFun 2 lambda_26) args
         in lambda_26)
  in let
    impure_45 =
      ErlangFun 2
        (let
           lambda_36 [w_39, r_40] =
             BIF.erlang__apply__2
               [attr_25,
                ErlangCons w_39
                  (ErlangCons r_40
                     (ErlangCons (ErlangAtom "false") ErlangEmptyList))]
           lambda_36 [arg_37, arg_38] = EXC.function_clause unit
           lambda_36 args = EXC.badarity (ErlangFun 2 lambda_36) args
         in lambda_36)
  in
    case i_0 of
      (ErlangAtom "loop") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangAtom "switch_body") ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangAtom "RETURN") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "RETURNR"), a_56]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_56 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL"), a_60]) ->
        let    tup_el_63 = toErl 0
        in let arg_61 = ErlangTuple [ErlangAtom "stack", tup_el_63]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_61
               (ErlangCons (ErlangCons a_60 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_R"), a_68, _, b_69, c_70,
                    d_71]) ->
        let    tup_el_74 = toErl 0
        in let arg_72 = ErlangTuple [ErlangAtom "stack", tup_el_74]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_72
               (ErlangCons
                  (ErlangCons a_68
                     (ErlangCons b_69
                        (ErlangCons c_70 (ErlangCons d_71 ErlangEmptyList))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_GR"), a_85, _, b_86, c_87, d_88,
                    e_89]) ->
        let    tup_el_92 = toErl 0
        in let arg_90 = ErlangTuple [ErlangAtom "stack", tup_el_92]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_90
               (ErlangCons
                  (ErlangCons a_85
                     (ErlangCons b_86
                        (ErlangCons c_87
                           (ErlangCons d_88
                              (ErlangCons e_89 ErlangEmptyList)))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_PGR"), a_105, _, b_106, c_107,
                    d_108, e_109, f_110]) ->
        let    tup_el_113 = toErl 0
        in let arg_111 = ErlangTuple [ErlangAtom "stack", tup_el_113]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_111
               (ErlangCons
                  (ErlangCons a_105
                     (ErlangCons b_106
                        (ErlangCons c_107
                           (ErlangCons d_108
                              (ErlangCons e_109
                                 (ErlangCons f_110 ErlangEmptyList))))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_T"), a_128]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons (ErlangCons a_128 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_VALUE"), a_134]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_134 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "JUMP"), _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "JUMPIF"), a_141, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_141 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SWITCH_V2"), a_145, _, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_145 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SWITCH_V3"), a_149, _, _, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_149 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SWITCH_VN"), a_153, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_153 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "PUSH"), a_157]) ->
        let    tup_el_160 = toErl 0
        in let arg_158 = ErlangTuple [ErlangAtom "stack", tup_el_160]
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons arg_158 (ErlangCons a_157 ErlangEmptyList)]
      (ErlangAtom "DUPA") ->
        let    tup_el_165 = toErl 0
        in let arg_163 = ErlangTuple [ErlangAtom "stack", tup_el_165]
        in let tup_el_168 = toErl 0
        in let arg_166 = ErlangTuple [ErlangAtom "stack", tup_el_168]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_163 (ErlangCons arg_166 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DUP"), a_170]) ->
        let    tup_el_173 = toErl 0
        in let arg_171 = ErlangTuple [ErlangAtom "stack", tup_el_173]
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons arg_171 (ErlangCons a_170 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "POP"), a_176]) ->
        let    tup_el_180 = toErl 0
        in let arg_178 = ErlangTuple [ErlangAtom "stack", tup_el_180]
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons a_176 (ErlangCons arg_178 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STORE"), a_182, b_183]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_182 (ErlangCons b_183 ErlangEmptyList)]
      (ErlangAtom "INCA") ->
        let    tup_el_189 = toErl 0
        in let arg_187 = ErlangTuple [ErlangAtom "stack", tup_el_189]
        in let tup_el_192 = toErl 0
        in let arg_190 = ErlangTuple [ErlangAtom "stack", tup_el_192]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_187 (ErlangCons arg_190 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "INC"), a_194]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_194 (ErlangCons a_194 ErlangEmptyList)]
      (ErlangAtom "DECA") ->
        let    tup_el_200 = toErl 0
        in let arg_198 = ErlangTuple [ErlangAtom "stack", tup_el_200]
        in let tup_el_203 = toErl 0
        in let arg_201 = ErlangTuple [ErlangAtom "stack", tup_el_203]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_198 (ErlangCons arg_201 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DEC"), a_205]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_205 (ErlangCons a_205 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADD"), a_209, b_210, c_211]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_209
             (ErlangCons (ErlangCons b_210 (ErlangCons c_211 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SUB"), a_219, b_220, c_221]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_219
             (ErlangCons (ErlangCons b_220 (ErlangCons c_221 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MUL"), a_229, b_230, c_231]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_229
             (ErlangCons (ErlangCons b_230 (ErlangCons c_231 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DIV"), a_239, b_240, c_241]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_239
             (ErlangCons (ErlangCons b_240 (ErlangCons c_241 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MOD"), a_249, b_250, c_251]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_249
             (ErlangCons (ErlangCons b_250 (ErlangCons c_251 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "POW"), a_259, b_260, c_261]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_259
             (ErlangCons (ErlangCons b_260 (ErlangCons c_261 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LT"), a_269, b_270, c_271]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_269
             (ErlangCons (ErlangCons b_270 (ErlangCons c_271 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GT"), a_279, b_280, c_281]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_279
             (ErlangCons (ErlangCons b_280 (ErlangCons c_281 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "EQ"), a_289, b_290, c_291]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_289
             (ErlangCons (ErlangCons b_290 (ErlangCons c_291 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ELT"), a_299, b_300, c_301]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_299
             (ErlangCons (ErlangCons b_300 (ErlangCons c_301 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "EGT"), a_309, b_310, c_311]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_309
             (ErlangCons (ErlangCons b_310 (ErlangCons c_311 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "NEQ"), a_319, b_320, c_321]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_319
             (ErlangCons (ErlangCons b_320 (ErlangCons c_321 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AND"), a_329, b_330, c_331]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_329
             (ErlangCons (ErlangCons b_330 (ErlangCons c_331 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "OR"), a_339, b_340, c_341]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_339
             (ErlangCons (ErlangCons b_340 (ErlangCons c_341 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "NOT"), a_349, b_350]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_349 (ErlangCons b_350 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "TUPLE"), a_354, n_355]) ->
        let    rop_360 = toErl 0
        in let cond_358 = BIF.erlang__op_greater [n_355, rop_360]
        in let
          arg_357 =
            case cond_358 of
              (ErlangAtom "true") ->
                let    tup_el_363 = toErl 0
                in let lcRet_361 = ErlangTuple [ErlangAtom "stack", tup_el_363]
                in ErlangCons lcRet_361 ErlangEmptyList
              _ -> ErlangEmptyList
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons a_354 (ErlangCons arg_357 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ELEMENT"), a_365, b_366, c_367]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_365
             (ErlangCons (ErlangCons b_366 (ErlangCons c_367 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SETELEMENT"), a_375, b_376, c_377,
                    d_378]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_375
             (ErlangCons
                (ErlangCons b_376
                   (ErlangCons c_377 (ErlangCons d_378 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_EMPTY"), a_388]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_388 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_LOOKUP"), a_392, b_393, c_394]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_392
             (ErlangCons (ErlangCons b_393 (ErlangCons c_394 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_LOOKUPD"), a_402, b_403, c_404,
                    d_405]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_402
             (ErlangCons
                (ErlangCons b_403
                   (ErlangCons c_404 (ErlangCons d_405 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_UPDATE"), a_415, b_416, c_417,
                    d_418]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_415
             (ErlangCons
                (ErlangCons b_416
                   (ErlangCons c_417 (ErlangCons d_418 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_DELETE"), a_428, b_429, c_430]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_428
             (ErlangCons (ErlangCons b_429 (ErlangCons c_430 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_MEMBER"), a_438, b_439, c_440]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_438
             (ErlangCons (ErlangCons b_439 (ErlangCons c_440 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_FROM_LIST"), a_448, b_449]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_448 (ErlangCons b_449 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_TO_LIST"), a_453, b_454]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_453 (ErlangCons b_454 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_SIZE"), a_458, b_459]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_458 (ErlangCons b_459 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "NIL"), a_463]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_463 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_NIL"), a_467, b_468]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_467 (ErlangCons b_468 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CONS"), a_472, b_473, c_474]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_472
             (ErlangCons (ErlangCons b_473 (ErlangCons c_474 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "HD"), a_482, b_483]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_482 (ErlangCons b_483 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "TL"), a_487, b_488]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_487 (ErlangCons b_488 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LENGTH"), a_492, b_493]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_492 (ErlangCons b_493 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "APPEND"), a_497, b_498, c_499]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_497
             (ErlangCons (ErlangCons b_498 (ErlangCons c_499 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_JOIN"), a_507, b_508, c_509]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_507
             (ErlangCons (ErlangCons b_508 (ErlangCons c_509 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "INT_TO_STR"), a_517, b_518]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_517 (ErlangCons b_518 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADDR_TO_STR"), a_522, b_523]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_522 (ErlangCons b_523 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_REVERSE"), a_527, b_528]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_527 (ErlangCons b_528 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_LENGTH"), a_532, b_533]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_532 (ErlangCons b_533 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "INT_TO_ADDR"), a_537, b_538]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_537 (ErlangCons b_538 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VARIANT"), a_542, b_543, c_544,
                    d_545]) ->
        let    tup_el_550 = toErl 0
        in let head_548 = ErlangTuple [ErlangAtom "stack", tup_el_550]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons a_542
               (ErlangCons
                  (ErlangCons head_548
                     (ErlangCons b_543
                        (ErlangCons c_544 (ErlangCons d_545 ErlangEmptyList))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VARIANT_TEST"), a_559, b_560,
                    c_561]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_559
             (ErlangCons (ErlangCons b_560 (ErlangCons c_561 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VARIANT_ELEMENT"), a_569, b_570,
                    c_571]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_569
             (ErlangCons (ErlangCons b_570 (ErlangCons c_571 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangAtom "BITS_NONEA") ->
        let    tup_el_581 = toErl 0
        in let arg_579 = ErlangTuple [ErlangAtom "stack", tup_el_581]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_579 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_NONE"), a_584]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_584 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangAtom "BITS_ALLA") ->
        let    tup_el_590 = toErl 0
        in let arg_588 = ErlangTuple [ErlangAtom "stack", tup_el_590]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_588 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_ALL"), a_593]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_593 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_ALL_N"), a_597, b_598]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_597 (ErlangCons b_598 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_SET"), a_602, b_603, c_604]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_602
             (ErlangCons (ErlangCons b_603 (ErlangCons c_604 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_CLEAR"), a_612, b_613, c_614]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_612
             (ErlangCons (ErlangCons b_613 (ErlangCons c_614 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_TEST"), a_622, b_623, c_624]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_622
             (ErlangCons (ErlangCons b_623 (ErlangCons c_624 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_SUM"), a_632, b_633]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_632 (ErlangCons b_633 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_OR"), a_637, b_638, c_639]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_637
             (ErlangCons (ErlangCons b_638 (ErlangCons c_639 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_AND"), a_647, b_648, c_649]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_647
             (ErlangCons (ErlangCons b_648 (ErlangCons c_649 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_DIFF"), a_657, b_658, c_659]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_657
             (ErlangCons (ErlangCons b_658 (ErlangCons c_659 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SHA3"), a_667, b_668]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_667
             (ErlangCons (ErlangCons b_668 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SHA256"), a_674, b_675]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_674
             (ErlangCons (ErlangCons b_675 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLAKE2B"), a_681, b_682]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_681
             (ErlangCons (ErlangCons b_682 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VERIFY_SIG"), a_688, b_689, c_690,
                    d_691]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_688
             (ErlangCons
                (ErlangCons b_689
                   (ErlangCons c_690 (ErlangCons d_691 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VERIFY_SIG_SECP256K1"), a_701, b_702,
                    c_703, d_704]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_701
             (ErlangCons
                (ErlangCons b_702
                   (ErlangCons c_703 (ErlangCons d_704 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ECVERIFY_SECP256K1"), a_714, b_715,
                    c_716, d_717]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_714
             (ErlangCons
                (ErlangCons b_715
                   (ErlangCons c_716 (ErlangCons d_717 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ECRECOVER_SECP256K1"), a_727, b_728,
                    c_729]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_727
             (ErlangCons (ErlangCons b_728 (ErlangCons c_729 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CONTRACT_TO_ADDRESS"), a_737,
                    b_738]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_737
             (ErlangCons (ErlangCons b_738 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADDRESS_TO_CONTRACT"), a_744,
                    b_745]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_744
             (ErlangCons (ErlangCons b_745 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AUTH_TX_HASH"), a_751]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_751 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AUTH_TX"), a_755]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_755 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_TO_INT"), a_759, b_760]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_759
             (ErlangCons (ErlangCons b_760 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_TO_STR"), a_766, b_767]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_766
             (ErlangCons (ErlangCons b_767 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_CONCAT"), a_773, b_774,
                    c_775]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_773
             (ErlangCons (ErlangCons b_774 (ErlangCons c_775 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_SPLIT"), a_783, b_784,
                    c_785]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_783
             (ErlangCons (ErlangCons b_784 (ErlangCons c_785 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_CHECK"), a_793, b_794, c_795,
                    d_796]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_793
             (ErlangCons
                (ErlangCons b_794
                   (ErlangCons c_795 (ErlangCons d_796 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_CHECK_QUERY"), a_806, b_807,
                    c_808, d_809, e_810]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_806
             (ErlangCons
                (ErlangCons b_807
                   (ErlangCons c_808
                      (ErlangCons d_809 (ErlangCons e_810 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_ORACLE"), a_822, b_823]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_822
             (ErlangCons (ErlangCons b_823 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_CONTRACT"), a_829, b_830]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_829
             (ErlangCons (ErlangCons b_830 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_PAYABLE"), a_836, b_837]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_836
             (ErlangCons (ErlangCons b_837 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CREATOR"), a_843]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_843 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADDRESS"), a_847]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_847 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BALANCE"), a_851]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_851 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BALANCE_OTHER"), a_855, b_856]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_855
             (ErlangCons (ErlangCons b_856 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORIGIN"), a_862]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_862 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALLER"), a_866]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_866 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GASPRICE"), a_870]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_870 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "FEE"), a_874]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_874 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLOCKHASH"), a_878, b_879]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_878
             (ErlangCons (ErlangCons b_879 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BENEFICIARY"), a_885]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_885 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "TIMESTAMP"), a_889]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_889 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GENERATION"), a_893]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_893 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MICROBLOCK"), a_897]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_897 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DIFFICULTY"), a_901]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_901 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GASLIMIT"), a_905]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_905 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GAS"), a_909]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_909 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG0"), a_913]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons (ErlangCons a_913 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG1"), a_919, b_920]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons (ErlangCons a_919 (ErlangCons b_920 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG2"), a_928, b_929, c_930]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_928
                   (ErlangCons b_929 (ErlangCons c_930 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG3"), a_940, b_941, c_942,
                    d_943]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_940
                   (ErlangCons b_941
                      (ErlangCons c_942 (ErlangCons d_943 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG4"), a_955, b_956, c_957, d_958,
                    e_959]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_955
                   (ErlangCons b_956
                      (ErlangCons c_957
                         (ErlangCons d_958
                            (ErlangCons e_959 ErlangEmptyList)))))
                ErlangEmptyList)]
      (ErlangAtom "DEACTIVATE") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SPEND"), a_976, b_977]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons (ErlangCons a_976 (ErlangCons b_977 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_REGISTER"), a_985, b_986,
                    c_987, d_988, e_989, f_990, g_991]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_985
             (ErlangCons
                (ErlangCons b_986
                   (ErlangCons c_987
                      (ErlangCons d_988
                         (ErlangCons e_989
                            (ErlangCons f_990
                               (ErlangCons g_991 ErlangEmptyList))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_QUERY"), a_1007, b_1008,
                    c_1009, d_1010, e_1011, f_1012, g_1013, h_1014]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_1007
             (ErlangCons
                (ErlangCons b_1008
                   (ErlangCons c_1009
                      (ErlangCons d_1010
                         (ErlangCons e_1011
                            (ErlangCons f_1012
                               (ErlangCons g_1013
                                  (ErlangCons h_1014 ErlangEmptyList)))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_RESPOND"), a_1032, b_1033,
                    c_1034, d_1035, e_1036, f_1037]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1032
                   (ErlangCons b_1033
                      (ErlangCons c_1034
                         (ErlangCons d_1035
                            (ErlangCons e_1036
                               (ErlangCons f_1037 ErlangEmptyList))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_EXTEND"), a_1053, b_1054,
                    c_1055]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1053
                   (ErlangCons b_1054 (ErlangCons c_1055 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_GET_ANSWER"), a_1065, b_1066,
                    c_1067, d_1068, e_1069]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1065
             (ErlangCons
                (ErlangCons b_1066
                   (ErlangCons c_1067
                      (ErlangCons d_1068 (ErlangCons e_1069 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_GET_QUESTION"), a_1081, b_1082,
                    c_1083, d_1084, e_1085]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1081
             (ErlangCons
                (ErlangCons b_1082
                   (ErlangCons c_1083
                      (ErlangCons d_1084 (ErlangCons e_1085 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_QUERY_FEE"), a_1097,
                    b_1098]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1097
             (ErlangCons (ErlangCons b_1098 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_EXPIRY"), a_1104, b_1105]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_1104
             (ErlangCons (ErlangCons b_1105 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_RESOLVE"), a_1111, b_1112,
                    c_1113, d_1114]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_1111
             (ErlangCons
                (ErlangCons b_1112
                   (ErlangCons c_1113 (ErlangCons d_1114 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_PRECLAIM"), a_1124, b_1125,
                    c_1126]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1124
                   (ErlangCons b_1125 (ErlangCons c_1126 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_CLAIM"), a_1136, b_1137, c_1138,
                    d_1139, e_1140]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1136
                   (ErlangCons b_1137
                      (ErlangCons c_1138
                         (ErlangCons d_1139
                            (ErlangCons e_1140 ErlangEmptyList)))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_UPDATE"), a_1154, b_1155, c_1156,
                    d_1157, e_1158, f_1159]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1154
                   (ErlangCons b_1155
                      (ErlangCons c_1156
                         (ErlangCons d_1157
                            (ErlangCons e_1158
                               (ErlangCons f_1159 ErlangEmptyList))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_TRANSFER"), a_1175, b_1176,
                    c_1177, d_1178]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1175
                   (ErlangCons b_1176
                      (ErlangCons c_1177 (ErlangCons d_1178 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_REVOKE"), a_1190, b_1191,
                    c_1192]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1190
                   (ErlangCons b_1191 (ErlangCons c_1192 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_LOOKUP"), a_1202, b_1203]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_1202
             (ErlangCons (ErlangCons b_1203 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G1_NEG"), a_1209,
                    b_1210]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1209
             (ErlangCons (ErlangCons b_1210 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G1_NORM"), a_1216,
                    b_1217]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1216
             (ErlangCons (ErlangCons b_1217 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G1_VALID"), a_1223,
                    b_1224]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1223
             (ErlangCons (ErlangCons b_1224 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G1_IS_ZERO"), a_1230,
                    b_1231]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1230
             (ErlangCons (ErlangCons b_1231 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G1_ADD"), a_1237, b_1238,
                    c_1239]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1237
             (ErlangCons
                (ErlangCons b_1238 (ErlangCons c_1239 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G1_MUL"), a_1247, b_1248,
                    c_1249]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1247
             (ErlangCons
                (ErlangCons b_1248 (ErlangCons c_1249 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G2_NEG"), a_1257,
                    b_1258]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1257
             (ErlangCons (ErlangCons b_1258 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G2_NORM"), a_1264,
                    b_1265]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1264
             (ErlangCons (ErlangCons b_1265 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G2_VALID"), a_1271,
                    b_1272]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1271
             (ErlangCons (ErlangCons b_1272 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G2_IS_ZERO"), a_1278,
                    b_1279]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1278
             (ErlangCons (ErlangCons b_1279 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G2_ADD"), a_1285, b_1286,
                    c_1287]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1285
             (ErlangCons
                (ErlangCons b_1286 (ErlangCons c_1287 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_G2_MUL"), a_1295, b_1296,
                    c_1297]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1295
             (ErlangCons
                (ErlangCons b_1296 (ErlangCons c_1297 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_GT_INV"), a_1305,
                    b_1306]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1305
             (ErlangCons (ErlangCons b_1306 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_GT_ADD"), a_1312, b_1313,
                    c_1314]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1312
             (ErlangCons
                (ErlangCons b_1313 (ErlangCons c_1314 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_GT_MUL"), a_1322, b_1323,
                    c_1324]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1322
             (ErlangCons
                (ErlangCons b_1323 (ErlangCons c_1324 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_GT_POW"), a_1332, b_1333,
                    c_1334]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1332
             (ErlangCons
                (ErlangCons b_1333 (ErlangCons c_1334 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_GT_IS_ONE"), a_1342,
                    b_1343]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1342
             (ErlangCons (ErlangCons b_1343 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_PAIRING"), a_1349, b_1350,
                    c_1351]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1349
             (ErlangCons
                (ErlangCons b_1350 (ErlangCons c_1351 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_MILLER_LOOP"), a_1359,
                    b_1360, c_1361]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1359
             (ErlangCons
                (ErlangCons b_1360 (ErlangCons c_1361 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_FINAL_EXP"), a_1369,
                    b_1370]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1369
             (ErlangCons (ErlangCons b_1370 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_INT_TO_FR"), a_1376,
                    b_1377]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1376
             (ErlangCons (ErlangCons b_1377 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_INT_TO_FP"), a_1383,
                    b_1384]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1383
             (ErlangCons (ErlangCons b_1384 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_FR_TO_INT"), a_1390,
                    b_1391]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1390
             (ErlangCons (ErlangCons b_1391 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLS12_381_FP_TO_INT"), a_1397,
                    b_1398]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1397
             (ErlangCons (ErlangCons b_1398 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_TO_LIST"), a_1404, b_1405]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1404
             (ErlangCons (ErlangCons b_1405 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_FROM_LIST"), a_1411, b_1412]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1411
             (ErlangCons (ErlangCons b_1412 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_TO_UPPER"), a_1418, b_1419]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1418
             (ErlangCons (ErlangCons b_1419 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_TO_LOWER"), a_1425, b_1426]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1425
             (ErlangCons (ErlangCons b_1426 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CHAR_TO_INT"), a_1432, b_1433]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1432
             (ErlangCons (ErlangCons b_1433 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CHAR_FROM_INT"), a_1439, b_1440]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1439
             (ErlangCons (ErlangCons b_1440 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CREATE"), a_1446, b_1447, c_1448]) ->
        let    tup_el_1451 = toErl 0
        in let arg_1449 = ErlangTuple [ErlangAtom "stack", tup_el_1451]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_1449
               (ErlangCons
                  (ErlangCons a_1446
                     (ErlangCons b_1447 (ErlangCons c_1448 ErlangEmptyList)))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CLONE"), a_1460, b_1461, c_1462,
                    d_1463]) ->
        let    tup_el_1466 = toErl 0
        in let arg_1464 = ErlangTuple [ErlangAtom "stack", tup_el_1466]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_1464
               (ErlangCons
                  (ErlangCons a_1460
                     (ErlangCons b_1461
                        (ErlangCons c_1462
                           (ErlangCons d_1463 ErlangEmptyList))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CLONE_G"), a_1477, b_1478, c_1479,
                    d_1480, e_1481]) ->
        let    tup_el_1484 = toErl 0
        in let arg_1482 = ErlangTuple [ErlangAtom "stack", tup_el_1484]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_1482
               (ErlangCons
                  (ErlangCons a_1477
                     (ErlangCons b_1478
                        (ErlangCons c_1479
                           (ErlangCons d_1480
                              (ErlangCons e_1481 ErlangEmptyList)))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTECODE_HASH"), a_1497, b_1498]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_1497
             (ErlangCons (ErlangCons b_1498 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ABORT"), a_1504]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_1504 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "EXIT"), a_1508]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_1508 ErlangEmptyList)]
      (ErlangAtom "NOP") ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__attributes__1 [arg_1515] = EXC.function_clause unit
erlps__attributes__1 args =
  EXC.badarity (ErlangFun 1 erlps__attributes__1) args

erlps__var_writes__1 :: ErlangFun
erlps__var_writes__1 [(ErlangTuple [(ErlangAtom "i"), _, i_0])] =
  erlps__var_writes__1 [i_0]
erlps__var_writes__1 [i_0] =
  let matchExpr_4 = erlps__attributes__1 [i_0]
  in
    case matchExpr_4 of
      (ErlangMap map_2) | (DM.Just w_3) <-
                            (Map.lookup (ErlangAtom "write") map_2) ->
        case w_3 of
          (ErlangTuple [(ErlangAtom "var"), _]) ->
            ErlangCons w_3 ErlangEmptyList
          (ErlangTuple [(ErlangAtom "arg"), _]) ->
            ErlangCons w_3 ErlangEmptyList
          (ErlangTuple [(ErlangAtom "store"), _]) ->
            ErlangCons w_3 ErlangEmptyList
          (ErlangTuple [(ErlangAtom "stack"), _]) -> ErlangEmptyList
          (ErlangAtom "none") -> ErlangEmptyList
          (ErlangAtom "pc") -> ErlangEmptyList
          something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_4
erlps__var_writes__1 [arg_12] = EXC.function_clause unit
erlps__var_writes__1 args =
  EXC.badarity (ErlangFun 1 erlps__var_writes__1) args

erlps__independent__2 :: ErlangFun
erlps__independent__2 [_,
                       (ErlangTuple [(ErlangAtom "switch"), _, _, _, _])]
  =
  ErlangAtom "false"
erlps__independent__2 [(ErlangTuple [(ErlangAtom "i"), _, i_0]),
                       (ErlangTuple [(ErlangAtom "i"), _, j_1])]
  =
  let matchExpr_7 = erlps__attributes__1 [i_0]
  in
    case matchExpr_7 of
      (ErlangMap map_3) | (DM.Just purei_6) <-
                            (Map.lookup (ErlangAtom "pure") map_3)
                        , (DM.Just ri_5) <-
                            (Map.lookup (ErlangAtom "read") map_3)
                        , (DM.Just wi_4) <-
                            (Map.lookup (ErlangAtom "write") map_3) ->
        let matchExpr_13 = erlps__attributes__1 [j_1]
        in
          case matchExpr_13 of
            (ErlangMap map_9) | (DM.Just purej_12) <-
                                  (Map.lookup (ErlangAtom "pure") map_9)
                              , (DM.Just rj_11) <-
                                  (Map.lookup (ErlangAtom "read") map_9)
                              , (DM.Just wj_10) <-
                                  (Map.lookup (ErlangAtom "write") map_9) ->
              let    tup_el_16 = toErl 0
              in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
              in let
                stacki_20 = BIF.lists__member__2 [arg_14, ErlangCons wi_4 ri_5]
              in let tup_el_23 = toErl 0
              in let arg_21 = ErlangTuple [ErlangAtom "stack", tup_el_23]
              in let
                stackj_27 =
                  BIF.lists__member__2 [arg_21, ErlangCons wj_10 rj_11]
              in
                case ErlangAtom "true" of
                  _ | (weakEq wi_4 (ErlangAtom "pc")) ||
                        (weakEq wj_10 (ErlangAtom "pc")) ->
                    ErlangAtom "false"
                  _ | (ErlangAtom "true") ==
                        (falsifyErrors
                           (\ _ ->
                              let
                                op_arg_28 =
                                  BIF.erlang__op_or [purei_6, purej_12]
                              in BIF.erlang__not__1 [op_arg_28])) ->
                    ErlangAtom "false"
                  _ | (ErlangAtom "true") ==
                        (falsifyErrors
                           (\ _ ->
                              BIF.erlang__op_and [stacki_20, stackj_27])) ->
                    ErlangAtom "false"
                  _ | weakEq wi_4 wj_10 -> ErlangAtom "false"
                  _ ->
                    let    op_arg_34 = BIF.lists__member__2 [wi_4, rj_11]
                    in let lop_33 = BIF.erlang__not__1 [op_arg_34]
                    in
                      case lop_33 of
                        (ErlangAtom "false") -> ErlangAtom "false"
                        (ErlangAtom "true") ->
                          let op_arg_37 = BIF.lists__member__2 [wj_10, ri_5]
                          in BIF.erlang__not__1 [op_arg_37]
                        _ -> EXC.badarg1 lop_33
            _ -> EXC.badmatch matchExpr_13
      _ -> EXC.badmatch matchExpr_7
erlps__independent__2 [arg_40, arg_41] = EXC.function_clause unit
erlps__independent__2 args =
  EXC.badarity (ErlangFun 2 erlps__independent__2) args

erlps__merge_ann__2 :: ErlangFun
erlps__merge_ann__2 [(ErlangMap map_0), (ErlangMap map_2)]
  | (DM.Just livein_1) <- (Map.lookup (ErlangAtom "live_in") map_0)
  , (DM.Just liveout_3) <-
      (Map.lookup (ErlangAtom "live_out") map_2) =
  ErlangMap
    (Map.fromFoldable
       [DT.Tuple (ErlangAtom "live_in") livein_1,
        DT.Tuple (ErlangAtom "live_out") liveout_3])
erlps__merge_ann__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__merge_ann__2 args =
  EXC.badarity (ErlangFun 2 erlps__merge_ann__2) args

erlps__swap_instrs__2 :: ErlangFun
erlps__swap_instrs__2 [(ErlangTuple [(ErlangAtom "i"),
                                     (ErlangMap map_0), i_2]),
                       (ErlangTuple [(ErlangAtom "i"), (ErlangMap map_3), j_6])]
  | (DM.Just live1_1) <- (Map.lookup (ErlangAtom "live_in") map_0)
  , (DM.Just live3_5) <- (Map.lookup (ErlangAtom "live_out") map_3)
  , (DM.Just live2_4) <-
      (Map.lookup (ErlangAtom "live_in") map_3) =
  let   
    writesi_9 =
      BIF.do_remote_fun_call "Ordsets" "erlps__subtract__2"
        [live2_4, live1_1]
  in let matchExpr_13 = erlps__attributes__1 [i_2]
  in
    case matchExpr_13 of
      (ErlangMap map_11) | (DM.Just readsi_12) <-
                             (Map.lookup (ErlangAtom "read") map_11) ->
        let   
          arg_15 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__2"
              [live3_5, readsi_12]
        in let
          readsj_18 =
            BIF.do_remote_fun_call "Ordsets" "erlps__subtract__2"
              [live2_4, arg_15]
        in let
          arg_19 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__1"
              [ErlangCons live1_1
                 (ErlangCons live2_4 (ErlangCons live3_5 ErlangEmptyList))]
        in let
          arg_27 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__2"
              [writesi_9, readsj_18]
        in let
          live2__30 =
            BIF.do_remote_fun_call "Ordsets" "erlps__subtract__2"
              [arg_19, arg_27]
        in let
          tup_el_33 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "live_in") live1_1,
                  DT.Tuple (ErlangAtom "live_out") live2__30])
        in let tup_el_31 = ErlangTuple [ErlangAtom "i", tup_el_33, j_6]
        in let
          tup_el_41 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "live_in") live2__30,
                  DT.Tuple (ErlangAtom "live_out") live3_5])
        in let tup_el_39 = ErlangTuple [ErlangAtom "i", tup_el_41, i_2]
        in ErlangTuple [tup_el_31, tup_el_39]
      _ -> EXC.badmatch matchExpr_13
erlps__swap_instrs__2 [arg_47, arg_48] = EXC.function_clause unit
erlps__swap_instrs__2 args =
  EXC.badarity (ErlangFun 2 erlps__swap_instrs__2) args

erlps__live_in__2 :: ErlangFun
erlps__live_in__2 [(ErlangTuple [(ErlangAtom "store"), _]), _] =
  ErlangAtom "true"
erlps__live_in__2 [r_0, (ErlangMap map_1)]
  | (DM.Just livein_2) <-
      (Map.lookup (ErlangAtom "live_in") map_1) =
  BIF.do_remote_fun_call "Ordsets" "erlps__is_element__2"
    [r_0, livein_2]
erlps__live_in__2 [r_0,
                   (ErlangTuple [(ErlangAtom "i"), ann_1, _])]
  =
  erlps__live_in__2 [r_0, ann_1]
erlps__live_in__2 [r_0,
                   (ErlangCons i_1@(ErlangTuple [(ErlangAtom "i"), _, _]) _)]
  =
  erlps__live_in__2 [r_0, i_1]
erlps__live_in__2 [r_0,
                   (ErlangCons (ErlangTuple [(ErlangAtom "switch"), a_1, _,
                                             alts_2, def_3]) _)]
  =
  let lop_4 = BIF.erlang__op_eq [r_0, a_1]
  in
    case lop_4 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") ->
        let
          arg_7 =
            ErlangFun 1
              (let
                 lambda_8 [code_10] = erlps__live_in__2 [r_0, code_10]
                 lambda_8 [arg_9] = EXC.function_clause unit
                 lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
               in lambda_8)
        in
          BIF.do_remote_fun_call "Lists" "erlps__any__2"
            [arg_7, ErlangCons def_3 alts_2]
      _ -> EXC.badarg1 lop_4
erlps__live_in__2 [_, (ErlangAtom "missing")] =
  ErlangAtom "false"
erlps__live_in__2 [_, (ErlangEmptyList)] = ErlangAtom "false"
erlps__live_in__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__live_in__2 args =
  EXC.badarity (ErlangFun 2 erlps__live_in__2) args

erlps__live_out__2 :: ErlangFun
erlps__live_out__2 [(ErlangTuple [(ErlangAtom "store"), _]), _] =
  ErlangAtom "true"
erlps__live_out__2 [r_0, (ErlangMap map_1)]
  | (DM.Just liveout_2) <-
      (Map.lookup (ErlangAtom "live_out") map_1) =
  BIF.do_remote_fun_call "Ordsets" "erlps__is_element__2"
    [r_0, liveout_2]
erlps__live_out__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__live_out__2 args =
  EXC.badarity (ErlangFun 2 erlps__live_out__2) args

erlps__simplify__2 :: ErlangFun
erlps__simplify__2 [(ErlangEmptyList), _] = ErlangEmptyList
erlps__simplify__2 [(ErlangAtom "missing"), _] =
  ErlangAtom "missing"
erlps__simplify__2 [(ErlangCons i_0 code_1), options_2] =
  let    arg_3 = erlps__simpl_s__2 [i_0, options_2]
  in let arg_6 = erlps__simplify__2 [code_1, options_2]
  in erlps__simpl_top__3 [arg_3, arg_6, options_2]
erlps__simplify__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__simplify__2 args =
  EXC.badarity (ErlangFun 2 erlps__simplify__2) args

erlps__simpl_s__2 :: ErlangFun
erlps__simpl_s__2 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                 type_1, alts_2, def_3]),
                   options_4]
  =
  let   
    tup_el_8 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__simplify__2 [lc_11, options_4]
           in ErlangCons lcRet_12 ErlangEmptyList)
        alts_2
  in let tup_el_15 = erlps__simplify__2 [def_3, options_4]
  in
    ErlangTuple
      [ErlangAtom "switch", arg_0, type_1, tup_el_8, tup_el_15]
erlps__simpl_s__2 [i_0, _] = i_0
erlps__simpl_s__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__simpl_s__2 args =
  EXC.badarity (ErlangFun 2 erlps__simpl_s__2) args

erlps__simpl_top__3 :: ErlangFun
erlps__simpl_top__3 [i_0, code_1, options_2] =
  let arg_3 = toErl 5000
  in erlps__simpl_top__4 [arg_3, i_0, code_1, options_2]
erlps__simpl_top__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__simpl_top__3 args =
  EXC.badarity (ErlangFun 3 erlps__simpl_top__3) args

erlps__simpl_top__4 :: ErlangFun
erlps__simpl_top__4 [(ErlangInt num_0), i_1, code_2, _options_3]
  | (ErlangInt num_0) == (toErl 0) =
  let
    arg_4 =
      ErlangTuple [ErlangAtom "optimizer_out_of_fuel", i_1, code_2]
  in erlps__code_error__1 [arg_4]
erlps__simpl_top__4 [fuel_0, i_1, code_2, options_3] =
  let arg_5 = erlps__rules__0 []
  in erlps__apply_rules__5 [fuel_0, arg_5, i_1, code_2, options_3]
erlps__simpl_top__4 [arg_9, arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__simpl_top__4 args =
  EXC.badarity (ErlangFun 4 erlps__simpl_top__4) args

erlps__apply_rules__5 :: ErlangFun
erlps__apply_rules__5 [fuel_0, rules_1, i_2, code_3, options_4] =
  let   
    cons_16 =
      ErlangFun 2
        (let
           lambda_5 [x_8, xs_9] =
             let    rop_12 = toErl 1
             in let arg_10 = BIF.erlang__op_minus [fuel_0, rop_12]
             in erlps__simpl_top__4 [arg_10, x_8, xs_9, options_4]
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let
    case_17 = erlps__apply_rules_once__3 [rules_1, i_2, code_3]
  in
    case case_17 of
      (ErlangAtom "false") -> ErlangCons i_2 code_3
      (ErlangTuple [rname_23, new_24, rest_25]) ->
        let   
          case_26 = erlps__is_debug__2 [ErlangAtom "opt_rules", options_4]
        in let
          _ =
            case case_26 of
              (ErlangAtom "true") ->
                let    arg_32 = BIF.erlang__op_append [new_24, rest_25]
                in let
                  matchExpr_37 =
                    erlps__drop_common_suffix__2 [ErlangCons i_2 code_3, arg_32]
                in
                  case matchExpr_37 of
                    (ErlangTuple [oldcode_35, newcode_36]) ->
                      let
                        arg_40 =
                          ErlangFun 0
                            (let
                               lambda_41 [] =
                                 let   
                                   arg_42 = toErl "  Applied ~p:\n~s  ==>\n~s\n"
                                 in let arg_47 = toErl "    "
                                 in let
                                   head_46 =
                                     erlps__pp_ann__2 [arg_47, oldcode_35]
                                 in let arg_51 = toErl "    "
                                 in let
                                   head_50 =
                                     erlps__pp_ann__2 [arg_51, newcode_36]
                                 in
                                   BIF.do_remote_fun_call "Erlang.Io"
                                     "erlps__format__2"
                                     [arg_42,
                                      ErlangCons rname_23
                                        (ErlangCons head_46
                                           (ErlangCons head_50
                                              ErlangEmptyList))]
                               lambda_41 [] = EXC.function_clause unit
                               lambda_41 args =
                                 EXC.badarity (ErlangFun 0 lambda_41) args
                             in lambda_41)
                      in
                        erlps__debug__3
                          [ErlangAtom "opt_rules", options_4, arg_40]
                    _ -> EXC.badmatch matchExpr_37
              (ErlangAtom "false") -> ErlangAtom "ok"
              something_else -> EXC.case_clause something_else
        in
          BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
            [cons_16, rest_25, new_24]
      something_else -> EXC.case_clause something_else
erlps__apply_rules__5 [arg_57, arg_58, arg_59, arg_60, arg_61] =
  EXC.function_clause unit
erlps__apply_rules__5 args =
  EXC.badarity (ErlangFun 5 erlps__apply_rules__5) args

erlps__apply_rules_once__3 :: ErlangFun
erlps__apply_rules_once__3 [(ErlangEmptyList), _, _] =
  ErlangAtom "false"
erlps__apply_rules_once__3 [(ErlangCons (ErlangTuple [rname_0,
                                                      rule_1]) rules_2),
                            i_3, code_4]
  =
  let
    case_5 =
      BIF.erlang__apply__2
        [rule_1, ErlangCons i_3 (ErlangCons code_4 ErlangEmptyList)]
  in
    case case_5 of
      (ErlangAtom "false") ->
        erlps__apply_rules_once__3 [rules_2, i_3, code_4]
      (ErlangTuple [new_12, rest_13]) ->
        ErlangTuple [rname_0, new_12, rest_13]
      something_else -> EXC.case_clause something_else
erlps__apply_rules_once__3 [arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__apply_rules_once__3 args =
  EXC.badarity (ErlangFun 3 erlps__apply_rules_once__3) args

erlps__merge_rules__0 :: ErlangFun
erlps__merge_rules__0 [] =
  let    tup_el_2 = ErlangFun 2 erlps__r_push_consume__2
  in let
    head_0 = ErlangTuple [ErlangAtom "r_push_consume", tup_el_2]
  in let tup_el_6 = ErlangFun 2 erlps__r_one_shot_var__2
  in let
    head_4 = ErlangTuple [ErlangAtom "r_one_shot_var", tup_el_6]
  in let tup_el_10 = ErlangFun 2 erlps__r_write_to_dead_var__2
  in let
    head_8 =
      ErlangTuple [ErlangAtom "r_write_to_dead_var", tup_el_10]
  in let tup_el_14 = ErlangFun 2 erlps__r_inline_switch_target__2
  in let
    head_12 =
      ErlangTuple [ErlangAtom "r_inline_switch_target", tup_el_14]
  in
    ErlangCons head_0
      (ErlangCons head_4
         (ErlangCons head_8 (ErlangCons head_12 ErlangEmptyList)))
erlps__merge_rules__0 args =
  EXC.badarity (ErlangFun 0 erlps__merge_rules__0) args

erlps__rules__0 :: ErlangFun
erlps__rules__0 [] =
  let    lop_0 = erlps__merge_rules__0 []
  in let tup_el_4 = ErlangFun 2 erlps__r_swap_push__2
  in let head_2 = ErlangTuple [ErlangAtom "r_swap_push", tup_el_4]
  in let tup_el_8 = ErlangFun 2 erlps__r_swap_pop__2
  in let head_6 = ErlangTuple [ErlangAtom "r_swap_pop", tup_el_8]
  in let tup_el_12 = ErlangFun 2 erlps__r_swap_write__2
  in let
    head_10 = ErlangTuple [ErlangAtom "r_swap_write", tup_el_12]
  in let tup_el_16 = ErlangFun 2 erlps__r_constant_propagation__2
  in let
    head_14 =
      ErlangTuple [ErlangAtom "r_constant_propagation", tup_el_16]
  in let
    tup_el_20 = ErlangFun 2 erlps__r_prune_impossible_branches__2
  in let
    head_18 =
      ErlangTuple [ErlangAtom "r_prune_impossible_branches", tup_el_20]
  in let
    tup_el_24 = ErlangFun 2 erlps__r_single_successful_branch__2
  in let
    head_22 =
      ErlangTuple [ErlangAtom "r_single_successful_branch", tup_el_24]
  in let tup_el_28 = ErlangFun 2 erlps__r_inline_store__2
  in let
    head_26 = ErlangTuple [ErlangAtom "r_inline_store", tup_el_28]
  in let tup_el_32 = ErlangFun 2 erlps__r_float_switch_body__2
  in let
    head_30 =
      ErlangTuple [ErlangAtom "r_float_switch_body", tup_el_32]
  in
    BIF.erlang__op_append
      [lop_0,
       ErlangCons head_2
         (ErlangCons head_6
            (ErlangCons head_10
               (ErlangCons head_14
                  (ErlangCons head_18
                     (ErlangCons head_22
                        (ErlangCons head_26
                           (ErlangCons head_30 ErlangEmptyList)))))))]
erlps__rules__0 args =
  EXC.badarity (ErlangFun 0 erlps__rules__0) args

erlps__r_push_consume__2 :: ErlangFun
erlps__r_push_consume__2 [(ErlangTuple [(ErlangAtom "i"), ann1_0,
                                        (ErlangTuple [(ErlangAtom "STORE"),
                                                      (ErlangTuple [(ErlangAtom "stack"),
                                                                    (ErlangInt num_1)]),
                                                      a_2])]),
                          code_3]
  | (ErlangInt num_1) == (toErl 0) =
  let arg_6 = toErl 0
  in
    erlps__inline_push__5
      [ann1_0, a_2, arg_6, code_3, ErlangEmptyList]
erlps__r_push_consume__2 [(ErlangTuple [(ErlangAtom "i"), ann1_0,
                                        i_1]),
                          (ErlangCons (ErlangTuple [(ErlangAtom "i"), ann2_2,
                                                    (ErlangTuple [(ErlangAtom "STORE"),
                                                                  r_3,
                                                                  (ErlangTuple [(ErlangAtom "stack"),
                                                                                (ErlangInt num_4)])])]) code_5)]
  | (ErlangInt num_4) == (toErl 0) =
  let    case_7 = erlps__op_view__1 [i_1]
  in let
    lop_6 =
      case case_7 of
        (ErlangTuple [_,
                      (ErlangTuple [(ErlangAtom "stack"), (ErlangInt num_9)]),
                      _]) | (ErlangInt num_9) == (toErl 0) ->
          ErlangAtom "true"
        _ -> ErlangAtom "false"
  in let
    ispush_12 =
      case lop_6 of
        (ErlangAtom "true") -> ErlangAtom "true"
        (ErlangAtom "false") ->
          case i_1 of
            (ErlangTuple [(ErlangAtom "VARIANT"),
                          (ErlangTuple [(ErlangAtom "stack"),
                                        (ErlangInt num_11)]),
                          _, _, _]) | (ErlangInt num_11) == (toErl 0) ->
              ErlangAtom "true"
            _ -> ErlangAtom "false"
        _ -> EXC.badarg1 lop_6
  in
    case ErlangAtom "true" of
      _ | (==) (ErlangAtom "true") ispush_12 ->
        let    tup_el_16 = erlps__merge_ann__2 [ann1_0, ann2_2]
        in let arg_20 = toErl 2
        in let tup_el_19 = BIF.erlang__setelement__3 [arg_20, i_1, r_3]
        in let
          head_14 = ErlangTuple [ErlangAtom "i", tup_el_16, tup_el_19]
        in ErlangTuple [ErlangCons head_14 ErlangEmptyList, code_5]
      _ -> ErlangAtom "false"
erlps__r_push_consume__2 [_, _] = ErlangAtom "false"
erlps__r_push_consume__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_push_consume__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_push_consume__2) args

erlps__inline_push__5 :: ErlangFun
erlps__inline_push__5 [ann_0, arg_1, stack_2,
                       (ErlangCons ai_3@(ErlangTuple [(ErlangAtom "i"), _,
                                                      (ErlangAtom "switch_body")]) code_4),
                       acc_5]
  =
  let    tup_el_13 = toErl 0
  in let tup_el_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "STORE", tup_el_11, arg_1]
  in let arg_6 = ErlangTuple [ErlangAtom "i", ann_0, tup_el_9]
  in let matchExpr_18 = erlps__swap_instrs__2 [arg_6, ai_3]
  in
    case matchExpr_18 of
      (ErlangTuple [ai1_16,
                    (ErlangTuple [(ErlangAtom "i"), ann1_17, _])]) ->
        erlps__inline_push__5
          [ann1_17, arg_1, stack_2, code_4, ErlangCons ai1_16 acc_5]
      _ -> EXC.badmatch matchExpr_18
erlps__inline_push__5 [ann1_0, arg_1, stack_2,
                       (ErlangCons ai_5@(ErlangTuple [(ErlangAtom "i"), ann2_3,
                                                      i_4]) code_6),
                       acc_7]
  =
  let case_8 = erlps__op_view__1 [i_4]
  in
    case case_8 of
      (ErlangTuple [op_10, r_11, as_12]) ->
        let   
          arg_13 =
            flmap
              (\ lc_16 ->
                 case lc_16 of
                   (ErlangTuple [(ErlangAtom "stack"),
                                 (ErlangInt num_15)]) | (ErlangInt num_15) ==
                                                          (toErl 0) ->
                     let    tup_el_19 = toErl 0
                     in let
                       lcRet_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
                     in ErlangCons lcRet_17 ErlangEmptyList
                   _ -> ErlangEmptyList)
              as_12
        in let consumes_20 = BIF.erlang__length__1 [arg_13]
        in let tup_el_25 = toErl 0
        in let lop_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
        in let cond_22 = BIF.erlang__op_eq [lop_23, r_11]
        in let
          arg_21 =
            case cond_22 of
              (ErlangAtom "true") ->
                let    tup_el_29 = toErl 0
                in let lcRet_27 = ErlangTuple [ErlangAtom "stack", tup_el_29]
                in ErlangCons lcRet_27 ErlangEmptyList
              _ -> ErlangEmptyList
        in let produces_30 = BIF.erlang__length__1 [arg_21]
        in let case_31 = BIF.erlang__op_greater [consumes_20, stack_2]
        in
          case case_31 of
            (ErlangAtom "true") ->
              let matchExpr_38 = erlps__split_stack_arg__2 [stack_2, as_12]
              in
                case matchExpr_38 of
                  (ErlangTuple [as0_36, as1_37]) ->
                    let    tup_el_41 = erlps__merge_ann__2 [ann1_0, ann2_3]
                    in let
                      rop_49 =
                        BIF.erlang__op_append
                          [ErlangCons arg_1 ErlangEmptyList, as1_37]
                    in let arg_47 = BIF.erlang__op_append [as0_36, rop_49]
                    in let
                      tup_el_44 = erlps__from_op_view__3 [op_10, r_11, arg_47]
                    in let
                      head_39 =
                        ErlangTuple [ErlangAtom "i", tup_el_41, tup_el_44]
                    in let
                      tup_el_56 =
                        BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                          [ErlangCons head_39 acc_7]
                    in ErlangTuple [tup_el_56, code_6]
                  _ -> EXC.badmatch matchExpr_38
            (ErlangAtom "false") | weakNEq arg_1 r_11 ->
              let    tup_el_66 = toErl 0
              in let tup_el_64 = ErlangTuple [ErlangAtom "stack", tup_el_66]
              in let
                tup_el_62 = ErlangTuple [ErlangAtom "STORE", tup_el_64, arg_1]
              in let arg_59 = ErlangTuple [ErlangAtom "i", ann1_0, tup_el_62]
              in let matchExpr_71 = erlps__swap_instrs__2 [arg_59, ai_5]
              in
                case matchExpr_71 of
                  (ErlangTuple [ai1_69,
                                (ErlangTuple [(ErlangAtom "i"), ann1b_70,
                                              _])]) ->
                    let    lop_75 = BIF.erlang__op_plus [stack_2, produces_30]
                    in let arg_74 = BIF.erlang__op_minus [lop_75, consumes_20]
                    in
                      erlps__inline_push__5
                        [ann1b_70, arg_1, arg_74, code_6,
                         ErlangCons ai1_69 acc_7]
                  _ -> EXC.badmatch matchExpr_71
            (ErlangAtom "false") -> ErlangAtom "false"
            something_else -> EXC.case_clause something_else
      _ -> ErlangAtom "false"
erlps__inline_push__5 [_, _, _, _, _] = ErlangAtom "false"
erlps__inline_push__5 [arg_0, arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__inline_push__5 args =
  EXC.badarity (ErlangFun 5 erlps__inline_push__5) args

erlps__split_stack_arg__2 :: ErlangFun
erlps__split_stack_arg__2 [n_0, as_1] =
  erlps__split_stack_arg__3 [n_0, as_1, ErlangEmptyList]
erlps__split_stack_arg__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__split_stack_arg__2 args =
  EXC.badarity (ErlangFun 2 erlps__split_stack_arg__2) args

erlps__split_stack_arg__3 :: ErlangFun
erlps__split_stack_arg__3 [(ErlangInt num_0),
                           (ErlangCons (ErlangTuple [(ErlangAtom "stack"),
                                                     (ErlangInt num_1)]) as_2),
                           acc_3]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 0) =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_3]
  in ErlangTuple [tup_el_4, as_2]
erlps__split_stack_arg__3 [n_0, (ErlangCons a_1 as_2), acc_3] =
  let
    n1_10 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") ==
              (falsifyErrors
                 (\ _ ->
                    let    tup_el_7 = toErl 0
                    in let rop_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
                    in BIF.erlang__op_eq [a_1, rop_5])) ->
          let rop_9 = toErl 1
          in BIF.erlang__op_minus [n_0, rop_9]
        _ -> n_0
  in erlps__split_stack_arg__3 [n1_10, as_2, ErlangCons a_1 acc_3]
erlps__split_stack_arg__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__split_stack_arg__3 args =
  EXC.badarity (ErlangFun 3 erlps__split_stack_arg__3) args

erlps__r_swap_push__2 :: ErlangFun
erlps__r_swap_push__2 [push_1@(ErlangTuple [(ErlangAtom "i"), _,
                                            pushi_0]),
                       (ErlangCons i_2 code_3)]
  =
  let case_4 = erlps__op_view__1 [pushi_0]
  in
    case case_4 of
      (ErlangTuple [_,
                    (ErlangTuple [(ErlangAtom "stack"), (ErlangInt num_6)]),
                    _]) | (ErlangInt num_6) == (toErl 0) ->
        let case_7 = erlps__independent__2 [push_1, i_2]
        in
          case case_7 of
            (ErlangAtom "true") ->
              let matchExpr_14 = erlps__swap_instrs__2 [push_1, i_2]
              in
                case matchExpr_14 of
                  (ErlangTuple [i1_12, push1_13]) ->
                    ErlangTuple
                      [ErlangCons i1_12 (ErlangCons push1_13 ErlangEmptyList),
                       code_3]
                  _ -> EXC.badmatch matchExpr_14
            (ErlangAtom "false") -> ErlangAtom "false"
            something_else -> EXC.case_clause something_else
      _ -> ErlangAtom "false"
erlps__r_swap_push__2 [_, _] = ErlangAtom "false"
erlps__r_swap_push__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__r_swap_push__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_swap_push__2) args

erlps__r_swap_pop__2 :: ErlangFun
erlps__r_swap_pop__2 [ia_1@(ErlangTuple [(ErlangAtom "i"), _,
                                         i_0]),
                      (ErlangCons ja_3@(ErlangTuple [(ErlangAtom "i"), _,
                                                     j_2]) code_4)]
  =
  let case_5 = erlps__independent__2 [ia_1, ja_3]
  in
    case case_5 of
      (ErlangAtom "true") ->
        let    tup_el_9 = erlps__op_view__1 [i_0]
        in let tup_el_11 = erlps__op_view__1 [j_2]
        in let case_8 = ErlangTuple [tup_el_9, tup_el_11]
        in
          case case_8 of
            (ErlangTuple [(ErlangAtom "false"), _]) -> ErlangAtom "false"
            (ErlangTuple [_, (ErlangAtom "false")]) -> ErlangAtom "false"
            (ErlangTuple [(ErlangTuple [_, ir_13, ias_14]),
                          (ErlangTuple [_, rj_15, jas_16])]) ->
              let    tup_el_20 = toErl 0
              in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
              in let
                op_arg_17 =
                  BIF.lists__member__2 [arg_18, ErlangCons ir_13 ias_14]
              in let nonstacki_24 = BIF.erlang__not__1 [op_arg_17]
              in let tup_el_29 = toErl 0
              in let rop_27 = ErlangTuple [ErlangAtom "stack", tup_el_29]
              in let lop_25 = BIF.erlang__op_neq [rj_15, rop_27]
              in let
                popj_34 =
                  case lop_25 of
                    (ErlangAtom "false") -> ErlangAtom "false"
                    (ErlangAtom "true") ->
                      let    tup_el_32 = toErl 0
                      in let
                        arg_30 = ErlangTuple [ErlangAtom "stack", tup_el_32]
                      in BIF.lists__member__2 [arg_30, jas_16]
                    _ -> EXC.badarg1 lop_25
              in let
                case_35 =
                  case nonstacki_24 of
                    (ErlangAtom "false") -> ErlangAtom "false"
                    (ErlangAtom "true") -> popj_34
                    _ -> EXC.badarg1 nonstacki_24
              in
                case case_35 of
                  (ErlangAtom "false") -> ErlangAtom "false"
                  (ErlangAtom "true") ->
                    let matchExpr_41 = erlps__swap_instrs__2 [ia_1, ja_3]
                    in
                      case matchExpr_41 of
                        (ErlangTuple [ja1_39, ia1_40]) ->
                          ErlangTuple
                            [ErlangCons ja1_39
                               (ErlangCons ia1_40 ErlangEmptyList),
                             code_4]
                        _ -> EXC.badmatch matchExpr_41
                  something_else -> EXC.case_clause something_else
            something_else -> EXC.case_clause something_else
      (ErlangAtom "false") -> ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__r_swap_pop__2 [_, _] = ErlangAtom "false"
erlps__r_swap_pop__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__r_swap_pop__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_swap_pop__2) args

erlps__r_swap_write__2 :: ErlangFun
erlps__r_swap_write__2 [i_0@(ErlangTuple [(ErlangAtom "i"), _,
                                          _]),
                        (ErlangCons j_1 code_2)]
  =
  let    tup_el_4 = erlps__var_writes__1 [i_0]
  in let tup_el_6 = erlps__independent__2 [i_0, j_1]
  in let case_3 = ErlangTuple [tup_el_4, tup_el_6]
  in
    case case_3 of
      (ErlangTuple [(ErlangCons _ (ErlangEmptyList)),
                    (ErlangAtom "true")]) ->
        let matchExpr_13 = erlps__swap_instrs__2 [i_0, j_1]
        in
          case matchExpr_13 of
            (ErlangTuple [j1_11, i1_12]) ->
              erlps__r_swap_write__3
                [ErlangCons j1_11 ErlangEmptyList, i1_12, code_2]
            _ -> EXC.badmatch matchExpr_13
      _ -> ErlangAtom "false"
erlps__r_swap_write__2 [_, _] = ErlangAtom "false"
erlps__r_swap_write__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__r_swap_write__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_swap_write__2) args

erlps__r_swap_write__3 :: ErlangFun
erlps__r_swap_write__3 [pre_0, i_1,
                        (ErlangCons j_2@(ErlangTuple [(ErlangAtom "i"), _,
                                                      (ErlangAtom "switch_body")]) code_3)]
  =
  let matchExpr_8 = erlps__swap_instrs__2 [i_1, j_2]
  in
    case matchExpr_8 of
      (ErlangTuple [j1_6, i1_7]) ->
        erlps__r_swap_write__3 [ErlangCons j1_6 pre_0, i1_7, code_3]
      _ -> EXC.badmatch matchExpr_8
erlps__r_swap_write__3 [pre_0, i_1,
                        code0_4@(ErlangCons j_2 code_3)]
  =
  let    arg_6 = erlps__merge_rules__0 []
  in let case_5 = erlps__apply_rules_once__3 [arg_6, i_1, code0_4]
  in
    case case_5 of
      (ErlangTuple [_rule_9, new_10, rest_11]) ->
        let   
          lop_13 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [pre_0]
        in let tup_el_12 = BIF.erlang__op_append [lop_13, new_10]
        in ErlangTuple [tup_el_12, rest_11]
      (ErlangAtom "false") ->
        let case_17 = erlps__independent__2 [i_1, j_2]
        in
          case case_17 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              let matchExpr_24 = erlps__swap_instrs__2 [i_1, j_2]
              in
                case matchExpr_24 of
                  (ErlangTuple [j1_22, i1_23]) ->
                    erlps__r_swap_write__3
                      [ErlangCons j1_22 pre_0, i1_23, code_3]
                  _ -> EXC.badmatch matchExpr_24
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__r_swap_write__3 [_, _, _] = ErlangAtom "false"
erlps__r_swap_write__3 [arg_0, arg_1, arg_2] =
  EXC.function_clause unit
erlps__r_swap_write__3 args =
  EXC.badarity (ErlangFun 3 erlps__r_swap_write__3) args

erlps__r_constant_propagation__2 :: ErlangFun
erlps__r_constant_propagation__2 [cons_4@(ErlangTuple [(ErlangAtom "i"),
                                                       ann1_0,
                                                       (ErlangTuple [(ErlangAtom "CONS"),
                                                                     r_1, x_2,
                                                                     xs_3])]),
                                  (ErlangCons (ErlangTuple [(ErlangAtom "i"),
                                                            ann_5,
                                                            (ErlangTuple [(ErlangAtom "IS_NIL"),
                                                                          s_6,
                                                                          r_7])]) code_8)]
  | r_7 == r_1 =
  let   
    tup_el_14 =
      ErlangTuple [ErlangAtom "immediate", ErlangAtom "false"]
  in let
    tup_el_11 = ErlangTuple [ErlangAtom "STORE", s_6, tup_el_14]
  in let store_17 = ErlangTuple [ErlangAtom "i", ann_5, tup_el_11]
  in let
    cons1_29 =
      case r_1 of
        (ErlangTuple [(ErlangAtom "stack"),
                      (ErlangInt num_19)]) | (ErlangInt num_19) == (toErl 0) ->
          let    tup_el_26 = toErl 9999
          in let tup_el_24 = ErlangTuple [ErlangAtom "var", tup_el_26]
          in let
            tup_el_22 = ErlangTuple [ErlangAtom "CONS", tup_el_24, x_2, xs_3]
          in ErlangTuple [ErlangAtom "i", ann1_0, tup_el_22]
        _ -> cons_4
  in
    ErlangTuple
      [ErlangCons cons1_29 (ErlangCons store_17 ErlangEmptyList),
       code_8]
erlps__r_constant_propagation__2 [nil_2@(ErlangTuple [(ErlangAtom "i"),
                                                      ann1_0,
                                                      (ErlangTuple [(ErlangAtom "NIL"),
                                                                    r_1])]),
                                  (ErlangCons (ErlangTuple [(ErlangAtom "i"),
                                                            ann_3,
                                                            (ErlangTuple [(ErlangAtom "IS_NIL"),
                                                                          s_4,
                                                                          r_5])]) code_6)]
  | r_5 == r_1 =
  let   
    tup_el_12 =
      ErlangTuple [ErlangAtom "immediate", ErlangAtom "true"]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "STORE", s_4, tup_el_12]
  in let store_15 = ErlangTuple [ErlangAtom "i", ann_3, tup_el_9]
  in let
    nil1_25 =
      case r_1 of
        (ErlangTuple [(ErlangAtom "stack"),
                      (ErlangInt num_17)]) | (ErlangInt num_17) == (toErl 0) ->
          let    tup_el_24 = toErl 9999
          in let tup_el_22 = ErlangTuple [ErlangAtom "var", tup_el_24]
          in let tup_el_20 = ErlangTuple [ErlangAtom "NIL", tup_el_22]
          in ErlangTuple [ErlangAtom "i", ann1_0, tup_el_20]
        _ -> nil_2
  in
    ErlangTuple
      [ErlangCons nil1_25 (ErlangCons store_15 ErlangEmptyList),
       code_6]
erlps__r_constant_propagation__2 [(ErlangTuple [(ErlangAtom "i"),
                                                ann_0, i_1]),
                                  code_2]
  =
  let case_3 = erlps__op_view__1 [i_1]
  in
    case case_3 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangTuple [op_5, r_6, as_7]) ->
        let   
          vs_12 =
            flmap
              (\ lc_10 ->
                 case lc_10 of
                   (ErlangTuple [(ErlangAtom "immediate"), v_9]) ->
                     ErlangCons v_9 ErlangEmptyList
                   _ -> ErlangEmptyList)
              as_7
        in let lop_14 = BIF.erlang__length__1 [vs_12]
        in let rop_16 = BIF.erlang__length__1 [as_7]
        in let case_13 = BIF.erlang__op_eq [lop_14, rop_16]
        in
          case case_13 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              let case_18 = erlps__eval_op__2 [op_5, vs_12]
              in
                case case_18 of
                  (ErlangAtom "no_eval") -> ErlangAtom "false"
                  v_21 ->
                    let   
                      tup_el_29 = ErlangTuple [ErlangAtom "immediate", v_21]
                    in let
                      tup_el_26 =
                        ErlangTuple [ErlangAtom "STORE", r_6, tup_el_29]
                    in let
                      head_23 = ErlangTuple [ErlangAtom "i", ann_0, tup_el_26]
                    in ErlangTuple [ErlangCons head_23 ErlangEmptyList, code_2]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__r_constant_propagation__2 [_, _] = ErlangAtom "false"
erlps__r_constant_propagation__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_constant_propagation__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_constant_propagation__2) args

erlps__eval_op__2 :: ErlangFun
erlps__eval_op__2 [(ErlangAtom "ADD"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | (isEInt x_0) && (isEInt y_1) =
  BIF.erlang__op_plus [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "SUB"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | (isEInt x_0) && (isEInt y_1) =
  BIF.erlang__op_minus [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "MUL"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | (isEInt x_0) && (isEInt y_1) =
  BIF.erlang__op_mult [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "DIV"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | ((isEInt x_0) && (isEInt y_1)) && (weakNEq y_1 (toErl 0)) =
  BIF.erlang__op_div_strict [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "MOD"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | ((isEInt x_0) && (isEInt y_1)) && (weakNEq y_1 (toErl 0)) =
  BIF.erlang__op_rem_strict [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "POW"),
                   (ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  ErlangAtom "no_eval"
erlps__eval_op__2 [(ErlangAtom "LT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_lesser [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "GT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_greater [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "EQ"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_exactEq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "ELT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_lesserEq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "EGT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_greaterEq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "NEQ"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_exactNeq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "NOT"),
                   (ErlangCons (ErlangAtom "true") (ErlangEmptyList))]
  =
  ErlangAtom "false"
erlps__eval_op__2 [(ErlangAtom "NOT"),
                   (ErlangCons (ErlangAtom "false") (ErlangEmptyList))]
  =
  ErlangAtom "true"
erlps__eval_op__2 [_, _] = ErlangAtom "no_eval"
erlps__eval_op__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__eval_op__2 args =
  EXC.badarity (ErlangFun 2 erlps__eval_op__2) args

erlps__r_prune_impossible_branches__2 :: ErlangFun
erlps__r_prune_impossible_branches__2 [(ErlangTuple [(ErlangAtom "switch"),
                                                     (ErlangTuple [(ErlangAtom "immediate"),
                                                                   v_0]),
                                                     type_1, alts_2,
                                                     (ErlangAtom "missing")]),
                                       code_3]
  =
  let case_4 = erlps__pick_branch__3 [type_1, v_0, alts_2]
  in
    case case_4 of
      (ErlangAtom "false") -> ErlangAtom "false"
      alt_8 -> ErlangTuple [alt_8, code_3]
erlps__r_prune_impossible_branches__2 [(ErlangTuple [(ErlangAtom "switch"),
                                                     (ErlangTuple [(ErlangAtom "immediate"),
                                                                   v_0]),
                                                     (ErlangAtom "boolean"),
                                                     alts_3@(ErlangCons false_1 (ErlangCons true_2 (ErlangEmptyList))),
                                                     def_4]),
                                       code_5]
  | (weakEq v_0 (ErlangAtom "true")) ||
      (weakEq v_0 (ErlangAtom "false")) =
  let   
    head_6 =
      case ErlangAtom "true" of
        _ | (==) (ErlangAtom "true") v_0 -> ErlangAtom "missing"
        _ -> false_1
  in let
    head_8 =
      case ErlangAtom "true" of
        _ | (==) (ErlangAtom "true") v_0 -> true_2
        _ -> ErlangAtom "missing"
  in let
    case_11 =
      BIF.erlang__op_eq
        [alts_3, ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList)]
  in
    case case_11 of
      (ErlangAtom "true") -> ErlangAtom "false"
      (ErlangAtom "false") ->
        case ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList) of
          (ErlangCons (ErlangAtom "missing") (ErlangCons (ErlangAtom "missing") (ErlangEmptyList))) ->
            ErlangTuple [def_4, code_5]
          _ ->
            let    tup_el_20 = ErlangTuple [ErlangAtom "immediate", v_0]
            in let
              head_18 =
                ErlangTuple
                  [ErlangAtom "switch", tup_el_20, ErlangAtom "boolean",
                   ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList), def_4]
            in ErlangTuple [ErlangCons head_18 ErlangEmptyList, code_5]
      something_else -> EXC.case_clause something_else
erlps__r_prune_impossible_branches__2 [variant_2@(ErlangTuple [(ErlangAtom "i"),
                                                               _,
                                                               (ErlangTuple [(ErlangAtom "VARIANT"),
                                                                             r_0,
                                                                             (ErlangTuple [(ErlangAtom "immediate"),
                                                                                           _]),
                                                                             (ErlangTuple [(ErlangAtom "immediate"),
                                                                                           tag_1]),
                                                                             (ErlangTuple [(ErlangAtom "immediate"),
                                                                                           _])])]),
                                       (ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                                 r_3,
                                                                 type_4@(ErlangTuple [(ErlangAtom "variant"),
                                                                                      _]),
                                                                 alts_5,
                                                                 (ErlangAtom "missing")]) code_6)]
  | r_3 == r_0
  , isEInt tag_1 =
  let    rop_12 = toErl 1
  in let arg_10 = BIF.erlang__op_plus [tag_1, rop_12]
  in let
    tup_el_9 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_10, alts_5]
  in let case_7 = ErlangTuple [r_0, tup_el_9]
  in
    case case_7 of
      (ErlangTuple [_, (ErlangAtom "missing")]) ->
        let   
          alts1_17 =
            flmap
              (\ lc_15 ->
                 case lc_15 of
                   _ -> ErlangCons (ErlangAtom "missing") ErlangEmptyList)
              alts_5
        in let case_18 = BIF.erlang__op_eq [alts_5, alts1_17]
        in
          case case_18 of
            (ErlangAtom "true") -> ErlangAtom "false"
            (ErlangAtom "false") ->
              let
                head_24 =
                  ErlangTuple
                    [ErlangAtom "switch", r_0, type_4, alts1_17,
                     ErlangAtom "missing"]
              in
                ErlangTuple
                  [ErlangCons variant_2 (ErlangCons head_24 ErlangEmptyList),
                   code_6]
            something_else -> EXC.case_clause something_else
      (ErlangTuple [(ErlangTuple [(ErlangAtom "stack"),
                                  (ErlangInt num_32)]),
                    alt_33]) | (ErlangInt num_32) == (toErl 0) ->
        ErlangTuple [alt_33, code_6]
      (ErlangTuple [_, alt_36]) ->
        let case_37 = erlps__live_in__2 [r_0, alt_36]
        in
          case case_37 of
            (ErlangAtom "true") ->
              ErlangTuple [ErlangCons variant_2 alt_36, code_6]
            (ErlangAtom "false") -> ErlangTuple [alt_36, code_6]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__r_prune_impossible_branches__2 [_, _] = ErlangAtom "false"
erlps__r_prune_impossible_branches__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_prune_impossible_branches__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_prune_impossible_branches__2)
    args

erlps__pick_branch__3 :: ErlangFun
erlps__pick_branch__3 [(ErlangAtom "boolean"), v_0,
                       (ErlangCons false_1 (ErlangCons true_2 (ErlangEmptyList)))]
  | (weakEq v_0 (ErlangAtom "true")) ||
      (weakEq v_0 (ErlangAtom "false")) =
  let
    alt_3 =
      case ErlangAtom "true" of
        _ | (==) (ErlangAtom "true") v_0 -> true_2
        _ -> false_1
  in
    case alt_3 of
      (ErlangAtom "missing") -> ErlangAtom "false"
      _ -> alt_3
erlps__pick_branch__3 [_type_0, _v_1, _alts_2] =
  ErlangAtom "false"
erlps__pick_branch__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__pick_branch__3 args =
  EXC.badarity (ErlangFun 3 erlps__pick_branch__3) args

erlps__r_single_successful_branch__2 :: ErlangFun
erlps__r_single_successful_branch__2 [(ErlangTuple [(ErlangAtom "switch"),
                                                    r_0, type_1, alts_2,
                                                    def_3]),
                                      code_4]
  =
  let
    case_5 =
      erlps__push_code_out_of_switch__1 [ErlangCons def_3 alts_2]
  in
    case case_5 of
      (ErlangTuple [_, (ErlangAtom "none")]) -> ErlangAtom "false"
      (ErlangTuple [_, (ErlangAtom "many")]) -> ErlangAtom "false"
      (ErlangTuple [_,
                    (ErlangCons (ErlangTuple [(ErlangAtom "i"), _,
                                              (ErlangAtom "switch_body")]) (ErlangEmptyList))]) ->
        ErlangAtom "false"
      (ErlangTuple [(ErlangCons def1_9 alts1_10), pushedout_11]) ->
        let
          head_13 =
            ErlangTuple [ErlangAtom "switch", r_0, type_1, alts1_10, def1_9]
        in ErlangTuple [ErlangCons head_13 pushedout_11, code_4]
      something_else -> EXC.case_clause something_else
erlps__r_single_successful_branch__2 [_, _] = ErlangAtom "false"
erlps__r_single_successful_branch__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_single_successful_branch__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_single_successful_branch__2)
    args

erlps__push_code_out_of_switch__1 :: ErlangFun
erlps__push_code_out_of_switch__1 [(ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, ErlangAtom "none"]
erlps__push_code_out_of_switch__1 [(ErlangCons alt_0 alts_1)] =
  let matchExpr_5 = erlps__push_code_out_of_alt__1 [alt_0]
  in
    case matchExpr_5 of
      (ErlangTuple [alt1_3, pushedalt_4]) ->
        let matchExpr_9 = erlps__push_code_out_of_switch__1 [alts_1]
        in
          case matchExpr_9 of
            (ErlangTuple [alts1_7, pushedalts_8]) ->
              let    case_10 = ErlangTuple [pushedalt_4, pushedalts_8]
              in let
                pushed_13 =
                  case case_10 of
                    (ErlangTuple [(ErlangAtom "none"), _]) -> pushedalts_8
                    (ErlangTuple [_, (ErlangAtom "none")]) -> pushedalt_4
                    _ -> ErlangAtom "many"
              in ErlangTuple [ErlangCons alt1_3 alts1_7, pushed_13]
            _ -> EXC.badmatch matchExpr_9
      _ -> EXC.badmatch matchExpr_5
erlps__push_code_out_of_switch__1 [arg_18] =
  EXC.function_clause unit
erlps__push_code_out_of_switch__1 args =
  EXC.badarity (ErlangFun 1 erlps__push_code_out_of_switch__1)
    args

erlps__push_code_out_of_alt__1 :: ErlangFun
erlps__push_code_out_of_alt__1 [(ErlangAtom "missing")] =
  ErlangTuple [ErlangAtom "missing", ErlangAtom "none"]
erlps__push_code_out_of_alt__1 [(ErlangCons body_0@(ErlangTuple [(ErlangAtom "i"),
                                                                 _,
                                                                 (ErlangAtom "switch_body")]) code_1)]
  =
  let case_2 = erlps__does_abort__1 [code_1]
  in
    case case_2 of
      (ErlangAtom "true") ->
        ErlangTuple [ErlangCons body_0 code_1, ErlangAtom "none"]
      (ErlangAtom "false") ->
        ErlangTuple
          [ErlangCons body_0 ErlangEmptyList, ErlangCons body_0 code_1]
      something_else -> EXC.case_clause something_else
erlps__push_code_out_of_alt__1 [(ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                          r_0, type_1, alts_2,
                                                          def_3]) (ErlangEmptyList))]
  =
  let
    matchExpr_10 =
      erlps__push_code_out_of_switch__1 [ErlangCons def_3 alts_2]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangCons def1_7 alts1_8), pushed_9]) ->
        let
          head_12 =
            ErlangTuple [ErlangAtom "switch", r_0, type_1, alts1_8, def1_7]
        in ErlangTuple [ErlangCons head_12 ErlangEmptyList, pushed_9]
      _ -> EXC.badmatch matchExpr_10
erlps__push_code_out_of_alt__1 [code_0] =
  ErlangTuple [code_0, ErlangAtom "many"]
erlps__push_code_out_of_alt__1 [arg_3] = EXC.function_clause unit
erlps__push_code_out_of_alt__1 args =
  EXC.badarity (ErlangFun 1 erlps__push_code_out_of_alt__1) args

erlps__does_abort__1 :: ErlangFun
erlps__does_abort__1 [(ErlangCons i_0 code_1)] =
  let lop_2 = erlps__does_abort__1 [i_0]
  in
    case lop_2 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> erlps__does_abort__1 [code_1]
      _ -> EXC.badarg1 lop_2
erlps__does_abort__1 [(ErlangTuple [(ErlangAtom "i"), _,
                                    (ErlangTuple [(ErlangAtom "ABORT"), _])])]
  =
  ErlangAtom "true"
erlps__does_abort__1 [(ErlangTuple [(ErlangAtom "i"), _,
                                    (ErlangTuple [(ErlangAtom "EXIT"), _])])]
  =
  ErlangAtom "true"
erlps__does_abort__1 [(ErlangAtom "missing")] = ErlangAtom "true"
erlps__does_abort__1 [(ErlangTuple [(ErlangAtom "switch"), _, _,
                                    alts_0, def_1])]
  =
  let arg_2 = ErlangFun 1 erlps__does_abort__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__all__2"
      [arg_2, ErlangCons def_1 alts_0]
erlps__does_abort__1 [_] = ErlangAtom "false"
erlps__does_abort__1 [arg_0] = EXC.function_clause unit
erlps__does_abort__1 args =
  EXC.badarity (ErlangFun 1 erlps__does_abort__1) args

erlps__r_inline_switch_target__2 :: ErlangFun
erlps__r_inline_switch_target__2 [(ErlangTuple [(ErlangAtom "i"),
                                                ann_0,
                                                (ErlangTuple [(ErlangAtom "STORE"),
                                                              r_1, a_2])]),
                                  (ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                            r_3, type_4, alts_5,
                                                            def_6]) code_7)]
  | r_3 == r_1 =
  let    case_8 = erlps__is_reg__1 [a_2]
  in let
    ann1_20 =
      case case_8 of
        (ErlangAtom "true") ->
          let    arg_14 = BIF.maps__get__2 [ErlangAtom "live_out", ann_0]
          in let
            val_12 =
              BIF.do_remote_fun_call "Ordsets" "erlps__add_element__2"
                [a_2, arg_14]
          in let
            mapExt_17 =
              ErlangMap (Map.singleton (ErlangAtom "live_out") val_12)
          in
            case findMissingKey ann_0 [ErlangAtom "live_out"] of
              (DM.Nothing) -> BIF.maps__merge__2 [ann_0, mapExt_17]
              (DM.Just missing_19) -> EXC.badkey missing_19
        (ErlangAtom "false") -> ann_0
        something_else -> EXC.case_clause something_else
  in let tup_el_23 = ErlangTuple [ErlangAtom "STORE", r_1, a_2]
  in let
    store_27 = ErlangTuple [ErlangAtom "i", ann1_20, tup_el_23]
  in let
    switch_33 =
      ErlangTuple [ErlangAtom "switch", a_2, type_4, alts_5, def_6]
  in
    case r_1 of
      a_35 | a_35 == a_2 -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "stack"),
                    (ErlangInt num_36)]) | (ErlangInt num_36) == (toErl 0) ->
        ErlangTuple [ErlangCons switch_33 ErlangEmptyList, code_7]
      (ErlangTuple [(ErlangAtom "var"), _]) ->
        let   
          arg_42 =
            ErlangFun 1
              (let
                 lambda_43 [alt_45] = erlps__live_in__2 [r_1, alt_45]
                 lambda_43 [arg_44] = EXC.function_clause unit
                 lambda_43 args = EXC.badarity (ErlangFun 1 lambda_43) args
               in lambda_43)
        in let
          case_41 =
            BIF.do_remote_fun_call "Lists" "erlps__any__2"
              [arg_42, ErlangCons def_6 alts_5]
        in
          case case_41 of
            (ErlangAtom "false") ->
              ErlangTuple [ErlangCons switch_33 ErlangEmptyList, code_7]
            (ErlangAtom "true") | (ErlangAtom "true") ==
                                    (falsifyErrors
                                       (\ _ ->
                                          let    tup_el_58 = toErl 0
                                          in let
                                            rop_56 =
                                              ErlangTuple
                                                [ErlangAtom "stack", tup_el_58]
                                          in
                                            BIF.erlang__op_neq
                                              [a_2, rop_56])) ->
              ErlangTuple
                [ErlangCons store_27 (ErlangCons switch_33 ErlangEmptyList),
                 code_7]
            (ErlangAtom "true") -> ErlangAtom "false"
            something_else -> EXC.case_clause something_else
      _ -> ErlangAtom "false"
erlps__r_inline_switch_target__2 [_, _] = ErlangAtom "false"
erlps__r_inline_switch_target__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_inline_switch_target__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_inline_switch_target__2) args

erlps__r_float_switch_body__2 :: ErlangFun
erlps__r_float_switch_body__2 [i_0@(ErlangTuple [(ErlangAtom "i"),
                                                 _, _]),
                               (ErlangCons j_1@(ErlangTuple [(ErlangAtom "i"),
                                                             _,
                                                             (ErlangAtom "switch_body")]) code_2)]
  =
  let matchExpr_7 = erlps__swap_instrs__2 [i_0, j_1]
  in
    case matchExpr_7 of
      (ErlangTuple [j1_5, i1_6]) ->
        ErlangTuple
          [ErlangEmptyList, ErlangCons j1_5 (ErlangCons i1_6 code_2)]
      _ -> EXC.badmatch matchExpr_7
erlps__r_float_switch_body__2 [_, _] = ErlangAtom "false"
erlps__r_float_switch_body__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_float_switch_body__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_float_switch_body__2) args

erlps__r_inline_store__2 :: ErlangFun
erlps__r_inline_store__2 [(ErlangTuple [(ErlangAtom "i"), _,
                                        (ErlangTuple [(ErlangAtom "STORE"), r_0,
                                                      r_1])]),
                          code_2]
  | r_1 == r_0 =
  ErlangTuple [ErlangEmptyList, code_2]
erlps__r_inline_store__2 [i_2@(ErlangTuple [(ErlangAtom "i"), _,
                                            (ErlangTuple [(ErlangAtom "STORE"),
                                                          r_0@(ErlangTuple [(ErlangAtom "var"),
                                                                            _]),
                                                          a_1])]),
                          code_3]
  =
  let
    inline_5 =
      case a_1 of
        (ErlangTuple [(ErlangAtom "arg"), _]) -> ErlangAtom "true"
        (ErlangTuple [(ErlangAtom "immediate"), _]) -> ErlangAtom "true"
        (ErlangTuple [(ErlangAtom "store"), _]) -> ErlangAtom "true"
        _ -> ErlangAtom "false"
  in
    case ErlangAtom "true" of
      _ | (==) (ErlangAtom "true") inline_5 ->
        erlps__r_inline_store__5
          [ErlangCons i_2 ErlangEmptyList, ErlangAtom "false", r_0, a_1,
           code_3]
      _ -> ErlangAtom "false"
erlps__r_inline_store__2 [_, _] = ErlangAtom "false"
erlps__r_inline_store__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_inline_store__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_inline_store__2) args

erlps__r_inline_store__5 :: ErlangFun
erlps__r_inline_store__5 [acc_0, progress_1, r_2, a_3,
                          (ErlangCons i_4@(ErlangTuple [(ErlangAtom "i"), _,
                                                        (ErlangAtom "switch_body")]) code_5)]
  =
  erlps__r_inline_store__5
    [ErlangCons i_4 acc_0, progress_1, r_2, a_3, code_5]
erlps__r_inline_store__5 [acc_0, progress_1, r_2, a_3,
                          (ErlangCons (ErlangTuple [(ErlangAtom "i"), ann_4,
                                                    i_5]) code_6)]
  =
  let matchExpr_10 = erlps__attributes__1 [i_5]
  in
    case matchExpr_10 of
      (ErlangMap map_8) | (DM.Just w_9) <-
                            (Map.lookup (ErlangAtom "write") map_8) ->
        let   
          inl_15 =
            ErlangFun 1
              (let
                 lambda_11 [x_13] | weakEq x_13 r_2 = a_3
                 lambda_11 [x_14] = x_14
                 lambda_11 [arg_12] = EXC.function_clause unit
                 lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
               in lambda_11)
        in let case_16 = erlps__live_in__2 [r_2, ann_4]
        in
          case case_16 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              let    case_19 = erlps__op_view__1 [i_5]
              in let
                matchExpr_40 =
                  case case_19 of
                    (ErlangTuple [op_21, s_22, as_23]) ->
                      let case_24 = BIF.lists__member__2 [r_2, as_23]
                      in
                        case case_24 of
                          (ErlangAtom "true") ->
                            let   
                              arg_30 =
                                BIF.do_remote_fun_call "Lists" "erlps__map__2"
                                  [inl_15, as_23]
                            in let
                              tup_el_27 =
                                erlps__from_op_view__3 [op_21, s_22, arg_30]
                            in ErlangTuple [tup_el_27, ErlangAtom "true"]
                          (ErlangAtom "false") -> ErlangTuple [i_5, progress_1]
                          something_else -> EXC.case_clause something_else
                    _ -> ErlangTuple [i_5, progress_1]
              in
                case matchExpr_40 of
                  (ErlangTuple [i1_38, progress1_39]) ->
                    let    head_41 = ErlangTuple [ErlangAtom "i", ann_4, i1_38]
                    in let
                      case_47 =
                        BIF.lists__member__2
                          [w_9, ErlangCons r_2 (ErlangCons a_3 ErlangEmptyList)]
                    in
                      case case_47 of
                        (ErlangAtom "true") | (==) (ErlangAtom "true")
                                                progress1_39 ->
                          let
                            tup_el_54 =
                              BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                                [ErlangCons head_41 acc_0]
                          in ErlangTuple [tup_el_54, code_6]
                        (ErlangAtom "true") -> ErlangAtom "false"
                        (ErlangAtom "false") ->
                          erlps__r_inline_store__5
                            [ErlangCons head_41 acc_0, progress1_39, r_2, a_3,
                             code_6]
                        something_else -> EXC.case_clause something_else
                  _ -> EXC.badmatch matchExpr_40
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_10
erlps__r_inline_store__5 [acc_0, (ErlangAtom "true"), _, _,
                          code_1]
  =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
  in ErlangTuple [tup_el_2, code_1]
erlps__r_inline_store__5 [_, (ErlangAtom "false"), _, _, _] =
  ErlangAtom "false"
erlps__r_inline_store__5 [arg_0, arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__r_inline_store__5 args =
  EXC.badarity (ErlangFun 5 erlps__r_inline_store__5) args

erlps__r_one_shot_var__2 :: ErlangFun
erlps__r_one_shot_var__2 [(ErlangTuple [(ErlangAtom "i"), ann1_0,
                                        i_1]),
                          (ErlangCons (ErlangTuple [(ErlangAtom "i"), ann2_2,
                                                    j_3]) code_4)]
  =
  let case_5 = erlps__op_view__1 [i_1]
  in
    case case_5 of
      (ErlangTuple [op_7, r_8@(ErlangTuple [(ErlangAtom "var"), _]),
                    as_9]) ->
        let   
          copy_15 =
            case j_3 of
              (ErlangTuple [(ErlangAtom "STORE"), s_11, r_12]) | r_12 == r_8 ->
                ErlangTuple [ErlangAtom "write_to", s_11]
              _ -> ErlangAtom "false"
        in let tup_el_17 = erlps__live_out__2 [r_8, ann2_2]
        in let case_16 = ErlangTuple [tup_el_17, copy_15]
        in
          case case_16 of
            (ErlangTuple [(ErlangAtom "false"),
                          (ErlangTuple [(ErlangAtom "write_to"), x_21])]) ->
              let    tup_el_25 = erlps__merge_ann__2 [ann1_0, ann2_2]
              in let tup_el_28 = erlps__from_op_view__3 [op_7, x_21, as_9]
              in let
                head_23 = ErlangTuple [ErlangAtom "i", tup_el_25, tup_el_28]
              in ErlangTuple [ErlangCons head_23 ErlangEmptyList, code_4]
            _ -> ErlangAtom "false"
      _ -> ErlangAtom "false"
erlps__r_one_shot_var__2 [_, _] = ErlangAtom "false"
erlps__r_one_shot_var__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_one_shot_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_one_shot_var__2) args

erlps__r_write_to_dead_var__2 :: ErlangFun
erlps__r_write_to_dead_var__2 [(ErlangTuple [(ErlangAtom "i"), _,
                                             (ErlangTuple [(ErlangAtom "STORE"),
                                                           (ErlangTuple [(ErlangAtom "var"),
                                                                         (ErlangInt num_0)]),
                                                           (ErlangTuple [(ErlangAtom "stack"),
                                                                         (ErlangInt num_1)])])]),
                               _]
  | (ErlangInt num_0) == (toErl 9999)
  , (ErlangInt num_1) == (toErl 0) =
  ErlangAtom "false"
erlps__r_write_to_dead_var__2 [(ErlangTuple [(ErlangAtom "i"),
                                             ann_0, i_1]),
                               code_2]
  =
  let matchExpr_6 = erlps__attributes__1 [i_1]
  in
    case matchExpr_6 of
      (ErlangMap map_4) | (DM.Just pure_5) <-
                            (Map.lookup (ErlangAtom "pure") map_4) ->
        let case_7 = erlps__op_view__1 [i_1]
        in
          case case_7 of
            (ErlangTuple [_op_9, r_10, as_11]) | (ErlangAtom "true") ==
                                                   (falsifyErrors
                                                      (\ _ ->
                                                         let   
                                                           tup_el_16 = toErl 0
                                                         in let
                                                           rop_14 =
                                                             ErlangTuple
                                                               [ErlangAtom
                                                                  "stack",
                                                                tup_el_16]
                                                         in let
                                                           lop_12 =
                                                             BIF.erlang__op_neq
                                                               [r_10, rop_14]
                                                         in
                                                           case lop_12 of
                                                             (ErlangAtom "false") ->
                                                               ErlangAtom
                                                                 "false"
                                                             (ErlangAtom "true") ->
                                                               pure_5
                                                             _ ->
                                                               EXC.badarg1
                                                                 lop_12)) ->
              let case_17 = erlps__live_out__2 [r_10, ann_0]
              in
                case case_17 of
                  (ErlangAtom "false") ->
                    let
                      tup_el_20 =
                        flmap
                          (\ lc_23 ->
                             let    tup_el_28 = toErl 0
                             in let
                               rop_26 =
                                 ErlangTuple [ErlangAtom "stack", tup_el_28]
                             in let cond_24 = BIF.erlang__op_eq [lc_23, rop_26]
                             in
                               case cond_24 of
                                 (ErlangAtom "true") ->
                                   let    tup_el_36 = toErl 9999
                                   in let
                                     tup_el_34 =
                                       ErlangTuple [ErlangAtom "var", tup_el_36]
                                   in let tup_el_39 = toErl 0
                                   in let
                                     tup_el_37 =
                                       ErlangTuple
                                         [ErlangAtom "stack", tup_el_39]
                                   in let
                                     tup_el_32 =
                                       ErlangTuple
                                         [ErlangAtom "STORE", tup_el_34,
                                          tup_el_37]
                                   in let
                                     lcRet_29 =
                                       ErlangTuple
                                         [ErlangAtom "i", ann_0, tup_el_32]
                                   in ErlangCons lcRet_29 ErlangEmptyList
                                 _ -> ErlangEmptyList)
                          as_11
                    in ErlangTuple [tup_el_20, code_2]
                  (ErlangAtom "true") -> ErlangAtom "false"
                  something_else -> EXC.case_clause something_else
            _ -> ErlangAtom "false"
      _ -> EXC.badmatch matchExpr_6
erlps__r_write_to_dead_var__2 [_, _] = ErlangAtom "false"
erlps__r_write_to_dead_var__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_write_to_dead_var__2 args =
  EXC.badarity (ErlangFun 2 erlps__r_write_to_dead_var__2) args

erlps__op_view__1 :: ErlangFun
erlps__op_view__1 [(ErlangTuple [(ErlangAtom "ABORT"), r_0])] =
  ErlangTuple
    [ErlangAtom "ABORT", ErlangAtom "none",
     ErlangCons r_0 ErlangEmptyList]
erlps__op_view__1 [t_0] | isETuple t_0 =
  let matchExpr_5 = BIF.erlang__tuple_to_list__1 [t_0]
  in
    case matchExpr_5 of
      (ErlangCons op_2 (ErlangCons r_3 as_4)) ->
        let   
          checkreads_20 =
            ErlangFun 2
              (let
                 lambda_6 [rs_9, x_10] =
                   let   
                     rop_13 =
                       BIF.erlang__op_unAppend
                         [rs_9,
                          ErlangCons (ErlangAtom "dst")
                            (ErlangCons (ErlangAtom "src") ErlangEmptyList)]
                   in let case_11 = BIF.erlang__op_eq [ErlangEmptyList, rop_13]
                   in
                     case case_11 of
                       (ErlangAtom "true") -> x_10
                       (ErlangAtom "false") -> ErlangAtom "false"
                       something_else -> EXC.case_clause something_else
                 lambda_6 [arg_7, arg_8] = EXC.function_clause unit
                 lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
               in lambda_6)
        in let
          tail_27 =
            flmap
              (\ lc_29 ->
                 case lc_29 of
                   _ -> ErlangCons (ErlangAtom "src") ErlangEmptyList)
              as_4
        in let
          arg_22 =
            BIF.erlang__list_to_tuple__1
              [ErlangCons op_2 (ErlangCons (ErlangAtom "dst") tail_27)]
        in let case_21 = erlps__attributes__1 [arg_22]
        in
          case case_21 of
            (ErlangMap map_31) | (DM.Just rs_32) <-
                                   (Map.lookup (ErlangAtom "read") map_31)
                               , (DM.Just (ErlangAtom "dst")) <-
                                   (Map.lookup (ErlangAtom "write") map_31) ->
              let arg_34 = ErlangTuple [op_2, r_3, as_4]
              in
                BIF.erlang__apply__2
                  [checkreads_20,
                   ErlangCons rs_32 (ErlangCons arg_34 ErlangEmptyList)]
            (ErlangMap map_39) | (DM.Just rs_40) <-
                                   (Map.lookup (ErlangAtom "read") map_39)
                               , (DM.Just (ErlangAtom "none")) <-
                                   (Map.lookup (ErlangAtom "write") map_39) ->
              let
                arg_42 =
                  ErlangTuple [op_2, ErlangAtom "none", ErlangCons r_3 as_4]
              in
                BIF.erlang__apply__2
                  [checkreads_20,
                   ErlangCons rs_40 (ErlangCons arg_42 ErlangEmptyList)]
            _ -> ErlangAtom "false"
      _ -> EXC.badmatch matchExpr_5
erlps__op_view__1 [_] = ErlangAtom "false"
erlps__op_view__1 [arg_0] = EXC.function_clause unit
erlps__op_view__1 args =
  EXC.badarity (ErlangFun 1 erlps__op_view__1) args

erlps__from_op_view__3 :: ErlangFun
erlps__from_op_view__3 [op_0, (ErlangAtom "none"), as_1] =
  BIF.erlang__list_to_tuple__1 [ErlangCons op_0 as_1]
erlps__from_op_view__3 [op_0, r_1, as_2] =
  BIF.erlang__list_to_tuple__1
    [ErlangCons op_0 (ErlangCons r_1 as_2)]
erlps__from_op_view__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__from_op_view__3 args =
  EXC.badarity (ErlangFun 3 erlps__from_op_view__3) args

erlps__unannotate__1 :: ErlangFun
erlps__unannotate__1 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                    type_1, alts_2, def_3])]
  =
  let   
    tup_el_8 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__unannotate__1 [lc_11]
           in ErlangCons lcRet_12 ErlangEmptyList)
        alts_2
  in let tup_el_14 = erlps__unannotate__1 [def_3]
  in let
    head_4 =
      ErlangTuple
        [ErlangAtom "switch", arg_0, type_1, tup_el_8, tup_el_14]
  in ErlangCons head_4 ErlangEmptyList
erlps__unannotate__1 [(ErlangAtom "missing")] =
  ErlangAtom "missing"
erlps__unannotate__1 [code_0] | isEList code_0 =
  let arg_1 = ErlangFun 1 erlps__unannotate__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
      [arg_1, code_0]
erlps__unannotate__1 [(ErlangTuple [(ErlangAtom "i"), _ann_0,
                                    i_1])]
  =
  ErlangCons i_1 ErlangEmptyList
erlps__unannotate__1 [arg_4] = EXC.function_clause unit
erlps__unannotate__1 args =
  EXC.badarity (ErlangFun 1 erlps__unannotate__1) args

erlps__desugar__1 :: ErlangFun
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_1)]),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 1)
  , (ErlangInt num_2) == (toErl 0) =
  let
    head_3 = BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__0" []
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"), a_0,
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_1)]),
                                 a_2])]
  | (ErlangInt num_1) == (toErl 1)
  , a_2 == a_0 =
  let    arg_4 = erlps__desugar_arg__1 [a_0]
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__1" [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_1)]),
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 0)
  , (ErlangInt num_2) == (toErl 1) =
  let
    head_3 = BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__0" []
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"), a_0, a_1,
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_2) == (toErl 1)
  , a_1 == a_0 =
  let    arg_4 = erlps__desugar_arg__1 [a_0]
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__1" [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "SUB"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_1)]),
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 0)
  , (ErlangInt num_2) == (toErl 1) =
  let
    head_3 = BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__dec__0" []
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "SUB"), a_0, a_1,
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_2) == (toErl 1)
  , a_1 == a_0 =
  let    arg_4 = erlps__desugar_arg__1 [a_0]
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__dec__1" [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "STORE"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 a_1])]
  | (ErlangInt num_0) == (toErl 0) =
  let    arg_3 = erlps__desugar_arg__1 [a_1]
  in let
    head_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__push__1" [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "STORE"), r_0,
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_1)])])]
  | (ErlangInt num_1) == (toErl 0) =
  let    arg_3 = erlps__desugar_arg__1 [r_0]
  in let
    head_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__pop__1" [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                 type_1, alts_2, def_3])]
  =
  let    tup_el_6 = erlps__desugar_arg__1 [arg_0]
  in let
    tup_el_9 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__desugar__1 [lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        alts_2
  in let tup_el_15 = erlps__desugar__1 [def_3]
  in let
    head_4 =
      ErlangTuple
        [ErlangAtom "switch", tup_el_6, type_1, tup_el_9, tup_el_15]
  in ErlangCons head_4 ErlangEmptyList
erlps__desugar__1 [(ErlangAtom "missing")] = ErlangAtom "missing"
erlps__desugar__1 [code_0] | isEList code_0 =
  let arg_1 = ErlangFun 1 erlps__desugar__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
      [arg_1, code_0]
erlps__desugar__1 [i_0] =
  let head_1 = erlps__desugar_args__1 [i_0]
  in ErlangCons head_1 ErlangEmptyList
erlps__desugar__1 [arg_4] = EXC.function_clause unit
erlps__desugar__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar__1) args

erlps__desugar_args__1 :: ErlangFun
erlps__desugar_args__1 [i_0] | isETuple i_0 =
  let matchExpr_4 = BIF.erlang__tuple_to_list__1 [i_0]
  in
    case matchExpr_4 of
      (ErlangCons op_2 args_3) ->
        let    arg_8 = ErlangFun 1 erlps__desugar_arg__1
        in let
          tail_7 =
            BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_8, args_3]
        in BIF.erlang__list_to_tuple__1 [ErlangCons op_2 tail_7]
      _ -> EXC.badmatch matchExpr_4
erlps__desugar_args__1 [i_0] = i_0
erlps__desugar_args__1 [arg_1] = EXC.function_clause unit
erlps__desugar_args__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar_args__1) args

erlps__desugar_arg__1 :: ErlangFun
erlps__desugar_arg__1 [(ErlangTuple [(ErlangAtom "store"), n_0])]
  =
  let tup_el_2 = BIF.erlang__op_neg [n_0]
  in ErlangTuple [ErlangAtom "var", tup_el_2]
erlps__desugar_arg__1 [a_0] = a_0
erlps__desugar_arg__1 [arg_1] = EXC.function_clause unit
erlps__desugar_arg__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar_arg__1) args

erlps__to_basic_blocks__1 :: ErlangFun
erlps__to_basic_blocks__1 [funs_0] =
  let    arg_1 = BIF.maps__to_list__1 [funs_0]
  in let
    arg_3 = BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__new__0" []
  in erlps__to_basic_blocks__2 [arg_1, arg_3]
erlps__to_basic_blocks__1 [arg_4] = EXC.function_clause unit
erlps__to_basic_blocks__1 args =
  EXC.badarity (ErlangFun 1 erlps__to_basic_blocks__1) args

erlps__to_basic_blocks__2 :: ErlangFun
erlps__to_basic_blocks__2 [(ErlangCons (ErlangTuple [name_0,
                                                     (ErlangTuple [attrs_1,
                                                                   sig_2,
                                                                   code_3])]) left_4),
                           acc_5]
  =
  let   
    head_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__return__0" []
  in let
    arg_7 =
      BIF.erlang__op_append
        [code_3, ErlangCons head_10 ErlangEmptyList]
  in let bb_12 = erlps__bb__2 [name_0, arg_7]
  in let
    arg_14 =
      BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__insert_fun__5"
        [name_0, attrs_1, sig_2, bb_12, acc_5]
  in erlps__to_basic_blocks__2 [left_4, arg_14]
erlps__to_basic_blocks__2 [(ErlangEmptyList), acc_0] = acc_0
erlps__to_basic_blocks__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__to_basic_blocks__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_basic_blocks__2) args

erlps__bb__2 :: ErlangFun
erlps__bb__2 [_name_0, code_1] =
  let    blocks0_3 = erlps__blocks__1 [code_1]
  in let blocks1_5 = erlps__optimize_blocks__1 [blocks0_3]
  in let arg_6 = ErlangFun 1 erlps__split_calls__1
  in let
    blocks_8 =
      BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
        [arg_6, blocks1_5]
  in let lcSrc_10 = erlps__with_ixs__1 [blocks_8]
  in let
    arg_9 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [i_12, (ErlangTuple [ref_13, _])]) ->
               let lcRet_15 = ErlangTuple [ref_13, i_12]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_10
  in let labels_18 = BIF.maps__from_list__1 [arg_9]
  in let
    bbs_25 =
      flmap
        (\ lc_21 ->
           let lcRet_22 = erlps__set_labels__2 [labels_18, lc_21]
           in ErlangCons lcRet_22 ErlangEmptyList)
        blocks_8
  in BIF.maps__from_list__1 [bbs_25]
erlps__bb__2 [arg_27, arg_28] = EXC.function_clause unit
erlps__bb__2 args = EXC.badarity (ErlangFun 2 erlps__bb__2) args

erlps__blocks__1 :: ErlangFun
erlps__blocks__1 [code_0] =
  let    top_1 = BIF.erlang__make_ref__0 []
  in let
    head_3 =
      ErlangTuple [ErlangAtom "blk", top_1, code_0, ErlangAtom "none"]
  in
    erlps__blocks__2
      [ErlangCons head_3 ErlangEmptyList, ErlangEmptyList]
erlps__blocks__1 [arg_10] = EXC.function_clause unit
erlps__blocks__1 args =
  EXC.badarity (ErlangFun 1 erlps__blocks__1) args

erlps__blocks__2 :: ErlangFun
erlps__blocks__2 [(ErlangEmptyList), acc_0] =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
erlps__blocks__2 [(ErlangCons blk_0 blocks_1), acc_2] =
  erlps__block__4 [blk_0, ErlangEmptyList, blocks_1, acc_2]
erlps__blocks__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__blocks__2 args =
  EXC.badarity (ErlangFun 2 erlps__blocks__2) args

erlps__block__4 :: ErlangFun
erlps__block__4 [(ErlangTuple [(ErlangAtom "blk"), ref_0,
                               (ErlangEmptyList), _]),
                 codeacc_1, blocks_2, blockacc_3]
  =
  let   
    tup_el_8 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [codeacc_1]
  in let head_6 = ErlangTuple [ref_0, tup_el_8]
  in erlps__blocks__2 [blocks_2, ErlangCons head_6 blockacc_3]
erlps__block__4 [blk_1@(ErlangTuple [(ErlangAtom "blk"), _,
                                     (ErlangCons (ErlangAtom "switch_body") code_0),
                                     _]),
                 acc_2, blocks_3, blockacc_4]
  =
  let
    arg_5 =
      case blk_1 of
        (ErlangTuple [(ErlangAtom "blk"), ref_9, code_10,
                      catchall_11]) ->
          ErlangTuple [ErlangAtom "blk", ref_9, code_0, ErlangAtom "none"]
        _ -> EXC.badrecord (ErlangAtom "blk")
  in erlps__block__4 [arg_5, acc_2, blocks_3, blockacc_4]
erlps__block__4 [blk_6@(ErlangTuple [(ErlangAtom "blk"), _,
                                     (ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                               arg_0, type_1,
                                                               alts_2,
                                                               default_3]) code_4),
                                     catchall_5]),
                 acc_7, blocks_8, blockacc_9]
  =
  let   
    freshblk_24 =
      ErlangFun 2
        (let
           lambda_10 [c_13, ca_14] =
             let    r_15 = BIF.erlang__make_ref__0 []
             in let
               head_18 = ErlangTuple [ErlangAtom "blk", r_15, c_13, ca_14]
             in ErlangTuple [r_15, ErlangCons head_18 ErlangEmptyList]
           lambda_10 [arg_11, arg_12] = EXC.function_clause unit
           lambda_10 args = EXC.badarity (ErlangFun 2 lambda_10) args
         in lambda_10)
  in let
    matchExpr_30 =
      BIF.erlang__apply__2
        [freshblk_24,
         ErlangCons code_4 (ErlangCons catchall_5 ErlangEmptyList)]
  in
    case matchExpr_30 of
      (ErlangTuple [restref_28, restblk_29]) ->
        let
          matchExpr_53 =
            case default_3 of
              (ErlangAtom "missing") | weakEq catchall_5 (ErlangAtom "none") ->
                let   
                  tup_el_36 =
                    ErlangBinary
                      (BIN.fromInts (toErl "Incomplete patterns") (toErl 8) 1
                         BIN.Big)
                in let arg_34 = ErlangTuple [ErlangAtom "immediate", tup_el_36]
                in let
                  head_33 =
                    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__abort__1"
                      [arg_34]
                in
                  BIF.erlang__apply__2
                    [freshblk_24,
                     ErlangCons (ErlangCons head_33 ErlangEmptyList)
                       (ErlangCons (ErlangAtom "none") ErlangEmptyList)]
              (ErlangAtom "missing") ->
                ErlangTuple [catchall_5, ErlangEmptyList]
              _ ->
                let    head_45 = ErlangTuple [ErlangAtom "jump", restref_28]
                in let
                  arg_42 =
                    BIF.erlang__op_append
                      [default_3, ErlangCons head_45 ErlangEmptyList]
                in
                  BIF.erlang__apply__2
                    [freshblk_24,
                     ErlangCons arg_42 (ErlangCons catchall_5 ErlangEmptyList)]
        in
          case matchExpr_53 of
            (ErlangTuple [defref_51, defblk_52]) ->
              let    tup_el_58 = toErl 0
              in let rop_56 = ErlangTuple [ErlangAtom "stack", tup_el_58]
              in let cond_54 = BIF.erlang__op_eq [arg_0, rop_56]
              in let
                pop_64 =
                  case cond_54 of
                    (ErlangAtom "true") ->
                      let    tup_el_63 = toErl 9999
                      in let
                        tup_el_61 = ErlangTuple [ErlangAtom "var", tup_el_63]
                      in let
                        lcRet_59 = ErlangTuple [ErlangAtom "POP", tup_el_61]
                      in ErlangCons lcRet_59 ErlangEmptyList
                    _ -> ErlangEmptyList
              in let
                matchExpr_275 =
                  case type_1 of
                    (ErlangAtom "boolean") ->
                      case alts_2 of
                        (ErlangCons falsecode_66 (ErlangCons truecode_67 (ErlangEmptyList))) ->
                          let
                            matchExpr_83 =
                              case truecode_67 of
                                (ErlangAtom "missing") ->
                                  ErlangTuple [defref_51, ErlangEmptyList]
                                _ ->
                                  let   
                                    head_75 =
                                      ErlangTuple
                                        [ErlangAtom "jump", restref_28]
                                  in let
                                    arg_72 =
                                      BIF.erlang__op_append
                                        [truecode_67,
                                         ErlangCons head_75 ErlangEmptyList]
                                  in
                                    BIF.erlang__apply__2
                                      [freshblk_24,
                                       ErlangCons arg_72
                                         (ErlangCons defref_51 ErlangEmptyList)]
                          in
                            case matchExpr_83 of
                              (ErlangTuple [thenref_81, thenblk_82]) ->
                                let   
                                  elsecode_95 =
                                    case falsecode_66 of
                                      (ErlangAtom "missing") ->
                                        let
                                          head_85 =
                                            ErlangTuple
                                              [ErlangAtom "jump", defref_51]
                                        in ErlangCons head_85 ErlangEmptyList
                                      _ ->
                                        let
                                          head_91 =
                                            ErlangTuple
                                              [ErlangAtom "jump", restref_28]
                                        in
                                          BIF.erlang__op_append
                                            [falsecode_66,
                                             ErlangCons head_91 ErlangEmptyList]
                                in let
                                  lop_97 =
                                    BIF.do_remote_fun_call "Lists"
                                      "erlps__usort__1" [alts_2]
                                in let
                                  case_96 =
                                    BIF.erlang__op_eq
                                      [lop_97,
                                       ErlangCons (ErlangAtom "missing")
                                         ErlangEmptyList]
                                in
                                  case case_96 of
                                    (ErlangAtom "true") ->
                                      let   
                                        head_107 =
                                          ErlangTuple
                                            [ErlangAtom "jump", defref_51]
                                      in let
                                        record_updt_104 =
                                          BIF.erlang__op_append
                                            [pop_64,
                                             ErlangCons head_107
                                               ErlangEmptyList]
                                      in let
                                        tup_el_102 =
                                          case blk_6 of
                                            (ErlangTuple [(ErlangAtom "blk"),
                                                          ref_111, code_112,
                                                          catchall_113]) ->
                                              ErlangTuple
                                                [ErlangAtom "blk", ref_111,
                                                 record_updt_104, catchall_113]
                                            _ ->
                                              EXC.badrecord (ErlangAtom "blk")
                                      in
                                        ErlangTuple
                                          [tup_el_102, ErlangEmptyList,
                                           ErlangEmptyList]
                                    (ErlangAtom "false") ->
                                      case arg_0 of
                                        (ErlangTuple [(ErlangAtom "immediate"),
                                                      (ErlangAtom "false")]) ->
                                          let
                                            tup_el_117 =
                                              case blk_6 of
                                                (ErlangTuple [(ErlangAtom "blk"),
                                                              ref_120, code_121,
                                                              catchall_122]) ->
                                                  ErlangTuple
                                                    [ErlangAtom "blk", ref_120,
                                                     elsecode_95, catchall_122]
                                                _ ->
                                                  EXC.badrecord
                                                    (ErlangAtom "blk")
                                          in
                                            ErlangTuple
                                              [tup_el_117, ErlangEmptyList,
                                               thenblk_82]
                                        (ErlangTuple [(ErlangAtom "immediate"),
                                                      (ErlangAtom "true")]) ->
                                          let   
                                            tup_el_125 =
                                              case blk_6 of
                                                (ErlangTuple [(ErlangAtom "blk"),
                                                              ref_128, code_129,
                                                              catchall_130]) ->
                                                  ErlangTuple
                                                    [ErlangAtom "blk", ref_128,
                                                     ErlangEmptyList,
                                                     catchall_130]
                                                _ ->
                                                  EXC.badrecord
                                                    (ErlangAtom "blk")
                                          in let
                                            head_132 =
                                              ErlangTuple
                                                [ErlangAtom "jump", thenref_81]
                                          in
                                            ErlangTuple
                                              [tup_el_125,
                                               ErlangCons head_132
                                                 ErlangEmptyList,
                                               thenblk_82]
                                        _ ->
                                          let   
                                            tup_el_137 =
                                              case blk_6 of
                                                (ErlangTuple [(ErlangAtom "blk"),
                                                              ref_140, code_141,
                                                              catchall_142]) ->
                                                  ErlangTuple
                                                    [ErlangAtom "blk", ref_140,
                                                     elsecode_95, catchall_142]
                                                _ ->
                                                  EXC.badrecord
                                                    (ErlangAtom "blk")
                                          in let
                                            head_144 =
                                              ErlangTuple
                                                [ErlangAtom "jumpif", arg_0,
                                                 thenref_81]
                                          in
                                            ErlangTuple
                                              [tup_el_137,
                                               ErlangCons head_144
                                                 ErlangEmptyList,
                                               thenblk_82]
                                    something_else ->
                                      EXC.case_clause something_else
                              _ -> EXC.badmatch matchExpr_83
                        _ -> EXC.badmatch alts_2
                    (ErlangAtom "tuple") ->
                      case alts_2 of
                        (ErlangCons tcode_150 (ErlangEmptyList)) ->
                          case tcode_150 of
                            (ErlangAtom "missing") ->
                              let   
                                head_158 =
                                  ErlangTuple [ErlangAtom "jump", defref_51]
                              in let
                                record_updt_155 =
                                  BIF.erlang__op_append
                                    [pop_64,
                                     ErlangCons head_158 ErlangEmptyList]
                              in let
                                tup_el_153 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_162,
                                                  code_163, catchall_164]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_162,
                                         record_updt_155, catchall_164]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_153, ErlangEmptyList, ErlangEmptyList]
                            _ ->
                              let   
                                head_174 =
                                  ErlangTuple [ErlangAtom "jump", restref_28]
                              in let
                                rop_171 =
                                  BIF.erlang__op_append
                                    [tcode_150,
                                     ErlangCons head_174 ErlangEmptyList]
                              in let
                                record_updt_169 =
                                  BIF.erlang__op_append [pop_64, rop_171]
                              in let
                                tup_el_167 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_178,
                                                  code_179, catchall_180]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_178,
                                         record_updt_169, catchall_180]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_167, ErlangEmptyList, ErlangEmptyList]
                        _ -> EXC.badmatch alts_2
                    (ErlangTuple [(ErlangAtom "variant"),
                                  (ErlangCons _ (ErlangEmptyList))]) ->
                      case alts_2 of
                        (ErlangCons altcode_183 (ErlangEmptyList)) ->
                          case altcode_183 of
                            (ErlangAtom "missing") ->
                              let   
                                head_191 =
                                  ErlangTuple [ErlangAtom "jump", defref_51]
                              in let
                                record_updt_188 =
                                  BIF.erlang__op_append
                                    [pop_64,
                                     ErlangCons head_191 ErlangEmptyList]
                              in let
                                tup_el_186 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_195,
                                                  code_196, catchall_197]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_195,
                                         record_updt_188, catchall_197]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_186, ErlangEmptyList, ErlangEmptyList]
                            _ ->
                              let   
                                head_207 =
                                  ErlangTuple [ErlangAtom "jump", restref_28]
                              in let
                                rop_204 =
                                  BIF.erlang__op_append
                                    [altcode_183,
                                     ErlangCons head_207 ErlangEmptyList]
                              in let
                                record_updt_202 =
                                  BIF.erlang__op_append [pop_64, rop_204]
                              in let
                                tup_el_200 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_211,
                                                  code_212, catchall_213]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_211,
                                         record_updt_202, catchall_213]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_200, ErlangEmptyList, ErlangEmptyList]
                        _ -> EXC.badmatch alts_2
                    (ErlangTuple [(ErlangAtom "variant"), _ar_216]) ->
                      let   
                        lop_218 =
                          BIF.do_remote_fun_call "Lists" "erlps__usort__1"
                            [alts_2]
                      in let
                        case_217 =
                          BIF.erlang__op_eq
                            [lop_218,
                             ErlangCons (ErlangAtom "missing") ErlangEmptyList]
                      in
                        case case_217 of
                          (ErlangAtom "true") ->
                            let   
                              head_228 =
                                ErlangTuple [ErlangAtom "jump", defref_51]
                            in let
                              record_updt_225 =
                                BIF.erlang__op_append
                                  [pop_64, ErlangCons head_228 ErlangEmptyList]
                            in let
                              tup_el_223 =
                                case blk_6 of
                                  (ErlangTuple [(ErlangAtom "blk"), ref_232,
                                                code_233, catchall_234]) ->
                                    ErlangTuple
                                      [ErlangAtom "blk", ref_232,
                                       record_updt_225, catchall_234]
                                  _ -> EXC.badrecord (ErlangAtom "blk")
                            in
                              ErlangTuple
                                [tup_el_223, ErlangEmptyList, ErlangEmptyList]
                          (ErlangAtom "false") ->
                            let   
                              mkblk_251 =
                                ErlangFun 1
                                  (let
                                     lambda_237 [(ErlangAtom "missing")] =
                                       ErlangTuple [defref_51, ErlangEmptyList]
                                     lambda_237 [acode_241] =
                                       let   
                                         head_245 =
                                           ErlangTuple
                                             [ErlangAtom "jump", restref_28]
                                       in let
                                         arg_242 =
                                           BIF.erlang__op_append
                                             [acode_241,
                                              ErlangCons head_245
                                                ErlangEmptyList]
                                       in
                                         BIF.erlang__apply__2
                                           [freshblk_24,
                                            ErlangCons arg_242
                                              (ErlangCons defref_51
                                                 ErlangEmptyList)]
                                     lambda_237 [arg_238] =
                                       EXC.function_clause unit
                                     lambda_237 args =
                                       EXC.badarity (ErlangFun 1 lambda_237)
                                         args
                                   in lambda_237)
                            in let
                              arg_252 =
                                BIF.do_remote_fun_call "Lists" "erlps__map__2"
                                  [mkblk_251, alts_2]
                            in let
                              matchExpr_257 =
                                BIF.do_remote_fun_call "Lists" "erlps__unzip__1"
                                  [arg_252]
                            in
                              case matchExpr_257 of
                                (ErlangTuple [altrefs_255, altbs_256]) ->
                                  let   
                                    tup_el_258 =
                                      case blk_6 of
                                        (ErlangTuple [(ErlangAtom "blk"),
                                                      ref_261, code_262,
                                                      catchall_263]) ->
                                          ErlangTuple
                                            [ErlangAtom "blk", ref_261,
                                             ErlangEmptyList, catchall_263]
                                        _ -> EXC.badrecord (ErlangAtom "blk")
                                  in let
                                    head_265 =
                                      ErlangTuple
                                        [ErlangAtom "switch", arg_0,
                                         altrefs_255]
                                  in let
                                    tup_el_270 =
                                      BIF.do_remote_fun_call "Lists"
                                        "erlps__append__1" [altbs_256]
                                  in
                                    ErlangTuple
                                      [tup_el_258,
                                       ErlangCons head_265 ErlangEmptyList,
                                       tup_el_270]
                                _ -> EXC.badmatch matchExpr_257
                          something_else -> EXC.case_clause something_else
                    something_else -> EXC.case_clause something_else
              in
                case matchExpr_275 of
                  (ErlangTuple [blk1_272, code1_273, altblks_274]) ->
                    let   
                      blk2_281 =
                        case blk1_272 of
                          (ErlangTuple [(ErlangAtom "blk"), ref_278, code_279,
                                        catchall_280]) ->
                            ErlangTuple
                              [ErlangAtom "blk", ref_278, code_279, defref_51]
                          _ -> EXC.badrecord (ErlangAtom "blk")
                    in let arg_283 = BIF.erlang__op_append [code1_273, acc_7]
                    in let
                      rop_290 = BIF.erlang__op_append [altblks_274, blocks_8]
                    in let rop_288 = BIF.erlang__op_append [restblk_29, rop_290]
                    in let arg_286 = BIF.erlang__op_append [defblk_52, rop_288]
                    in erlps__block__4 [blk2_281, arg_283, arg_286, blockacc_9]
                  _ -> EXC.badmatch matchExpr_275
            _ -> EXC.badmatch matchExpr_53
      _ -> EXC.badmatch matchExpr_30
erlps__block__4 [blk_2@(ErlangTuple [(ErlangAtom "blk"), _,
                                     (ErlangCons i_0 code_1), _]),
                 acc_3, blocks_4, blockacc_5]
  =
  let
    arg_6 =
      case blk_2 of
        (ErlangTuple [(ErlangAtom "blk"), ref_9, code_10,
                      catchall_11]) ->
          ErlangTuple [ErlangAtom "blk", ref_9, code_1, catchall_11]
        _ -> EXC.badrecord (ErlangAtom "blk")
  in
    erlps__block__4
      [arg_6, ErlangCons i_0 acc_3, blocks_4, blockacc_5]
erlps__block__4 [arg_17, arg_18, arg_19, arg_20] =
  EXC.function_clause unit
erlps__block__4 args =
  EXC.badarity (ErlangFun 4 erlps__block__4) args

erlps__optimize_blocks__1 :: ErlangFun
erlps__optimize_blocks__1 [blocks_0] =
  let   
    rev_12 =
      ErlangFun 1
        (let
           lambda_1 [bs_3] =
             flmap
               (\ lc_7 ->
                  case lc_7 of
                    (ErlangTuple [ref_5, code_6]) ->
                      let   
                        tup_el_10 =
                          BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                            [code_6]
                      in let lcRet_8 = ErlangTuple [ref_5, tup_el_10]
                      in ErlangCons lcRet_8 ErlangEmptyList
                    _ -> ErlangEmptyList)
               bs_3
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let
    rblocks_15 =
      BIF.erlang__apply__2
        [rev_12, ErlangCons blocks_0 ErlangEmptyList]
  in let rblockmap_17 = BIF.maps__from_list__1 [rblocks_15]
  in let
    rblocks1_20 =
      erlps__reorder_blocks__2 [rblocks_15, ErlangEmptyList]
  in let
    rblocks2_31 =
      flmap
        (\ lc_24 ->
           case lc_24 of
             (ErlangTuple [ref_22, code_23]) ->
               let   
                 tup_el_27 =
                   erlps__inline_block__3 [rblockmap_17, ref_22, code_23]
               in let lcRet_25 = ErlangTuple [ref_22, tup_el_27]
               in ErlangCons lcRet_25 ErlangEmptyList
             _ -> ErlangEmptyList)
        rblocks1_20
  in let rblocks3_33 = erlps__shortcut_jump_chains__1 [rblocks2_31]
  in let rblocks4_35 = erlps__remove_dead_blocks__1 [rblocks3_33]
  in let
    rblocks5_44 =
      flmap
        (\ lc_39 ->
           case lc_39 of
             (ErlangTuple [ref_37, code_38]) ->
               let    tup_el_42 = erlps__tweak_returns__1 [code_38]
               in let lcRet_40 = ErlangTuple [ref_37, tup_el_42]
               in ErlangCons lcRet_40 ErlangEmptyList
             _ -> ErlangEmptyList)
        rblocks4_35
  in
    BIF.erlang__apply__2
      [rev_12, ErlangCons rblocks5_44 ErlangEmptyList]
erlps__optimize_blocks__1 [arg_47] = EXC.function_clause unit
erlps__optimize_blocks__1 args =
  EXC.badarity (ErlangFun 1 erlps__optimize_blocks__1) args

erlps__reorder_blocks__2 :: ErlangFun
erlps__reorder_blocks__2 [(ErlangEmptyList), acc_0] =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
erlps__reorder_blocks__2 [(ErlangCons (ErlangTuple [ref_0,
                                                    code_1]) blocks_2),
                          acc_3]
  =
  erlps__reorder_blocks__4 [ref_0, code_1, blocks_2, acc_3]
erlps__reorder_blocks__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__reorder_blocks__2 args =
  EXC.badarity (ErlangFun 2 erlps__reorder_blocks__2) args

erlps__reorder_blocks__4 :: ErlangFun
erlps__reorder_blocks__4 [ref_0, code_1, blocks_2, acc_3] =
  let head_4 = ErlangTuple [ref_0, code_1]
  in
    case code_1 of
      (ErlangCons (ErlangAtom "RETURN") _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "RETURNR"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "CALL_T"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "EXIT"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "ABORT"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "switch"), _, _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "jump"), l_22]) _) ->
        let   
          notl_28 =
            ErlangFun 1
              (let
                 lambda_23 [(ErlangTuple [l1_25, _])] =
                   BIF.erlang__op_neq [l1_25, l_22]
                 lambda_23 [arg_24] = EXC.function_clause unit
                 lambda_23 args = EXC.badarity (ErlangFun 1 lambda_23) args
               in lambda_23)
        in let
          case_29 =
            BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
              [notl_28, blocks_2]
        in
          case case_29 of
            (ErlangTuple [blocks1_32,
                          (ErlangCons (ErlangTuple [l_33,
                                                    code1_34]) blocks2_35)]) | l_33 ==
                                                                                 l_22 ->
              let arg_38 = BIF.erlang__op_append [blocks1_32, blocks2_35]
              in
                erlps__reorder_blocks__4
                  [l_22, code1_34, arg_38, ErlangCons head_4 acc_3]
            (ErlangTuple [_, (ErlangEmptyList)]) ->
              erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__reorder_blocks__4 [arg_44, arg_45, arg_46, arg_47] =
  EXC.function_clause unit
erlps__reorder_blocks__4 args =
  EXC.badarity (ErlangFun 4 erlps__reorder_blocks__4) args

erlps__inline_block__3 :: ErlangFun
erlps__inline_block__3 [blockmap_0, ref_1,
                        code0_4@(ErlangCons (ErlangTuple [(ErlangAtom "jump"),
                                                          l_2]) code_3)]
  | weakNEq l_2 ref_1 =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [l_2, blockmap_0, ErlangAtom "nocode"]
  in
    case case_5 of
      dest_9 | (ErlangAtom "true") ==
                 (falsifyErrors
                    (\ _ ->
                       let    lop_10 = BIF.erlang__length__1 [dest_9]
                       in let rop_12 = toErl 3
                       in BIF.erlang__op_lesser [lop_10, rop_12])) ->
        let    arg_14 = BIF.maps__remove__2 [ref_1, blockmap_0]
        in let lop_13 = erlps__inline_block__3 [arg_14, l_2, dest_9]
        in BIF.erlang__op_append [lop_13, code_3]
      _ -> code0_4
erlps__inline_block__3 [_, _, code_0] = code_0
erlps__inline_block__3 [arg_1, arg_2, arg_3] =
  EXC.function_clause unit
erlps__inline_block__3 args =
  EXC.badarity (ErlangFun 3 erlps__inline_block__3) args

erlps__shortcut_jump_chains__1 :: ErlangFun
erlps__shortcut_jump_chains__1 [rblocks_0] =
  let   
    arg_1 =
      ErlangFun 2
        (let
           lambda_2 [(ErlangTuple [l1_5,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "jump"),
                                                             l2_6]) (ErlangEmptyList))]),
                     sub_7]
             =
             let   
               val_10 =
                 BIF.do_remote_fun_call "Maps" "erlps__get__3"
                   [l2_6, sub_7, l2_6]
             in let mapExt_14 = ErlangMap (Map.singleton l1_5 val_10)
             in BIF.maps__merge__2 [sub_7, mapExt_14]
           lambda_2 [_, sub_16] = sub_16
           lambda_2 [arg_3, arg_4] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
         in lambda_2)
  in let arg_17 = ErlangMap Map.empty
  in let
    subst_19 =
      BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
        [arg_1, arg_17, rblocks_0]
  in
    flmap
      (\ lc_23 ->
         case lc_23 of
           (ErlangTuple [ref_21, code_22]) ->
             let    tup_el_26 = erlps__update_labels__2 [subst_19, code_22]
             in let lcRet_24 = ErlangTuple [ref_21, tup_el_26]
             in ErlangCons lcRet_24 ErlangEmptyList
           _ -> ErlangEmptyList)
      rblocks_0
erlps__shortcut_jump_chains__1 [arg_29] =
  EXC.function_clause unit
erlps__shortcut_jump_chains__1 args =
  EXC.badarity (ErlangFun 1 erlps__shortcut_jump_chains__1) args

erlps__update_labels__2 :: ErlangFun
erlps__update_labels__2 [sub_0, ref_1] | isEReference ref_1 =
  BIF.do_remote_fun_call "Maps" "erlps__get__3"
    [ref_1, sub_0, ref_1]
erlps__update_labels__2 [sub_0, l_1] | isEList l_1 =
  let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [x_5] = erlps__update_labels__2 [sub_0, x_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_2, l_1]
erlps__update_labels__2 [sub_0, t_1] | isETuple t_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_2 = erlps__update_labels__2 [sub_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__update_labels__2 [_, x_0] = x_0
erlps__update_labels__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__update_labels__2 args =
  EXC.badarity (ErlangFun 2 erlps__update_labels__2) args

erlps__remove_dead_blocks__1 :: ErlangFun
erlps__remove_dead_blocks__1 [blocks_1@(ErlangCons (ErlangTuple [top_0,
                                                                 _]) _)]
  =
  let    blockmap_3 = BIF.maps__from_list__1 [blocks_1]
  in let arg_8 = ErlangMap Map.empty
  in let
    liveblocks_9 =
      erlps__chase_labels__3
        [ErlangCons top_0 ErlangEmptyList, blockmap_3, arg_8]
  in
    flmap
      (\ lc_13 ->
         case lc_13 of
           b_12@(ErlangTuple [l_11, _]) ->
             let cond_14 = BIF.maps__is_key__2 [l_11, liveblocks_9]
             in
               case cond_14 of
                 (ErlangAtom "true") -> ErlangCons b_12 ErlangEmptyList
                 _ -> ErlangEmptyList
           _ -> ErlangEmptyList)
      blocks_1
erlps__remove_dead_blocks__1 [arg_18] = EXC.function_clause unit
erlps__remove_dead_blocks__1 args =
  EXC.badarity (ErlangFun 1 erlps__remove_dead_blocks__1) args

erlps__chase_labels__3 :: ErlangFun
erlps__chase_labels__3 [(ErlangEmptyList), _, live_0] = live_0
erlps__chase_labels__3 [(ErlangCons l_0 ls_1), map_2, live_3] =
  let    code_6 = BIF.maps__get__2 [l_0, map_2]
  in let
    jump_30 =
      ErlangFun 1
        (let
           lambda_7 [(ErlangTuple [(ErlangAtom "jump"), a_9])] =
             let    op_arg_11 = BIF.maps__is_key__2 [a_9, live_3]
             in let cond_10 = BIF.erlang__not__1 [op_arg_11]
             in
               case cond_10 of
                 (ErlangAtom "true") -> ErlangCons a_9 ErlangEmptyList
                 _ -> ErlangEmptyList
           lambda_7 [(ErlangTuple [(ErlangAtom "jumpif"), _, a_15])] =
             let    op_arg_17 = BIF.maps__is_key__2 [a_15, live_3]
             in let cond_16 = BIF.erlang__not__1 [op_arg_17]
             in
               case cond_16 of
                 (ErlangAtom "true") -> ErlangCons a_15 ErlangEmptyList
                 _ -> ErlangEmptyList
           lambda_7 [(ErlangTuple [(ErlangAtom "switch"), _, as_21])] =
             flmap
               (\ lc_24 ->
                  let    op_arg_26 = BIF.maps__is_key__2 [lc_24, live_3]
                  in let cond_25 = BIF.erlang__not__1 [op_arg_26]
                  in
                    case cond_25 of
                      (ErlangAtom "true") -> ErlangCons lc_24 ErlangEmptyList
                      _ -> ErlangEmptyList)
               as_21
           lambda_7 [_] = ErlangEmptyList
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    new_33 =
      BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
        [jump_30, code_6]
  in let arg_34 = BIF.erlang__op_append [new_33, ls_1]
  in let
    mapExt_42 = ErlangMap (Map.singleton l_0 (ErlangAtom "true"))
  in let arg_38 = BIF.maps__merge__2 [live_3, mapExt_42]
  in erlps__chase_labels__3 [arg_34, map_2, arg_38]
erlps__chase_labels__3 [arg_44, arg_45, arg_46] =
  EXC.function_clause unit
erlps__chase_labels__3 args =
  EXC.badarity (ErlangFun 3 erlps__chase_labels__3) args

erlps__tweak_returns__1 :: ErlangFun
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") (ErlangCons (ErlangTuple [(ErlangAtom "PUSH"),
                                                                                     a_0]) code_1))]
  =
  let head_2 = ErlangTuple [ErlangAtom "RETURNR", a_0]
  in ErlangCons head_2 code_1
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangTuple [(ErlangAtom "CALL_T"),
                                                                                            _]) _))]
  =
  code_0
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangTuple [(ErlangAtom "ABORT"),
                                                                                            _]) _))]
  =
  code_0
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangTuple [(ErlangAtom "EXIT"),
                                                                                            _]) _))]
  =
  code_0
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangAtom "loop") _))]
  =
  code_0
erlps__tweak_returns__1 [code_0] = code_0
erlps__tweak_returns__1 [arg_1] = EXC.function_clause unit
erlps__tweak_returns__1 args =
  EXC.badarity (ErlangFun 1 erlps__tweak_returns__1) args

erlps__split_calls__1 :: ErlangFun
erlps__split_calls__1 [(ErlangTuple [ref_0, code_1])] =
  erlps__split_calls__4
    [ref_0, code_1, ErlangEmptyList, ErlangEmptyList]
erlps__split_calls__1 [arg_6] = EXC.function_clause unit
erlps__split_calls__1 args =
  EXC.badarity (ErlangFun 1 erlps__split_calls__1) args

erlps__split_calls__4 :: ErlangFun
erlps__split_calls__4 [ref_0, (ErlangEmptyList), acc_1, blocks_2]
  =
  let   
    tup_el_6 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in let head_4 = ErlangTuple [ref_0, tup_el_6]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_4 blocks_2]
erlps__split_calls__4 [ref_0, (ErlangCons i_1 code_2), acc_3,
                       blocks_4]
  | (((((((onElement (toErl 1) i_1 weakEq (ErlangAtom "CALL")) ||
            (onElement (toErl 1) i_1 weakEq (ErlangAtom "CALL_R"))) ||
           (onElement (toErl 1) i_1 weakEq (ErlangAtom "CALL_GR"))) ||
          (onElement (toErl 1) i_1 weakEq (ErlangAtom "CALL_PGR"))) ||
         (onElement (toErl 1) i_1 weakEq (ErlangAtom "CREATE"))) ||
        (onElement (toErl 1) i_1 weakEq (ErlangAtom "CLONE"))) ||
       (onElement (toErl 1) i_1 weakEq (ErlangAtom "CLONE_G"))) ||
      (onElement (toErl 1) i_1 weakEq (ErlangAtom "jumpif")) =
  let    arg_5 = BIF.erlang__make_ref__0 []
  in let
    tup_el_11 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons i_1 acc_3]
  in let head_9 = ErlangTuple [ref_0, tup_el_11]
  in
    erlps__split_calls__4
      [arg_5, code_2, ErlangEmptyList, ErlangCons head_9 blocks_4]
erlps__split_calls__4 [ref_0,
                       (ErlangCons i_1@(ErlangTuple [(ErlangAtom "ABORT"),
                                                     _]) _code_2),
                       acc_3, blocks_4]
  =
  let   
    tup_el_8 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons i_1 acc_3]
  in let head_6 = ErlangTuple [ref_0, tup_el_8]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_6 blocks_4]
erlps__split_calls__4 [ref_0,
                       (ErlangCons i_1@(ErlangTuple [(ErlangAtom "EXIT"),
                                                     _]) _code_2),
                       acc_3, blocks_4]
  =
  let   
    tup_el_8 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons i_1 acc_3]
  in let head_6 = ErlangTuple [ref_0, tup_el_8]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_6 blocks_4]
erlps__split_calls__4 [ref_0, (ErlangCons i_1 code_2), acc_3,
                       blocks_4]
  =
  erlps__split_calls__4
    [ref_0, code_2, ErlangCons i_1 acc_3, blocks_4]
erlps__split_calls__4 [arg_11, arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__split_calls__4 args =
  EXC.badarity (ErlangFun 4 erlps__split_calls__4) args

erlps__set_labels__2 :: ErlangFun
erlps__set_labels__2 [labels_0, (ErlangTuple [ref_1, code_2])]
  | isEReference ref_1 =
  let    tup_el_3 = BIF.maps__get__2 [ref_1, labels_0]
  in let
    tup_el_6 =
      flmap
        (\ lc_9 ->
           let lcRet_10 = erlps__set_labels__2 [labels_0, lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        code_2
  in ErlangTuple [tup_el_3, tup_el_6]
erlps__set_labels__2 [_labels_0, (ErlangAtom "loop")] =
  let arg_1 = toErl 0
  in BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__jump__1" [arg_1]
erlps__set_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "jump"), ref_1])]
  =
  let arg_2 = BIF.maps__get__2 [ref_1, labels_0]
  in BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__jump__1" [arg_2]
erlps__set_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "jumpif"), arg_1, ref_2])]
  =
  let arg_4 = BIF.maps__get__2 [ref_2, labels_0]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__jumpif__2"
      [arg_1, arg_4]
erlps__set_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "switch"), arg_1, refs_2])]
  =
  let
    case_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = BIF.maps__get__2 [lc_6, labels_0]
           in ErlangCons lcRet_7 ErlangEmptyList)
        refs_2
  in
    case case_3 of
      (ErlangCons r1_10 (ErlangCons r2_11 (ErlangEmptyList))) ->
        BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__switch__3"
          [arg_1, r1_10, r2_11]
      (ErlangCons r1_15 (ErlangCons r2_16 (ErlangCons r3_17 (ErlangEmptyList)))) ->
        BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__switch__4"
          [arg_1, r1_15, r2_16, r3_17]
      rs_22 ->
        BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__switch__2"
          [arg_1, rs_22]
erlps__set_labels__2 [_, i_0] = i_0
erlps__set_labels__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__set_labels__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_labels__2) args

erlps__with_ixs__1 :: ErlangFun
erlps__with_ixs__1 [xs_0] =
  let    arg_2 = toErl 0
  in let lop_4 = BIF.erlang__length__1 [xs_0]
  in let rop_6 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [lop_4, rop_6]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_1, xs_0]
erlps__with_ixs__1 [arg_8] = EXC.function_clause unit
erlps__with_ixs__1 args =
  EXC.badarity (ErlangFun 1 erlps__with_ixs__1) args

erlps__drop_common_suffix__2 :: ErlangFun
erlps__drop_common_suffix__2 [xs_0, ys_1] =
  let   
    arg_2 = BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [xs_0]
  in let
    arg_4 = BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [ys_1]
  in erlps__drop_common_suffix_r__2 [arg_2, arg_4]
erlps__drop_common_suffix__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__drop_common_suffix__2 args =
  EXC.badarity (ErlangFun 2 erlps__drop_common_suffix__2) args

erlps__drop_common_suffix_r__2 :: ErlangFun
erlps__drop_common_suffix_r__2 [(ErlangCons x_0 xs_1),
                                (ErlangCons x_2 ys_3)]
  | x_2 == x_0 =
  erlps__drop_common_suffix_r__2 [xs_1, ys_3]
erlps__drop_common_suffix_r__2 [xs_0, ys_1] =
  let   
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [xs_0]
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [ys_1]
  in ErlangTuple [tup_el_2, tup_el_4]
erlps__drop_common_suffix_r__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__drop_common_suffix_r__2 args =
  EXC.badarity (ErlangFun 2 erlps__drop_common_suffix_r__2) args