module Aeso.Fcode.To.Fate(erlps__compile__2,
                          erlps__term_to_fate__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__is_debug__2 :: ErlangFun
erlps__is_debug__2 [tag_0, options_1] =
  let   
    tags_5 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "debug", options_1, ErlangEmptyList]
  in let lop_6 = BIF.erlang__op_eq [tags_5, ErlangAtom "all"]
  in
    case lop_6 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> BIF.lists__member__2 [tag_0, tags_5]
      _ -> EXC.badarg1 lop_6
erlps__is_debug__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__is_debug__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__debug__3 :: ErlangFun
erlps__debug__3 [tag_0, options_1, fun_2] =
  let case_3 = erlps__is_debug__2 [tag_0, options_1]
  in
    case case_3 of
      (ErlangAtom "true") ->
        BIF.erlang__apply__2 [fun_2, ErlangEmptyList]
      (ErlangAtom "false") -> ErlangAtom "ok"
      something_else -> EXC.case_clause something_else
erlps__debug__3 [arg_7, arg_8, arg_9] = EXC.function_clause unit
erlps__debug__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__code_error__1 :: ErlangFun
erlps__code_error__1 [err_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Code.Errors" "erlps__format__1"
        [err_0]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_1]
erlps__code_error__1 [arg_3] = EXC.function_clause unit
erlps__code_error__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__compile__2 :: ErlangFun
erlps__compile__2 [fcode_0, options_1] =
  case fcode_0 of
    (ErlangMap map_2) | (DM.Just functions_4) <-
                          (Map.lookup (ErlangAtom "functions") map_2)
                      , (DM.Just contractname_3) <-
                          (Map.lookup (ErlangAtom "contract_name") map_2) ->
      let   
        sfuns_9 =
          erlps__functions_to_scode__3
            [contractname_3, functions_4, options_1]
      in let sfuns1_12 = erlps__optimize_scode__2 [sfuns_9, options_1]
      in let fatecode_14 = erlps__to_basic_blocks__1 [sfuns1_12]
      in let
        arg_17 =
          ErlangFun 0
            (let
               lambda_18 [] =
                 let    arg_19 = toErl "~s\n"
                 in let
                   head_21 =
                     BIF.do_remote_fun_call "Aeb.Fate.Asm" "erlps__pp__1"
                       [fatecode_14]
                 in
                   BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                     [arg_19, ErlangCons head_21 ErlangEmptyList]
               lambda_18 [] = EXC.function_clause unit
               lambda_18 args = EXC.badarity (ErlangFun 0 lambda_18) args
             in lambda_18)
      in let
        _ = erlps__debug__3 [ErlangAtom "compile", options_1, arg_17]
      in fatecode_14
    _ -> EXC.badmatch fcode_0
erlps__compile__2 [arg_24, arg_25] = EXC.function_clause unit
erlps__compile__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_function_id__1 :: ErlangFun
erlps__make_function_id__1 [x_0] =
  let arg_1 = erlps__make_function_name__1 [x_0]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Code"
      "erlps__symbol_identifier__1" [arg_1]
erlps__make_function_id__1 [arg_3] = EXC.function_clause unit
erlps__make_function_id__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__make_function_name__1 :: ErlangFun
erlps__make_function_name__1 [(ErlangAtom "event")] =
  let    bin_el_0 = toErl 67
  in let bin_el_1 = toErl 104
  in let bin_el_2 = toErl 97
  in let bin_el_3 = toErl 105
  in let bin_el_4 = toErl 110
  in let bin_el_5 = toErl 46
  in let bin_el_6 = toErl 101
  in let bin_el_7 = toErl 118
  in let bin_el_8 = toErl 101
  in let bin_el_9 = toErl 110
  in let bin_el_10 = toErl 116
  in
    ErlangBinary
      (BIN.concat
         [BIN.fromInt bin_el_0 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_3 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_4 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_5 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_9 (toErl 8) 1 BIN.Big,
          BIN.fromInt bin_el_10 (toErl 8) 1 BIN.Big])
erlps__make_function_name__1 [(ErlangTuple [(ErlangAtom "entrypoint"),
                                            name_0])]
  =
  name_0
erlps__make_function_name__1 [(ErlangTuple [(ErlangAtom "local_fun"),
                                            xs_0])]
  =
  let    lop_2 = toErl "."
  in let arg_5 = toErl "."
  in let
    rop_3 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [xs_0, arg_5]
  in let arg_1 = BIF.erlang__op_append [lop_2, rop_3]
  in BIF.erlang__list_to_binary__1 [arg_1]
erlps__make_function_name__1 [arg_6] = EXC.function_clause unit
erlps__make_function_name__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__functions_to_scode__3 :: ErlangFun
erlps__functions_to_scode__3 [contractname_0, functions_1,
                              options_2]
  =
  let    funnames_4 = BIF.maps__keys__1 [functions_1]
  in let lcSrc_6 = BIF.maps__to_list__1 [functions_1]
  in let
    arg_5 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [name_8, (ErlangMap map_9)]) | (DM.Just type_13) <-
                                                           (Map.lookup
                                                              (ErlangAtom
                                                                 "return")
                                                              map_9)
                                                       , (DM.Just attrs_12) <-
                                                           (Map.lookup
                                                              (ErlangAtom
                                                                 "attrs")
                                                              map_9)
                                                       , (DM.Just body_11) <-
                                                           (Map.lookup
                                                              (ErlangAtom
                                                                 "body")
                                                              map_9)
                                                       , (DM.Just args_10) <-
                                                           (Map.lookup
                                                              (ErlangAtom
                                                                 "args")
                                                              map_9) ->
               let    tup_el_16 = erlps__make_function_name__1 [name_8]
               in let
                 tup_el_18 =
                   erlps__function_to_scode__8
                     [contractname_0, funnames_4, name_8, attrs_12, args_10,
                      body_11, type_13, options_2]
               in let lcRet_15 = ErlangTuple [tup_el_16, tup_el_18]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_6
  in BIF.maps__from_list__1 [arg_5]
erlps__functions_to_scode__3 [arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__functions_to_scode__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__function_to_scode__8 :: ErlangFun
erlps__function_to_scode__8 [contractname_0, functions_1, name_2,
                             attrs0_3, args_4, body_5, restype_6, _options_7]
  =
  let matchExpr_12 = erlps__typesig_to_scode__2 [args_4, restype_6]
  in
    case matchExpr_12 of
      (ErlangTuple [argtypes_10, restype1_11]) ->
        let   
          attrs_17 =
            BIF.erlang__op_unAppend
              [attrs0_3, ErlangCons (ErlangAtom "stateful") ErlangEmptyList]
        in let
          arg_18 =
            erlps__init_env__4 [contractname_0, functions_1, name_2, args_4]
        in let scode_24 = erlps__to_scode__2 [arg_18, body_5]
        in let tup_el_26 = ErlangTuple [argtypes_10, restype1_11]
        in ErlangTuple [attrs_17, tup_el_26, scode_24]
      _ -> EXC.badmatch matchExpr_12
erlps__function_to_scode__8 [arg_30, arg_31, arg_32, arg_33,
                             arg_34, arg_35, arg_36, arg_37]
  =
  EXC.function_clause unit
erlps__function_to_scode__8 args =
  EXC.badarity (ErlangFun 8 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__typesig_to_scode__2 :: ErlangFun
erlps__typesig_to_scode__2 [args_0, res_1] =
  let    tup_el_4 = toErl 0
  in let tup_el_5 = ErlangMap Map.empty
  in let arg_3 = ErlangTuple [tup_el_4, tup_el_5]
  in let _ = BIF.erlang__put__2 [ErlangAtom "$tvars", arg_3]
  in let
    tup_el_6 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [_, t_8]) ->
               let lcRet_10 = erlps__type_to_scode__1 [t_8]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_0
  in let tup_el_12 = erlps__type_to_scode__1 [res_1]
  in let r_14 = ErlangTuple [tup_el_6, tup_el_12]
  in let _ = BIF.erlang__erase__1 [ErlangAtom "$tvars"]
  in r_14
erlps__typesig_to_scode__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__typesig_to_scode__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type_to_scode__1 :: ErlangFun
erlps__type_to_scode__1 [(ErlangAtom "integer")] =
  ErlangAtom "integer"
erlps__type_to_scode__1 [(ErlangAtom "boolean")] =
  ErlangAtom "boolean"
erlps__type_to_scode__1 [(ErlangAtom "string")] =
  ErlangAtom "string"
erlps__type_to_scode__1 [(ErlangAtom "address")] =
  ErlangAtom "address"
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "bytes"),
                                       n_0])]
  =
  ErlangTuple [ErlangAtom "bytes", n_0]
erlps__type_to_scode__1 [(ErlangAtom "contract")] =
  ErlangAtom "contract"
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "oracle"), _,
                                       _])]
  =
  ErlangAtom "oracle"
erlps__type_to_scode__1 [(ErlangAtom "oracle_query")] =
  ErlangAtom "oracle_query"
erlps__type_to_scode__1 [(ErlangAtom "name")] = ErlangAtom "name"
erlps__type_to_scode__1 [(ErlangAtom "channel")] =
  ErlangAtom "channel"
erlps__type_to_scode__1 [(ErlangAtom "bits")] = ErlangAtom "bits"
erlps__type_to_scode__1 [(ErlangAtom "any")] = ErlangAtom "any"
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "variant"),
                                       cons_0])]
  =
  let
    tup_el_2 =
      flmap
        (\ lc_5 ->
           let    tup_el_8 = erlps__types_to_scode__1 [lc_5]
           in let lcRet_6 = ErlangTuple [ErlangAtom "tuple", tup_el_8]
           in ErlangCons lcRet_6 ErlangEmptyList)
        cons_0
  in ErlangTuple [ErlangAtom "variant", tup_el_2]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "list"),
                                       type_0])]
  =
  let tup_el_2 = erlps__type_to_scode__1 [type_0]
  in ErlangTuple [ErlangAtom "list", tup_el_2]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                       (ErlangCons type_0 (ErlangEmptyList))])]
  =
  erlps__type_to_scode__1 [type_0]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                       types_0])]
  =
  let tup_el_2 = erlps__types_to_scode__1 [types_0]
  in ErlangTuple [ErlangAtom "tuple", tup_el_2]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "map"), key_0,
                                       val_1])]
  =
  let    tup_el_3 = erlps__type_to_scode__1 [key_0]
  in let tup_el_5 = erlps__type_to_scode__1 [val_1]
  in ErlangTuple [ErlangAtom "map", tup_el_3, tup_el_5]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "function"),
                                       _args_0, _res_1])]
  =
  ErlangTuple
    [ErlangAtom "tuple",
     ErlangCons (ErlangAtom "string")
       (ErlangCons (ErlangAtom "any") ErlangEmptyList)]
erlps__type_to_scode__1 [(ErlangTuple [(ErlangAtom "tvar"),
                                       x_0])]
  =
  let matchExpr_4 = BIF.erlang__get__1 [ErlangAtom "$tvars"]
  in
    case matchExpr_4 of
      (ErlangTuple [i_2, vars_3]) ->
        let
          case_5 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [x_0, vars_3, ErlangAtom "false"]
        in
          case case_5 of
            (ErlangAtom "false") ->
              let    rop_13 = toErl 1
              in let tup_el_11 = BIF.erlang__op_plus [i_2, rop_13]
              in let mapExt_18 = ErlangMap (Map.singleton x_0 i_2)
              in let tup_el_14 = BIF.maps__merge__2 [vars_3, mapExt_18]
              in let arg_10 = ErlangTuple [tup_el_11, tup_el_14]
              in let _ = BIF.erlang__put__2 [ErlangAtom "$tvars", arg_10]
              in ErlangTuple [ErlangAtom "tvar", i_2]
            j_22 -> ErlangTuple [ErlangAtom "tvar", j_22]
      _ -> EXC.badmatch matchExpr_4
erlps__type_to_scode__1 [arg_25] = EXC.function_clause unit
erlps__type_to_scode__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__types_to_scode__1 :: ErlangFun
erlps__types_to_scode__1 [ts_0] =
  let arg_1 = ErlangFun 1 erlps__type_to_scode__1
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_1, ts_0]
erlps__types_to_scode__1 [arg_3] = EXC.function_clause unit
erlps__types_to_scode__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__init_env__4 :: ErlangFun
erlps__init_env__4 [contractname_0, funnames_1, name_2, args_3] =
  let    lcSrc_7 = erlps__with_ixs__1 [args_3]
  in let
    tup_el_6 =
      flmap
        (\ lc_11 ->
           case lc_11 of
             (ErlangTuple [i_9, (ErlangTuple [x_10, _])]) ->
               let    tup_el_14 = ErlangTuple [ErlangAtom "arg", i_9]
               in let lcRet_12 = ErlangTuple [x_10, tup_el_14]
               in ErlangCons lcRet_12 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_7
  in
    ErlangTuple
      [ErlangAtom "env", contractname_0, tup_el_6, funnames_1, name_2,
       ErlangAtom "true"]
erlps__init_env__4 [arg_20, arg_21, arg_22, arg_23] =
  EXC.function_clause unit
erlps__init_env__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__next_var__1 :: ErlangFun
erlps__next_var__1 [(ErlangTuple [(ErlangAtom "env"), _, vars_0,
                                  _, _, _])]
  =
  let    lop_1 = toErl 1
  in let op_arg_5 = toErl 1
  in let head_4 = BIF.erlang__op_neg [op_arg_5]
  in let
    tail_6 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [_, (ErlangTuple [(ErlangAtom "var"), j_8])]) ->
               ErlangCons j_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        vars_0
  in let
    rop_2 =
      BIF.do_remote_fun_call "Lists" "erlps__max__1"
        [ErlangCons head_4 tail_6]
  in BIF.erlang__op_plus [lop_1, rop_2]
erlps__next_var__1 [arg_11] = EXC.function_clause unit
erlps__next_var__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__bind_var__3 :: ErlangFun
erlps__bind_var__3 [name_0, var_1,
                    env_3@(ErlangTuple [(ErlangAtom "env"), _, vars_2, _, _,
                                        _])]
  =
  let head_6 = ErlangTuple [name_0, var_1]
  in
    case env_3 of
      (ErlangTuple [(ErlangAtom "env"), contract_10, vars_11,
                    locals_12, current_function_13, tailpos_14]) ->
        ErlangTuple
          [ErlangAtom "env", contract_10, ErlangCons head_6 vars_2,
           locals_12, current_function_13, tailpos_14]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_var__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__bind_var__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__bind_local__2 :: ErlangFun
erlps__bind_local__2 [name_0, env_1] =
  let    i_3 = erlps__next_var__1 [env_1]
  in let arg_7 = ErlangTuple [ErlangAtom "var", i_3]
  in let tup_el_5 = erlps__bind_var__3 [name_0, arg_7, env_1]
  in ErlangTuple [i_3, tup_el_5]
erlps__bind_local__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__bind_local__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__notail__1 :: ErlangFun
erlps__notail__1 [env_0] =
  case env_0 of
    (ErlangTuple [(ErlangAtom "env"), contract_3, vars_4, locals_5,
                  current_function_6, tailpos_7]) ->
      ErlangTuple
        [ErlangAtom "env", contract_3, vars_4, locals_5,
         current_function_6, ErlangAtom "false"]
    _ -> EXC.badrecord (ErlangAtom "env")
erlps__notail__1 [arg_8] = EXC.function_clause unit
erlps__notail__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lookup_var__2 :: ErlangFun
erlps__lookup_var__2 [(ErlangTuple [(ErlangAtom "env"), _,
                                    vars_0, _, _, _]),
                      x_1]
  =
  let    arg_4 = toErl 1
  in let case_2 = BIF.lists__keyfind__3 [x_1, arg_4, vars_0]
  in
    case case_2 of
      (ErlangTuple [_, var_6]) -> var_6
      (ErlangAtom "false") ->
        let
          arg_7 = ErlangTuple [ErlangAtom "unbound_variable", x_1, vars_0]
        in erlps__code_error__1 [arg_7]
      something_else -> EXC.case_clause something_else
erlps__lookup_var__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__lookup_var__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lit_to_fate__1 :: ErlangFun
erlps__lit_to_fate__1 [l_0] =
  case l_0 of
    (ErlangTuple [(ErlangAtom "int"), n_2]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_integer__1"
        [n_2]
    (ErlangTuple [(ErlangAtom "string"), s_4]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
        [s_4]
    (ErlangTuple [(ErlangAtom "bytes"), b_6]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_bytes__1"
        [b_6]
    (ErlangTuple [(ErlangAtom "bool"), b_8]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_boolean__1"
        [b_8]
    (ErlangTuple [(ErlangAtom "account_pubkey"), k_10]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_address__1"
        [k_10]
    (ErlangTuple [(ErlangAtom "contract_pubkey"), k_12]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_contract__1"
        [k_12]
    (ErlangTuple [(ErlangAtom "oracle_pubkey"), k_14]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_oracle__1"
        [k_14]
    (ErlangTuple [(ErlangAtom "oracle_query_id"), h_16]) ->
      BIF.do_remote_fun_call "Aeb.Fate.Data"
        "erlps__make_oracle_query__1" [h_16]
    (ErlangTuple [(ErlangAtom "typerep"), t_18]) ->
      let arg_19 = erlps__type_to_scode__1 [t_18]
      in
        BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
          [arg_19]
    something_else -> EXC.case_clause something_else
erlps__lit_to_fate__1 [arg_21] = EXC.function_clause unit
erlps__lit_to_fate__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__term_to_fate__1 :: ErlangFun
erlps__term_to_fate__1 [e_0] =
  let arg_1 = ErlangMap Map.empty
  in erlps__term_to_fate__2 [arg_1, e_0]
erlps__term_to_fate__1 [arg_3] = EXC.function_clause unit
erlps__term_to_fate__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__term_to_fate__2 :: ErlangFun
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "lit"), l_1])]
  =
  erlps__lit_to_fate__1 [l_1]
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "-"),
                                      (ErlangCons (ErlangTuple [(ErlangAtom "lit"),
                                                                (ErlangTuple [(ErlangAtom "int"),
                                                                              (ErlangInt num_1)])]) (ErlangCons (ErlangTuple [(ErlangAtom "lit"),
                                                                                                                              (ErlangTuple [(ErlangAtom "int"),
                                                                                                                                            n_2])]) (ErlangEmptyList)))])]
  | (ErlangInt num_1) == (toErl 0) =
  let arg_3 = BIF.erlang__op_neg [n_2]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_integer__1"
      [arg_3]
erlps__term_to_fate__2 [_env_0, (ErlangAtom "nil")] =
  BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_list__1"
    [ErlangEmptyList]
erlps__term_to_fate__2 [env_0,
                        (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "::"),
                                      (ErlangCons hd_1 (ErlangCons tl_2 (ErlangEmptyList)))])]
  =
  let    head_3 = erlps__term_to_fate__2 [env_0, hd_1]
  in let tail_6 = erlps__term_to_fate__2 [env_0, tl_2]
  in ErlangCons head_3 tail_6
erlps__term_to_fate__2 [env_0,
                        (ErlangTuple [(ErlangAtom "tuple"), as_1])]
  =
  let   
    arg_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__term_to_fate__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        as_1
  in let arg_2 = BIF.erlang__list_to_tuple__1 [arg_3]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_tuple__1"
      [arg_2]
erlps__term_to_fate__2 [env_0,
                        (ErlangTuple [(ErlangAtom "con"), ar_1, i_2, as_3])]
  =
  let   
    fateas_10 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__term_to_fate__2 [env_0, lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        as_3
  in let arg_13 = BIF.erlang__list_to_tuple__1 [fateas_10]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_variant__3"
      [ar_1, i_2, arg_13]
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "builtin"),
                                      (ErlangAtom "bits_all"),
                                      (ErlangEmptyList)])]
  =
  let    op_arg_2 = toErl 1
  in let arg_1 = BIF.erlang__op_neg [op_arg_2]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_bits__1"
      [arg_1]
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "builtin"),
                                      (ErlangAtom "bits_none"),
                                      (ErlangEmptyList)])]
  =
  let arg_1 = toErl 0
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_bits__1"
      [arg_1]
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "op"),
                                      (ErlangAtom "bits_set"),
                                      (ErlangCons b_1 (ErlangCons i_2 (ErlangEmptyList)))])]
  =
  let matchExpr_5 = erlps__term_to_fate__1 [b_1]
  in
    case matchExpr_5 of
      (ErlangTuple [(ErlangAtom "bits"), n_4]) ->
        let    j_7 = erlps__term_to_fate__1 [i_2]
        in let lop_12 = toErl 1
        in let rop_11 = BIF.erlang__bsl__2 [lop_12, j_7]
        in let tup_el_9 = BIF.erlang__bor__2 [n_4, rop_11]
        in ErlangTuple [ErlangAtom "bits", tup_el_9]
      _ -> EXC.badmatch matchExpr_5
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "op"),
                                      (ErlangAtom "bits_clear"),
                                      (ErlangCons b_1 (ErlangCons i_2 (ErlangEmptyList)))])]
  =
  let matchExpr_5 = erlps__term_to_fate__1 [b_1]
  in
    case matchExpr_5 of
      (ErlangTuple [(ErlangAtom "bits"), n_4]) ->
        let    j_7 = erlps__term_to_fate__1 [i_2]
        in let lop_13 = toErl 1
        in let op_arg_12 = BIF.erlang__bsl__2 [lop_13, j_7]
        in let rop_11 = BIF.erlang__bnot__1 [op_arg_12]
        in let tup_el_9 = BIF.erlang__band__2 [n_4, rop_11]
        in ErlangTuple [ErlangAtom "bits", tup_el_9]
      _ -> EXC.badmatch matchExpr_5
erlps__term_to_fate__2 [env_0,
                        (ErlangTuple [(ErlangAtom "let"), x_1, e_2, body_3])]
  =
  let    val_6 = erlps__term_to_fate__2 [env_0, e_2]
  in let mapExt_9 = ErlangMap (Map.singleton x_1 val_6)
  in let env1_11 = BIF.maps__merge__2 [env_0, mapExt_9]
  in erlps__term_to_fate__2 [env1_11, body_3]
erlps__term_to_fate__2 [env_0,
                        (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let
    case_2 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [x_1, env_0, ErlangAtom "undefined"]
  in
    case case_2 of
      (ErlangAtom "undefined") ->
        BIF.erlang__throw__1 [ErlangAtom "not_a_fate_value"]
      v_7 -> v_7
erlps__term_to_fate__2 [_env_0,
                        (ErlangTuple [(ErlangAtom "builtin"),
                                      (ErlangAtom "map_empty"),
                                      (ErlangEmptyList)])]
  =
  let arg_1 = ErlangMap Map.empty
  in
    BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_map__1"
      [arg_1]
erlps__term_to_fate__2 [env_0,
                        (ErlangTuple [(ErlangAtom "op"), (ErlangAtom "map_set"),
                                      (ErlangCons m_1 (ErlangCons k_2 (ErlangCons v_3 (ErlangEmptyList))))])]
  =
  let    map_6 = erlps__term_to_fate__2 [env_0, m_1]
  in let key_8 = erlps__term_to_fate__2 [env_0, k_2]
  in let val_11 = erlps__term_to_fate__2 [env_0, v_3]
  in let mapExt_14 = ErlangMap (Map.singleton key_8 val_11)
  in BIF.maps__merge__2 [map_6, mapExt_14]
erlps__term_to_fate__2 [_env_0, _] =
  BIF.erlang__throw__1 [ErlangAtom "not_a_fate_value"]
erlps__term_to_fate__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__term_to_fate__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_scode__2 :: ErlangFun
erlps__to_scode__2 [env_0, t_1] =
  EXC.tryOfCatch (\ _ -> erlps__term_to_fate__1 [t_1])
    (\ of_3 ->
       let    arg_8 = ErlangTuple [ErlangAtom "immediate", of_3]
       in let head_7 = erlps__push__1 [arg_8]
       in ErlangCons head_7 ErlangEmptyList)
    (\ ex_4 ->
       case ex_4 of
         (ErlangTuple [(ErlangAtom "throw"),
                       (ErlangAtom "not_a_fate_value"), _]) ->
           erlps__to_scode1__2 [env_0, t_1]
         ex_5 -> EXC.raise ex_5)
erlps__to_scode__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__to_scode__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_scode1__2 :: ErlangFun
erlps__to_scode1__2 [_env_0,
                     (ErlangTuple [(ErlangAtom "lit"), l_1])]
  =
  let    tup_el_5 = erlps__lit_to_fate__1 [l_1]
  in let arg_3 = ErlangTuple [ErlangAtom "immediate", tup_el_5]
  in let head_2 = erlps__push__1 [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__to_scode1__2 [_env_0, (ErlangAtom "nil")] =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__nil__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "var"), x_1])]
  =
  let    arg_3 = erlps__lookup_var__2 [env_0, x_1]
  in let head_2 = erlps__push__1 [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "con"), ar_1, i_2, as_3])]
  =
  let    n_5 = BIF.erlang__length__1 [as_3]
  in let
    head_6 =
      flmap
        (\ lc_9 ->
           let    arg_11 = erlps__notail__1 [env_0]
           in let lcRet_10 = erlps__to_scode__2 [arg_11, lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        as_3
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let arg_19 = ErlangTuple [ErlangAtom "immediate", ar_1]
  in let arg_22 = ErlangTuple [ErlangAtom "immediate", i_2]
  in let arg_25 = ErlangTuple [ErlangAtom "immediate", n_5]
  in let
    head_15 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__variant__4"
        [arg_16, arg_19, arg_22, arg_25]
  in ErlangCons head_6 (ErlangCons head_15 ErlangEmptyList)
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "tuple"), as_1])]
  =
  let    n_3 = BIF.erlang__length__1 [as_1]
  in let
    head_4 =
      flmap
        (\ lc_7 ->
           let    arg_9 = erlps__notail__1 [env_0]
           in let lcRet_8 = erlps__to_scode__2 [arg_9, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        as_1
  in let head_13 = erlps__tuple__1 [n_3]
  in ErlangCons head_4 (ErlangCons head_13 ErlangEmptyList)
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "proj"), e_1, i_2])]
  =
  let    arg_4 = erlps__notail__1 [env_0]
  in let head_3 = erlps__to_scode__2 [arg_4, e_1]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in let arg_12 = ErlangTuple [ErlangAtom "immediate", i_2]
  in let tup_el_17 = toErl 0
  in let arg_15 = ErlangTuple [ErlangAtom "stack", tup_el_17]
  in let
    head_8 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__element_op__3"
        [arg_9, arg_12, arg_15]
  in ErlangCons head_3 (ErlangCons head_8 ErlangEmptyList)
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "set_proj"), r_1, i_2, e_3])]
  =
  let    arg_5 = erlps__notail__1 [env_0]
  in let head_4 = erlps__to_scode__2 [arg_5, e_3]
  in let arg_10 = erlps__notail__1 [env_0]
  in let head_9 = erlps__to_scode__2 [arg_10, r_1]
  in let tup_el_17 = toErl 0
  in let arg_15 = ErlangTuple [ErlangAtom "stack", tup_el_17]
  in let arg_18 = ErlangTuple [ErlangAtom "immediate", i_2]
  in let tup_el_23 = toErl 0
  in let arg_21 = ErlangTuple [ErlangAtom "stack", tup_el_23]
  in let tup_el_26 = toErl 0
  in let arg_24 = ErlangTuple [ErlangAtom "stack", tup_el_26]
  in let
    head_14 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__setelement__4"
        [arg_15, arg_18, arg_21, arg_24]
  in
    ErlangCons head_4
      (ErlangCons head_9 (ErlangCons head_14 ErlangEmptyList))
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "op"), op_1, args_2])]
  =
  let arg_4 = erlps__op_to_scode__1 [op_1]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "let"), x_1,
                                   (ErlangTuple [(ErlangAtom "var"), y_2]),
                                   body_3])]
  =
  let    arg_5 = erlps__lookup_var__2 [env_0, y_2]
  in let env1_9 = erlps__bind_var__3 [x_1, arg_5, env_0]
  in erlps__to_scode__2 [env1_9, body_3]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "let"), x_1, expr_2, body_3])]
  =
  let matchExpr_8 = erlps__bind_local__2 [x_1, env_0]
  in
    case matchExpr_8 of
      (ErlangTuple [i_6, env1_7]) ->
        let    arg_10 = erlps__notail__1 [env_0]
        in let head_9 = erlps__to_scode__2 [arg_10, expr_2]
        in let arg_15 = ErlangTuple [ErlangAtom "var", i_6]
        in let tup_el_20 = toErl 0
        in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
        in let
          head_14 =
            BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__store__2"
              [arg_15, arg_18]
        in let head_22 = erlps__to_scode__2 [env1_7, body_3]
        in
          ErlangCons head_9
            (ErlangCons head_14 (ErlangCons head_22 ErlangEmptyList))
      _ -> EXC.badmatch matchExpr_8
erlps__to_scode1__2 [env_1@(ErlangTuple [(ErlangAtom "env"), _,
                                         _, _, fun_0, (ErlangAtom "true")]),
                     (ErlangTuple [(ErlangAtom "def"), fun_2, args_3])]
  | fun_2 == fun_0 =
  let   
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [arg_8, (ErlangTuple [is_9, acc_10, env1_11])] =
             let    arg_12 = toErl "_"
             in let matchExpr_16 = erlps__bind_local__2 [arg_12, env1_11]
             in
               case matchExpr_16 of
                 (ErlangTuple [i_14, env2_15]) ->
                   let    arg_17 = erlps__notail__1 [env2_15]
                   in let argcode_20 = erlps__to_scode__2 [arg_17, arg_8]
                   in let arg_26 = ErlangTuple [ErlangAtom "var", i_14]
                   in let tup_el_31 = toErl 0
                   in let arg_29 = ErlangTuple [ErlangAtom "stack", tup_el_31]
                   in let
                     head_25 =
                       BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__store__2"
                         [arg_26, arg_29]
                   in
                     ErlangTuple
                       [ErlangCons i_14 is_9,
                        ErlangCons acc_10
                          (ErlangCons argcode_20
                             (ErlangCons head_25 ErlangEmptyList)),
                        env2_15]
                 _ -> EXC.badmatch matchExpr_16
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let
    arg_39 = ErlangTuple [ErlangEmptyList, ErlangEmptyList, env_1]
  in let
    matchExpr_47 =
      BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
        [arg_4, arg_39, args_3]
  in
    case matchExpr_47 of
      (ErlangTuple [vars_44, code_45, _env_46]) ->
        let    arg_53 = toErl 0
        in let lop_55 = BIF.erlang__length__1 [vars_44]
        in let rop_57 = toErl 1
        in let arg_54 = BIF.erlang__op_minus [lop_55, rop_57]
        in let
          arg_52 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_53, arg_54]
        in let
          arg_58 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [vars_44]
        in let
          lcSrc_51 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_52, arg_58]
        in let
          head_50 =
            flmap
              (\ lc_62 ->
                 case lc_62 of
                   (ErlangTuple [i_60, j_61]) ->
                     let    arg_64 = ErlangTuple [ErlangAtom "arg", i_60]
                     in let arg_67 = ErlangTuple [ErlangAtom "var", j_61]
                     in let
                       lcRet_63 =
                         BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__store__2"
                           [arg_64, arg_67]
                     in ErlangCons lcRet_63 ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_51
        in
          ErlangCons code_45
            (ErlangCons head_50
               (ErlangCons (ErlangAtom "loop") ErlangEmptyList))
      _ -> EXC.badmatch matchExpr_47
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "def"), fun_1, args_2])]
  =
  let    fname_4 = erlps__make_function_id__1 [fun_1]
  in let
    lbl_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
        [fname_4]
  in let arg_10 = ErlangTuple [ErlangAtom "immediate", lbl_6]
  in let arg_8 = erlps__local_call__2 [env_0, arg_10]
  in erlps__call_to_scode__3 [env_0, arg_8, args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "funcall"), fun_1, args_2])]
  =
  let    head_5 = erlps__to_scode__2 [env_0, fun_1]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let head_9 = erlps__local_call__2 [env_0, arg_11]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_5 (ErlangCons head_9 ErlangEmptyList),
       args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "builtin"), b_1, args_2])]
  =
  erlps__builtin_to_scode__3 [env_0, b_1, args_2]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "remote"), argst_1, rett_2, ct_3,
                                   fun_4,
                                   (ErlangCons gas_5 (ErlangCons value_6 args_7))])]
  =
  let    lbl_9 = erlps__make_function_id__1 [fun_4]
  in let
    arg_10 =
      flmap
        (\ lc_13 ->
           let    tup_el_15 = toErl "_"
           in let lcRet_14 = ErlangTuple [tup_el_15, lc_13]
           in ErlangCons lcRet_14 ErlangEmptyList)
        argst_1
  in let matchExpr_20 = erlps__typesig_to_scode__2 [arg_10, rett_2]
  in
    case matchExpr_20 of
      (ErlangTuple [argtypes_18, rettype0_19]) ->
        let    arg_23 = ErlangTuple [ErlangAtom "tuple", argtypes_18]
        in let
          tup_el_22 =
            BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
              [arg_23]
        in let
          argtype_26 = ErlangTuple [ErlangAtom "immediate", tup_el_22]
        in let
          tup_el_28 =
            BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_typerep__1"
              [rettype0_19]
        in let
          rettype_30 = ErlangTuple [ErlangAtom "immediate", tup_el_28]
        in
          case gas_5 of
            (ErlangTuple [(ErlangAtom "builtin"),
                          (ErlangAtom "call_gas_left"), _]) ->
              let    tup_el_34 = toErl 0
              in let arg_32 = ErlangTuple [ErlangAtom "stack", tup_el_34]
              in let tup_el_40 = toErl 0
              in let arg_38 = ErlangTuple [ErlangAtom "stack", tup_el_40]
              in let
                call_41 =
                  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_r__5"
                    [arg_32, lbl_9, argtype_26, rettype_30, arg_38]
              in
                erlps__call_to_scode__3
                  [env_0, call_41, ErlangCons ct_3 (ErlangCons value_6 args_7)]
            _ ->
              let    tup_el_51 = toErl 0
              in let arg_49 = ErlangTuple [ErlangAtom "stack", tup_el_51]
              in let tup_el_57 = toErl 0
              in let arg_55 = ErlangTuple [ErlangAtom "stack", tup_el_57]
              in let tup_el_60 = toErl 0
              in let arg_58 = ErlangTuple [ErlangAtom "stack", tup_el_60]
              in let
                call_61 =
                  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_gr__6"
                    [arg_49, lbl_9, argtype_26, rettype_30, arg_55, arg_58]
              in
                erlps__call_to_scode__3
                  [env_0, call_61,
                   ErlangCons ct_3
                     (ErlangCons value_6 (ErlangCons gas_5 args_7))]
      _ -> EXC.badmatch matchExpr_20
erlps__to_scode1__2 [_env_0,
                     (ErlangTuple [(ErlangAtom "get_state"), reg_1])]
  =
  let    arg_3 = ErlangTuple [ErlangAtom "store", reg_1]
  in let head_2 = erlps__push__1 [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "set_state"), reg_1, val_2])]
  =
  let    tup_el_7 = ErlangTuple [ErlangAtom "store", reg_1]
  in let tup_el_12 = toErl 0
  in let tup_el_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    head_5 = ErlangTuple [ErlangAtom "STORE", tup_el_7, tup_el_10]
  in let arg_15 = toErl 0
  in let head_14 = erlps__tuple__1 [arg_15]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_5 (ErlangCons head_14 ErlangEmptyList),
       ErlangCons val_2 ErlangEmptyList]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "closure"), fun_1, fvs_2])]
  =
  let    tup_el_11 = erlps__make_function_id__1 [fun_1]
  in let tup_el_9 = ErlangTuple [ErlangAtom "string", tup_el_11]
  in let head_7 = ErlangTuple [ErlangAtom "lit", tup_el_9]
  in let
    arg_4 =
      ErlangTuple
        [ErlangAtom "tuple",
         ErlangCons head_7 (ErlangCons fvs_2 ErlangEmptyList)]
  in erlps__to_scode__2 [env_0, arg_4]
erlps__to_scode1__2 [env_0,
                     (ErlangTuple [(ErlangAtom "switch"), case_1])]
  =
  erlps__split_to_scode__2 [env_0, case_1]
erlps__to_scode1__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__to_scode1__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__local_call__2 :: ErlangFun
erlps__local_call__2 [env_0, fun_1]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            case env_0 of
              (ErlangTuple arr_5) | (DM.Just field_4) <- (arr_5 DA.!! 5) ->
                field_4
              _ -> EXC.badrecord (ErlangAtom "env"))) =
  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_t__1" [fun_1]
erlps__local_call__2 [_env_0, fun_1] =
  BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call__1" [fun_1]
erlps__local_call__2 [arg_3, arg_4] = EXC.function_clause unit
erlps__local_call__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_to_scode__2 :: ErlangFun
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "nosplit"), expr_1])]
  =
  let head_4 = erlps__to_scode__2 [env_0, expr_1]
  in
    ErlangCons (ErlangAtom "switch_body")
      (ErlangCons head_4 ErlangEmptyList)
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangTuple [(ErlangAtom "tuple"), _]),
                                        x_1, alts_2])]
  =
  let
    matchExpr_8 = erlps__catchall_to_scode__3 [env_0, x_1, alts_2]
  in
    case matchExpr_8 of
      (ErlangTuple [def_6, alts1_7]) ->
        let    arg_11 = erlps__lookup_var__2 [env_0, x_1]
        in let
          case_12 =
            flmap
              (\ lc_16 ->
                 case lc_16 of
                   (ErlangTuple [(ErlangAtom "case"),
                                 (ErlangTuple [(ErlangAtom "tuple"), xs_14]),
                                 split_15]) ->
                     let lcRet_17 = ErlangTuple [xs_14, split_15]
                     in ErlangCons lcRet_17 ErlangEmptyList
                   _ -> ErlangEmptyList)
              alts1_7
        in let
          alt_34 =
            case case_12 of
              (ErlangEmptyList) -> ErlangAtom "missing"
              (ErlangCons (ErlangTuple [xs_20, s_21]) _) ->
                let matchExpr_27 = erlps__match_tuple__3 [env_0, arg_11, xs_20]
                in
                  case matchExpr_27 of
                    (ErlangTuple [code_25, env1_26]) ->
                      let head_30 = erlps__split_to_scode__2 [env1_26, s_21]
                      in ErlangCons code_25 (ErlangCons head_30 ErlangEmptyList)
                    _ -> EXC.badmatch matchExpr_27
              something_else -> EXC.case_clause something_else
        in let lop_36 = BIF.erlang__op_eq [def_6, ErlangAtom "missing"]
        in let
          case_35 =
            case lop_36 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") ->
                BIF.erlang__op_neq [alt_34, ErlangAtom "missing"]
              _ -> EXC.badarg1 lop_36
        in
          case case_35 of
            (ErlangAtom "true") -> alt_34
            (ErlangAtom "false") ->
              let
                head_41 =
                  ErlangTuple
                    [ErlangAtom "switch", arg_11, ErlangAtom "tuple",
                     ErlangCons alt_34 ErlangEmptyList, def_6]
              in ErlangCons head_41 ErlangEmptyList
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_8
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangAtom "boolean"), x_1, alts_2])]
  =
  let
    matchExpr_8 = erlps__catchall_to_scode__3 [env_0, x_1, alts_2]
  in
    case matchExpr_8 of
      (ErlangTuple [def_6, alts1_7]) ->
        let   
          getalt_21 =
            ErlangFun 1
              (let
                 lambda_9 [b_11] =
                   let    arg_13 = ErlangTuple [ErlangAtom "bool", b_11]
                   in let arg_16 = toErl 2
                   in let
                     case_12 = BIF.lists__keyfind__3 [arg_13, arg_16, alts1_7]
                   in
                     case case_12 of
                       (ErlangAtom "false") -> ErlangAtom "missing"
                       (ErlangTuple [(ErlangAtom "case"), _, s_18]) ->
                         erlps__split_to_scode__2 [env_0, s_18]
                       something_else -> EXC.case_clause something_else
                 lambda_9 [arg_10] = EXC.function_clause unit
                 lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
               in lambda_9)
        in let
          head_22 =
            BIF.erlang__apply__2
              [getalt_21, ErlangCons (ErlangAtom "false") ErlangEmptyList]
        in let
          head_26 =
            BIF.erlang__apply__2
              [getalt_21, ErlangCons (ErlangAtom "true") ErlangEmptyList]
        in let arg_33 = erlps__lookup_var__2 [env_0, x_1]
        in let
          head_34 =
            ErlangTuple
              [ErlangAtom "switch", arg_33, ErlangAtom "boolean",
               ErlangCons head_22 (ErlangCons head_26 ErlangEmptyList), def_6]
        in ErlangCons head_34 ErlangEmptyList
      _ -> EXC.badmatch matchExpr_8
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangTuple [(ErlangAtom "list"), _]),
                                        x_1, alts_2])]
  =
  let
    matchExpr_8 = erlps__catchall_to_scode__3 [env_0, x_1, alts_2]
  in
    case matchExpr_8 of
      (ErlangTuple [def_6, alts1_7]) ->
        let    arg_11 = erlps__lookup_var__2 [env_0, x_1]
        in let
          getalt_63 =
            ErlangFun 1
              (let
                 lambda_12 [p_14] =
                   let
                     case_15 =
                       flmap
                         (\ lc_19 ->
                            case lc_19 of
                              c_18@(ErlangTuple [(ErlangAtom "case"), pat_17,
                                                 _]) ->
                                let    lop_21 = BIF.erlang__op_eq [pat_17, p_14]
                                in let
                                  cond_20 =
                                    case lop_21 of
                                      (ErlangAtom "true") -> ErlangAtom "true"
                                      (ErlangAtom "false") ->
                                        let
                                          lop_24 =
                                            BIF.erlang__is_tuple__1 [pat_17]
                                        in
                                          case lop_24 of
                                            (ErlangAtom "false") ->
                                              ErlangAtom "false"
                                            (ErlangAtom "true") ->
                                              let    arg_27 = toErl 1
                                              in let
                                                lop_26 =
                                                  BIF.erlang__element__2
                                                    [arg_27, pat_17]
                                              in
                                                BIF.erlang__op_eq [lop_26, p_14]
                                            _ -> EXC.badarg1 lop_24
                                      _ -> EXC.badarg1 lop_21
                                in
                                  case cond_20 of
                                    (ErlangAtom "true") ->
                                      ErlangCons c_18 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              _ -> ErlangEmptyList)
                         alts1_7
                   in
                     case case_15 of
                       (ErlangEmptyList) -> ErlangAtom "missing"
                       (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                 (ErlangAtom "nil"),
                                                 s_31]) _) ->
                         erlps__split_to_scode__2 [env_0, s_31]
                       (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                 (ErlangTuple [(ErlangAtom "::"),
                                                               y_34, z_35]),
                                                 s_36]) _) ->
                         let matchExpr_41 = erlps__bind_local__2 [y_34, env_0]
                         in
                           case matchExpr_41 of
                             (ErlangTuple [i_39, env1_40]) ->
                               let
                                 matchExpr_46 =
                                   erlps__bind_local__2 [z_35, env1_40]
                               in
                                 case matchExpr_46 of
                                   (ErlangTuple [j_44, env2_45]) ->
                                     let   
                                       arg_48 =
                                         ErlangTuple [ErlangAtom "var", i_39]
                                     in let
                                       head_47 =
                                         BIF.do_remote_fun_call "Aeb.Fate.Ops"
                                           "erlps__hd__2" [arg_48, arg_11]
                                     in let
                                       arg_54 =
                                         ErlangTuple [ErlangAtom "var", j_44]
                                     in let
                                       head_53 =
                                         BIF.do_remote_fun_call "Aeb.Fate.Ops"
                                           "erlps__tl__2" [arg_54, arg_11]
                                     in let
                                       head_59 =
                                         erlps__split_to_scode__2
                                           [env2_45, s_36]
                                     in
                                       ErlangCons head_47
                                         (ErlangCons head_53
                                            (ErlangCons head_59
                                               ErlangEmptyList))
                                   _ -> EXC.badmatch matchExpr_46
                             _ -> EXC.badmatch matchExpr_41
                       something_else -> EXC.case_clause something_else
                 lambda_12 [arg_13] = EXC.function_clause unit
                 lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
               in lambda_12)
        in let
          head_64 =
            BIF.erlang__apply__2
              [getalt_63, ErlangCons (ErlangAtom "::") ErlangEmptyList]
        in let
          head_68 =
            BIF.erlang__apply__2
              [getalt_63, ErlangCons (ErlangAtom "nil") ErlangEmptyList]
        in let tup_el_76 = toErl 0
        in let arg_74 = ErlangTuple [ErlangAtom "stack", tup_el_76]
        in let
          head_73 =
            BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_nil__2"
              [arg_74, arg_11]
        in let tup_el_83 = toErl 0
        in let tup_el_81 = ErlangTuple [ErlangAtom "stack", tup_el_83]
        in let
          head_79 =
            ErlangTuple
              [ErlangAtom "switch", tup_el_81, ErlangAtom "boolean",
               ErlangCons head_64 (ErlangCons head_68 ErlangEmptyList), def_6]
        in ErlangCons head_73 (ErlangCons head_79 ErlangEmptyList)
      _ -> EXC.badmatch matchExpr_8
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"), type_1, x_2,
                                        alts_3])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_17 = BIF.erlang__op_eq [type_1, ErlangAtom "integer"]
            in
              case lop_17 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [type_1, ErlangAtom "string"]
                _ -> EXC.badarg1 lop_17)) =
  let
    matchExpr_9 = erlps__catchall_to_scode__3 [env_0, x_2, alts_3]
  in
    case matchExpr_9 of
      (ErlangTuple [def_7, alts1_8]) ->
        let arg_12 = erlps__lookup_var__2 [env_0, x_2]
        in
          erlps__literal_split_to_scode__5
            [env_0, type_1, arg_12, alts1_8, def_7]
      _ -> EXC.badmatch matchExpr_9
erlps__split_to_scode__2 [env_0,
                          (ErlangTuple [(ErlangAtom "split"),
                                        (ErlangTuple [(ErlangAtom "variant"),
                                                      cons_1]),
                                        x_2, alts_3])]
  =
  let
    matchExpr_9 = erlps__catchall_to_scode__3 [env_0, x_2, alts_3]
  in
    case matchExpr_9 of
      (ErlangTuple [def_7, alts1_8]) ->
        let    arg_12 = erlps__lookup_var__2 [env_0, x_2]
        in let
          getalt_42 =
            ErlangFun 1
              (let
                 lambda_13 [i_15] =
                   let
                     case_16 =
                       flmap
                         (\ lc_21 ->
                            case lc_21 of
                              (ErlangTuple [(ErlangAtom "case"),
                                            (ErlangTuple [(ErlangAtom "con"), _,
                                                          j_18, xs_19]),
                                            s_20]) ->
                                let cond_22 = BIF.erlang__op_eq [i_15, j_18]
                                in
                                  case cond_22 of
                                    (ErlangAtom "true") ->
                                      let lcRet_25 = ErlangTuple [xs_19, s_20]
                                      in ErlangCons lcRet_25 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              _ -> ErlangEmptyList)
                         alts1_8
                   in
                     case case_16 of
                       (ErlangEmptyList) -> ErlangAtom "missing"
                       (ErlangCons (ErlangTuple [xs_28, s_29]) _) ->
                         let
                           matchExpr_35 =
                             erlps__match_variant__3 [env_0, arg_12, xs_28]
                         in
                           case matchExpr_35 of
                             (ErlangTuple [code_33, env1_34]) ->
                               let
                                 head_38 =
                                   erlps__split_to_scode__2 [env1_34, s_29]
                               in
                                 ErlangCons code_33
                                   (ErlangCons head_38 ErlangEmptyList)
                             _ -> EXC.badmatch matchExpr_35
                       something_else -> EXC.case_clause something_else
                 lambda_13 [arg_14] = EXC.function_clause unit
                 lambda_13 args = EXC.badarity (ErlangFun 1 lambda_13) args
               in lambda_13)
        in let
          tup_el_44 =
            flmap
              (\ lc_47 ->
                 let lcRet_48 = BIF.erlang__length__1 [lc_47]
                 in ErlangCons lcRet_48 ErlangEmptyList)
              cons_1
        in let stype_50 = ErlangTuple [ErlangAtom "variant", tup_el_44]
        in let arg_54 = toErl 0
        in let lop_56 = BIF.erlang__length__1 [cons_1]
        in let rop_58 = toErl 1
        in let arg_55 = BIF.erlang__op_minus [lop_56, rop_58]
        in let
          lcSrc_53 =
            BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_54, arg_55]
        in let
          tup_el_52 =
            flmap
              (\ lc_60 ->
                 let
                   lcRet_61 =
                     BIF.erlang__apply__2
                       [getalt_42, ErlangCons lc_60 ErlangEmptyList]
                 in ErlangCons lcRet_61 ErlangEmptyList)
              lcSrc_53
        in let case_51 = ErlangTuple [tup_el_52, def_7]
        in
          case case_51 of
            (ErlangTuple [(ErlangCons salt_65 (ErlangEmptyList)),
                          (ErlangAtom "missing")]) | weakNEq salt_65
                                                       (ErlangAtom "missing") ->
              salt_65
            (ErlangTuple [salts_66, _]) ->
              let
                head_67 =
                  ErlangTuple
                    [ErlangAtom "switch", arg_12, stype_50, salts_66, def_7]
              in ErlangCons head_67 ErlangEmptyList
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_9
erlps__split_to_scode__2 [arg_74, arg_75] =
  EXC.function_clause unit
erlps__split_to_scode__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__literal_split_to_scode__5 :: ErlangFun
erlps__literal_split_to_scode__5 [_env_0, _type_1, arg_2,
                                  (ErlangEmptyList), def_3]
  =
  ErlangTuple
    [ErlangAtom "switch", arg_2, ErlangAtom "boolean",
     ErlangCons (ErlangAtom "missing")
       (ErlangCons (ErlangAtom "missing") ErlangEmptyList),
     def_3]
erlps__literal_split_to_scode__5 [env_0, type_1, arg_2,
                                  (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                            lit_3,
                                                            body_4]) alts_5),
                                  def_6]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_44 = BIF.erlang__op_eq [type_1, ErlangAtom "integer"]
            in
              case lop_44 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [type_1, ErlangAtom "string"]
                _ -> EXC.badarg1 lop_44)) =
  let    true_9 = erlps__split_to_scode__2 [env_0, body_4]
  in let
    false_16 =
      case alts_5 of
        (ErlangEmptyList) -> ErlangAtom "missing"
        _ ->
          erlps__literal_split_to_scode__5
            [env_0, type_1, arg_2, alts_5, ErlangAtom "missing"]
  in let
    slit_21 =
      case lit_3 of
        (ErlangTuple [(ErlangAtom "int"), n_18]) -> n_18
        (ErlangTuple [(ErlangAtom "string"), s_19]) ->
          BIF.do_remote_fun_call "Aeb.Fate.Data" "erlps__make_string__1"
            [s_19]
        something_else -> EXC.case_clause something_else
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let arg_27 = ErlangTuple [ErlangAtom "immediate", slit_21]
  in let
    head_22 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__eq__3"
        [arg_23, arg_2, arg_27]
  in let tup_el_35 = toErl 0
  in let tup_el_33 = ErlangTuple [ErlangAtom "stack", tup_el_35]
  in let
    head_31 =
      ErlangTuple
        [ErlangAtom "switch", tup_el_33, ErlangAtom "boolean",
         ErlangCons false_16 (ErlangCons true_9 ErlangEmptyList), def_6]
  in ErlangCons head_22 (ErlangCons head_31 ErlangEmptyList)
erlps__literal_split_to_scode__5 [arg_49, arg_50, arg_51, arg_52,
                                  arg_53]
  =
  EXC.function_clause unit
erlps__literal_split_to_scode__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__catchall_to_scode__3 :: ErlangFun
erlps__catchall_to_scode__3 [env_0, x_1, alts_2] =
  erlps__catchall_to_scode__4 [env_0, x_1, alts_2, ErlangEmptyList]
erlps__catchall_to_scode__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__catchall_to_scode__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__catchall_to_scode__4 :: ErlangFun
erlps__catchall_to_scode__4 [env_0, x_1,
                             (ErlangCons (ErlangTuple [(ErlangAtom "case"),
                                                       (ErlangTuple [(ErlangAtom "var"),
                                                                     y_2]),
                                                       split_3]) _),
                             acc_4]
  =
  let    arg_6 = erlps__lookup_var__2 [env_0, x_1]
  in let env1_10 = erlps__bind_var__3 [y_2, arg_6, env_0]
  in let tup_el_11 = erlps__split_to_scode__2 [env1_10, split_3]
  in let
    tup_el_14 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_4]
  in ErlangTuple [tup_el_11, tup_el_14]
erlps__catchall_to_scode__4 [env_0, x_1,
                             (ErlangCons alt_2 alts_3), acc_4]
  =
  erlps__catchall_to_scode__4
    [env_0, x_1, alts_3, ErlangCons alt_2 acc_4]
erlps__catchall_to_scode__4 [_, _, (ErlangEmptyList), acc_0] =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
  in ErlangTuple [ErlangAtom "missing", tup_el_2]
erlps__catchall_to_scode__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__catchall_to_scode__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__match_tuple__3 :: ErlangFun
erlps__match_tuple__3 [env_0, arg_1, xs_2] =
  let    arg_4 = toErl 0
  in let arg_8 = toErl 3
  in let
    arg_5 =
      BIF.erlang__make_fun__3
        [ErlangAtom "aeb_fate_ops", ErlangAtom "element_op", arg_8]
  in erlps__match_tuple__5 [env_0, arg_4, arg_5, arg_1, xs_2]
erlps__match_tuple__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__match_tuple__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__match_variant__3 :: ErlangFun
erlps__match_variant__3 [env_0, arg_1, xs_2] =
  let   
    elem_13 =
      ErlangFun 3
        (let
           lambda_3 [dst_7, i_8, val_9] =
             BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__variant_element__3"
               [dst_7, val_9, i_8]
           lambda_3 [arg_4, arg_5, arg_6] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 3 lambda_3) args
         in lambda_3)
  in let arg_15 = toErl 0
  in erlps__match_tuple__5 [env_0, arg_15, elem_13, arg_1, xs_2]
erlps__match_variant__3 [arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__match_variant__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__match_tuple__5 :: ErlangFun
erlps__match_tuple__5 [env_0, i_1, elem_2, arg_3,
                       (ErlangCons (ErlangCons (ErlangInt num_4) (ErlangEmptyList)) xs_5)]
  | (ErlangInt num_4) == (toErl 95) =
  let    rop_9 = toErl 1
  in let arg_7 = BIF.erlang__op_plus [i_1, rop_9]
  in erlps__match_tuple__5 [env_0, arg_7, elem_2, arg_3, xs_5]
erlps__match_tuple__5 [env_0, i_1, elem_2, arg_3,
                       (ErlangCons x_4 xs_5)]
  =
  let matchExpr_10 = erlps__bind_local__2 [x_4, env_0]
  in
    case matchExpr_10 of
      (ErlangTuple [j_8, env1_9]) ->
        let    rop_14 = toErl 1
        in let arg_12 = BIF.erlang__op_plus [i_1, rop_14]
        in let
          matchExpr_20 =
            erlps__match_tuple__5 [env1_9, arg_12, elem_2, arg_3, xs_5]
        in
          case matchExpr_20 of
            (ErlangTuple [code_18, env2_19]) ->
              let    arg_23 = ErlangTuple [ErlangAtom "var", j_8]
              in let arg_26 = ErlangTuple [ErlangAtom "immediate", i_1]
              in let
                head_22 =
                  BIF.erlang__apply__2
                    [elem_2,
                     ErlangCons arg_23
                       (ErlangCons arg_26 (ErlangCons arg_3 ErlangEmptyList))]
              in
                ErlangTuple
                  [ErlangCons head_22 (ErlangCons code_18 ErlangEmptyList),
                   env2_19]
            _ -> EXC.badmatch matchExpr_20
      _ -> EXC.badmatch matchExpr_10
erlps__match_tuple__5 [env_0, _, _, _, (ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, env_0]
erlps__match_tuple__5 [arg_3, arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__match_tuple__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__call_to_scode__3 :: ErlangFun
erlps__call_to_scode__3 [env_0, callcode_1, args_2] =
  let   
    lcSrc_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [args_2]
  in let
    head_3 =
      flmap
        (\ lc_7 ->
           let    arg_9 = erlps__notail__1 [env_0]
           in let lcRet_8 = erlps__to_scode__2 [arg_9, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        lcSrc_4
  in ErlangCons head_3 (ErlangCons callcode_1 ErlangEmptyList)
erlps__call_to_scode__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__call_to_scode__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__builtin_to_scode__3 :: ErlangFun
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_event"),
                            args_1]
  =
  let    arg_8 = BIF.erlang__length__1 [args_1]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
        [arg_8, arg_10]
  in let
    head_4 =
      BIF.erlang__apply__3
        [ErlangAtom "aeb_fate_ops", ErlangAtom "log", arg_7]
  in let arg_15 = toErl 0
  in let head_14 = erlps__tuple__1 [arg_15]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_4 (ErlangCons head_14 ErlangEmptyList),
       args_1]
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "map_empty"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_empty__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "bits_none"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_none__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "bits_all"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_all__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_to_int"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_to_int__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_to_str"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_to_str__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_concat"),
                            args_1@(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_concat__3"
        [arg_4, arg_7, arg_10]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "bytes_split"),
                            args_1@(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bytes_split__3"
        [arg_4, arg_7, arg_10]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "abort"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__abort__1" [arg_4]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_spend"),
                            args_1@(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    head_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__spend__2"
        [arg_5, arg_8]
  in let arg_13 = toErl 0
  in let head_12 = erlps__tuple__1 [arg_13]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_4 (ErlangCons head_12 ErlangEmptyList),
       args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "chain_balance"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__balance_other__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "chain_block_hash"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__blockhash__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_coinbase"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__beneficiary__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_timestamp"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__timestamp__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_block_height"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__generation__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_difficulty"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__difficulty__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "chain_gas_limit"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gaslimit__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "contract_balance"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__balance__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "contract_address"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__address__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "contract_creator"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__contract_creator__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_origin"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__origin__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_caller"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__caller__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_value"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__call_value__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0,
                            (ErlangAtom "call_gas_price"), (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gasprice__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "call_gas_left"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gas__1" [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_register"),
                            args_7@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _qfee_3 (ErlangCons _ttl_4 (ErlangCons _qtype_5 (ErlangCons _rtype_6 (ErlangEmptyList)))))))]
  =
  let    tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let tup_el_21 = toErl 0
  in let arg_19 = ErlangTuple [ErlangAtom "stack", tup_el_21]
  in let tup_el_24 = toErl 0
  in let arg_22 = ErlangTuple [ErlangAtom "stack", tup_el_24]
  in let tup_el_27 = toErl 0
  in let arg_25 = ErlangTuple [ErlangAtom "stack", tup_el_27]
  in let tup_el_30 = toErl 0
  in let arg_28 = ErlangTuple [ErlangAtom "stack", tup_el_30]
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_register__7"
        [arg_10, arg_13, arg_16, arg_19, arg_22, arg_25, arg_28]
  in erlps__call_to_scode__3 [env_0, arg_9, args_7]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_query_fee"),
                            args_2@(ErlangCons _oracle_1 (ErlangEmptyList))]
  =
  let    tup_el_7 = toErl 0
  in let arg_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
  in let tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_query_fee__2" [arg_5, arg_8]
  in erlps__call_to_scode__3 [env_0, arg_4, args_2]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_query"),
                            args_8@(ErlangCons _oracle_1 (ErlangCons _question_2 (ErlangCons _qfee_3 (ErlangCons _qttl_4 (ErlangCons _rttl_5 (ErlangCons _qtype_6 (ErlangCons _rtype_7 (ErlangEmptyList))))))))]
  =
  let    tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let tup_el_28 = toErl 0
  in let arg_26 = ErlangTuple [ErlangAtom "stack", tup_el_28]
  in let tup_el_31 = toErl 0
  in let arg_29 = ErlangTuple [ErlangAtom "stack", tup_el_31]
  in let tup_el_34 = toErl 0
  in let arg_32 = ErlangTuple [ErlangAtom "stack", tup_el_34]
  in let
    arg_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_query__8"
        [arg_11, arg_14, arg_17, arg_20, arg_23, arg_26, arg_29, arg_32]
  in erlps__call_to_scode__3 [env_0, arg_10, args_8]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_get_question"),
                            args_5@(ErlangCons _oracle_1 (ErlangCons _queryid_2 (ErlangCons _qtype_3 (ErlangCons _rtype_4 (ErlangEmptyList)))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_get_question__5"
        [arg_8, arg_11, arg_14, arg_17, arg_20]
  in erlps__call_to_scode__3 [env_0, arg_7, args_5]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_respond"),
                            args_7@(ErlangCons _sign_1 (ErlangCons _oracle_2 (ErlangCons _queryid_3 (ErlangCons _response_4 (ErlangCons _qtype_5 (ErlangCons _rtype_6 (ErlangEmptyList)))))))]
  =
  let    tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let tup_el_25 = toErl 0
  in let arg_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
  in let tup_el_28 = toErl 0
  in let arg_26 = ErlangTuple [ErlangAtom "stack", tup_el_28]
  in let
    head_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_respond__6"
        [arg_11, arg_14, arg_17, arg_20, arg_23, arg_26]
  in let arg_31 = toErl 0
  in let head_30 = erlps__tuple__1 [arg_31]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_10 (ErlangCons head_30 ErlangEmptyList),
       args_7]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_extend"),
                            args_4@(ErlangCons _sign_1 (ErlangCons _oracle_2 (ErlangCons _ttl_3 (ErlangEmptyList))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_extend__3"
        [arg_8, arg_11, arg_14]
  in let arg_19 = toErl 0
  in let head_18 = erlps__tuple__1 [arg_19]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_7 (ErlangCons head_18 ErlangEmptyList),
       args_4]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_get_answer"),
                            args_5@(ErlangCons _oracle_1 (ErlangCons _queryid_2 (ErlangCons _qtype_3 (ErlangCons _rtype_4 (ErlangEmptyList)))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_get_answer__5"
        [arg_8, arg_11, arg_14, arg_17, arg_20]
  in erlps__call_to_scode__3 [env_0, arg_7, args_5]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "oracle_check"),
                            args_4@(ErlangCons _oracle_1 (ErlangCons _qtype_2 (ErlangCons _rtype_3 (ErlangEmptyList))))]
  =
  let    tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__oracle_check__4"
        [arg_7, arg_10, arg_13, arg_16]
  in erlps__call_to_scode__3 [env_0, arg_6, args_4]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "oracle_check_query"),
                            args_5@(ErlangCons _oracle_1 (ErlangCons _query_2 (ErlangCons _qtype_3 (ErlangCons _rtype_4 (ErlangEmptyList)))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let tup_el_19 = toErl 0
  in let arg_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
  in let tup_el_22 = toErl 0
  in let arg_20 = ErlangTuple [ErlangAtom "stack", tup_el_22]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops"
        "erlps__oracle_check_query__5"
        [arg_8, arg_11, arg_14, arg_17, arg_20]
  in erlps__call_to_scode__3 [env_0, arg_7, args_5]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "address_is_oracle"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_oracle__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "address_is_contract"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_contract__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0,
                            (ErlangAtom "address_is_payable"),
                            args_1@(ErlangCons _ (ErlangEmptyList))]
  =
  let    tup_el_6 = toErl 0
  in let arg_4 = ErlangTuple [ErlangAtom "stack", tup_el_6]
  in let tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let
    arg_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__is_payable__2"
        [arg_4, arg_7]
  in erlps__call_to_scode__3 [env_0, arg_3, args_1]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_resolve"),
                            args_4@(ErlangCons _name_1 (ErlangCons _key_2 (ErlangCons _type_3 (ErlangEmptyList))))]
  =
  let    tup_el_9 = toErl 0
  in let arg_7 = ErlangTuple [ErlangAtom "stack", tup_el_9]
  in let tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_resolve__4"
        [arg_7, arg_10, arg_13, arg_16]
  in erlps__call_to_scode__3 [env_0, arg_6, args_4]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_preclaim"),
                            args_4@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _hash_3 (ErlangEmptyList))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_preclaim__3"
        [arg_8, arg_11, arg_14]
  in let arg_19 = toErl 0
  in let head_18 = erlps__tuple__1 [arg_19]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_7 (ErlangCons head_18 ErlangEmptyList),
       args_4]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_claim"),
                            args_6@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _namestring_3 (ErlangCons _salt_4 (ErlangCons _namefee_5 (ErlangEmptyList))))))]
  =
  let    tup_el_12 = toErl 0
  in let arg_10 = ErlangTuple [ErlangAtom "stack", tup_el_12]
  in let tup_el_15 = toErl 0
  in let arg_13 = ErlangTuple [ErlangAtom "stack", tup_el_15]
  in let tup_el_18 = toErl 0
  in let arg_16 = ErlangTuple [ErlangAtom "stack", tup_el_18]
  in let tup_el_21 = toErl 0
  in let arg_19 = ErlangTuple [ErlangAtom "stack", tup_el_21]
  in let tup_el_24 = toErl 0
  in let arg_22 = ErlangTuple [ErlangAtom "stack", tup_el_24]
  in let
    head_9 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_claim__5"
        [arg_10, arg_13, arg_16, arg_19, arg_22]
  in let arg_27 = toErl 0
  in let head_26 = erlps__tuple__1 [arg_27]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_9 (ErlangCons head_26 ErlangEmptyList),
       args_6]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_transfer"),
                            args_5@(ErlangCons _sign_1 (ErlangCons _from_2 (ErlangCons _to_3 (ErlangCons _name_4 (ErlangEmptyList)))))]
  =
  let    tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in let tup_el_14 = toErl 0
  in let arg_12 = ErlangTuple [ErlangAtom "stack", tup_el_14]
  in let tup_el_17 = toErl 0
  in let arg_15 = ErlangTuple [ErlangAtom "stack", tup_el_17]
  in let tup_el_20 = toErl 0
  in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
  in let
    head_8 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_transfer__4"
        [arg_9, arg_12, arg_15, arg_18]
  in let arg_23 = toErl 0
  in let head_22 = erlps__tuple__1 [arg_23]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_8 (ErlangCons head_22 ErlangEmptyList),
       args_5]
erlps__builtin_to_scode__3 [env_0, (ErlangAtom "aens_revoke"),
                            args_4@(ErlangCons _sign_1 (ErlangCons _account_2 (ErlangCons _name_3 (ErlangEmptyList))))]
  =
  let    tup_el_10 = toErl 0
  in let arg_8 = ErlangTuple [ErlangAtom "stack", tup_el_10]
  in let tup_el_13 = toErl 0
  in let arg_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let tup_el_16 = toErl 0
  in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__aens_revoke__3"
        [arg_8, arg_11, arg_14]
  in let arg_19 = toErl 0
  in let head_18 = erlps__tuple__1 [arg_19]
  in
    erlps__call_to_scode__3
      [env_0, ErlangCons head_7 (ErlangCons head_18 ErlangEmptyList),
       args_4]
erlps__builtin_to_scode__3 [_env_0, (ErlangAtom "auth_tx_hash"),
                            (ErlangEmptyList)]
  =
  let    tup_el_4 = toErl 0
  in let arg_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__auth_tx_hash__1"
        [arg_2]
  in ErlangCons head_1 ErlangEmptyList
erlps__builtin_to_scode__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__builtin_to_scode__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__op_to_scode__1 :: ErlangFun
erlps__op_to_scode__1 [(ErlangAtom "+")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__add__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "-")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sub__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "*")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__mul__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "/")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__divide__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "mod")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__modulo__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "^")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__pow__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "++")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__append__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "::")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__cons__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "<")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__lt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom ">")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__gt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "=<")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__elt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom ">=")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__egt__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "==")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__eq__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "!=")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__neq__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "!")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__not_op__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "map_get")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_lookup__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "map_get_d")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_lookup__4"
      [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "map_set")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_update__4"
      [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "map_from_list")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_from_list__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "map_to_list")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_to_list__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "map_delete")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_delete__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "map_member")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_member__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "map_size")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__map_size___2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "string_length")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_length__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "string_concat")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__str_join__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_set")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_set__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_clear")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_clear__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_test")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_test__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_sum")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_sum__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "bits_intersection")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_and__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_union")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_or__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "bits_difference")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__bits_diff__3"
      [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "address_to_str")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__addr_to_str__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "int_to_str")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__int_to_str__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "contract_to_address")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__contract_to_address__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "address_to_contract")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__address_to_contract__2" [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "crypto_verify_sig")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__verify_sig__4"
      [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "crypto_verify_sig_secp256k1")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__verify_sig_secp256k1__4" [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "crypto_ecverify_secp256k1")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in let tup_el_11 = toErl 0
  in let arg_9 = ErlangTuple [ErlangAtom "stack", tup_el_11]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__ecverify_secp256k1__4" [arg_0, arg_3, arg_6, arg_9]
erlps__op_to_scode__1 [(ErlangAtom "crypto_ecrecover_secp256k1")]
  =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in let tup_el_8 = toErl 0
  in let arg_6 = ErlangTuple [ErlangAtom "stack", tup_el_8]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops"
      "erlps__ecrecover_secp256k1__3" [arg_0, arg_3, arg_6]
erlps__op_to_scode__1 [(ErlangAtom "crypto_sha3")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha3__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "crypto_sha256")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha256__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "crypto_blake2b")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__blake2b__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "string_sha3")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha3__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "string_sha256")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__sha256__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [(ErlangAtom "string_blake2b")] =
  let    tup_el_2 = toErl 0
  in let arg_0 = ErlangTuple [ErlangAtom "stack", tup_el_2]
  in let tup_el_5 = toErl 0
  in let arg_3 = ErlangTuple [ErlangAtom "stack", tup_el_5]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__blake2b__2"
      [arg_0, arg_3]
erlps__op_to_scode__1 [arg_6] = EXC.function_clause unit
erlps__op_to_scode__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__push__1 :: ErlangFun
erlps__push__1 [a_0] =
  let    tup_el_4 = toErl 0
  in let tup_el_2 = ErlangTuple [ErlangAtom "stack", tup_el_4]
  in ErlangTuple [ErlangAtom "STORE", tup_el_2, a_0]
erlps__push__1 [arg_6] = EXC.function_clause unit
erlps__push__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tuple__1 :: ErlangFun
erlps__tuple__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 0) =
  let    tup_el_5 = ErlangTuple []
  in let tup_el_3 = ErlangTuple [ErlangAtom "tuple", tup_el_5]
  in let arg_1 = ErlangTuple [ErlangAtom "immediate", tup_el_3]
  in erlps__push__1 [arg_1]
erlps__tuple__1 [n_0] =
  let    tup_el_3 = toErl 0
  in let arg_1 = ErlangTuple [ErlangAtom "stack", tup_el_3]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__tuple__2"
      [arg_1, n_0]
erlps__tuple__1 [arg_5] = EXC.function_clause unit
erlps__tuple__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__optimize_scode__2 :: ErlangFun
erlps__optimize_scode__2 [funs_0, options_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [name_6, def_7] =
             erlps__optimize_fun__4 [funs_0, name_6, def_7, options_1]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_2, funs_0]
erlps__optimize_scode__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__optimize_scode__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__flatten__1 :: ErlangFun
erlps__flatten__1 [(ErlangAtom "missing")] = ErlangAtom "missing"
erlps__flatten__1 [code_0] =
  let    arg_1 = ErlangFun 1 erlps__flatten_s__1
  in let
    arg_2 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [code_0]
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_1, arg_2]
erlps__flatten__1 [arg_4] = EXC.function_clause unit
erlps__flatten__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__flatten_s__1 :: ErlangFun
erlps__flatten_s__1 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                   type_1, alts_2, catch_3])]
  =
  let   
    tup_el_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__flatten__1 [lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        alts_2
  in let tup_el_13 = erlps__flatten__1 [catch_3]
  in
    ErlangTuple
      [ErlangAtom "switch", arg_0, type_1, tup_el_7, tup_el_13]
erlps__flatten_s__1 [i_0] = i_0
erlps__flatten_s__1 [arg_1] = EXC.function_clause unit
erlps__flatten_s__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__optimize_fun__4 :: ErlangFun
erlps__optimize_fun__4 [_funs_0, name_1,
                        (ErlangTuple [attrs_2, sig_3, code_4]), options_5]
  =
  let    code0_7 = erlps__flatten__1 [code_4]
  in let
    arg_10 =
      ErlangFun 0
        (let
           lambda_11 [] =
             let arg_12 = toErl "Optimizing ~s\n"
             in
               BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                 [arg_12, ErlangCons name_1 ErlangEmptyList]
           lambda_11 [] = EXC.function_clause unit
           lambda_11 args = EXC.badarity (ErlangFun 0 lambda_11) args
         in lambda_11)
  in let _ = erlps__debug__3 [ErlangAtom "opt", options_5, arg_10]
  in let arg_16 = toErl 0
  in let
    code1_19 = erlps__simpl_loop__3 [arg_16, code0_7, options_5]
  in let code2_21 = erlps__desugar__1 [code1_19]
  in ErlangTuple [attrs_2, sig_3, code2_21]
erlps__optimize_fun__4 [arg_25, arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__optimize_fun__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__simpl_loop__3 :: ErlangFun
erlps__simpl_loop__3 [n_0, code_1, options_2]
  | weakGeq n_0 (toErl 10) =
  let   
    arg_5 =
      ErlangFun 0
        (let
           lambda_6 [] =
             let
               arg_7 =
                 toErl "  No simpl_loop fixed_point after ~p iterations.\n\n"
             in
               BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                 [arg_7, ErlangCons n_0 ErlangEmptyList]
           lambda_6 [] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 0 lambda_6) args
         in lambda_6)
  in let _ = erlps__debug__3 [ErlangAtom "opt", options_2, arg_5]
  in code_1
erlps__simpl_loop__3 [n_0, code_1, options_2] =
  let    acode_4 = erlps__annotate_code__1 [code_1]
  in let rop_7 = toErl 0
  in let cond_5 = BIF.erlang__op_eq [n_0, rop_7]
  in let
    _ =
      case cond_5 of
        (ErlangAtom "true") ->
          let   
            arg_11 =
              ErlangFun 0
                (let
                   lambda_12 [] =
                     let    arg_13 = toErl "  annotated:\n~s\n"
                     in let arg_16 = toErl "    "
                     in let head_15 = erlps__pp_ann__2 [arg_16, acode_4]
                     in
                       BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                         [arg_13, ErlangCons head_15 ErlangEmptyList]
                   lambda_12 [] = EXC.function_clause unit
                   lambda_12 args = EXC.badarity (ErlangFun 0 lambda_12) args
                 in lambda_12)
          in let
            lcRet_8 = erlps__debug__3 [ErlangAtom "opt", options_2, arg_11]
          in ErlangCons lcRet_8 ErlangEmptyList
        _ -> ErlangEmptyList
  in let code1_21 = erlps__simplify__2 [acode_4, options_2]
  in let cond_22 = BIF.erlang__op_neq [code1_21, acode_4]
  in let
    _ =
      case cond_22 of
        (ErlangAtom "true") ->
          let   
            arg_28 =
              ErlangFun 0
                (let
                   lambda_29 [] =
                     let    arg_30 = toErl "  optimized:\n~s\n"
                     in let arg_33 = toErl "    "
                     in let head_32 = erlps__pp_ann__2 [arg_33, code1_21]
                     in
                       BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                         [arg_30, ErlangCons head_32 ErlangEmptyList]
                   lambda_29 [] = EXC.function_clause unit
                   lambda_29 args = EXC.badarity (ErlangFun 0 lambda_29) args
                 in lambda_29)
          in let
            lcRet_25 = erlps__debug__3 [ErlangAtom "opt", options_2, arg_28]
          in ErlangCons lcRet_25 ErlangEmptyList
        _ -> ErlangEmptyList
  in let code2_37 = erlps__unannotate__1 [code1_21]
  in let case_38 = BIF.erlang__op_eq [code_1, code2_37]
  in
    case case_38 of
      (ErlangAtom "true") ->
        let   
          arg_43 =
            ErlangFun 0
              (let
                 lambda_44 [] =
                   let   
                     arg_45 =
                       toErl
                         "  Reached simpl_loop fixed point after ~p iteration~s.\n\n"
                   in let
                     head_49 =
                       case ErlangAtom "true" of
                         _ | weakNEq n_0 (toErl 1) -> toErl "s"
                         _ -> toErl ""
                   in
                     BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                       [arg_45,
                        ErlangCons n_0 (ErlangCons head_49 ErlangEmptyList)]
                 lambda_44 [] = EXC.function_clause unit
                 lambda_44 args = EXC.badarity (ErlangFun 0 lambda_44) args
               in lambda_44)
        in let _ = erlps__debug__3 [ErlangAtom "opt", options_2, arg_43]
        in code2_37
      (ErlangAtom "false") ->
        let    rop_53 = toErl 1
        in let arg_51 = BIF.erlang__op_plus [n_0, rop_53]
        in erlps__simpl_loop__3 [arg_51, code2_37, options_2]
      something_else -> EXC.case_clause something_else
erlps__simpl_loop__3 [arg_56, arg_57, arg_58] =
  EXC.function_clause unit
erlps__simpl_loop__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pp_ann__2 :: ErlangFun
erlps__pp_ann__2 [ind_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "switch"), arg_1,
                                            type_2, alts_3, def_4]) code_5)]
  =
  let   
    tags_26 =
      case type_2 of
        (ErlangAtom "boolean") ->
          let    head_7 = toErl "FALSE"
          in let head_9 = toErl "TRUE"
          in ErlangCons head_7 (ErlangCons head_9 ErlangEmptyList)
        (ErlangAtom "tuple") ->
          let head_11 = toErl "(_)"
          in ErlangCons head_11 ErlangEmptyList
        (ErlangTuple [(ErlangAtom "variant"), ar_13]) ->
          let    arg_15 = toErl 0
          in let lop_17 = BIF.erlang__length__1 [ar_13]
          in let rop_19 = toErl 1
          in let arg_16 = BIF.erlang__op_minus [lop_17, rop_19]
          in let
            lcSrc_14 =
              BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_15, arg_16]
          in
            flmap
              (\ lc_21 ->
                 let    lop_23 = toErl "C"
                 in let rop_24 = BIF.erlang__integer_to_list__1 [lc_21]
                 in let lcRet_22 = BIF.erlang__op_append [lop_23, rop_24]
                 in ErlangCons lcRet_22 ErlangEmptyList)
              lcSrc_14
        something_else -> EXC.case_clause something_else
  in let lop_27 = toErl "  "
  in let ind1_29 = BIF.erlang__op_append [lop_27, ind_0]
  in let lop_30 = toErl "  "
  in let ind2_32 = BIF.erlang__op_append [lop_30, ind1_29]
  in let head_35 = toErl "SWITCH "
  in let head_37 = erlps__pp_arg__1 [arg_1]
  in let head_40 = toErl "\n"
  in let
    lcSrc_43 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2" [tags_26, alts_3]
  in let
    head_42 =
      flmap
        (\ lc_48 ->
           case lc_48 of
             (ErlangTuple [tag_46, alt_47]) ->
               let cond_49 = BIF.erlang__op_neq [alt_47, ErlangAtom "missing"]
               in
                 case cond_49 of
                   (ErlangAtom "true") ->
                     let    head_57 = toErl " =>\n"
                     in let head_59 = erlps__pp_ann__2 [ind2_32, alt_47]
                     in
                       ErlangCons
                         (ErlangCons ind1_29
                            (ErlangCons tag_46
                               (ErlangCons head_57
                                  (ErlangCons head_59 ErlangEmptyList))))
                         ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_43
  in let cond_65 = BIF.erlang__op_neq [def_4, ErlangAtom "missing"]
  in let
    head_64 =
      case cond_65 of
        (ErlangAtom "true") ->
          let    head_71 = toErl "_ =>\n"
          in let head_73 = erlps__pp_ann__2 [ind2_32, def_4]
          in
            ErlangCons
              (ErlangCons ind1_29
                 (ErlangCons head_71 (ErlangCons head_73 ErlangEmptyList)))
              ErlangEmptyList
        _ -> ErlangEmptyList
  in let head_78 = erlps__pp_ann__2 [ind_0, code_5]
  in
    ErlangCons ind_0
      (ErlangCons head_35
         (ErlangCons head_37
            (ErlangCons head_40
               (ErlangCons head_42
                  (ErlangCons head_64 (ErlangCons head_78 ErlangEmptyList))))))
erlps__pp_ann__2 [ind_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "i"), (ErlangMap map_1),
                                            i_4]) code_5)]
  | (DM.Just out_3) <- (Map.lookup (ErlangAtom "live_out") map_1)
  , (DM.Just in_2) <- (Map.lookup (ErlangAtom "live_in") map_1) =
  let   
    fmt_17 =
      ErlangFun 1
        (let
           lambda_6 [(ErlangEmptyList)] = toErl "()"
           lambda_6 [xs_8] =
             let   
               arg_9 =
                 flmap
                   (\ lc_12 ->
                      let    arg_14 = erlps__pp_arg__1 [lc_12]
                      in let
                        lcRet_13 =
                          BIF.do_remote_fun_call "Lists" "erlps__flatten__1"
                            [arg_14]
                      in ErlangCons lcRet_13 ErlangEmptyList)
                   xs_8
             in let arg_16 = toErl " "
             in
               BIF.do_remote_fun_call "String" "erlps__join__2" [arg_9, arg_16]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let arg_21 = erlps__desugar_args__1 [i_4]
  in let head_20 = erlps__pp_op__1 [arg_21]
  in let lop_26 = BIF.erlang__op_append [in_2, out_3]
  in let cond_25 = BIF.erlang__op_neq [lop_26, ErlangEmptyList]
  in let
    ann_43 =
      case cond_25 of
        (ErlangAtom "true") ->
          let    head_31 = toErl "   % "
          in let
            head_33 =
              BIF.erlang__apply__2 [fmt_17, ErlangCons in_2 ErlangEmptyList]
          in let head_37 = toErl " -> "
          in let
            head_39 =
              BIF.erlang__apply__2 [fmt_17, ErlangCons out_3 ErlangEmptyList]
          in
            ErlangCons
              (ErlangCons head_31
                 (ErlangCons head_33
                    (ErlangCons head_37 (ErlangCons head_39 ErlangEmptyList))))
              ErlangEmptyList
        _ -> ErlangEmptyList
  in let arg_45 = toErl "~-40s~s\n"
  in let
    head_44 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_45,
         ErlangCons
           (ErlangCons ind_0 (ErlangCons head_20 ErlangEmptyList))
           (ErlangCons ann_43 ErlangEmptyList)]
  in let head_52 = erlps__pp_ann__2 [ind_0, code_5]
  in ErlangCons head_44 (ErlangCons head_52 ErlangEmptyList)
erlps__pp_ann__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__pp_ann__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__pp_ann__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pp_op__1 :: ErlangFun
erlps__pp_op__1 [(ErlangAtom "switch_body")] =
  toErl "SWITCH-BODY"
erlps__pp_op__1 [(ErlangAtom "loop")] = toErl "LOOP"
erlps__pp_op__1 [i_0] =
  let arg_2 = ErlangMap Map.empty
  in
    BIF.do_remote_fun_call "Aeb.Fate.Pp" "erlps__format_op__2"
      [i_0, arg_2]
erlps__pp_op__1 [arg_3] = EXC.function_clause unit
erlps__pp_op__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pp_arg__1 :: ErlangFun
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "immediate"), i_0])]
  =
  let arg_1 = toErl "~w"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons i_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "arg"), n_0])] =
  let arg_1 = toErl "arg~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons n_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "store"), n_0])] =
  let arg_1 = toErl "store~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons n_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "var"), n_0])] =
  let arg_1 = toErl "var~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons n_0 ErlangEmptyList]
erlps__pp_arg__1 [(ErlangTuple [(ErlangAtom "stack"),
                                (ErlangInt num_0)])]
  | (ErlangInt num_0) == (toErl 0) =
  toErl "a"
erlps__pp_arg__1 [arg_1] = EXC.function_clause unit
erlps__pp_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__annotate_code__1 :: ErlangFun
erlps__annotate_code__1 [code_0] =
  let arg_1 = toErl 5
  in erlps__annotate_code__3 [arg_1, ErlangEmptyList, code_0]
erlps__annotate_code__1 [arg_4] = EXC.function_clause unit
erlps__annotate_code__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__annotate_code__3 :: ErlangFun
erlps__annotate_code__3 [fuel_0, livetop_1, code_2] =
  let
    matchExpr_8 =
      erlps__ann_live__3 [livetop_1, code_2, ErlangEmptyList]
  in
    case matchExpr_8 of
      (ErlangTuple [code1_6, livein_7]) ->
        let case_9 = BIF.erlang__op_eq [livein_7, livetop_1]
        in
          case case_9 of
            (ErlangAtom "true") -> code1_6
            (ErlangAtom "false") | weakLeq fuel_0 (toErl 0) ->
              erlps__code_error__1 [ErlangAtom "liveness_analysis_out_of_fuel"]
            (ErlangAtom "false") ->
              let    rop_15 = toErl 1
              in let arg_13 = BIF.erlang__op_minus [fuel_0, rop_15]
              in erlps__annotate_code__3 [arg_13, livein_7, code_2]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_8
erlps__annotate_code__3 [arg_18, arg_19, arg_20] =
  EXC.function_clause unit
erlps__annotate_code__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__ann_live__3 :: ErlangFun
erlps__ann_live__3 [_livetop_0, (ErlangAtom "missing"),
                    _liveout_1]
  =
  ErlangTuple [ErlangAtom "missing", ErlangEmptyList]
erlps__ann_live__3 [_livetop_0, (ErlangEmptyList), liveout_1] =
  ErlangTuple [ErlangEmptyList, liveout_1]
erlps__ann_live__3 [livetop_0, (ErlangCons i_1 is_2), liveout_3]
  =
  let matchExpr_9 = erlps__ann_live__3 [livetop_0, is_2, liveout_3]
  in
    case matchExpr_9 of
      (ErlangTuple [is1_7, livemid_8]) ->
        let
          matchExpr_15 = erlps__ann_live1__3 [livetop_0, i_1, livemid_8]
        in
          case matchExpr_15 of
            (ErlangTuple [i1_13, livein_14]) ->
              ErlangTuple [ErlangCons i1_13 is1_7, livein_14]
            _ -> EXC.badmatch matchExpr_15
      _ -> EXC.badmatch matchExpr_9
erlps__ann_live__3 [arg_20, arg_21, arg_22] =
  EXC.function_clause unit
erlps__ann_live__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__ann_live1__3 :: ErlangFun
erlps__ann_live1__3 [_livetop_0, (ErlangAtom "switch_body"),
                     liveout_1]
  =
  let   
    ann_6 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "live_in") liveout_1,
            DT.Tuple (ErlangAtom "live_out") liveout_1])
  in let
    tup_el_7 =
      ErlangTuple [ErlangAtom "i", ann_6, ErlangAtom "switch_body"]
  in ErlangTuple [tup_el_7, liveout_1]
erlps__ann_live1__3 [livetop_0, (ErlangAtom "loop"), _liveout_1]
  =
  let   
    ann_6 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "live_in") livetop_0,
            DT.Tuple (ErlangAtom "live_out") ErlangEmptyList])
  in let
    tup_el_7 = ErlangTuple [ErlangAtom "i", ann_6, ErlangAtom "loop"]
  in ErlangTuple [tup_el_7, livetop_0]
erlps__ann_live1__3 [livetop_0,
                     (ErlangTuple [(ErlangAtom "switch"), arg_1, type_2, alts_3,
                                   def_4]),
                     liveout_5]
  =
  let    cond_6 = erlps__is_reg__1 [arg_1]
  in let
    read_9 =
      case cond_6 of
        (ErlangAtom "true") -> ErlangCons arg_1 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    arg_10 =
      flmap
        (\ lc_13 ->
           let lcRet_14 = erlps__ann_live__3 [livetop_0, lc_13, liveout_5]
           in ErlangCons lcRet_14 ErlangEmptyList)
        alts_3
  in let
    matchExpr_20 =
      BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_10]
  in
    case matchExpr_20 of
      (ErlangTuple [alts1_18, livealts_19]) ->
        let
          matchExpr_26 = erlps__ann_live__3 [livetop_0, def_4, liveout_5]
        in
          case matchExpr_26 of
            (ErlangTuple [def1_24, livedef_25]) ->
              let   
                livein_32 =
                  BIF.do_remote_fun_call "Ordsets" "erlps__union__1"
                    [ErlangCons read_9 (ErlangCons livedef_25 livealts_19)]
              in let
                tup_el_33 =
                  ErlangTuple
                    [ErlangAtom "switch", arg_1, type_2, alts1_18, def1_24]
              in ErlangTuple [tup_el_33, livein_32]
            _ -> EXC.badmatch matchExpr_26
      _ -> EXC.badmatch matchExpr_20
erlps__ann_live1__3 [_livetop_0, i_1, liveout_2] =
  let matchExpr_7 = erlps__attributes__1 [i_1]
  in
    case matchExpr_7 of
      (ErlangMap map_4) | (DM.Just w_6) <-
                            (Map.lookup (ErlangAtom "write") map_4)
                        , (DM.Just reads0_5) <-
                            (Map.lookup (ErlangAtom "read") map_4) ->
        let    arg_8 = ErlangFun 1 erlps__is_reg__1
        in let
          reads_10 =
            BIF.do_remote_fun_call "Lists" "erlps__filter__2"
              [arg_8, reads0_5]
        in let
          arg_11 =
            BIF.erlang__op_unAppend
              [liveout_2, ErlangCons w_6 ErlangEmptyList]
        in let
          livein_17 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__2"
              [arg_11, reads_10]
        in let
          ann_22 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "live_in") livein_17,
                  DT.Tuple (ErlangAtom "live_out") liveout_2])
        in let tup_el_23 = ErlangTuple [ErlangAtom "i", ann_22, i_1]
        in ErlangTuple [tup_el_23, livein_17]
      _ -> EXC.badmatch matchExpr_7
erlps__ann_live1__3 [arg_28, arg_29, arg_30] =
  EXC.function_clause unit
erlps__ann_live1__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__is_reg__1 :: ErlangFun
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "stack"),
                                (ErlangInt num_0)])]
  | (ErlangInt num_0) == (toErl 0) =
  ErlangAtom "false"
erlps__is_reg__1 [(ErlangAtom "none")] = ErlangAtom "false"
erlps__is_reg__1 [(ErlangAtom "pc")] = ErlangAtom "false"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "immediate"), _])] =
  ErlangAtom "false"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "arg"), _])] =
  ErlangAtom "true"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "store"), _])] =
  ErlangAtom "true"
erlps__is_reg__1 [(ErlangTuple [(ErlangAtom "var"), _])] =
  ErlangAtom "true"
erlps__is_reg__1 [arg_0] = EXC.function_clause unit
erlps__is_reg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__attributes__1 :: ErlangFun
erlps__attributes__1 [i_0] =
  let   
    set_9 =
      ErlangFun 1
        (let
           lambda_1 [l_3] | isEList l_3 =
             BIF.do_remote_fun_call "Ordsets" "erlps__from_list__1" [l_3]
           lambda_1 [x_5] =
             BIF.do_remote_fun_call "Ordsets" "erlps__from_list__1"
               [ErlangCons x_5 ErlangEmptyList]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let
    attr_25 =
      ErlangFun 3
        (let
           lambda_10 [w_14, r_15, p_16] =
             let
               val_20 =
                 BIF.erlang__apply__2 [set_9, ErlangCons r_15 ErlangEmptyList]
             in
               ErlangMap
                 (Map.fromFoldable
                    [DT.Tuple (ErlangAtom "read") val_20,
                     DT.Tuple (ErlangAtom "write") w_14,
                     DT.Tuple (ErlangAtom "pure") p_16])
           lambda_10 [arg_11, arg_12, arg_13] = EXC.function_clause unit
           lambda_10 args = EXC.badarity (ErlangFun 3 lambda_10) args
         in lambda_10)
  in let
    pure_35 =
      ErlangFun 2
        (let
           lambda_26 [w_29, r_30] =
             BIF.erlang__apply__2
               [attr_25,
                ErlangCons w_29
                  (ErlangCons r_30
                     (ErlangCons (ErlangAtom "true") ErlangEmptyList))]
           lambda_26 [arg_27, arg_28] = EXC.function_clause unit
           lambda_26 args = EXC.badarity (ErlangFun 2 lambda_26) args
         in lambda_26)
  in let
    impure_45 =
      ErlangFun 2
        (let
           lambda_36 [w_39, r_40] =
             BIF.erlang__apply__2
               [attr_25,
                ErlangCons w_39
                  (ErlangCons r_40
                     (ErlangCons (ErlangAtom "false") ErlangEmptyList))]
           lambda_36 [arg_37, arg_38] = EXC.function_clause unit
           lambda_36 args = EXC.badarity (ErlangFun 2 lambda_36) args
         in lambda_36)
  in
    case i_0 of
      (ErlangAtom "loop") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangAtom "switch_body") ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangAtom "RETURN") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "RETURNR"), a_56]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_56 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL"), a_60]) ->
        let    tup_el_63 = toErl 0
        in let arg_61 = ErlangTuple [ErlangAtom "stack", tup_el_63]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_61
               (ErlangCons (ErlangCons a_60 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_R"), a_68, _, b_69, c_70,
                    d_71]) ->
        let    tup_el_74 = toErl 0
        in let arg_72 = ErlangTuple [ErlangAtom "stack", tup_el_74]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_72
               (ErlangCons
                  (ErlangCons a_68
                     (ErlangCons b_69
                        (ErlangCons c_70 (ErlangCons d_71 ErlangEmptyList))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_GR"), a_85, _, b_86, c_87, d_88,
                    e_89]) ->
        let    tup_el_92 = toErl 0
        in let arg_90 = ErlangTuple [ErlangAtom "stack", tup_el_92]
        in
          BIF.erlang__apply__2
            [impure_45,
             ErlangCons arg_90
               (ErlangCons
                  (ErlangCons a_85
                     (ErlangCons b_86
                        (ErlangCons c_87
                           (ErlangCons d_88
                              (ErlangCons e_89 ErlangEmptyList)))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_T"), a_105]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons (ErlangCons a_105 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALL_VALUE"), a_111]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_111 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "JUMP"), _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "JUMPIF"), a_118, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_118 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SWITCH_V2"), a_122, _, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_122 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SWITCH_V3"), a_126, _, _, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_126 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SWITCH_VN"), a_130, _]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_130 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "PUSH"), a_134]) ->
        let    tup_el_137 = toErl 0
        in let arg_135 = ErlangTuple [ErlangAtom "stack", tup_el_137]
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons arg_135 (ErlangCons a_134 ErlangEmptyList)]
      (ErlangAtom "DUPA") ->
        let    tup_el_142 = toErl 0
        in let arg_140 = ErlangTuple [ErlangAtom "stack", tup_el_142]
        in let tup_el_145 = toErl 0
        in let arg_143 = ErlangTuple [ErlangAtom "stack", tup_el_145]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_140 (ErlangCons arg_143 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DUP"), a_147]) ->
        let    tup_el_150 = toErl 0
        in let arg_148 = ErlangTuple [ErlangAtom "stack", tup_el_150]
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons arg_148 (ErlangCons a_147 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "POP"), a_153]) ->
        let    tup_el_157 = toErl 0
        in let arg_155 = ErlangTuple [ErlangAtom "stack", tup_el_157]
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons a_153 (ErlangCons arg_155 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STORE"), a_159, b_160]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_159 (ErlangCons b_160 ErlangEmptyList)]
      (ErlangAtom "INCA") ->
        let    tup_el_166 = toErl 0
        in let arg_164 = ErlangTuple [ErlangAtom "stack", tup_el_166]
        in let tup_el_169 = toErl 0
        in let arg_167 = ErlangTuple [ErlangAtom "stack", tup_el_169]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_164 (ErlangCons arg_167 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "INC"), a_171]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_171 (ErlangCons a_171 ErlangEmptyList)]
      (ErlangAtom "DECA") ->
        let    tup_el_177 = toErl 0
        in let arg_175 = ErlangTuple [ErlangAtom "stack", tup_el_177]
        in let tup_el_180 = toErl 0
        in let arg_178 = ErlangTuple [ErlangAtom "stack", tup_el_180]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_175 (ErlangCons arg_178 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DEC"), a_182]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_182 (ErlangCons a_182 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADD"), a_186, b_187, c_188]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_186
             (ErlangCons (ErlangCons b_187 (ErlangCons c_188 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SUB"), a_196, b_197, c_198]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_196
             (ErlangCons (ErlangCons b_197 (ErlangCons c_198 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MUL"), a_206, b_207, c_208]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_206
             (ErlangCons (ErlangCons b_207 (ErlangCons c_208 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DIV"), a_216, b_217, c_218]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_216
             (ErlangCons (ErlangCons b_217 (ErlangCons c_218 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MOD"), a_226, b_227, c_228]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_226
             (ErlangCons (ErlangCons b_227 (ErlangCons c_228 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "POW"), a_236, b_237, c_238]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_236
             (ErlangCons (ErlangCons b_237 (ErlangCons c_238 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LT"), a_246, b_247, c_248]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_246
             (ErlangCons (ErlangCons b_247 (ErlangCons c_248 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GT"), a_256, b_257, c_258]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_256
             (ErlangCons (ErlangCons b_257 (ErlangCons c_258 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "EQ"), a_266, b_267, c_268]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_266
             (ErlangCons (ErlangCons b_267 (ErlangCons c_268 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ELT"), a_276, b_277, c_278]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_276
             (ErlangCons (ErlangCons b_277 (ErlangCons c_278 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "EGT"), a_286, b_287, c_288]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_286
             (ErlangCons (ErlangCons b_287 (ErlangCons c_288 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "NEQ"), a_296, b_297, c_298]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_296
             (ErlangCons (ErlangCons b_297 (ErlangCons c_298 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AND"), a_306, b_307, c_308]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_306
             (ErlangCons (ErlangCons b_307 (ErlangCons c_308 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "OR"), a_316, b_317, c_318]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_316
             (ErlangCons (ErlangCons b_317 (ErlangCons c_318 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "NOT"), a_326, b_327]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_326 (ErlangCons b_327 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "TUPLE"), a_331, n_332]) ->
        let    rop_337 = toErl 0
        in let cond_335 = BIF.erlang__op_greater [n_332, rop_337]
        in let
          arg_334 =
            case cond_335 of
              (ErlangAtom "true") ->
                let    tup_el_340 = toErl 0
                in let lcRet_338 = ErlangTuple [ErlangAtom "stack", tup_el_340]
                in ErlangCons lcRet_338 ErlangEmptyList
              _ -> ErlangEmptyList
        in
          BIF.erlang__apply__2
            [pure_35, ErlangCons a_331 (ErlangCons arg_334 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ELEMENT"), a_342, b_343, c_344]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_342
             (ErlangCons (ErlangCons b_343 (ErlangCons c_344 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SETELEMENT"), a_352, b_353, c_354,
                    d_355]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_352
             (ErlangCons
                (ErlangCons b_353
                   (ErlangCons c_354 (ErlangCons d_355 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_EMPTY"), a_365]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_365 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_LOOKUP"), a_369, b_370, c_371]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_369
             (ErlangCons (ErlangCons b_370 (ErlangCons c_371 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_LOOKUPD"), a_379, b_380, c_381,
                    d_382]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_379
             (ErlangCons
                (ErlangCons b_380
                   (ErlangCons c_381 (ErlangCons d_382 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_UPDATE"), a_392, b_393, c_394,
                    d_395]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_392
             (ErlangCons
                (ErlangCons b_393
                   (ErlangCons c_394 (ErlangCons d_395 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_DELETE"), a_405, b_406, c_407]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_405
             (ErlangCons (ErlangCons b_406 (ErlangCons c_407 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_MEMBER"), a_415, b_416, c_417]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_415
             (ErlangCons (ErlangCons b_416 (ErlangCons c_417 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_FROM_LIST"), a_425, b_426]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_425 (ErlangCons b_426 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_TO_LIST"), a_430, b_431]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_430 (ErlangCons b_431 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MAP_SIZE"), a_435, b_436]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_435 (ErlangCons b_436 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "NIL"), a_440]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_440 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_NIL"), a_444, b_445]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_444 (ErlangCons b_445 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CONS"), a_449, b_450, c_451]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_449
             (ErlangCons (ErlangCons b_450 (ErlangCons c_451 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "HD"), a_459, b_460]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_459 (ErlangCons b_460 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "TL"), a_464, b_465]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_464 (ErlangCons b_465 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LENGTH"), a_469, b_470]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_469 (ErlangCons b_470 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "APPEND"), a_474, b_475, c_476]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_474
             (ErlangCons (ErlangCons b_475 (ErlangCons c_476 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_JOIN"), a_484, b_485, c_486]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_484
             (ErlangCons (ErlangCons b_485 (ErlangCons c_486 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "INT_TO_STR"), a_494, b_495]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_494 (ErlangCons b_495 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADDR_TO_STR"), a_499, b_500]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_499 (ErlangCons b_500 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_REVERSE"), a_504, b_505]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_504 (ErlangCons b_505 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "STR_LENGTH"), a_509, b_510]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_509 (ErlangCons b_510 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "INT_TO_ADDR"), a_514, b_515]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_514 (ErlangCons b_515 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VARIANT"), a_519, b_520, c_521,
                    d_522]) ->
        let    tup_el_527 = toErl 0
        in let head_525 = ErlangTuple [ErlangAtom "stack", tup_el_527]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons a_519
               (ErlangCons
                  (ErlangCons head_525
                     (ErlangCons b_520
                        (ErlangCons c_521 (ErlangCons d_522 ErlangEmptyList))))
                  ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VARIANT_TEST"), a_536, b_537,
                    c_538]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_536
             (ErlangCons (ErlangCons b_537 (ErlangCons c_538 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VARIANT_ELEMENT"), a_546, b_547,
                    c_548]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_546
             (ErlangCons (ErlangCons b_547 (ErlangCons c_548 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangAtom "BITS_NONEA") ->
        let    tup_el_558 = toErl 0
        in let arg_556 = ErlangTuple [ErlangAtom "stack", tup_el_558]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_556 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_NONE"), a_561]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_561 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangAtom "BITS_ALLA") ->
        let    tup_el_567 = toErl 0
        in let arg_565 = ErlangTuple [ErlangAtom "stack", tup_el_567]
        in
          BIF.erlang__apply__2
            [pure_35,
             ErlangCons arg_565 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_ALL"), a_570]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_570 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_ALL_N"), a_574, b_575]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_574 (ErlangCons b_575 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_SET"), a_579, b_580, c_581]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_579
             (ErlangCons (ErlangCons b_580 (ErlangCons c_581 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_CLEAR"), a_589, b_590, c_591]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_589
             (ErlangCons (ErlangCons b_590 (ErlangCons c_591 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_TEST"), a_599, b_600, c_601]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_599
             (ErlangCons (ErlangCons b_600 (ErlangCons c_601 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_SUM"), a_609, b_610]) ->
        BIF.erlang__apply__2
          [pure_35, ErlangCons a_609 (ErlangCons b_610 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_OR"), a_614, b_615, c_616]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_614
             (ErlangCons (ErlangCons b_615 (ErlangCons c_616 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_AND"), a_624, b_625, c_626]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_624
             (ErlangCons (ErlangCons b_625 (ErlangCons c_626 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BITS_DIFF"), a_634, b_635, c_636]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_634
             (ErlangCons (ErlangCons b_635 (ErlangCons c_636 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SHA3"), a_644, b_645]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_644
             (ErlangCons (ErlangCons b_645 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SHA256"), a_651, b_652]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_651
             (ErlangCons (ErlangCons b_652 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLAKE2B"), a_658, b_659]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_658
             (ErlangCons (ErlangCons b_659 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VERIFY_SIG"), a_665, b_666, c_667,
                    d_668]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_665
             (ErlangCons
                (ErlangCons b_666
                   (ErlangCons c_667 (ErlangCons d_668 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "VERIFY_SIG_SECP256K1"), a_678, b_679,
                    c_680, d_681]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_678
             (ErlangCons
                (ErlangCons b_679
                   (ErlangCons c_680 (ErlangCons d_681 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ECVERIFY_SECP256K1"), a_691, b_692,
                    c_693, d_694]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_691
             (ErlangCons
                (ErlangCons b_692
                   (ErlangCons c_693 (ErlangCons d_694 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ECRECOVER_SECP256K1"), a_704, b_705,
                    c_706]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_704
             (ErlangCons (ErlangCons b_705 (ErlangCons c_706 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CONTRACT_TO_ADDRESS"), a_714,
                    b_715]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_714
             (ErlangCons (ErlangCons b_715 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADDRESS_TO_CONTRACT"), a_721,
                    b_722]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_721
             (ErlangCons (ErlangCons b_722 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AUTH_TX_HASH"), a_728]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_728 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_TO_INT"), a_732, b_733]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_732
             (ErlangCons (ErlangCons b_733 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_TO_STR"), a_739, b_740]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_739
             (ErlangCons (ErlangCons b_740 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_CONCAT"), a_746, b_747,
                    c_748]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_746
             (ErlangCons (ErlangCons b_747 (ErlangCons c_748 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BYTES_SPLIT"), a_756, b_757,
                    c_758]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_756
             (ErlangCons (ErlangCons b_757 (ErlangCons c_758 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_CHECK"), a_766, b_767, c_768,
                    d_769]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_766
             (ErlangCons
                (ErlangCons b_767
                   (ErlangCons c_768 (ErlangCons d_769 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_CHECK_QUERY"), a_779, b_780,
                    c_781, d_782, e_783]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_779
             (ErlangCons
                (ErlangCons b_780
                   (ErlangCons c_781
                      (ErlangCons d_782 (ErlangCons e_783 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_ORACLE"), a_795, b_796]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_795
             (ErlangCons (ErlangCons b_796 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_CONTRACT"), a_802, b_803]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_802
             (ErlangCons (ErlangCons b_803 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "IS_PAYABLE"), a_809, b_810]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_809
             (ErlangCons (ErlangCons b_810 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CREATOR"), a_816]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_816 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ADDRESS"), a_820]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_820 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BALANCE"), a_824]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_824 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BALANCE_OTHER"), a_828, b_829]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_828
             (ErlangCons (ErlangCons b_829 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORIGIN"), a_835]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_835 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "CALLER"), a_839]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_839 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GASPRICE"), a_843]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_843 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BLOCKHASH"), a_847, b_848]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_847
             (ErlangCons (ErlangCons b_848 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "BENEFICIARY"), a_854]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_854 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "TIMESTAMP"), a_858]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_858 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GENERATION"), a_862]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_862 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "MICROBLOCK"), a_866]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_866 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "DIFFICULTY"), a_870]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_870 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GASLIMIT"), a_874]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_874 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "GAS"), a_878]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_878 (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG0"), a_882]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons (ErlangCons a_882 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG1"), a_888, b_889]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons (ErlangCons a_888 (ErlangCons b_889 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG2"), a_897, b_898, c_899]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_897
                   (ErlangCons b_898 (ErlangCons c_899 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG3"), a_909, b_910, c_911,
                    d_912]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_909
                   (ErlangCons b_910
                      (ErlangCons c_911 (ErlangCons d_912 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "LOG4"), a_924, b_925, c_926, d_927,
                    e_928]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_924
                   (ErlangCons b_925
                      (ErlangCons c_926
                         (ErlangCons d_927
                            (ErlangCons e_928 ErlangEmptyList)))))
                ErlangEmptyList)]
      (ErlangAtom "DEACTIVATE") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "SPEND"), a_945, b_946]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons (ErlangCons a_945 (ErlangCons b_946 ErlangEmptyList))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_REGISTER"), a_954, b_955,
                    c_956, d_957, e_958, f_959, g_960]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_954
             (ErlangCons
                (ErlangCons b_955
                   (ErlangCons c_956
                      (ErlangCons d_957
                         (ErlangCons e_958
                            (ErlangCons f_959
                               (ErlangCons g_960 ErlangEmptyList))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_QUERY"), a_976, b_977, c_978,
                    d_979, e_980, f_981, g_982, h_983]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons a_976
             (ErlangCons
                (ErlangCons b_977
                   (ErlangCons c_978
                      (ErlangCons d_979
                         (ErlangCons e_980
                            (ErlangCons f_981
                               (ErlangCons g_982
                                  (ErlangCons h_983 ErlangEmptyList)))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_RESPOND"), a_1001, b_1002,
                    c_1003, d_1004, e_1005, f_1006]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1001
                   (ErlangCons b_1002
                      (ErlangCons c_1003
                         (ErlangCons d_1004
                            (ErlangCons e_1005
                               (ErlangCons f_1006 ErlangEmptyList))))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_EXTEND"), a_1022, b_1023,
                    c_1024]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1022
                   (ErlangCons b_1023 (ErlangCons c_1024 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_GET_ANSWER"), a_1034, b_1035,
                    c_1036, d_1037, e_1038]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1034
             (ErlangCons
                (ErlangCons b_1035
                   (ErlangCons c_1036
                      (ErlangCons d_1037 (ErlangCons e_1038 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_GET_QUESTION"), a_1050, b_1051,
                    c_1052, d_1053, e_1054]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1050
             (ErlangCons
                (ErlangCons b_1051
                   (ErlangCons c_1052
                      (ErlangCons d_1053 (ErlangCons e_1054 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ORACLE_QUERY_FEE"), a_1066,
                    b_1067]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1066
             (ErlangCons (ErlangCons b_1067 ErlangEmptyList) ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_RESOLVE"), a_1073, b_1074,
                    c_1075, d_1076]) ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons a_1073
             (ErlangCons
                (ErlangCons b_1074
                   (ErlangCons c_1075 (ErlangCons d_1076 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_PRECLAIM"), a_1086, b_1087,
                    c_1088]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1086
                   (ErlangCons b_1087 (ErlangCons c_1088 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_CLAIM"), a_1098, b_1099, c_1100,
                    d_1101, e_1102]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1098
                   (ErlangCons b_1099
                      (ErlangCons c_1100
                         (ErlangCons d_1101
                            (ErlangCons e_1102 ErlangEmptyList)))))
                ErlangEmptyList)]
      (ErlangAtom "AENS_UPDATE") ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_TRANSFER"), a_1119, b_1120,
                    c_1121, d_1122]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1119
                   (ErlangCons b_1120
                      (ErlangCons c_1121 (ErlangCons d_1122 ErlangEmptyList))))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "AENS_REVOKE"), a_1134, b_1135,
                    c_1136]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "none")
             (ErlangCons
                (ErlangCons a_1134
                   (ErlangCons b_1135 (ErlangCons c_1136 ErlangEmptyList)))
                ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "ABORT"), a_1146]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_1146 ErlangEmptyList)]
      (ErlangTuple [(ErlangAtom "EXIT"), a_1150]) ->
        BIF.erlang__apply__2
          [impure_45,
           ErlangCons (ErlangAtom "pc") (ErlangCons a_1150 ErlangEmptyList)]
      (ErlangAtom "NOP") ->
        BIF.erlang__apply__2
          [pure_35,
           ErlangCons (ErlangAtom "none")
             (ErlangCons ErlangEmptyList ErlangEmptyList)]
      something_else -> EXC.case_clause something_else
erlps__attributes__1 [arg_1157] = EXC.function_clause unit
erlps__attributes__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__var_writes__1 :: ErlangFun
erlps__var_writes__1 [(ErlangTuple [(ErlangAtom "i"), _, i_0])] =
  erlps__var_writes__1 [i_0]
erlps__var_writes__1 [i_0] =
  let matchExpr_4 = erlps__attributes__1 [i_0]
  in
    case matchExpr_4 of
      (ErlangMap map_2) | (DM.Just w_3) <-
                            (Map.lookup (ErlangAtom "write") map_2) ->
        case w_3 of
          (ErlangTuple [(ErlangAtom "var"), _]) ->
            ErlangCons w_3 ErlangEmptyList
          (ErlangTuple [(ErlangAtom "arg"), _]) ->
            ErlangCons w_3 ErlangEmptyList
          (ErlangTuple [(ErlangAtom "store"), _]) ->
            ErlangCons w_3 ErlangEmptyList
          (ErlangTuple [(ErlangAtom "stack"), _]) -> ErlangEmptyList
          (ErlangAtom "none") -> ErlangEmptyList
          (ErlangAtom "pc") -> ErlangEmptyList
          something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_4
erlps__var_writes__1 [arg_12] = EXC.function_clause unit
erlps__var_writes__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__independent__2 :: ErlangFun
erlps__independent__2 [_,
                       (ErlangTuple [(ErlangAtom "switch"), _, _, _, _])]
  =
  ErlangAtom "false"
erlps__independent__2 [(ErlangTuple [(ErlangAtom "i"), _, i_0]),
                       (ErlangTuple [(ErlangAtom "i"), _, j_1])]
  =
  let matchExpr_7 = erlps__attributes__1 [i_0]
  in
    case matchExpr_7 of
      (ErlangMap map_3) | (DM.Just purei_6) <-
                            (Map.lookup (ErlangAtom "pure") map_3)
                        , (DM.Just ri_5) <-
                            (Map.lookup (ErlangAtom "read") map_3)
                        , (DM.Just wi_4) <-
                            (Map.lookup (ErlangAtom "write") map_3) ->
        let matchExpr_13 = erlps__attributes__1 [j_1]
        in
          case matchExpr_13 of
            (ErlangMap map_9) | (DM.Just purej_12) <-
                                  (Map.lookup (ErlangAtom "pure") map_9)
                              , (DM.Just rj_11) <-
                                  (Map.lookup (ErlangAtom "read") map_9)
                              , (DM.Just wj_10) <-
                                  (Map.lookup (ErlangAtom "write") map_9) ->
              let    tup_el_16 = toErl 0
              in let arg_14 = ErlangTuple [ErlangAtom "stack", tup_el_16]
              in let
                stacki_20 = BIF.lists__member__2 [arg_14, ErlangCons wi_4 ri_5]
              in let tup_el_23 = toErl 0
              in let arg_21 = ErlangTuple [ErlangAtom "stack", tup_el_23]
              in let
                stackj_27 =
                  BIF.lists__member__2 [arg_21, ErlangCons wj_10 rj_11]
              in
                case ErlangAtom "true" of
                  _ | (ErlangAtom "true") ==
                        (falsifyErrors
                           (\ _ ->
                              let
                                lop_28 =
                                  BIF.erlang__op_eq [wi_4, ErlangAtom "pc"]
                              in
                                case lop_28 of
                                  (ErlangAtom "true") -> ErlangAtom "true"
                                  (ErlangAtom "false") ->
                                    BIF.erlang__op_eq [wj_10, ErlangAtom "pc"]
                                  _ -> EXC.badarg1 lop_28)) ->
                    ErlangAtom "false"
                  _ | (ErlangAtom "true") ==
                        (falsifyErrors
                           (\ _ ->
                              let
                                op_arg_33 =
                                  BIF.erlang__op_or [purei_6, purej_12]
                              in BIF.erlang__not__1 [op_arg_33])) ->
                    ErlangAtom "false"
                  _ | (ErlangAtom "true") ==
                        (falsifyErrors
                           (\ _ ->
                              BIF.erlang__op_and [stacki_20, stackj_27])) ->
                    ErlangAtom "false"
                  _ | weakEq wi_4 wj_10 -> ErlangAtom "false"
                  _ ->
                    let    op_arg_39 = BIF.lists__member__2 [wi_4, rj_11]
                    in let lop_38 = BIF.erlang__not__1 [op_arg_39]
                    in
                      case lop_38 of
                        (ErlangAtom "false") -> ErlangAtom "false"
                        (ErlangAtom "true") ->
                          let op_arg_42 = BIF.lists__member__2 [wj_10, ri_5]
                          in BIF.erlang__not__1 [op_arg_42]
                        _ -> EXC.badarg1 lop_38
            _ -> EXC.badmatch matchExpr_13
      _ -> EXC.badmatch matchExpr_7
erlps__independent__2 [arg_45, arg_46] = EXC.function_clause unit
erlps__independent__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__merge_ann__2 :: ErlangFun
erlps__merge_ann__2 [(ErlangMap map_0), (ErlangMap map_2)]
  | (DM.Just livein_1) <- (Map.lookup (ErlangAtom "live_in") map_0)
  , (DM.Just liveout_3) <-
      (Map.lookup (ErlangAtom "live_out") map_2) =
  ErlangMap
    (Map.fromFoldable
       [DT.Tuple (ErlangAtom "live_in") livein_1,
        DT.Tuple (ErlangAtom "live_out") liveout_3])
erlps__merge_ann__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__merge_ann__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__swap_instrs__2 :: ErlangFun
erlps__swap_instrs__2 [(ErlangTuple [(ErlangAtom "i"),
                                     (ErlangMap map_0), i_2]),
                       (ErlangTuple [(ErlangAtom "i"), (ErlangMap map_3), j_6])]
  | (DM.Just live1_1) <- (Map.lookup (ErlangAtom "live_in") map_0)
  , (DM.Just live3_5) <- (Map.lookup (ErlangAtom "live_out") map_3)
  , (DM.Just live2_4) <-
      (Map.lookup (ErlangAtom "live_in") map_3) =
  let   
    writesi_9 =
      BIF.do_remote_fun_call "Ordsets" "erlps__subtract__2"
        [live2_4, live1_1]
  in let matchExpr_13 = erlps__attributes__1 [i_2]
  in
    case matchExpr_13 of
      (ErlangMap map_11) | (DM.Just readsi_12) <-
                             (Map.lookup (ErlangAtom "read") map_11) ->
        let   
          arg_15 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__2"
              [live3_5, readsi_12]
        in let
          readsj_18 =
            BIF.do_remote_fun_call "Ordsets" "erlps__subtract__2"
              [live2_4, arg_15]
        in let
          arg_19 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__1"
              [ErlangCons live1_1
                 (ErlangCons live2_4 (ErlangCons live3_5 ErlangEmptyList))]
        in let
          arg_27 =
            BIF.do_remote_fun_call "Ordsets" "erlps__union__2"
              [writesi_9, readsj_18]
        in let
          live2__30 =
            BIF.do_remote_fun_call "Ordsets" "erlps__subtract__2"
              [arg_19, arg_27]
        in let
          tup_el_33 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "live_in") live1_1,
                  DT.Tuple (ErlangAtom "live_out") live2__30])
        in let tup_el_31 = ErlangTuple [ErlangAtom "i", tup_el_33, j_6]
        in let
          tup_el_41 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple (ErlangAtom "live_in") live2__30,
                  DT.Tuple (ErlangAtom "live_out") live3_5])
        in let tup_el_39 = ErlangTuple [ErlangAtom "i", tup_el_41, i_2]
        in ErlangTuple [tup_el_31, tup_el_39]
      _ -> EXC.badmatch matchExpr_13
erlps__swap_instrs__2 [arg_47, arg_48] = EXC.function_clause unit
erlps__swap_instrs__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__live_in__2 :: ErlangFun
erlps__live_in__2 [(ErlangTuple [(ErlangAtom "store"), _]), _] =
  ErlangAtom "true"
erlps__live_in__2 [r_0, (ErlangMap map_1)]
  | (DM.Just livein_2) <-
      (Map.lookup (ErlangAtom "live_in") map_1) =
  BIF.do_remote_fun_call "Ordsets" "erlps__is_element__2"
    [r_0, livein_2]
erlps__live_in__2 [r_0,
                   (ErlangTuple [(ErlangAtom "i"), ann_1, _])]
  =
  erlps__live_in__2 [r_0, ann_1]
erlps__live_in__2 [r_0,
                   (ErlangCons i_1@(ErlangTuple [(ErlangAtom "i"), _, _]) _)]
  =
  erlps__live_in__2 [r_0, i_1]
erlps__live_in__2 [r_0,
                   (ErlangCons (ErlangTuple [(ErlangAtom "switch"), a_1, _,
                                             alts_2, def_3]) _)]
  =
  let lop_4 = BIF.erlang__op_eq [r_0, a_1]
  in
    case lop_4 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") ->
        let
          arg_7 =
            ErlangFun 1
              (let
                 lambda_8 [code_10] = erlps__live_in__2 [r_0, code_10]
                 lambda_8 [arg_9] = EXC.function_clause unit
                 lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
               in lambda_8)
        in
          BIF.do_remote_fun_call "Lists" "erlps__any__2"
            [arg_7, ErlangCons def_3 alts_2]
      _ -> EXC.badarg1 lop_4
erlps__live_in__2 [_, (ErlangAtom "missing")] =
  ErlangAtom "false"
erlps__live_in__2 [_, (ErlangEmptyList)] = ErlangAtom "false"
erlps__live_in__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__live_in__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__live_out__2 :: ErlangFun
erlps__live_out__2 [(ErlangTuple [(ErlangAtom "store"), _]), _] =
  ErlangAtom "true"
erlps__live_out__2 [r_0, (ErlangMap map_1)]
  | (DM.Just liveout_2) <-
      (Map.lookup (ErlangAtom "live_out") map_1) =
  BIF.do_remote_fun_call "Ordsets" "erlps__is_element__2"
    [r_0, liveout_2]
erlps__live_out__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__live_out__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__simplify__2 :: ErlangFun
erlps__simplify__2 [(ErlangEmptyList), _] = ErlangEmptyList
erlps__simplify__2 [(ErlangAtom "missing"), _] =
  ErlangAtom "missing"
erlps__simplify__2 [(ErlangCons i_0 code_1), options_2] =
  let    arg_3 = erlps__simpl_s__2 [i_0, options_2]
  in let arg_6 = erlps__simplify__2 [code_1, options_2]
  in erlps__simpl_top__3 [arg_3, arg_6, options_2]
erlps__simplify__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__simplify__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__simpl_s__2 :: ErlangFun
erlps__simpl_s__2 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                 type_1, alts_2, def_3]),
                   options_4]
  =
  let   
    tup_el_8 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__simplify__2 [lc_11, options_4]
           in ErlangCons lcRet_12 ErlangEmptyList)
        alts_2
  in let tup_el_15 = erlps__simplify__2 [def_3, options_4]
  in
    ErlangTuple
      [ErlangAtom "switch", arg_0, type_1, tup_el_8, tup_el_15]
erlps__simpl_s__2 [i_0, _] = i_0
erlps__simpl_s__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__simpl_s__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__simpl_top__3 :: ErlangFun
erlps__simpl_top__3 [i_0, code_1, options_2] =
  let arg_3 = toErl 5000
  in erlps__simpl_top__4 [arg_3, i_0, code_1, options_2]
erlps__simpl_top__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__simpl_top__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__simpl_top__4 :: ErlangFun
erlps__simpl_top__4 [(ErlangInt num_0), i_1, code_2, _options_3]
  | (ErlangInt num_0) == (toErl 0) =
  let
    arg_4 =
      ErlangTuple [ErlangAtom "optimizer_out_of_fuel", i_1, code_2]
  in erlps__code_error__1 [arg_4]
erlps__simpl_top__4 [fuel_0, i_1, code_2, options_3] =
  let arg_5 = erlps__rules__0 []
  in erlps__apply_rules__5 [fuel_0, arg_5, i_1, code_2, options_3]
erlps__simpl_top__4 [arg_9, arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__simpl_top__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__apply_rules__5 :: ErlangFun
erlps__apply_rules__5 [fuel_0, rules_1, i_2, code_3, options_4] =
  let   
    cons_16 =
      ErlangFun 2
        (let
           lambda_5 [x_8, xs_9] =
             let    rop_12 = toErl 1
             in let arg_10 = BIF.erlang__op_minus [fuel_0, rop_12]
             in erlps__simpl_top__4 [arg_10, x_8, xs_9, options_4]
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let
    case_17 = erlps__apply_rules_once__3 [rules_1, i_2, code_3]
  in
    case case_17 of
      (ErlangAtom "false") -> ErlangCons i_2 code_3
      (ErlangTuple [rname_23, new_24, rest_25]) ->
        let   
          case_26 = erlps__is_debug__2 [ErlangAtom "opt_rules", options_4]
        in let
          _ =
            case case_26 of
              (ErlangAtom "true") ->
                let    arg_32 = BIF.erlang__op_append [new_24, rest_25]
                in let
                  matchExpr_37 =
                    erlps__drop_common_suffix__2 [ErlangCons i_2 code_3, arg_32]
                in
                  case matchExpr_37 of
                    (ErlangTuple [oldcode_35, newcode_36]) ->
                      let
                        arg_40 =
                          ErlangFun 0
                            (let
                               lambda_41 [] =
                                 let   
                                   arg_42 = toErl "  Applied ~p:\n~s  ==>\n~s\n"
                                 in let arg_47 = toErl "    "
                                 in let
                                   head_46 =
                                     erlps__pp_ann__2 [arg_47, oldcode_35]
                                 in let arg_51 = toErl "    "
                                 in let
                                   head_50 =
                                     erlps__pp_ann__2 [arg_51, newcode_36]
                                 in
                                   BIF.do_remote_fun_call "Erlang.Io"
                                     "erlps__format__2"
                                     [arg_42,
                                      ErlangCons rname_23
                                        (ErlangCons head_46
                                           (ErlangCons head_50
                                              ErlangEmptyList))]
                               lambda_41 [] = EXC.function_clause unit
                               lambda_41 args =
                                 EXC.badarity (ErlangFun 0 lambda_41) args
                             in lambda_41)
                      in
                        erlps__debug__3
                          [ErlangAtom "opt_rules", options_4, arg_40]
                    _ -> EXC.badmatch matchExpr_37
              (ErlangAtom "false") -> ErlangAtom "ok"
              something_else -> EXC.case_clause something_else
        in
          BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
            [cons_16, rest_25, new_24]
      something_else -> EXC.case_clause something_else
erlps__apply_rules__5 [arg_57, arg_58, arg_59, arg_60, arg_61] =
  EXC.function_clause unit
erlps__apply_rules__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__apply_rules_once__3 :: ErlangFun
erlps__apply_rules_once__3 [(ErlangEmptyList), _, _] =
  ErlangAtom "false"
erlps__apply_rules_once__3 [(ErlangCons (ErlangTuple [rname_0,
                                                      rule_1]) rules_2),
                            i_3, code_4]
  =
  let
    case_5 =
      BIF.erlang__apply__2
        [rule_1, ErlangCons i_3 (ErlangCons code_4 ErlangEmptyList)]
  in
    case case_5 of
      (ErlangAtom "false") ->
        erlps__apply_rules_once__3 [rules_2, i_3, code_4]
      (ErlangTuple [new_12, rest_13]) ->
        ErlangTuple [rname_0, new_12, rest_13]
      something_else -> EXC.case_clause something_else
erlps__apply_rules_once__3 [arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__apply_rules_once__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__merge_rules__0 :: ErlangFun
erlps__merge_rules__0 [] =
  let    tup_el_2 = ErlangFun 2 erlps__r_push_consume__2
  in let
    head_0 = ErlangTuple [ErlangAtom "r_push_consume", tup_el_2]
  in let tup_el_6 = ErlangFun 2 erlps__r_one_shot_var__2
  in let
    head_4 = ErlangTuple [ErlangAtom "r_one_shot_var", tup_el_6]
  in let tup_el_10 = ErlangFun 2 erlps__r_write_to_dead_var__2
  in let
    head_8 =
      ErlangTuple [ErlangAtom "r_write_to_dead_var", tup_el_10]
  in let tup_el_14 = ErlangFun 2 erlps__r_inline_switch_target__2
  in let
    head_12 =
      ErlangTuple [ErlangAtom "r_inline_switch_target", tup_el_14]
  in
    ErlangCons head_0
      (ErlangCons head_4
         (ErlangCons head_8 (ErlangCons head_12 ErlangEmptyList)))
erlps__merge_rules__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__rules__0 :: ErlangFun
erlps__rules__0 [] =
  let    lop_0 = erlps__merge_rules__0 []
  in let tup_el_4 = ErlangFun 2 erlps__r_swap_push__2
  in let head_2 = ErlangTuple [ErlangAtom "r_swap_push", tup_el_4]
  in let tup_el_8 = ErlangFun 2 erlps__r_swap_pop__2
  in let head_6 = ErlangTuple [ErlangAtom "r_swap_pop", tup_el_8]
  in let tup_el_12 = ErlangFun 2 erlps__r_swap_write__2
  in let
    head_10 = ErlangTuple [ErlangAtom "r_swap_write", tup_el_12]
  in let tup_el_16 = ErlangFun 2 erlps__r_constant_propagation__2
  in let
    head_14 =
      ErlangTuple [ErlangAtom "r_constant_propagation", tup_el_16]
  in let
    tup_el_20 = ErlangFun 2 erlps__r_prune_impossible_branches__2
  in let
    head_18 =
      ErlangTuple [ErlangAtom "r_prune_impossible_branches", tup_el_20]
  in let
    tup_el_24 = ErlangFun 2 erlps__r_single_successful_branch__2
  in let
    head_22 =
      ErlangTuple [ErlangAtom "r_single_successful_branch", tup_el_24]
  in let tup_el_28 = ErlangFun 2 erlps__r_inline_store__2
  in let
    head_26 = ErlangTuple [ErlangAtom "r_inline_store", tup_el_28]
  in let tup_el_32 = ErlangFun 2 erlps__r_float_switch_body__2
  in let
    head_30 =
      ErlangTuple [ErlangAtom "r_float_switch_body", tup_el_32]
  in
    BIF.erlang__op_append
      [lop_0,
       ErlangCons head_2
         (ErlangCons head_6
            (ErlangCons head_10
               (ErlangCons head_14
                  (ErlangCons head_18
                     (ErlangCons head_22
                        (ErlangCons head_26
                           (ErlangCons head_30 ErlangEmptyList)))))))]
erlps__rules__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_push_consume__2 :: ErlangFun
erlps__r_push_consume__2 [(ErlangTuple [(ErlangAtom "i"), ann1_0,
                                        (ErlangTuple [(ErlangAtom "STORE"),
                                                      (ErlangTuple [(ErlangAtom "stack"),
                                                                    (ErlangInt num_1)]),
                                                      a_2])]),
                          code_3]
  | (ErlangInt num_1) == (toErl 0) =
  let arg_6 = toErl 0
  in
    erlps__inline_push__5
      [ann1_0, a_2, arg_6, code_3, ErlangEmptyList]
erlps__r_push_consume__2 [(ErlangTuple [(ErlangAtom "i"), ann1_0,
                                        i_1]),
                          (ErlangCons (ErlangTuple [(ErlangAtom "i"), ann2_2,
                                                    (ErlangTuple [(ErlangAtom "STORE"),
                                                                  r_3,
                                                                  (ErlangTuple [(ErlangAtom "stack"),
                                                                                (ErlangInt num_4)])])]) code_5)]
  | (ErlangInt num_4) == (toErl 0) =
  let    case_7 = erlps__op_view__1 [i_1]
  in let
    lop_6 =
      case case_7 of
        (ErlangTuple [_,
                      (ErlangTuple [(ErlangAtom "stack"), (ErlangInt num_9)]),
                      _]) | (ErlangInt num_9) == (toErl 0) ->
          ErlangAtom "true"
        _ -> ErlangAtom "false"
  in let
    ispush_12 =
      case lop_6 of
        (ErlangAtom "true") -> ErlangAtom "true"
        (ErlangAtom "false") ->
          case i_1 of
            (ErlangTuple [(ErlangAtom "VARIANT"),
                          (ErlangTuple [(ErlangAtom "stack"),
                                        (ErlangInt num_11)]),
                          _, _, _]) | (ErlangInt num_11) == (toErl 0) ->
              ErlangAtom "true"
            _ -> ErlangAtom "false"
        _ -> EXC.badarg1 lop_6
  in
    case ErlangAtom "true" of
      _ | (ErlangAtom "true") == (falsifyErrors (\ _ -> ispush_12)) ->
        let    tup_el_16 = erlps__merge_ann__2 [ann1_0, ann2_2]
        in let arg_20 = toErl 2
        in let tup_el_19 = BIF.erlang__setelement__3 [arg_20, i_1, r_3]
        in let
          head_14 = ErlangTuple [ErlangAtom "i", tup_el_16, tup_el_19]
        in ErlangTuple [ErlangCons head_14 ErlangEmptyList, code_5]
      _ -> ErlangAtom "false"
erlps__r_push_consume__2 [_, _] = ErlangAtom "false"
erlps__r_push_consume__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_push_consume__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__inline_push__5 :: ErlangFun
erlps__inline_push__5 [ann_0, arg_1, stack_2,
                       (ErlangCons ai_3@(ErlangTuple [(ErlangAtom "i"), _,
                                                      (ErlangAtom "switch_body")]) code_4),
                       acc_5]
  =
  let    tup_el_13 = toErl 0
  in let tup_el_11 = ErlangTuple [ErlangAtom "stack", tup_el_13]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "STORE", tup_el_11, arg_1]
  in let arg_6 = ErlangTuple [ErlangAtom "i", ann_0, tup_el_9]
  in let matchExpr_18 = erlps__swap_instrs__2 [arg_6, ai_3]
  in
    case matchExpr_18 of
      (ErlangTuple [ai1_16,
                    (ErlangTuple [(ErlangAtom "i"), ann1_17, _])]) ->
        erlps__inline_push__5
          [ann1_17, arg_1, stack_2, code_4, ErlangCons ai1_16 acc_5]
      _ -> EXC.badmatch matchExpr_18
erlps__inline_push__5 [ann1_0, arg_1, stack_2,
                       (ErlangCons ai_5@(ErlangTuple [(ErlangAtom "i"), ann2_3,
                                                      i_4]) code_6),
                       acc_7]
  =
  let case_8 = erlps__op_view__1 [i_4]
  in
    case case_8 of
      (ErlangTuple [op_10, r_11, as_12]) ->
        let   
          arg_13 =
            flmap
              (\ lc_16 ->
                 case lc_16 of
                   (ErlangTuple [(ErlangAtom "stack"),
                                 (ErlangInt num_15)]) | (ErlangInt num_15) ==
                                                          (toErl 0) ->
                     let    tup_el_19 = toErl 0
                     in let
                       lcRet_17 = ErlangTuple [ErlangAtom "stack", tup_el_19]
                     in ErlangCons lcRet_17 ErlangEmptyList
                   _ -> ErlangEmptyList)
              as_12
        in let consumes_20 = BIF.erlang__length__1 [arg_13]
        in let tup_el_25 = toErl 0
        in let lop_23 = ErlangTuple [ErlangAtom "stack", tup_el_25]
        in let cond_22 = BIF.erlang__op_eq [lop_23, r_11]
        in let
          arg_21 =
            case cond_22 of
              (ErlangAtom "true") ->
                let    tup_el_29 = toErl 0
                in let lcRet_27 = ErlangTuple [ErlangAtom "stack", tup_el_29]
                in ErlangCons lcRet_27 ErlangEmptyList
              _ -> ErlangEmptyList
        in let produces_30 = BIF.erlang__length__1 [arg_21]
        in let case_31 = BIF.erlang__op_greater [consumes_20, stack_2]
        in
          case case_31 of
            (ErlangAtom "true") ->
              let matchExpr_38 = erlps__split_stack_arg__2 [stack_2, as_12]
              in
                case matchExpr_38 of
                  (ErlangTuple [as0_36, as1_37]) ->
                    let    tup_el_41 = erlps__merge_ann__2 [ann1_0, ann2_3]
                    in let
                      rop_49 =
                        BIF.erlang__op_append
                          [ErlangCons arg_1 ErlangEmptyList, as1_37]
                    in let arg_47 = BIF.erlang__op_append [as0_36, rop_49]
                    in let
                      tup_el_44 = erlps__from_op_view__3 [op_10, r_11, arg_47]
                    in let
                      head_39 =
                        ErlangTuple [ErlangAtom "i", tup_el_41, tup_el_44]
                    in let
                      tup_el_56 =
                        BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                          [ErlangCons head_39 acc_7]
                    in ErlangTuple [tup_el_56, code_6]
                  _ -> EXC.badmatch matchExpr_38
            (ErlangAtom "false") | weakNEq arg_1 r_11 ->
              let    tup_el_66 = toErl 0
              in let tup_el_64 = ErlangTuple [ErlangAtom "stack", tup_el_66]
              in let
                tup_el_62 = ErlangTuple [ErlangAtom "STORE", tup_el_64, arg_1]
              in let arg_59 = ErlangTuple [ErlangAtom "i", ann1_0, tup_el_62]
              in let matchExpr_71 = erlps__swap_instrs__2 [arg_59, ai_5]
              in
                case matchExpr_71 of
                  (ErlangTuple [ai1_69,
                                (ErlangTuple [(ErlangAtom "i"), ann1b_70,
                                              _])]) ->
                    let    lop_75 = BIF.erlang__op_plus [stack_2, produces_30]
                    in let arg_74 = BIF.erlang__op_minus [lop_75, consumes_20]
                    in
                      erlps__inline_push__5
                        [ann1b_70, arg_1, arg_74, code_6,
                         ErlangCons ai1_69 acc_7]
                  _ -> EXC.badmatch matchExpr_71
            (ErlangAtom "false") -> ErlangAtom "false"
            something_else -> EXC.case_clause something_else
      _ -> ErlangAtom "false"
erlps__inline_push__5 [_, _, _, _, _] = ErlangAtom "false"
erlps__inline_push__5 [arg_0, arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__inline_push__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_stack_arg__2 :: ErlangFun
erlps__split_stack_arg__2 [n_0, as_1] =
  erlps__split_stack_arg__3 [n_0, as_1, ErlangEmptyList]
erlps__split_stack_arg__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__split_stack_arg__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_stack_arg__3 :: ErlangFun
erlps__split_stack_arg__3 [(ErlangInt num_0),
                           (ErlangCons (ErlangTuple [(ErlangAtom "stack"),
                                                     (ErlangInt num_1)]) as_2),
                           acc_3]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 0) =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_3]
  in ErlangTuple [tup_el_4, as_2]
erlps__split_stack_arg__3 [n_0, (ErlangCons a_1 as_2), acc_3] =
  let
    n1_10 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") ==
              (falsifyErrors
                 (\ _ ->
                    let    tup_el_7 = toErl 0
                    in let rop_5 = ErlangTuple [ErlangAtom "stack", tup_el_7]
                    in BIF.erlang__op_eq [a_1, rop_5])) ->
          let rop_9 = toErl 1
          in BIF.erlang__op_minus [n_0, rop_9]
        _ -> n_0
  in erlps__split_stack_arg__3 [n1_10, as_2, ErlangCons a_1 acc_3]
erlps__split_stack_arg__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__split_stack_arg__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_swap_push__2 :: ErlangFun
erlps__r_swap_push__2 [push_1@(ErlangTuple [(ErlangAtom "i"), _,
                                            pushi_0]),
                       (ErlangCons i_2 code_3)]
  =
  let case_4 = erlps__op_view__1 [pushi_0]
  in
    case case_4 of
      (ErlangTuple [_,
                    (ErlangTuple [(ErlangAtom "stack"), (ErlangInt num_6)]),
                    _]) | (ErlangInt num_6) == (toErl 0) ->
        let case_7 = erlps__independent__2 [push_1, i_2]
        in
          case case_7 of
            (ErlangAtom "true") ->
              let matchExpr_14 = erlps__swap_instrs__2 [push_1, i_2]
              in
                case matchExpr_14 of
                  (ErlangTuple [i1_12, push1_13]) ->
                    ErlangTuple
                      [ErlangCons i1_12 (ErlangCons push1_13 ErlangEmptyList),
                       code_3]
                  _ -> EXC.badmatch matchExpr_14
            (ErlangAtom "false") -> ErlangAtom "false"
            something_else -> EXC.case_clause something_else
      _ -> ErlangAtom "false"
erlps__r_swap_push__2 [_, _] = ErlangAtom "false"
erlps__r_swap_push__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__r_swap_push__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_swap_pop__2 :: ErlangFun
erlps__r_swap_pop__2 [ia_1@(ErlangTuple [(ErlangAtom "i"), _,
                                         i_0]),
                      (ErlangCons ja_3@(ErlangTuple [(ErlangAtom "i"), _,
                                                     j_2]) code_4)]
  =
  let case_5 = erlps__independent__2 [ia_1, ja_3]
  in
    case case_5 of
      (ErlangAtom "true") ->
        let    tup_el_9 = erlps__op_view__1 [i_0]
        in let tup_el_11 = erlps__op_view__1 [j_2]
        in let case_8 = ErlangTuple [tup_el_9, tup_el_11]
        in
          case case_8 of
            (ErlangTuple [(ErlangAtom "false"), _]) -> ErlangAtom "false"
            (ErlangTuple [_, (ErlangAtom "false")]) -> ErlangAtom "false"
            (ErlangTuple [(ErlangTuple [_, ir_13, ias_14]),
                          (ErlangTuple [_, rj_15, jas_16])]) ->
              let    tup_el_20 = toErl 0
              in let arg_18 = ErlangTuple [ErlangAtom "stack", tup_el_20]
              in let
                op_arg_17 =
                  BIF.lists__member__2 [arg_18, ErlangCons ir_13 ias_14]
              in let nonstacki_24 = BIF.erlang__not__1 [op_arg_17]
              in let tup_el_29 = toErl 0
              in let rop_27 = ErlangTuple [ErlangAtom "stack", tup_el_29]
              in let lop_25 = BIF.erlang__op_neq [rj_15, rop_27]
              in let
                popj_34 =
                  case lop_25 of
                    (ErlangAtom "false") -> ErlangAtom "false"
                    (ErlangAtom "true") ->
                      let    tup_el_32 = toErl 0
                      in let
                        arg_30 = ErlangTuple [ErlangAtom "stack", tup_el_32]
                      in BIF.lists__member__2 [arg_30, jas_16]
                    _ -> EXC.badarg1 lop_25
              in let
                case_35 =
                  case nonstacki_24 of
                    (ErlangAtom "false") -> ErlangAtom "false"
                    (ErlangAtom "true") -> popj_34
                    _ -> EXC.badarg1 nonstacki_24
              in
                case case_35 of
                  (ErlangAtom "false") -> ErlangAtom "false"
                  (ErlangAtom "true") ->
                    let matchExpr_41 = erlps__swap_instrs__2 [ia_1, ja_3]
                    in
                      case matchExpr_41 of
                        (ErlangTuple [ja1_39, ia1_40]) ->
                          ErlangTuple
                            [ErlangCons ja1_39
                               (ErlangCons ia1_40 ErlangEmptyList),
                             code_4]
                        _ -> EXC.badmatch matchExpr_41
                  something_else -> EXC.case_clause something_else
            something_else -> EXC.case_clause something_else
      (ErlangAtom "false") -> ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__r_swap_pop__2 [_, _] = ErlangAtom "false"
erlps__r_swap_pop__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__r_swap_pop__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_swap_write__2 :: ErlangFun
erlps__r_swap_write__2 [i_0@(ErlangTuple [(ErlangAtom "i"), _,
                                          _]),
                        (ErlangCons j_1 code_2)]
  =
  let    tup_el_4 = erlps__var_writes__1 [i_0]
  in let tup_el_6 = erlps__independent__2 [i_0, j_1]
  in let case_3 = ErlangTuple [tup_el_4, tup_el_6]
  in
    case case_3 of
      (ErlangTuple [(ErlangCons _ (ErlangEmptyList)),
                    (ErlangAtom "true")]) ->
        let matchExpr_13 = erlps__swap_instrs__2 [i_0, j_1]
        in
          case matchExpr_13 of
            (ErlangTuple [j1_11, i1_12]) ->
              erlps__r_swap_write__3
                [ErlangCons j1_11 ErlangEmptyList, i1_12, code_2]
            _ -> EXC.badmatch matchExpr_13
      _ -> ErlangAtom "false"
erlps__r_swap_write__2 [_, _] = ErlangAtom "false"
erlps__r_swap_write__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__r_swap_write__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_swap_write__3 :: ErlangFun
erlps__r_swap_write__3 [pre_0, i_1,
                        (ErlangCons j_2@(ErlangTuple [(ErlangAtom "i"), _,
                                                      (ErlangAtom "switch_body")]) code_3)]
  =
  let matchExpr_8 = erlps__swap_instrs__2 [i_1, j_2]
  in
    case matchExpr_8 of
      (ErlangTuple [j1_6, i1_7]) ->
        erlps__r_swap_write__3 [ErlangCons j1_6 pre_0, i1_7, code_3]
      _ -> EXC.badmatch matchExpr_8
erlps__r_swap_write__3 [pre_0, i_1,
                        code0_4@(ErlangCons j_2 code_3)]
  =
  let    arg_6 = erlps__merge_rules__0 []
  in let case_5 = erlps__apply_rules_once__3 [arg_6, i_1, code0_4]
  in
    case case_5 of
      (ErlangTuple [_rule_9, new_10, rest_11]) ->
        let   
          lop_13 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [pre_0]
        in let tup_el_12 = BIF.erlang__op_append [lop_13, new_10]
        in ErlangTuple [tup_el_12, rest_11]
      (ErlangAtom "false") ->
        let case_17 = erlps__independent__2 [i_1, j_2]
        in
          case case_17 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              let matchExpr_24 = erlps__swap_instrs__2 [i_1, j_2]
              in
                case matchExpr_24 of
                  (ErlangTuple [j1_22, i1_23]) ->
                    erlps__r_swap_write__3
                      [ErlangCons j1_22 pre_0, i1_23, code_3]
                  _ -> EXC.badmatch matchExpr_24
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__r_swap_write__3 [_, _, _] = ErlangAtom "false"
erlps__r_swap_write__3 [arg_0, arg_1, arg_2] =
  EXC.function_clause unit
erlps__r_swap_write__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_constant_propagation__2 :: ErlangFun
erlps__r_constant_propagation__2 [cons_4@(ErlangTuple [(ErlangAtom "i"),
                                                       ann1_0,
                                                       (ErlangTuple [(ErlangAtom "CONS"),
                                                                     r_1, x_2,
                                                                     xs_3])]),
                                  (ErlangCons (ErlangTuple [(ErlangAtom "i"),
                                                            ann_5,
                                                            (ErlangTuple [(ErlangAtom "IS_NIL"),
                                                                          s_6,
                                                                          r_7])]) code_8)]
  | r_7 == r_1 =
  let   
    tup_el_14 =
      ErlangTuple [ErlangAtom "immediate", ErlangAtom "false"]
  in let
    tup_el_11 = ErlangTuple [ErlangAtom "STORE", s_6, tup_el_14]
  in let store_17 = ErlangTuple [ErlangAtom "i", ann_5, tup_el_11]
  in let
    cons1_29 =
      case r_1 of
        (ErlangTuple [(ErlangAtom "stack"),
                      (ErlangInt num_19)]) | (ErlangInt num_19) == (toErl 0) ->
          let    tup_el_26 = toErl 9999
          in let tup_el_24 = ErlangTuple [ErlangAtom "var", tup_el_26]
          in let
            tup_el_22 = ErlangTuple [ErlangAtom "CONS", tup_el_24, x_2, xs_3]
          in ErlangTuple [ErlangAtom "i", ann1_0, tup_el_22]
        _ -> cons_4
  in
    ErlangTuple
      [ErlangCons cons1_29 (ErlangCons store_17 ErlangEmptyList),
       code_8]
erlps__r_constant_propagation__2 [nil_2@(ErlangTuple [(ErlangAtom "i"),
                                                      ann1_0,
                                                      (ErlangTuple [(ErlangAtom "NIL"),
                                                                    r_1])]),
                                  (ErlangCons (ErlangTuple [(ErlangAtom "i"),
                                                            ann_3,
                                                            (ErlangTuple [(ErlangAtom "IS_NIL"),
                                                                          s_4,
                                                                          r_5])]) code_6)]
  | r_5 == r_1 =
  let   
    tup_el_12 =
      ErlangTuple [ErlangAtom "immediate", ErlangAtom "true"]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "STORE", s_4, tup_el_12]
  in let store_15 = ErlangTuple [ErlangAtom "i", ann_3, tup_el_9]
  in let
    nil1_25 =
      case r_1 of
        (ErlangTuple [(ErlangAtom "stack"),
                      (ErlangInt num_17)]) | (ErlangInt num_17) == (toErl 0) ->
          let    tup_el_24 = toErl 9999
          in let tup_el_22 = ErlangTuple [ErlangAtom "var", tup_el_24]
          in let tup_el_20 = ErlangTuple [ErlangAtom "NIL", tup_el_22]
          in ErlangTuple [ErlangAtom "i", ann1_0, tup_el_20]
        _ -> nil_2
  in
    ErlangTuple
      [ErlangCons nil1_25 (ErlangCons store_15 ErlangEmptyList),
       code_6]
erlps__r_constant_propagation__2 [(ErlangTuple [(ErlangAtom "i"),
                                                ann_0, i_1]),
                                  code_2]
  =
  let case_3 = erlps__op_view__1 [i_1]
  in
    case case_3 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangTuple [op_5, r_6, as_7]) ->
        let   
          vs_12 =
            flmap
              (\ lc_10 ->
                 case lc_10 of
                   (ErlangTuple [(ErlangAtom "immediate"), v_9]) ->
                     ErlangCons v_9 ErlangEmptyList
                   _ -> ErlangEmptyList)
              as_7
        in let lop_14 = BIF.erlang__length__1 [vs_12]
        in let rop_16 = BIF.erlang__length__1 [as_7]
        in let case_13 = BIF.erlang__op_eq [lop_14, rop_16]
        in
          case case_13 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              let case_18 = erlps__eval_op__2 [op_5, vs_12]
              in
                case case_18 of
                  (ErlangAtom "no_eval") -> ErlangAtom "false"
                  v_21 ->
                    let   
                      tup_el_29 = ErlangTuple [ErlangAtom "immediate", v_21]
                    in let
                      tup_el_26 =
                        ErlangTuple [ErlangAtom "STORE", r_6, tup_el_29]
                    in let
                      head_23 = ErlangTuple [ErlangAtom "i", ann_0, tup_el_26]
                    in ErlangTuple [ErlangCons head_23 ErlangEmptyList, code_2]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__r_constant_propagation__2 [_, _] = ErlangAtom "false"
erlps__r_constant_propagation__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_constant_propagation__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__eval_op__2 :: ErlangFun
erlps__eval_op__2 [(ErlangAtom "ADD"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | (isEInt x_0) && (isEInt y_1) =
  BIF.erlang__op_plus [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "SUB"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | (isEInt x_0) && (isEInt y_1) =
  BIF.erlang__op_minus [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "MUL"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | (isEInt x_0) && (isEInt y_1) =
  BIF.erlang__op_mult [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "DIV"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | ((isEInt x_0) && (isEInt y_1)) && (weakNEq y_1 (toErl 0)) =
  BIF.erlang__op_div_strict [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "MOD"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  | ((isEInt x_0) && (isEInt y_1)) && (weakNEq y_1 (toErl 0)) =
  BIF.erlang__op_rem_strict [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "POW"),
                   (ErlangCons _ (ErlangCons _ (ErlangEmptyList)))]
  =
  ErlangAtom "no_eval"
erlps__eval_op__2 [(ErlangAtom "LT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_lesser [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "GT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_greater [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "EQ"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_exactEq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "ELT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_lesserEq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "EGT"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_greaterEq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "NEQ"),
                   (ErlangCons x_0 (ErlangCons y_1 (ErlangEmptyList)))]
  =
  BIF.erlang__op_exactNeq [x_0, y_1]
erlps__eval_op__2 [(ErlangAtom "NOT"),
                   (ErlangCons (ErlangAtom "true") (ErlangEmptyList))]
  =
  ErlangAtom "false"
erlps__eval_op__2 [(ErlangAtom "NOT"),
                   (ErlangCons (ErlangAtom "false") (ErlangEmptyList))]
  =
  ErlangAtom "true"
erlps__eval_op__2 [_, _] = ErlangAtom "no_eval"
erlps__eval_op__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__eval_op__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_prune_impossible_branches__2 :: ErlangFun
erlps__r_prune_impossible_branches__2 [(ErlangTuple [(ErlangAtom "switch"),
                                                     (ErlangTuple [(ErlangAtom "immediate"),
                                                                   v_0]),
                                                     type_1, alts_2,
                                                     (ErlangAtom "missing")]),
                                       code_3]
  =
  let case_4 = erlps__pick_branch__3 [type_1, v_0, alts_2]
  in
    case case_4 of
      (ErlangAtom "false") -> ErlangAtom "false"
      alt_8 -> ErlangTuple [alt_8, code_3]
erlps__r_prune_impossible_branches__2 [(ErlangTuple [(ErlangAtom "switch"),
                                                     (ErlangTuple [(ErlangAtom "immediate"),
                                                                   v_0]),
                                                     (ErlangAtom "boolean"),
                                                     alts_3@(ErlangCons false_1 (ErlangCons true_2 (ErlangEmptyList))),
                                                     def_4]),
                                       code_5]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_28 = BIF.erlang__op_eq [v_0, ErlangAtom "true"]
            in
              case lop_28 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [v_0, ErlangAtom "false"]
                _ -> EXC.badarg1 lop_28)) =
  let   
    head_6 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") == (falsifyErrors (\ _ -> v_0)) ->
          ErlangAtom "missing"
        _ -> false_1
  in let
    head_8 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") == (falsifyErrors (\ _ -> v_0)) -> true_2
        _ -> ErlangAtom "missing"
  in let
    case_11 =
      BIF.erlang__op_eq
        [alts_3, ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList)]
  in
    case case_11 of
      (ErlangAtom "true") -> ErlangAtom "false"
      (ErlangAtom "false") ->
        case ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList) of
          (ErlangCons (ErlangAtom "missing") (ErlangCons (ErlangAtom "missing") (ErlangEmptyList))) ->
            ErlangTuple [def_4, code_5]
          _ ->
            let    tup_el_20 = ErlangTuple [ErlangAtom "immediate", v_0]
            in let
              head_18 =
                ErlangTuple
                  [ErlangAtom "switch", tup_el_20, ErlangAtom "boolean",
                   ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList), def_4]
            in ErlangTuple [ErlangCons head_18 ErlangEmptyList, code_5]
      something_else -> EXC.case_clause something_else
erlps__r_prune_impossible_branches__2 [variant_2@(ErlangTuple [(ErlangAtom "i"),
                                                               _,
                                                               (ErlangTuple [(ErlangAtom "VARIANT"),
                                                                             r_0,
                                                                             (ErlangTuple [(ErlangAtom "immediate"),
                                                                                           _]),
                                                                             (ErlangTuple [(ErlangAtom "immediate"),
                                                                                           tag_1]),
                                                                             (ErlangTuple [(ErlangAtom "immediate"),
                                                                                           _])])]),
                                       (ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                                 r_3,
                                                                 type_4@(ErlangTuple [(ErlangAtom "variant"),
                                                                                      _]),
                                                                 alts_5,
                                                                 (ErlangAtom "missing")]) code_6)]
  | r_3 == r_0
  , isEInt tag_1 =
  let    rop_12 = toErl 1
  in let arg_10 = BIF.erlang__op_plus [tag_1, rop_12]
  in let
    tup_el_9 =
      BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_10, alts_5]
  in let case_7 = ErlangTuple [r_0, tup_el_9]
  in
    case case_7 of
      (ErlangTuple [_, (ErlangAtom "missing")]) ->
        let   
          alts1_17 =
            flmap
              (\ lc_15 ->
                 case lc_15 of
                   _ -> ErlangCons (ErlangAtom "missing") ErlangEmptyList)
              alts_5
        in let case_18 = BIF.erlang__op_eq [alts_5, alts1_17]
        in
          case case_18 of
            (ErlangAtom "true") -> ErlangAtom "false"
            (ErlangAtom "false") ->
              let
                head_24 =
                  ErlangTuple
                    [ErlangAtom "switch", r_0, type_4, alts1_17,
                     ErlangAtom "missing"]
              in
                ErlangTuple
                  [ErlangCons variant_2 (ErlangCons head_24 ErlangEmptyList),
                   code_6]
            something_else -> EXC.case_clause something_else
      (ErlangTuple [(ErlangTuple [(ErlangAtom "stack"),
                                  (ErlangInt num_32)]),
                    alt_33]) | (ErlangInt num_32) == (toErl 0) ->
        ErlangTuple [alt_33, code_6]
      (ErlangTuple [_, alt_36]) ->
        let case_37 = erlps__live_in__2 [r_0, alt_36]
        in
          case case_37 of
            (ErlangAtom "true") ->
              ErlangTuple [ErlangCons variant_2 alt_36, code_6]
            (ErlangAtom "false") -> ErlangTuple [alt_36, code_6]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__r_prune_impossible_branches__2 [_, _] = ErlangAtom "false"
erlps__r_prune_impossible_branches__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_prune_impossible_branches__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pick_branch__3 :: ErlangFun
erlps__pick_branch__3 [(ErlangAtom "boolean"), v_0,
                       (ErlangCons false_1 (ErlangCons true_2 (ErlangEmptyList)))]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_5 = BIF.erlang__op_eq [v_0, ErlangAtom "true"]
            in
              case lop_5 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [v_0, ErlangAtom "false"]
                _ -> EXC.badarg1 lop_5)) =
  let
    alt_3 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") == (falsifyErrors (\ _ -> v_0)) -> true_2
        _ -> false_1
  in
    case alt_3 of
      (ErlangAtom "missing") -> ErlangAtom "false"
      _ -> alt_3
erlps__pick_branch__3 [_type_0, _v_1, _alts_2] =
  ErlangAtom "false"
erlps__pick_branch__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__pick_branch__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_single_successful_branch__2 :: ErlangFun
erlps__r_single_successful_branch__2 [(ErlangTuple [(ErlangAtom "switch"),
                                                    r_0, type_1, alts_2,
                                                    def_3]),
                                      code_4]
  =
  let
    case_5 =
      erlps__push_code_out_of_switch__1 [ErlangCons def_3 alts_2]
  in
    case case_5 of
      (ErlangTuple [_, (ErlangAtom "none")]) -> ErlangAtom "false"
      (ErlangTuple [_, (ErlangAtom "many")]) -> ErlangAtom "false"
      (ErlangTuple [_,
                    (ErlangCons (ErlangTuple [(ErlangAtom "i"), _,
                                              (ErlangAtom "switch_body")]) (ErlangEmptyList))]) ->
        ErlangAtom "false"
      (ErlangTuple [(ErlangCons def1_9 alts1_10), pushedout_11]) ->
        let
          head_13 =
            ErlangTuple [ErlangAtom "switch", r_0, type_1, alts1_10, def1_9]
        in ErlangTuple [ErlangCons head_13 pushedout_11, code_4]
      something_else -> EXC.case_clause something_else
erlps__r_single_successful_branch__2 [_, _] = ErlangAtom "false"
erlps__r_single_successful_branch__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_single_successful_branch__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__push_code_out_of_switch__1 :: ErlangFun
erlps__push_code_out_of_switch__1 [(ErlangEmptyList)] =
  ErlangTuple [ErlangEmptyList, ErlangAtom "none"]
erlps__push_code_out_of_switch__1 [(ErlangCons alt_0 alts_1)] =
  let matchExpr_5 = erlps__push_code_out_of_alt__1 [alt_0]
  in
    case matchExpr_5 of
      (ErlangTuple [alt1_3, pushedalt_4]) ->
        let matchExpr_9 = erlps__push_code_out_of_switch__1 [alts_1]
        in
          case matchExpr_9 of
            (ErlangTuple [alts1_7, pushedalts_8]) ->
              let    case_10 = ErlangTuple [pushedalt_4, pushedalts_8]
              in let
                pushed_13 =
                  case case_10 of
                    (ErlangTuple [(ErlangAtom "none"), _]) -> pushedalts_8
                    (ErlangTuple [_, (ErlangAtom "none")]) -> pushedalt_4
                    _ -> ErlangAtom "many"
              in ErlangTuple [ErlangCons alt1_3 alts1_7, pushed_13]
            _ -> EXC.badmatch matchExpr_9
      _ -> EXC.badmatch matchExpr_5
erlps__push_code_out_of_switch__1 [arg_18] =
  EXC.function_clause unit
erlps__push_code_out_of_switch__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__push_code_out_of_alt__1 :: ErlangFun
erlps__push_code_out_of_alt__1 [(ErlangAtom "missing")] =
  ErlangTuple [ErlangAtom "missing", ErlangAtom "none"]
erlps__push_code_out_of_alt__1 [(ErlangCons body_0@(ErlangTuple [(ErlangAtom "i"),
                                                                 _,
                                                                 (ErlangAtom "switch_body")]) code_1)]
  =
  let case_2 = erlps__does_abort__1 [code_1]
  in
    case case_2 of
      (ErlangAtom "true") ->
        ErlangTuple [ErlangCons body_0 code_1, ErlangAtom "none"]
      (ErlangAtom "false") ->
        ErlangTuple
          [ErlangCons body_0 ErlangEmptyList, ErlangCons body_0 code_1]
      something_else -> EXC.case_clause something_else
erlps__push_code_out_of_alt__1 [(ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                          r_0, type_1, alts_2,
                                                          def_3]) (ErlangEmptyList))]
  =
  let
    matchExpr_10 =
      erlps__push_code_out_of_switch__1 [ErlangCons def_3 alts_2]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangCons def1_7 alts1_8), pushed_9]) ->
        let
          head_12 =
            ErlangTuple [ErlangAtom "switch", r_0, type_1, alts1_8, def1_7]
        in ErlangTuple [ErlangCons head_12 ErlangEmptyList, pushed_9]
      _ -> EXC.badmatch matchExpr_10
erlps__push_code_out_of_alt__1 [code_0] =
  ErlangTuple [code_0, ErlangAtom "many"]
erlps__push_code_out_of_alt__1 [arg_3] = EXC.function_clause unit
erlps__push_code_out_of_alt__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__does_abort__1 :: ErlangFun
erlps__does_abort__1 [(ErlangCons i_0 code_1)] =
  let lop_2 = erlps__does_abort__1 [i_0]
  in
    case lop_2 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> erlps__does_abort__1 [code_1]
      _ -> EXC.badarg1 lop_2
erlps__does_abort__1 [(ErlangTuple [(ErlangAtom "i"), _,
                                    (ErlangTuple [(ErlangAtom "ABORT"), _])])]
  =
  ErlangAtom "true"
erlps__does_abort__1 [(ErlangTuple [(ErlangAtom "i"), _,
                                    (ErlangTuple [(ErlangAtom "EXIT"), _])])]
  =
  ErlangAtom "true"
erlps__does_abort__1 [(ErlangAtom "missing")] = ErlangAtom "true"
erlps__does_abort__1 [(ErlangTuple [(ErlangAtom "switch"), _, _,
                                    alts_0, def_1])]
  =
  let arg_2 = ErlangFun 1 erlps__does_abort__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__all__2"
      [arg_2, ErlangCons def_1 alts_0]
erlps__does_abort__1 [_] = ErlangAtom "false"
erlps__does_abort__1 [arg_0] = EXC.function_clause unit
erlps__does_abort__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_inline_switch_target__2 :: ErlangFun
erlps__r_inline_switch_target__2 [(ErlangTuple [(ErlangAtom "i"),
                                                ann_0,
                                                (ErlangTuple [(ErlangAtom "STORE"),
                                                              r_1, a_2])]),
                                  (ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                            r_3, type_4, alts_5,
                                                            def_6]) code_7)]
  | r_3 == r_1 =
  let    case_8 = erlps__is_reg__1 [a_2]
  in let
    ann1_20 =
      case case_8 of
        (ErlangAtom "true") ->
          let    arg_14 = BIF.maps__get__2 [ErlangAtom "live_out", ann_0]
          in let
            val_12 =
              BIF.do_remote_fun_call "Ordsets" "erlps__add_element__2"
                [a_2, arg_14]
          in let
            mapExt_17 =
              ErlangMap (Map.singleton (ErlangAtom "live_out") val_12)
          in
            case findMissingKey ann_0 [ErlangAtom "live_out"] of
              (DM.Nothing) -> BIF.maps__merge__2 [ann_0, mapExt_17]
              (DM.Just missing_19) -> EXC.badkey missing_19
        (ErlangAtom "false") -> ann_0
        something_else -> EXC.case_clause something_else
  in let tup_el_23 = ErlangTuple [ErlangAtom "STORE", r_1, a_2]
  in let
    store_27 = ErlangTuple [ErlangAtom "i", ann1_20, tup_el_23]
  in let
    switch_33 =
      ErlangTuple [ErlangAtom "switch", a_2, type_4, alts_5, def_6]
  in
    case r_1 of
      a_35 | a_35 == a_2 -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "stack"),
                    (ErlangInt num_36)]) | (ErlangInt num_36) == (toErl 0) ->
        ErlangTuple [ErlangCons switch_33 ErlangEmptyList, code_7]
      (ErlangTuple [(ErlangAtom "var"), _]) ->
        let   
          arg_42 =
            ErlangFun 1
              (let
                 lambda_43 [alt_45] = erlps__live_in__2 [r_1, alt_45]
                 lambda_43 [arg_44] = EXC.function_clause unit
                 lambda_43 args = EXC.badarity (ErlangFun 1 lambda_43) args
               in lambda_43)
        in let
          case_41 =
            BIF.do_remote_fun_call "Lists" "erlps__any__2"
              [arg_42, ErlangCons def_6 alts_5]
        in
          case case_41 of
            (ErlangAtom "false") ->
              ErlangTuple [ErlangCons switch_33 ErlangEmptyList, code_7]
            (ErlangAtom "true") | (ErlangAtom "true") ==
                                    (falsifyErrors
                                       (\ _ ->
                                          let    tup_el_58 = toErl 0
                                          in let
                                            rop_56 =
                                              ErlangTuple
                                                [ErlangAtom "stack", tup_el_58]
                                          in
                                            BIF.erlang__op_neq
                                              [a_2, rop_56])) ->
              ErlangTuple
                [ErlangCons store_27 (ErlangCons switch_33 ErlangEmptyList),
                 code_7]
            (ErlangAtom "true") -> ErlangAtom "false"
            something_else -> EXC.case_clause something_else
      _ -> ErlangAtom "false"
erlps__r_inline_switch_target__2 [_, _] = ErlangAtom "false"
erlps__r_inline_switch_target__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_inline_switch_target__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_float_switch_body__2 :: ErlangFun
erlps__r_float_switch_body__2 [i_0@(ErlangTuple [(ErlangAtom "i"),
                                                 _, _]),
                               (ErlangCons j_1@(ErlangTuple [(ErlangAtom "i"),
                                                             _,
                                                             (ErlangAtom "switch_body")]) code_2)]
  =
  let matchExpr_7 = erlps__swap_instrs__2 [i_0, j_1]
  in
    case matchExpr_7 of
      (ErlangTuple [j1_5, i1_6]) ->
        ErlangTuple
          [ErlangEmptyList, ErlangCons j1_5 (ErlangCons i1_6 code_2)]
      _ -> EXC.badmatch matchExpr_7
erlps__r_float_switch_body__2 [_, _] = ErlangAtom "false"
erlps__r_float_switch_body__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_float_switch_body__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_inline_store__2 :: ErlangFun
erlps__r_inline_store__2 [(ErlangTuple [(ErlangAtom "i"), _,
                                        (ErlangTuple [(ErlangAtom "STORE"), r_0,
                                                      r_1])]),
                          code_2]
  | r_1 == r_0 =
  ErlangTuple [ErlangEmptyList, code_2]
erlps__r_inline_store__2 [i_2@(ErlangTuple [(ErlangAtom "i"), _,
                                            (ErlangTuple [(ErlangAtom "STORE"),
                                                          r_0@(ErlangTuple [(ErlangAtom "var"),
                                                                            _]),
                                                          a_1])]),
                          code_3]
  =
  let
    inline_5 =
      case a_1 of
        (ErlangTuple [(ErlangAtom "arg"), _]) -> ErlangAtom "true"
        (ErlangTuple [(ErlangAtom "immediate"), _]) -> ErlangAtom "true"
        (ErlangTuple [(ErlangAtom "store"), _]) -> ErlangAtom "true"
        _ -> ErlangAtom "false"
  in
    case ErlangAtom "true" of
      _ | (ErlangAtom "true") == (falsifyErrors (\ _ -> inline_5)) ->
        erlps__r_inline_store__5
          [ErlangCons i_2 ErlangEmptyList, ErlangAtom "false", r_0, a_1,
           code_3]
      _ -> ErlangAtom "false"
erlps__r_inline_store__2 [_, _] = ErlangAtom "false"
erlps__r_inline_store__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_inline_store__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_inline_store__5 :: ErlangFun
erlps__r_inline_store__5 [acc_0, progress_1, r_2, a_3,
                          (ErlangCons i_4@(ErlangTuple [(ErlangAtom "i"), _,
                                                        (ErlangAtom "switch_body")]) code_5)]
  =
  erlps__r_inline_store__5
    [ErlangCons i_4 acc_0, progress_1, r_2, a_3, code_5]
erlps__r_inline_store__5 [acc_0, progress_1, r_2, a_3,
                          (ErlangCons (ErlangTuple [(ErlangAtom "i"), ann_4,
                                                    i_5]) code_6)]
  =
  let matchExpr_10 = erlps__attributes__1 [i_5]
  in
    case matchExpr_10 of
      (ErlangMap map_8) | (DM.Just w_9) <-
                            (Map.lookup (ErlangAtom "write") map_8) ->
        let   
          inl_15 =
            ErlangFun 1
              (let
                 lambda_11 [x_13] | weakEq x_13 r_2 = a_3
                 lambda_11 [x_14] = x_14
                 lambda_11 [arg_12] = EXC.function_clause unit
                 lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
               in lambda_11)
        in let case_16 = erlps__live_in__2 [r_2, ann_4]
        in
          case case_16 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              let    case_19 = erlps__op_view__1 [i_5]
              in let
                matchExpr_40 =
                  case case_19 of
                    (ErlangTuple [op_21, s_22, as_23]) ->
                      let case_24 = BIF.lists__member__2 [r_2, as_23]
                      in
                        case case_24 of
                          (ErlangAtom "true") ->
                            let   
                              arg_30 =
                                BIF.do_remote_fun_call "Lists" "erlps__map__2"
                                  [inl_15, as_23]
                            in let
                              tup_el_27 =
                                erlps__from_op_view__3 [op_21, s_22, arg_30]
                            in ErlangTuple [tup_el_27, ErlangAtom "true"]
                          (ErlangAtom "false") -> ErlangTuple [i_5, progress_1]
                          something_else -> EXC.case_clause something_else
                    _ -> ErlangTuple [i_5, progress_1]
              in
                case matchExpr_40 of
                  (ErlangTuple [i1_38, progress1_39]) ->
                    let    head_41 = ErlangTuple [ErlangAtom "i", ann_4, i1_38]
                    in let
                      case_47 =
                        BIF.lists__member__2
                          [w_9, ErlangCons r_2 (ErlangCons a_3 ErlangEmptyList)]
                    in
                      case case_47 of
                        (ErlangAtom "true") | (ErlangAtom "true") ==
                                                (falsifyErrors
                                                   (\ _ -> progress1_39)) ->
                          let
                            tup_el_54 =
                              BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                                [ErlangCons head_41 acc_0]
                          in ErlangTuple [tup_el_54, code_6]
                        (ErlangAtom "true") -> ErlangAtom "false"
                        (ErlangAtom "false") ->
                          erlps__r_inline_store__5
                            [ErlangCons head_41 acc_0, progress1_39, r_2, a_3,
                             code_6]
                        something_else -> EXC.case_clause something_else
                  _ -> EXC.badmatch matchExpr_40
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_10
erlps__r_inline_store__5 [acc_0, (ErlangAtom "true"), _, _,
                          code_1]
  =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
  in ErlangTuple [tup_el_2, code_1]
erlps__r_inline_store__5 [_, (ErlangAtom "false"), _, _, _] =
  ErlangAtom "false"
erlps__r_inline_store__5 [arg_0, arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__r_inline_store__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_one_shot_var__2 :: ErlangFun
erlps__r_one_shot_var__2 [(ErlangTuple [(ErlangAtom "i"), ann1_0,
                                        i_1]),
                          (ErlangCons (ErlangTuple [(ErlangAtom "i"), ann2_2,
                                                    j_3]) code_4)]
  =
  let case_5 = erlps__op_view__1 [i_1]
  in
    case case_5 of
      (ErlangTuple [op_7, r_8@(ErlangTuple [(ErlangAtom "var"), _]),
                    as_9]) ->
        let   
          copy_15 =
            case j_3 of
              (ErlangTuple [(ErlangAtom "STORE"), s_11, r_12]) | r_12 == r_8 ->
                ErlangTuple [ErlangAtom "write_to", s_11]
              _ -> ErlangAtom "false"
        in let tup_el_17 = erlps__live_out__2 [r_8, ann2_2]
        in let case_16 = ErlangTuple [tup_el_17, copy_15]
        in
          case case_16 of
            (ErlangTuple [(ErlangAtom "false"),
                          (ErlangTuple [(ErlangAtom "write_to"), x_21])]) ->
              let    tup_el_25 = erlps__merge_ann__2 [ann1_0, ann2_2]
              in let tup_el_28 = erlps__from_op_view__3 [op_7, x_21, as_9]
              in let
                head_23 = ErlangTuple [ErlangAtom "i", tup_el_25, tup_el_28]
              in ErlangTuple [ErlangCons head_23 ErlangEmptyList, code_4]
            _ -> ErlangAtom "false"
      _ -> ErlangAtom "false"
erlps__r_one_shot_var__2 [_, _] = ErlangAtom "false"
erlps__r_one_shot_var__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_one_shot_var__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__r_write_to_dead_var__2 :: ErlangFun
erlps__r_write_to_dead_var__2 [(ErlangTuple [(ErlangAtom "i"), _,
                                             (ErlangTuple [(ErlangAtom "STORE"),
                                                           (ErlangTuple [(ErlangAtom "var"),
                                                                         (ErlangInt num_0)]),
                                                           (ErlangTuple [(ErlangAtom "stack"),
                                                                         (ErlangInt num_1)])])]),
                               _]
  | (ErlangInt num_0) == (toErl 9999)
  , (ErlangInt num_1) == (toErl 0) =
  ErlangAtom "false"
erlps__r_write_to_dead_var__2 [(ErlangTuple [(ErlangAtom "i"),
                                             ann_0, i_1]),
                               code_2]
  =
  let matchExpr_6 = erlps__attributes__1 [i_1]
  in
    case matchExpr_6 of
      (ErlangMap map_4) | (DM.Just pure_5) <-
                            (Map.lookup (ErlangAtom "pure") map_4) ->
        let case_7 = erlps__op_view__1 [i_1]
        in
          case case_7 of
            (ErlangTuple [_op_9, r_10, as_11]) | (ErlangAtom "true") ==
                                                   (falsifyErrors
                                                      (\ _ ->
                                                         let   
                                                           tup_el_16 = toErl 0
                                                         in let
                                                           rop_14 =
                                                             ErlangTuple
                                                               [ErlangAtom
                                                                  "stack",
                                                                tup_el_16]
                                                         in let
                                                           lop_12 =
                                                             BIF.erlang__op_neq
                                                               [r_10, rop_14]
                                                         in
                                                           case lop_12 of
                                                             (ErlangAtom "false") ->
                                                               ErlangAtom
                                                                 "false"
                                                             (ErlangAtom "true") ->
                                                               pure_5
                                                             _ ->
                                                               EXC.badarg1
                                                                 lop_12)) ->
              let case_17 = erlps__live_out__2 [r_10, ann_0]
              in
                case case_17 of
                  (ErlangAtom "false") ->
                    let
                      tup_el_20 =
                        flmap
                          (\ lc_23 ->
                             let    tup_el_28 = toErl 0
                             in let
                               rop_26 =
                                 ErlangTuple [ErlangAtom "stack", tup_el_28]
                             in let cond_24 = BIF.erlang__op_eq [lc_23, rop_26]
                             in
                               case cond_24 of
                                 (ErlangAtom "true") ->
                                   let    tup_el_36 = toErl 9999
                                   in let
                                     tup_el_34 =
                                       ErlangTuple [ErlangAtom "var", tup_el_36]
                                   in let tup_el_39 = toErl 0
                                   in let
                                     tup_el_37 =
                                       ErlangTuple
                                         [ErlangAtom "stack", tup_el_39]
                                   in let
                                     tup_el_32 =
                                       ErlangTuple
                                         [ErlangAtom "STORE", tup_el_34,
                                          tup_el_37]
                                   in let
                                     lcRet_29 =
                                       ErlangTuple
                                         [ErlangAtom "i", ann_0, tup_el_32]
                                   in ErlangCons lcRet_29 ErlangEmptyList
                                 _ -> ErlangEmptyList)
                          as_11
                    in ErlangTuple [tup_el_20, code_2]
                  (ErlangAtom "true") -> ErlangAtom "false"
                  something_else -> EXC.case_clause something_else
            _ -> ErlangAtom "false"
      _ -> EXC.badmatch matchExpr_6
erlps__r_write_to_dead_var__2 [_, _] = ErlangAtom "false"
erlps__r_write_to_dead_var__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__r_write_to_dead_var__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__op_view__1 :: ErlangFun
erlps__op_view__1 [(ErlangTuple [(ErlangAtom "ABORT"), r_0])] =
  ErlangTuple
    [ErlangAtom "ABORT", ErlangAtom "none",
     ErlangCons r_0 ErlangEmptyList]
erlps__op_view__1 [t_0] | isETuple t_0 =
  let matchExpr_5 = BIF.erlang__tuple_to_list__1 [t_0]
  in
    case matchExpr_5 of
      (ErlangCons op_2 (ErlangCons r_3 as_4)) ->
        let   
          checkreads_20 =
            ErlangFun 2
              (let
                 lambda_6 [rs_9, x_10] =
                   let   
                     rop_13 =
                       BIF.erlang__op_unAppend
                         [rs_9,
                          ErlangCons (ErlangAtom "dst")
                            (ErlangCons (ErlangAtom "src") ErlangEmptyList)]
                   in let case_11 = BIF.erlang__op_eq [ErlangEmptyList, rop_13]
                   in
                     case case_11 of
                       (ErlangAtom "true") -> x_10
                       (ErlangAtom "false") -> ErlangAtom "false"
                       something_else -> EXC.case_clause something_else
                 lambda_6 [arg_7, arg_8] = EXC.function_clause unit
                 lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
               in lambda_6)
        in let
          tail_27 =
            flmap
              (\ lc_29 ->
                 case lc_29 of
                   _ -> ErlangCons (ErlangAtom "src") ErlangEmptyList)
              as_4
        in let
          arg_22 =
            BIF.erlang__list_to_tuple__1
              [ErlangCons op_2 (ErlangCons (ErlangAtom "dst") tail_27)]
        in let case_21 = erlps__attributes__1 [arg_22]
        in
          case case_21 of
            (ErlangMap map_31) | (DM.Just rs_32) <-
                                   (Map.lookup (ErlangAtom "read") map_31)
                               , (DM.Just (ErlangAtom "dst")) <-
                                   (Map.lookup (ErlangAtom "write") map_31) ->
              let arg_34 = ErlangTuple [op_2, r_3, as_4]
              in
                BIF.erlang__apply__2
                  [checkreads_20,
                   ErlangCons rs_32 (ErlangCons arg_34 ErlangEmptyList)]
            (ErlangMap map_39) | (DM.Just rs_40) <-
                                   (Map.lookup (ErlangAtom "read") map_39)
                               , (DM.Just (ErlangAtom "none")) <-
                                   (Map.lookup (ErlangAtom "write") map_39) ->
              let
                arg_42 =
                  ErlangTuple [op_2, ErlangAtom "none", ErlangCons r_3 as_4]
              in
                BIF.erlang__apply__2
                  [checkreads_20,
                   ErlangCons rs_40 (ErlangCons arg_42 ErlangEmptyList)]
            _ -> ErlangAtom "false"
      _ -> EXC.badmatch matchExpr_5
erlps__op_view__1 [_] = ErlangAtom "false"
erlps__op_view__1 [arg_0] = EXC.function_clause unit
erlps__op_view__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__from_op_view__3 :: ErlangFun
erlps__from_op_view__3 [op_0, (ErlangAtom "none"), as_1] =
  BIF.erlang__list_to_tuple__1 [ErlangCons op_0 as_1]
erlps__from_op_view__3 [op_0, r_1, as_2] =
  BIF.erlang__list_to_tuple__1
    [ErlangCons op_0 (ErlangCons r_1 as_2)]
erlps__from_op_view__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__from_op_view__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__unannotate__1 :: ErlangFun
erlps__unannotate__1 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                    type_1, alts_2, def_3])]
  =
  let   
    tup_el_8 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__unannotate__1 [lc_11]
           in ErlangCons lcRet_12 ErlangEmptyList)
        alts_2
  in let tup_el_14 = erlps__unannotate__1 [def_3]
  in let
    head_4 =
      ErlangTuple
        [ErlangAtom "switch", arg_0, type_1, tup_el_8, tup_el_14]
  in ErlangCons head_4 ErlangEmptyList
erlps__unannotate__1 [(ErlangAtom "missing")] =
  ErlangAtom "missing"
erlps__unannotate__1 [code_0] | isEList code_0 =
  let arg_1 = ErlangFun 1 erlps__unannotate__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
      [arg_1, code_0]
erlps__unannotate__1 [(ErlangTuple [(ErlangAtom "i"), _ann_0,
                                    i_1])]
  =
  ErlangCons i_1 ErlangEmptyList
erlps__unannotate__1 [arg_4] = EXC.function_clause unit
erlps__unannotate__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__desugar__1 :: ErlangFun
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_1)]),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 1)
  , (ErlangInt num_2) == (toErl 0) =
  let
    head_3 = BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__0" []
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"), a_0,
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_1)]),
                                 a_2])]
  | (ErlangInt num_1) == (toErl 1)
  , a_2 == a_0 =
  let    arg_4 = erlps__desugar_arg__1 [a_0]
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__1" [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_1)]),
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 0)
  , (ErlangInt num_2) == (toErl 1) =
  let
    head_3 = BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__0" []
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "ADD"), a_0, a_1,
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_2) == (toErl 1)
  , a_1 == a_0 =
  let    arg_4 = erlps__desugar_arg__1 [a_0]
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__inc__1" [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "SUB"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_1)]),
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_0) == (toErl 0)
  , (ErlangInt num_1) == (toErl 0)
  , (ErlangInt num_2) == (toErl 1) =
  let
    head_3 = BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__dec__0" []
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "SUB"), a_0, a_1,
                                 (ErlangTuple [(ErlangAtom "immediate"),
                                               (ErlangInt num_2)])])]
  | (ErlangInt num_2) == (toErl 1)
  , a_1 == a_0 =
  let    arg_4 = erlps__desugar_arg__1 [a_0]
  in let
    head_3 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__dec__1" [arg_4]
  in ErlangCons head_3 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "STORE"),
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_0)]),
                                 a_1])]
  | (ErlangInt num_0) == (toErl 0) =
  let    arg_3 = erlps__desugar_arg__1 [a_1]
  in let
    head_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__push__1" [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "STORE"), r_0,
                                 (ErlangTuple [(ErlangAtom "stack"),
                                               (ErlangInt num_1)])])]
  | (ErlangInt num_1) == (toErl 0) =
  let    arg_3 = erlps__desugar_arg__1 [r_0]
  in let
    head_2 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__pop__1" [arg_3]
  in ErlangCons head_2 ErlangEmptyList
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "switch"), arg_0,
                                 type_1, alts_2, def_3])]
  =
  let    tup_el_6 = erlps__desugar_arg__1 [arg_0]
  in let
    tup_el_9 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__desugar__1 [lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        alts_2
  in let tup_el_15 = erlps__desugar__1 [def_3]
  in let
    head_4 =
      ErlangTuple
        [ErlangAtom "switch", tup_el_6, type_1, tup_el_9, tup_el_15]
  in ErlangCons head_4 ErlangEmptyList
erlps__desugar__1 [(ErlangAtom "missing")] = ErlangAtom "missing"
erlps__desugar__1 [code_0] | isEList code_0 =
  let arg_1 = ErlangFun 1 erlps__desugar__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
      [arg_1, code_0]
erlps__desugar__1 [i_0] =
  let head_1 = erlps__desugar_args__1 [i_0]
  in ErlangCons head_1 ErlangEmptyList
erlps__desugar__1 [arg_4] = EXC.function_clause unit
erlps__desugar__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__desugar_args__1 :: ErlangFun
erlps__desugar_args__1 [i_0] | isETuple i_0 =
  let matchExpr_4 = BIF.erlang__tuple_to_list__1 [i_0]
  in
    case matchExpr_4 of
      (ErlangCons op_2 args_3) ->
        let    arg_8 = ErlangFun 1 erlps__desugar_arg__1
        in let
          tail_7 =
            BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_8, args_3]
        in BIF.erlang__list_to_tuple__1 [ErlangCons op_2 tail_7]
      _ -> EXC.badmatch matchExpr_4
erlps__desugar_args__1 [i_0] = i_0
erlps__desugar_args__1 [arg_1] = EXC.function_clause unit
erlps__desugar_args__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__desugar_arg__1 :: ErlangFun
erlps__desugar_arg__1 [(ErlangTuple [(ErlangAtom "store"), n_0])]
  =
  let tup_el_2 = BIF.erlang__op_neg [n_0]
  in ErlangTuple [ErlangAtom "var", tup_el_2]
erlps__desugar_arg__1 [a_0] = a_0
erlps__desugar_arg__1 [arg_1] = EXC.function_clause unit
erlps__desugar_arg__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_basic_blocks__1 :: ErlangFun
erlps__to_basic_blocks__1 [funs_0] =
  let    arg_1 = BIF.maps__to_list__1 [funs_0]
  in let
    arg_3 = BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__new__0" []
  in erlps__to_basic_blocks__2 [arg_1, arg_3]
erlps__to_basic_blocks__1 [arg_4] = EXC.function_clause unit
erlps__to_basic_blocks__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__to_basic_blocks__2 :: ErlangFun
erlps__to_basic_blocks__2 [(ErlangCons (ErlangTuple [name_0,
                                                     (ErlangTuple [attrs_1,
                                                                   sig_2,
                                                                   code_3])]) left_4),
                           acc_5]
  =
  let   
    head_10 =
      BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__return__0" []
  in let
    arg_7 =
      BIF.erlang__op_append
        [code_3, ErlangCons head_10 ErlangEmptyList]
  in let bb_12 = erlps__bb__2 [name_0, arg_7]
  in let
    arg_14 =
      BIF.do_remote_fun_call "Aeb.Fate.Code" "erlps__insert_fun__5"
        [name_0, attrs_1, sig_2, bb_12, acc_5]
  in erlps__to_basic_blocks__2 [left_4, arg_14]
erlps__to_basic_blocks__2 [(ErlangEmptyList), acc_0] = acc_0
erlps__to_basic_blocks__2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__to_basic_blocks__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__bb__2 :: ErlangFun
erlps__bb__2 [_name_0, code_1] =
  let    blocks0_3 = erlps__blocks__1 [code_1]
  in let blocks1_5 = erlps__optimize_blocks__1 [blocks0_3]
  in let arg_6 = ErlangFun 1 erlps__split_calls__1
  in let
    blocks_8 =
      BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
        [arg_6, blocks1_5]
  in let lcSrc_10 = erlps__with_ixs__1 [blocks_8]
  in let
    arg_9 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [i_12, (ErlangTuple [ref_13, _])]) ->
               let lcRet_15 = ErlangTuple [ref_13, i_12]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_10
  in let labels_18 = BIF.maps__from_list__1 [arg_9]
  in let
    bbs_25 =
      flmap
        (\ lc_21 ->
           let lcRet_22 = erlps__set_labels__2 [labels_18, lc_21]
           in ErlangCons lcRet_22 ErlangEmptyList)
        blocks_8
  in BIF.maps__from_list__1 [bbs_25]
erlps__bb__2 [arg_27, arg_28] = EXC.function_clause unit
erlps__bb__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__blocks__1 :: ErlangFun
erlps__blocks__1 [code_0] =
  let    top_1 = BIF.erlang__make_ref__0 []
  in let
    head_3 =
      ErlangTuple [ErlangAtom "blk", top_1, code_0, ErlangAtom "none"]
  in
    erlps__blocks__2
      [ErlangCons head_3 ErlangEmptyList, ErlangEmptyList]
erlps__blocks__1 [arg_10] = EXC.function_clause unit
erlps__blocks__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__blocks__2 :: ErlangFun
erlps__blocks__2 [(ErlangEmptyList), acc_0] =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
erlps__blocks__2 [(ErlangCons blk_0 blocks_1), acc_2] =
  erlps__block__4 [blk_0, ErlangEmptyList, blocks_1, acc_2]
erlps__blocks__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__blocks__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__block__4 :: ErlangFun
erlps__block__4 [(ErlangTuple [(ErlangAtom "blk"), ref_0,
                               (ErlangEmptyList), _]),
                 codeacc_1, blocks_2, blockacc_3]
  =
  let   
    tup_el_8 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [codeacc_1]
  in let head_6 = ErlangTuple [ref_0, tup_el_8]
  in erlps__blocks__2 [blocks_2, ErlangCons head_6 blockacc_3]
erlps__block__4 [blk_1@(ErlangTuple [(ErlangAtom "blk"), _,
                                     (ErlangCons (ErlangAtom "switch_body") code_0),
                                     _]),
                 acc_2, blocks_3, blockacc_4]
  =
  let
    arg_5 =
      case blk_1 of
        (ErlangTuple [(ErlangAtom "blk"), ref_9, code_10,
                      catchall_11]) ->
          ErlangTuple [ErlangAtom "blk", ref_9, code_0, ErlangAtom "none"]
        _ -> EXC.badrecord (ErlangAtom "blk")
  in erlps__block__4 [arg_5, acc_2, blocks_3, blockacc_4]
erlps__block__4 [blk_6@(ErlangTuple [(ErlangAtom "blk"), _,
                                     (ErlangCons (ErlangTuple [(ErlangAtom "switch"),
                                                               arg_0, type_1,
                                                               alts_2,
                                                               default_3]) code_4),
                                     catchall_5]),
                 acc_7, blocks_8, blockacc_9]
  =
  let   
    freshblk_24 =
      ErlangFun 2
        (let
           lambda_10 [c_13, ca_14] =
             let    r_15 = BIF.erlang__make_ref__0 []
             in let
               head_18 = ErlangTuple [ErlangAtom "blk", r_15, c_13, ca_14]
             in ErlangTuple [r_15, ErlangCons head_18 ErlangEmptyList]
           lambda_10 [arg_11, arg_12] = EXC.function_clause unit
           lambda_10 args = EXC.badarity (ErlangFun 2 lambda_10) args
         in lambda_10)
  in let
    matchExpr_30 =
      BIF.erlang__apply__2
        [freshblk_24,
         ErlangCons code_4 (ErlangCons catchall_5 ErlangEmptyList)]
  in
    case matchExpr_30 of
      (ErlangTuple [restref_28, restblk_29]) ->
        let
          matchExpr_72 =
            case default_3 of
              (ErlangAtom "missing") | weakEq catchall_5 (ErlangAtom "none") ->
                let    bin_el_37 = toErl 73
                in let bin_el_38 = toErl 110
                in let bin_el_39 = toErl 99
                in let bin_el_40 = toErl 111
                in let bin_el_41 = toErl 109
                in let bin_el_42 = toErl 112
                in let bin_el_43 = toErl 108
                in let bin_el_44 = toErl 101
                in let bin_el_45 = toErl 116
                in let bin_el_46 = toErl 101
                in let bin_el_47 = toErl 32
                in let bin_el_48 = toErl 112
                in let bin_el_49 = toErl 97
                in let bin_el_50 = toErl 116
                in let bin_el_51 = toErl 116
                in let bin_el_52 = toErl 101
                in let bin_el_53 = toErl 114
                in let bin_el_54 = toErl 110
                in let bin_el_55 = toErl 115
                in let
                  tup_el_36 =
                    ErlangBinary
                      (BIN.concat
                         [BIN.fromInt bin_el_37 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_38 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_39 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_40 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_41 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_42 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_43 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_44 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_45 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_46 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_47 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_48 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_49 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_50 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_51 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_52 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_53 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_54 (toErl 8) 1 BIN.Big,
                          BIN.fromInt bin_el_55 (toErl 8) 1 BIN.Big])
                in let arg_34 = ErlangTuple [ErlangAtom "immediate", tup_el_36]
                in let
                  head_33 =
                    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__abort__1"
                      [arg_34]
                in
                  BIF.erlang__apply__2
                    [freshblk_24,
                     ErlangCons (ErlangCons head_33 ErlangEmptyList)
                       (ErlangCons (ErlangAtom "none") ErlangEmptyList)]
              (ErlangAtom "missing") ->
                ErlangTuple [catchall_5, ErlangEmptyList]
              _ ->
                let    head_64 = ErlangTuple [ErlangAtom "jump", restref_28]
                in let
                  arg_61 =
                    BIF.erlang__op_append
                      [default_3, ErlangCons head_64 ErlangEmptyList]
                in
                  BIF.erlang__apply__2
                    [freshblk_24,
                     ErlangCons arg_61 (ErlangCons catchall_5 ErlangEmptyList)]
        in
          case matchExpr_72 of
            (ErlangTuple [defref_70, defblk_71]) ->
              let    tup_el_77 = toErl 0
              in let rop_75 = ErlangTuple [ErlangAtom "stack", tup_el_77]
              in let cond_73 = BIF.erlang__op_eq [arg_0, rop_75]
              in let
                pop_83 =
                  case cond_73 of
                    (ErlangAtom "true") ->
                      let    tup_el_82 = toErl 9999
                      in let
                        tup_el_80 = ErlangTuple [ErlangAtom "var", tup_el_82]
                      in let
                        lcRet_78 = ErlangTuple [ErlangAtom "POP", tup_el_80]
                      in ErlangCons lcRet_78 ErlangEmptyList
                    _ -> ErlangEmptyList
              in let
                matchExpr_294 =
                  case type_1 of
                    (ErlangAtom "boolean") ->
                      case alts_2 of
                        (ErlangCons falsecode_85 (ErlangCons truecode_86 (ErlangEmptyList))) ->
                          let
                            matchExpr_102 =
                              case truecode_86 of
                                (ErlangAtom "missing") ->
                                  ErlangTuple [defref_70, ErlangEmptyList]
                                _ ->
                                  let   
                                    head_94 =
                                      ErlangTuple
                                        [ErlangAtom "jump", restref_28]
                                  in let
                                    arg_91 =
                                      BIF.erlang__op_append
                                        [truecode_86,
                                         ErlangCons head_94 ErlangEmptyList]
                                  in
                                    BIF.erlang__apply__2
                                      [freshblk_24,
                                       ErlangCons arg_91
                                         (ErlangCons defref_70 ErlangEmptyList)]
                          in
                            case matchExpr_102 of
                              (ErlangTuple [thenref_100, thenblk_101]) ->
                                let   
                                  elsecode_114 =
                                    case falsecode_85 of
                                      (ErlangAtom "missing") ->
                                        let
                                          head_104 =
                                            ErlangTuple
                                              [ErlangAtom "jump", defref_70]
                                        in ErlangCons head_104 ErlangEmptyList
                                      _ ->
                                        let
                                          head_110 =
                                            ErlangTuple
                                              [ErlangAtom "jump", restref_28]
                                        in
                                          BIF.erlang__op_append
                                            [falsecode_85,
                                             ErlangCons head_110
                                               ErlangEmptyList]
                                in let
                                  lop_116 =
                                    BIF.do_remote_fun_call "Lists"
                                      "erlps__usort__1" [alts_2]
                                in let
                                  case_115 =
                                    BIF.erlang__op_eq
                                      [lop_116,
                                       ErlangCons (ErlangAtom "missing")
                                         ErlangEmptyList]
                                in
                                  case case_115 of
                                    (ErlangAtom "true") ->
                                      let   
                                        head_126 =
                                          ErlangTuple
                                            [ErlangAtom "jump", defref_70]
                                      in let
                                        record_updt_123 =
                                          BIF.erlang__op_append
                                            [pop_83,
                                             ErlangCons head_126
                                               ErlangEmptyList]
                                      in let
                                        tup_el_121 =
                                          case blk_6 of
                                            (ErlangTuple [(ErlangAtom "blk"),
                                                          ref_130, code_131,
                                                          catchall_132]) ->
                                              ErlangTuple
                                                [ErlangAtom "blk", ref_130,
                                                 record_updt_123, catchall_132]
                                            _ ->
                                              EXC.badrecord (ErlangAtom "blk")
                                      in
                                        ErlangTuple
                                          [tup_el_121, ErlangEmptyList,
                                           ErlangEmptyList]
                                    (ErlangAtom "false") ->
                                      case arg_0 of
                                        (ErlangTuple [(ErlangAtom "immediate"),
                                                      (ErlangAtom "false")]) ->
                                          let
                                            tup_el_136 =
                                              case blk_6 of
                                                (ErlangTuple [(ErlangAtom "blk"),
                                                              ref_139, code_140,
                                                              catchall_141]) ->
                                                  ErlangTuple
                                                    [ErlangAtom "blk", ref_139,
                                                     elsecode_114, catchall_141]
                                                _ ->
                                                  EXC.badrecord
                                                    (ErlangAtom "blk")
                                          in
                                            ErlangTuple
                                              [tup_el_136, ErlangEmptyList,
                                               thenblk_101]
                                        (ErlangTuple [(ErlangAtom "immediate"),
                                                      (ErlangAtom "true")]) ->
                                          let   
                                            tup_el_144 =
                                              case blk_6 of
                                                (ErlangTuple [(ErlangAtom "blk"),
                                                              ref_147, code_148,
                                                              catchall_149]) ->
                                                  ErlangTuple
                                                    [ErlangAtom "blk", ref_147,
                                                     ErlangEmptyList,
                                                     catchall_149]
                                                _ ->
                                                  EXC.badrecord
                                                    (ErlangAtom "blk")
                                          in let
                                            head_151 =
                                              ErlangTuple
                                                [ErlangAtom "jump", thenref_100]
                                          in
                                            ErlangTuple
                                              [tup_el_144,
                                               ErlangCons head_151
                                                 ErlangEmptyList,
                                               thenblk_101]
                                        _ ->
                                          let   
                                            tup_el_156 =
                                              case blk_6 of
                                                (ErlangTuple [(ErlangAtom "blk"),
                                                              ref_159, code_160,
                                                              catchall_161]) ->
                                                  ErlangTuple
                                                    [ErlangAtom "blk", ref_159,
                                                     elsecode_114, catchall_161]
                                                _ ->
                                                  EXC.badrecord
                                                    (ErlangAtom "blk")
                                          in let
                                            head_163 =
                                              ErlangTuple
                                                [ErlangAtom "jumpif", arg_0,
                                                 thenref_100]
                                          in
                                            ErlangTuple
                                              [tup_el_156,
                                               ErlangCons head_163
                                                 ErlangEmptyList,
                                               thenblk_101]
                                    something_else ->
                                      EXC.case_clause something_else
                              _ -> EXC.badmatch matchExpr_102
                        _ -> EXC.badmatch alts_2
                    (ErlangAtom "tuple") ->
                      case alts_2 of
                        (ErlangCons tcode_169 (ErlangEmptyList)) ->
                          case tcode_169 of
                            (ErlangAtom "missing") ->
                              let   
                                head_177 =
                                  ErlangTuple [ErlangAtom "jump", defref_70]
                              in let
                                record_updt_174 =
                                  BIF.erlang__op_append
                                    [pop_83,
                                     ErlangCons head_177 ErlangEmptyList]
                              in let
                                tup_el_172 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_181,
                                                  code_182, catchall_183]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_181,
                                         record_updt_174, catchall_183]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_172, ErlangEmptyList, ErlangEmptyList]
                            _ ->
                              let   
                                head_193 =
                                  ErlangTuple [ErlangAtom "jump", restref_28]
                              in let
                                rop_190 =
                                  BIF.erlang__op_append
                                    [tcode_169,
                                     ErlangCons head_193 ErlangEmptyList]
                              in let
                                record_updt_188 =
                                  BIF.erlang__op_append [pop_83, rop_190]
                              in let
                                tup_el_186 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_197,
                                                  code_198, catchall_199]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_197,
                                         record_updt_188, catchall_199]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_186, ErlangEmptyList, ErlangEmptyList]
                        _ -> EXC.badmatch alts_2
                    (ErlangTuple [(ErlangAtom "variant"),
                                  (ErlangCons _ (ErlangEmptyList))]) ->
                      case alts_2 of
                        (ErlangCons altcode_202 (ErlangEmptyList)) ->
                          case altcode_202 of
                            (ErlangAtom "missing") ->
                              let   
                                head_210 =
                                  ErlangTuple [ErlangAtom "jump", defref_70]
                              in let
                                record_updt_207 =
                                  BIF.erlang__op_append
                                    [pop_83,
                                     ErlangCons head_210 ErlangEmptyList]
                              in let
                                tup_el_205 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_214,
                                                  code_215, catchall_216]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_214,
                                         record_updt_207, catchall_216]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_205, ErlangEmptyList, ErlangEmptyList]
                            _ ->
                              let   
                                head_226 =
                                  ErlangTuple [ErlangAtom "jump", restref_28]
                              in let
                                rop_223 =
                                  BIF.erlang__op_append
                                    [altcode_202,
                                     ErlangCons head_226 ErlangEmptyList]
                              in let
                                record_updt_221 =
                                  BIF.erlang__op_append [pop_83, rop_223]
                              in let
                                tup_el_219 =
                                  case blk_6 of
                                    (ErlangTuple [(ErlangAtom "blk"), ref_230,
                                                  code_231, catchall_232]) ->
                                      ErlangTuple
                                        [ErlangAtom "blk", ref_230,
                                         record_updt_221, catchall_232]
                                    _ -> EXC.badrecord (ErlangAtom "blk")
                              in
                                ErlangTuple
                                  [tup_el_219, ErlangEmptyList, ErlangEmptyList]
                        _ -> EXC.badmatch alts_2
                    (ErlangTuple [(ErlangAtom "variant"), _ar_235]) ->
                      let   
                        lop_237 =
                          BIF.do_remote_fun_call "Lists" "erlps__usort__1"
                            [alts_2]
                      in let
                        case_236 =
                          BIF.erlang__op_eq
                            [lop_237,
                             ErlangCons (ErlangAtom "missing") ErlangEmptyList]
                      in
                        case case_236 of
                          (ErlangAtom "true") ->
                            let   
                              head_247 =
                                ErlangTuple [ErlangAtom "jump", defref_70]
                            in let
                              record_updt_244 =
                                BIF.erlang__op_append
                                  [pop_83, ErlangCons head_247 ErlangEmptyList]
                            in let
                              tup_el_242 =
                                case blk_6 of
                                  (ErlangTuple [(ErlangAtom "blk"), ref_251,
                                                code_252, catchall_253]) ->
                                    ErlangTuple
                                      [ErlangAtom "blk", ref_251,
                                       record_updt_244, catchall_253]
                                  _ -> EXC.badrecord (ErlangAtom "blk")
                            in
                              ErlangTuple
                                [tup_el_242, ErlangEmptyList, ErlangEmptyList]
                          (ErlangAtom "false") ->
                            let   
                              mkblk_270 =
                                ErlangFun 1
                                  (let
                                     lambda_256 [(ErlangAtom "missing")] =
                                       ErlangTuple [defref_70, ErlangEmptyList]
                                     lambda_256 [acode_260] =
                                       let   
                                         head_264 =
                                           ErlangTuple
                                             [ErlangAtom "jump", restref_28]
                                       in let
                                         arg_261 =
                                           BIF.erlang__op_append
                                             [acode_260,
                                              ErlangCons head_264
                                                ErlangEmptyList]
                                       in
                                         BIF.erlang__apply__2
                                           [freshblk_24,
                                            ErlangCons arg_261
                                              (ErlangCons defref_70
                                                 ErlangEmptyList)]
                                     lambda_256 [arg_257] =
                                       EXC.function_clause unit
                                     lambda_256 args =
                                       EXC.badarity (ErlangFun 1 lambda_256)
                                         args
                                   in lambda_256)
                            in let
                              arg_271 =
                                BIF.do_remote_fun_call "Lists" "erlps__map__2"
                                  [mkblk_270, alts_2]
                            in let
                              matchExpr_276 =
                                BIF.do_remote_fun_call "Lists" "erlps__unzip__1"
                                  [arg_271]
                            in
                              case matchExpr_276 of
                                (ErlangTuple [altrefs_274, altbs_275]) ->
                                  let   
                                    tup_el_277 =
                                      case blk_6 of
                                        (ErlangTuple [(ErlangAtom "blk"),
                                                      ref_280, code_281,
                                                      catchall_282]) ->
                                          ErlangTuple
                                            [ErlangAtom "blk", ref_280,
                                             ErlangEmptyList, catchall_282]
                                        _ -> EXC.badrecord (ErlangAtom "blk")
                                  in let
                                    head_284 =
                                      ErlangTuple
                                        [ErlangAtom "switch", arg_0,
                                         altrefs_274]
                                  in let
                                    tup_el_289 =
                                      BIF.do_remote_fun_call "Lists"
                                        "erlps__append__1" [altbs_275]
                                  in
                                    ErlangTuple
                                      [tup_el_277,
                                       ErlangCons head_284 ErlangEmptyList,
                                       tup_el_289]
                                _ -> EXC.badmatch matchExpr_276
                          something_else -> EXC.case_clause something_else
                    something_else -> EXC.case_clause something_else
              in
                case matchExpr_294 of
                  (ErlangTuple [blk1_291, code1_292, altblks_293]) ->
                    let   
                      blk2_300 =
                        case blk1_291 of
                          (ErlangTuple [(ErlangAtom "blk"), ref_297, code_298,
                                        catchall_299]) ->
                            ErlangTuple
                              [ErlangAtom "blk", ref_297, code_298, defref_70]
                          _ -> EXC.badrecord (ErlangAtom "blk")
                    in let arg_302 = BIF.erlang__op_append [code1_292, acc_7]
                    in let
                      rop_309 = BIF.erlang__op_append [altblks_293, blocks_8]
                    in let rop_307 = BIF.erlang__op_append [restblk_29, rop_309]
                    in let arg_305 = BIF.erlang__op_append [defblk_71, rop_307]
                    in erlps__block__4 [blk2_300, arg_302, arg_305, blockacc_9]
                  _ -> EXC.badmatch matchExpr_294
            _ -> EXC.badmatch matchExpr_72
      _ -> EXC.badmatch matchExpr_30
erlps__block__4 [blk_2@(ErlangTuple [(ErlangAtom "blk"), _,
                                     (ErlangCons i_0 code_1), _]),
                 acc_3, blocks_4, blockacc_5]
  =
  let
    arg_6 =
      case blk_2 of
        (ErlangTuple [(ErlangAtom "blk"), ref_9, code_10,
                      catchall_11]) ->
          ErlangTuple [ErlangAtom "blk", ref_9, code_1, catchall_11]
        _ -> EXC.badrecord (ErlangAtom "blk")
  in
    erlps__block__4
      [arg_6, ErlangCons i_0 acc_3, blocks_4, blockacc_5]
erlps__block__4 [arg_17, arg_18, arg_19, arg_20] =
  EXC.function_clause unit
erlps__block__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__optimize_blocks__1 :: ErlangFun
erlps__optimize_blocks__1 [blocks_0] =
  let   
    rev_12 =
      ErlangFun 1
        (let
           lambda_1 [bs_3] =
             flmap
               (\ lc_7 ->
                  case lc_7 of
                    (ErlangTuple [ref_5, code_6]) ->
                      let   
                        tup_el_10 =
                          BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
                            [code_6]
                      in let lcRet_8 = ErlangTuple [ref_5, tup_el_10]
                      in ErlangCons lcRet_8 ErlangEmptyList
                    _ -> ErlangEmptyList)
               bs_3
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let
    rblocks_15 =
      BIF.erlang__apply__2
        [rev_12, ErlangCons blocks_0 ErlangEmptyList]
  in let rblockmap_17 = BIF.maps__from_list__1 [rblocks_15]
  in let
    rblocks1_20 =
      erlps__reorder_blocks__2 [rblocks_15, ErlangEmptyList]
  in let
    rblocks2_31 =
      flmap
        (\ lc_24 ->
           case lc_24 of
             (ErlangTuple [ref_22, code_23]) ->
               let   
                 tup_el_27 =
                   erlps__inline_block__3 [rblockmap_17, ref_22, code_23]
               in let lcRet_25 = ErlangTuple [ref_22, tup_el_27]
               in ErlangCons lcRet_25 ErlangEmptyList
             _ -> ErlangEmptyList)
        rblocks1_20
  in let rblocks3_33 = erlps__shortcut_jump_chains__1 [rblocks2_31]
  in let rblocks4_35 = erlps__remove_dead_blocks__1 [rblocks3_33]
  in let
    rblocks5_44 =
      flmap
        (\ lc_39 ->
           case lc_39 of
             (ErlangTuple [ref_37, code_38]) ->
               let    tup_el_42 = erlps__tweak_returns__1 [code_38]
               in let lcRet_40 = ErlangTuple [ref_37, tup_el_42]
               in ErlangCons lcRet_40 ErlangEmptyList
             _ -> ErlangEmptyList)
        rblocks4_35
  in
    BIF.erlang__apply__2
      [rev_12, ErlangCons rblocks5_44 ErlangEmptyList]
erlps__optimize_blocks__1 [arg_47] = EXC.function_clause unit
erlps__optimize_blocks__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__reorder_blocks__2 :: ErlangFun
erlps__reorder_blocks__2 [(ErlangEmptyList), acc_0] =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
erlps__reorder_blocks__2 [(ErlangCons (ErlangTuple [ref_0,
                                                    code_1]) blocks_2),
                          acc_3]
  =
  erlps__reorder_blocks__4 [ref_0, code_1, blocks_2, acc_3]
erlps__reorder_blocks__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__reorder_blocks__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__reorder_blocks__4 :: ErlangFun
erlps__reorder_blocks__4 [ref_0, code_1, blocks_2, acc_3] =
  let head_4 = ErlangTuple [ref_0, code_1]
  in
    case code_1 of
      (ErlangCons (ErlangAtom "RETURN") _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "RETURNR"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "CALL_T"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "EXIT"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "ABORT"), _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "switch"), _, _]) _) ->
        erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
      (ErlangCons (ErlangTuple [(ErlangAtom "jump"), l_22]) _) ->
        let   
          notl_28 =
            ErlangFun 1
              (let
                 lambda_23 [(ErlangTuple [l1_25, _])] =
                   BIF.erlang__op_neq [l1_25, l_22]
                 lambda_23 [arg_24] = EXC.function_clause unit
                 lambda_23 args = EXC.badarity (ErlangFun 1 lambda_23) args
               in lambda_23)
        in let
          case_29 =
            BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
              [notl_28, blocks_2]
        in
          case case_29 of
            (ErlangTuple [blocks1_32,
                          (ErlangCons (ErlangTuple [l_33,
                                                    code1_34]) blocks2_35)]) | l_33 ==
                                                                                 l_22 ->
              let arg_38 = BIF.erlang__op_append [blocks1_32, blocks2_35]
              in
                erlps__reorder_blocks__4
                  [l_22, code1_34, arg_38, ErlangCons head_4 acc_3]
            (ErlangTuple [_, (ErlangEmptyList)]) ->
              erlps__reorder_blocks__2 [blocks_2, ErlangCons head_4 acc_3]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__reorder_blocks__4 [arg_44, arg_45, arg_46, arg_47] =
  EXC.function_clause unit
erlps__reorder_blocks__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__inline_block__3 :: ErlangFun
erlps__inline_block__3 [blockmap_0, ref_1,
                        code0_4@(ErlangCons (ErlangTuple [(ErlangAtom "jump"),
                                                          l_2]) code_3)]
  | weakNEq l_2 ref_1 =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [l_2, blockmap_0, ErlangAtom "nocode"]
  in
    case case_5 of
      dest_9 | (ErlangAtom "true") ==
                 (falsifyErrors
                    (\ _ ->
                       let    lop_10 = BIF.erlang__length__1 [dest_9]
                       in let rop_12 = toErl 3
                       in BIF.erlang__op_lesser [lop_10, rop_12])) ->
        let    arg_14 = BIF.maps__remove__2 [ref_1, blockmap_0]
        in let lop_13 = erlps__inline_block__3 [arg_14, l_2, dest_9]
        in BIF.erlang__op_append [lop_13, code_3]
      _ -> code0_4
erlps__inline_block__3 [_, _, code_0] = code_0
erlps__inline_block__3 [arg_1, arg_2, arg_3] =
  EXC.function_clause unit
erlps__inline_block__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__shortcut_jump_chains__1 :: ErlangFun
erlps__shortcut_jump_chains__1 [rblocks_0] =
  let   
    arg_1 =
      ErlangFun 2
        (let
           lambda_2 [(ErlangTuple [l1_5,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "jump"),
                                                             l2_6]) (ErlangEmptyList))]),
                     sub_7]
             =
             let   
               val_10 =
                 BIF.do_remote_fun_call "Maps" "erlps__get__3"
                   [l2_6, sub_7, l2_6]
             in let mapExt_14 = ErlangMap (Map.singleton l1_5 val_10)
             in BIF.maps__merge__2 [sub_7, mapExt_14]
           lambda_2 [_, sub_16] = sub_16
           lambda_2 [arg_3, arg_4] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
         in lambda_2)
  in let arg_17 = ErlangMap Map.empty
  in let
    subst_19 =
      BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
        [arg_1, arg_17, rblocks_0]
  in
    flmap
      (\ lc_23 ->
         case lc_23 of
           (ErlangTuple [ref_21, code_22]) ->
             let    tup_el_26 = erlps__update_labels__2 [subst_19, code_22]
             in let lcRet_24 = ErlangTuple [ref_21, tup_el_26]
             in ErlangCons lcRet_24 ErlangEmptyList
           _ -> ErlangEmptyList)
      rblocks_0
erlps__shortcut_jump_chains__1 [arg_29] =
  EXC.function_clause unit
erlps__shortcut_jump_chains__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__update_labels__2 :: ErlangFun
erlps__update_labels__2 [sub_0, ref_1]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_reference__1 [ref_1])) =
  BIF.do_remote_fun_call "Maps" "erlps__get__3"
    [ref_1, sub_0, ref_1]
erlps__update_labels__2 [sub_0, l_1] | isEList l_1 =
  let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [x_5] = erlps__update_labels__2 [sub_0, x_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_2, l_1]
erlps__update_labels__2 [sub_0, t_1] | isETuple t_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_2 = erlps__update_labels__2 [sub_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__update_labels__2 [_, x_0] = x_0
erlps__update_labels__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__update_labels__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__remove_dead_blocks__1 :: ErlangFun
erlps__remove_dead_blocks__1 [blocks_1@(ErlangCons (ErlangTuple [top_0,
                                                                 _]) _)]
  =
  let    blockmap_3 = BIF.maps__from_list__1 [blocks_1]
  in let arg_8 = ErlangMap Map.empty
  in let
    liveblocks_9 =
      erlps__chase_labels__3
        [ErlangCons top_0 ErlangEmptyList, blockmap_3, arg_8]
  in
    flmap
      (\ lc_13 ->
         case lc_13 of
           b_12@(ErlangTuple [l_11, _]) ->
             let cond_14 = BIF.maps__is_key__2 [l_11, liveblocks_9]
             in
               case cond_14 of
                 (ErlangAtom "true") -> ErlangCons b_12 ErlangEmptyList
                 _ -> ErlangEmptyList
           _ -> ErlangEmptyList)
      blocks_1
erlps__remove_dead_blocks__1 [arg_18] = EXC.function_clause unit
erlps__remove_dead_blocks__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__chase_labels__3 :: ErlangFun
erlps__chase_labels__3 [(ErlangEmptyList), _, live_0] = live_0
erlps__chase_labels__3 [(ErlangCons l_0 ls_1), map_2, live_3] =
  let    code_6 = BIF.maps__get__2 [l_0, map_2]
  in let
    jump_30 =
      ErlangFun 1
        (let
           lambda_7 [(ErlangTuple [(ErlangAtom "jump"), a_9])] =
             let    op_arg_11 = BIF.maps__is_key__2 [a_9, live_3]
             in let cond_10 = BIF.erlang__not__1 [op_arg_11]
             in
               case cond_10 of
                 (ErlangAtom "true") -> ErlangCons a_9 ErlangEmptyList
                 _ -> ErlangEmptyList
           lambda_7 [(ErlangTuple [(ErlangAtom "jumpif"), _, a_15])] =
             let    op_arg_17 = BIF.maps__is_key__2 [a_15, live_3]
             in let cond_16 = BIF.erlang__not__1 [op_arg_17]
             in
               case cond_16 of
                 (ErlangAtom "true") -> ErlangCons a_15 ErlangEmptyList
                 _ -> ErlangEmptyList
           lambda_7 [(ErlangTuple [(ErlangAtom "switch"), _, as_21])] =
             flmap
               (\ lc_24 ->
                  let    op_arg_26 = BIF.maps__is_key__2 [lc_24, live_3]
                  in let cond_25 = BIF.erlang__not__1 [op_arg_26]
                  in
                    case cond_25 of
                      (ErlangAtom "true") -> ErlangCons lc_24 ErlangEmptyList
                      _ -> ErlangEmptyList)
               as_21
           lambda_7 [_] = ErlangEmptyList
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    new_33 =
      BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
        [jump_30, code_6]
  in let arg_34 = BIF.erlang__op_append [new_33, ls_1]
  in let
    mapExt_42 = ErlangMap (Map.singleton l_0 (ErlangAtom "true"))
  in let arg_38 = BIF.maps__merge__2 [live_3, mapExt_42]
  in erlps__chase_labels__3 [arg_34, map_2, arg_38]
erlps__chase_labels__3 [arg_44, arg_45, arg_46] =
  EXC.function_clause unit
erlps__chase_labels__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tweak_returns__1 :: ErlangFun
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") (ErlangCons (ErlangTuple [(ErlangAtom "PUSH"),
                                                                                     a_0]) code_1))]
  =
  let head_2 = ErlangTuple [ErlangAtom "RETURNR", a_0]
  in ErlangCons head_2 code_1
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangTuple [(ErlangAtom "CALL_T"),
                                                                                            _]) _))]
  =
  code_0
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangTuple [(ErlangAtom "ABORT"),
                                                                                            _]) _))]
  =
  code_0
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangTuple [(ErlangAtom "EXIT"),
                                                                                            _]) _))]
  =
  code_0
erlps__tweak_returns__1 [(ErlangCons (ErlangAtom "RETURN") code_0@(ErlangCons (ErlangAtom "loop") _))]
  =
  code_0
erlps__tweak_returns__1 [code_0] = code_0
erlps__tweak_returns__1 [arg_1] = EXC.function_clause unit
erlps__tweak_returns__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_calls__1 :: ErlangFun
erlps__split_calls__1 [(ErlangTuple [ref_0, code_1])] =
  erlps__split_calls__4
    [ref_0, code_1, ErlangEmptyList, ErlangEmptyList]
erlps__split_calls__1 [arg_6] = EXC.function_clause unit
erlps__split_calls__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__split_calls__4 :: ErlangFun
erlps__split_calls__4 [ref_0, (ErlangEmptyList), acc_1, blocks_2]
  =
  let   
    tup_el_6 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in let head_4 = ErlangTuple [ref_0, tup_el_6]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_4 blocks_2]
erlps__split_calls__4 [ref_0, (ErlangCons i_1 code_2), acc_3,
                       blocks_4]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    arg_20 = toErl 1
            in let lop_19 = BIF.erlang__element__2 [arg_20, i_1]
            in let lop_18 = BIF.erlang__op_eq [lop_19, ErlangAtom "CALL"]
            in let
              lop_17 =
                case lop_18 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    let    arg_24 = toErl 1
                    in let lop_23 = BIF.erlang__element__2 [arg_24, i_1]
                    in BIF.erlang__op_eq [lop_23, ErlangAtom "CALL_R"]
                  _ -> EXC.badarg1 lop_18
            in let
              lop_16 =
                case lop_17 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    let    arg_28 = toErl 1
                    in let lop_27 = BIF.erlang__element__2 [arg_28, i_1]
                    in BIF.erlang__op_eq [lop_27, ErlangAtom "CALL_GR"]
                  _ -> EXC.badarg1 lop_17
            in
              case lop_16 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  let    arg_32 = toErl 1
                  in let lop_31 = BIF.erlang__element__2 [arg_32, i_1]
                  in BIF.erlang__op_eq [lop_31, ErlangAtom "jumpif"]
                _ -> EXC.badarg1 lop_16)) =
  let    arg_5 = BIF.erlang__make_ref__0 []
  in let
    tup_el_11 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons i_1 acc_3]
  in let head_9 = ErlangTuple [ref_0, tup_el_11]
  in
    erlps__split_calls__4
      [arg_5, code_2, ErlangEmptyList, ErlangCons head_9 blocks_4]
erlps__split_calls__4 [ref_0,
                       (ErlangCons i_1@(ErlangTuple [(ErlangAtom "ABORT"),
                                                     _]) _code_2),
                       acc_3, blocks_4]
  =
  let   
    tup_el_8 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons i_1 acc_3]
  in let head_6 = ErlangTuple [ref_0, tup_el_8]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_6 blocks_4]
erlps__split_calls__4 [ref_0,
                       (ErlangCons i_1@(ErlangTuple [(ErlangAtom "EXIT"),
                                                     _]) _code_2),
                       acc_3, blocks_4]
  =
  let   
    tup_el_8 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons i_1 acc_3]
  in let head_6 = ErlangTuple [ref_0, tup_el_8]
  in
    BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
      [ErlangCons head_6 blocks_4]
erlps__split_calls__4 [ref_0, (ErlangCons i_1 code_2), acc_3,
                       blocks_4]
  =
  erlps__split_calls__4
    [ref_0, code_2, ErlangCons i_1 acc_3, blocks_4]
erlps__split_calls__4 [arg_11, arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__split_calls__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__set_labels__2 :: ErlangFun
erlps__set_labels__2 [labels_0, (ErlangTuple [ref_1, code_2])]
  | (ErlangAtom "true") ==
      (falsifyErrors (\ _ -> BIF.erlang__is_reference__1 [ref_1])) =
  let    tup_el_3 = BIF.maps__get__2 [ref_1, labels_0]
  in let
    tup_el_6 =
      flmap
        (\ lc_9 ->
           let lcRet_10 = erlps__set_labels__2 [labels_0, lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        code_2
  in ErlangTuple [tup_el_3, tup_el_6]
erlps__set_labels__2 [_labels_0, (ErlangAtom "loop")] =
  let arg_1 = toErl 0
  in BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__jump__1" [arg_1]
erlps__set_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "jump"), ref_1])]
  =
  let arg_2 = BIF.maps__get__2 [ref_1, labels_0]
  in BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__jump__1" [arg_2]
erlps__set_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "jumpif"), arg_1, ref_2])]
  =
  let arg_4 = BIF.maps__get__2 [ref_2, labels_0]
  in
    BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__jumpif__2"
      [arg_1, arg_4]
erlps__set_labels__2 [labels_0,
                      (ErlangTuple [(ErlangAtom "switch"), arg_1, refs_2])]
  =
  let
    case_3 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = BIF.maps__get__2 [lc_6, labels_0]
           in ErlangCons lcRet_7 ErlangEmptyList)
        refs_2
  in
    case case_3 of
      (ErlangCons r1_10 (ErlangCons r2_11 (ErlangEmptyList))) ->
        BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__switch__3"
          [arg_1, r1_10, r2_11]
      (ErlangCons r1_15 (ErlangCons r2_16 (ErlangCons r3_17 (ErlangEmptyList)))) ->
        BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__switch__4"
          [arg_1, r1_15, r2_16, r3_17]
      rs_22 ->
        BIF.do_remote_fun_call "Aeb.Fate.Ops" "erlps__switch__2"
          [arg_1, rs_22]
erlps__set_labels__2 [_, i_0] = i_0
erlps__set_labels__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__set_labels__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__with_ixs__1 :: ErlangFun
erlps__with_ixs__1 [xs_0] =
  let    arg_2 = toErl 0
  in let lop_4 = BIF.erlang__length__1 [xs_0]
  in let rop_6 = toErl 1
  in let arg_3 = BIF.erlang__op_minus [lop_4, rop_6]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_1, xs_0]
erlps__with_ixs__1 [arg_8] = EXC.function_clause unit
erlps__with_ixs__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__drop_common_suffix__2 :: ErlangFun
erlps__drop_common_suffix__2 [xs_0, ys_1] =
  let   
    arg_2 = BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [xs_0]
  in let
    arg_4 = BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [ys_1]
  in erlps__drop_common_suffix_r__2 [arg_2, arg_4]
erlps__drop_common_suffix__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__drop_common_suffix__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__drop_common_suffix_r__2 :: ErlangFun
erlps__drop_common_suffix_r__2 [(ErlangCons x_0 xs_1),
                                (ErlangCons x_2 ys_3)]
  | x_2 == x_0 =
  erlps__drop_common_suffix_r__2 [xs_1, ys_3]
erlps__drop_common_suffix_r__2 [xs_0, ys_1] =
  let   
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [xs_0]
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [ys_1]
  in ErlangTuple [tup_el_2, tup_el_4]
erlps__drop_common_suffix_r__2 [arg_6, arg_7] =
  EXC.function_clause unit
erlps__drop_common_suffix_r__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args