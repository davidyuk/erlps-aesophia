module Aeso.Scan.Lib(erlps__compile__1, erlps__string__3,
                     erlps__token__1, erlps__token__2, erlps__symbol__0,
                     erlps__skip__0, erlps__override__2, erlps__push__2,
                     erlps__pop__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__compile__1 :: ErlangFun
erlps__compile__1 [tokenspecs_0] =
  flmap
    (\ lc_4 ->
       case lc_4 of
         (ErlangTuple [s_2, spec_3]) ->
           let    tup_el_7 = erlps__compile_spec__1 [spec_3]
           in let lcRet_5 = ErlangTuple [s_2, tup_el_7]
           in ErlangCons lcRet_5 ErlangEmptyList
         _ -> ErlangEmptyList)
    tokenspecs_0
erlps__compile__1 [arg_9] = EXC.function_clause unit
erlps__compile__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__compile_spec__1 :: ErlangFun
erlps__compile_spec__1 [tokenspecs_0] =
  let    arg_2 = toErl 1
  in let arg_3 = BIF.erlang__length__1 [tokenspecs_0]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in let
    withixs_6 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [arg_1, tokenspecs_0]
  in let head_8 = toErl "^("
  in let arg_11 = toErl 0
  in let head_10 = erlps__name__1 [arg_11]
  in let
    arg_14 =
      flmap
        (\ lc_18 ->
           case lc_18 of
             (ErlangTuple [i_16, (ErlangTuple [r_17, _])]) ->
               let    head_20 = toErl "("
               in let head_22 = erlps__name__1 [i_16]
               in let head_27 = toErl ")"
               in
                 ErlangCons
                   (ErlangCons head_20
                      (ErlangCons head_22
                         (ErlangCons r_17
                            (ErlangCons head_27 ErlangEmptyList))))
                   ErlangEmptyList
             _ -> ErlangEmptyList)
        withixs_6
  in let arg_29 = toErl "|"
  in let
    head_13 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_14, arg_29]
  in let head_31 = toErl ")"
  in let
    matchExpr_34 =
      BIF.do_remote_fun_call "Re" "erlps__compile__1"
        [ErlangCons head_8
           (ErlangCons head_10
              (ErlangCons head_13 (ErlangCons head_31 ErlangEmptyList)))]
  in
    case matchExpr_34 of
      (ErlangTuple [(ErlangAtom "ok"), regex_33]) ->
        let
          actions_39 =
            flmap
              (\ lc_37 ->
                 case lc_37 of
                   (ErlangTuple [_, fun_36]) ->
                     ErlangCons fun_36 ErlangEmptyList
                   _ -> ErlangEmptyList)
              tokenspecs_0
        in
          ErlangFun 2
            (let
               lambda_40 [(ErlangEmptyList), _pos_43] = ErlangAtom "end_of_file"
               lambda_40 [s_44, pos_45] =
                 let   
                   head_50 =
                     ErlangTuple [ErlangAtom "capture", ErlangAtom "all_names"]
                 in let
                   case_46 =
                     BIF.do_remote_fun_call "Re" "erlps__run__3"
                       [s_44, regex_33, ErlangCons head_50 ErlangEmptyList]
                 in
                   case case_46 of
                     (ErlangTuple [(ErlangAtom "match"),
                                   (ErlangCons (ErlangTuple [(ErlangInt num_54),
                                                             n_55]) capture_56)]) | ((ErlangInt
                                                                                        num_54) ==
                                                                                       (toErl
                                                                                          0)) ->
                       let    lop_57 = toErl 1
                       in let
                         arg_60 =
                           ErlangFun 1
                             (let
                                lambda_61 [(ErlangTuple [p_63, _])] =
                                  let    op_arg_66 = toErl 1
                                  in let rop_65 = BIF.erlang__op_neg [op_arg_66]
                                  in BIF.erlang__op_eq [p_63, rop_65]
                                lambda_61 [arg_62] = EXC.function_clause unit
                                lambda_61 args =
                                  EXC.badarity (ErlangFun 1 lambda_61) args
                              in lambda_61)
                       in let
                         arg_59 =
                           BIF.do_remote_fun_call "Lists" "erlps__takewhile__2"
                             [arg_60, capture_56]
                       in let rop_58 = BIF.erlang__length__1 [arg_59]
                       in let index_68 = BIF.erlang__op_plus [lop_57, rop_58]
                       in let
                         action_71 =
                           BIF.do_remote_fun_call "Lists" "erlps__nth__2"
                             [index_68, actions_39]
                       in let
                         matchExpr_76 =
                           BIF.do_remote_fun_call "Lists" "erlps__split__2"
                             [n_55, s_44]
                       in
                         case matchExpr_76 of
                           (ErlangTuple [toks_74, rest_75]) ->
                             let   
                               tok_80 =
                                 BIF.erlang__apply__2
                                   [action_71,
                                    ErlangCons toks_74
                                      (ErlangCons pos_45 ErlangEmptyList)]
                             in let
                               tup_el_84 = erlps__next_pos__2 [toks_74, pos_45]
                             in
                               ErlangTuple
                                 [ErlangAtom "ok", tok_80, rest_75, tup_el_84]
                           _ -> EXC.badmatch matchExpr_76
                     (ErlangAtom "nomatch") -> ErlangAtom "error"
                     something_else -> EXC.case_clause something_else
               lambda_40 [arg_41, arg_42] = EXC.function_clause unit
               lambda_40 args = EXC.badarity (ErlangFun 2 lambda_40) args
             in lambda_40)
      _ -> EXC.badmatch matchExpr_34
erlps__compile_spec__1 [arg_87] = EXC.function_clause unit
erlps__compile_spec__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__token__1 :: ErlangFun
erlps__token__1 [tag_0] =
  let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [x_5] = x_5
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in erlps__token__2 [tag_0, arg_2]
erlps__token__1 [arg_6] = EXC.function_clause unit
erlps__token__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__token__2 :: ErlangFun
erlps__token__2 [tag_0, fun_1] =
  ErlangFun 2
    (let
       lambda_2 [s_5, p_6] =
         let   
           tup_el_12 =
             BIF.erlang__apply__2 [fun_1, ErlangCons s_5 ErlangEmptyList]
         in let tup_el_9 = ErlangTuple [tag_0, p_6, tup_el_12]
         in let tup_el_7 = ErlangTuple [ErlangAtom "token", tup_el_9]
         in ErlangTuple [tup_el_7, ErlangAtom "none"]
       lambda_2 [arg_3, arg_4] = EXC.function_clause unit
       lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
     in lambda_2)
erlps__token__2 [arg_16, arg_17] = EXC.function_clause unit
erlps__token__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__symbol__0 :: ErlangFun
erlps__symbol__0 [] =
  ErlangFun 2
    (let
       lambda_0 [s_3, p_4] =
         let    tup_el_8 = BIF.erlang__list_to_atom__1 [s_3]
         in let tup_el_7 = ErlangTuple [tup_el_8, p_4]
         in let tup_el_5 = ErlangTuple [ErlangAtom "token", tup_el_7]
         in ErlangTuple [tup_el_5, ErlangAtom "none"]
       lambda_0 [arg_1, arg_2] = EXC.function_clause unit
       lambda_0 args = EXC.badarity (ErlangFun 2 lambda_0) args
     in lambda_0)
erlps__symbol__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__skip__0 :: ErlangFun
erlps__skip__0 [] =
  ErlangFun 2
    (let
       lambda_0 [_, _] =
         ErlangTuple [ErlangAtom "skip", ErlangAtom "none"]
       lambda_0 [arg_1, arg_2] = EXC.function_clause unit
       lambda_0 args = EXC.badarity (ErlangFun 2 lambda_0) args
     in lambda_0)
erlps__skip__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__push__2 :: ErlangFun
erlps__push__2 [state_0, action_1] =
  ErlangFun 2
    (let
       lambda_2 [s_5, p_6] =
         let
           matchExpr_11 =
             BIF.erlang__apply__2
               [action_1, ErlangCons s_5 (ErlangCons p_6 ErlangEmptyList)]
         in
           case matchExpr_11 of
             (ErlangTuple [res_10, _]) ->
               let tup_el_13 = ErlangTuple [ErlangAtom "push", state_0]
               in ErlangTuple [res_10, tup_el_13]
             _ -> EXC.badmatch matchExpr_11
       lambda_2 [arg_3, arg_4] = EXC.function_clause unit
       lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
     in lambda_2)
erlps__push__2 [arg_16, arg_17] = EXC.function_clause unit
erlps__push__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pop__1 :: ErlangFun
erlps__pop__1 [action_0] =
  ErlangFun 2
    (let
       lambda_1 [s_4, p_5] =
         let
           matchExpr_10 =
             BIF.erlang__apply__2
               [action_0, ErlangCons s_4 (ErlangCons p_5 ErlangEmptyList)]
         in
           case matchExpr_10 of
             (ErlangTuple [res_9, _]) -> ErlangTuple [res_9, ErlangAtom "pop"]
             _ -> EXC.badmatch matchExpr_10
       lambda_1 [arg_2, arg_3] = EXC.function_clause unit
       lambda_1 args = EXC.badarity (ErlangFun 2 lambda_1) args
     in lambda_1)
erlps__pop__1 [arg_13] = EXC.function_clause unit
erlps__pop__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__override__2 :: ErlangFun
erlps__override__2 [(ErlangTuple [re1_0, action1_1]),
                    (ErlangTuple [re2_2, action2_3])]
  =
  let    head_5 = toErl "^("
  in let head_9 = toErl ")$"
  in let
    matchExpr_12 =
      BIF.do_remote_fun_call "Re" "erlps__compile__1"
        [ErlangCons head_5
           (ErlangCons re2_2 (ErlangCons head_9 ErlangEmptyList))]
  in
    case matchExpr_12 of
      (ErlangTuple [(ErlangAtom "ok"), compiled_11]) ->
        let
          tup_el_14 =
            ErlangFun 2
              (let
                 lambda_15 [s_18, p_19] =
                   let   
                     head_24 =
                       ErlangTuple [ErlangAtom "capture", ErlangAtom "none"]
                   in let
                     case_20 =
                       BIF.do_remote_fun_call "Re" "erlps__run__3"
                         [s_18, compiled_11, ErlangCons head_24 ErlangEmptyList]
                   in
                     case case_20 of
                       (ErlangAtom "match") ->
                         BIF.erlang__apply__2
                           [action2_3,
                            ErlangCons s_18 (ErlangCons p_19 ErlangEmptyList)]
                       (ErlangAtom "nomatch") ->
                         BIF.erlang__apply__2
                           [action1_1,
                            ErlangCons s_18 (ErlangCons p_19 ErlangEmptyList)]
                       something_else -> EXC.case_clause something_else
                 lambda_15 [arg_16, arg_17] = EXC.function_clause unit
                 lambda_15 args = EXC.badarity (ErlangFun 2 lambda_15) args
               in lambda_15)
        in ErlangTuple [re1_0, tup_el_14]
      _ -> EXC.badmatch matchExpr_12
erlps__override__2 [arg_34, arg_35] = EXC.function_clause unit
erlps__override__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__string__3 :: ErlangFun
erlps__string__3 [lexer_0, state_1, string_2] =
  let    tup_el_9 = toErl 1
  in let tup_el_10 = toErl 1
  in let arg_8 = ErlangTuple [tup_el_9, tup_el_10]
  in
    erlps__string__4
      [lexer_0, ErlangCons state_1 ErlangEmptyList, string_2, arg_8]
erlps__string__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__string__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__string__4 :: ErlangFun
erlps__string__4 [lexer_0, stack_1, string_2, pos_3] =
  let    arg_5 = toErl "\n"
  in let
    lines_7 =
      BIF.do_remote_fun_call "String" "erlps__split__3"
        [string_2, arg_5, ErlangAtom "all"]
  in
    erlps__string__5
      [lexer_0, stack_1, lines_7, pos_3, ErlangEmptyList]
erlps__string__4 [arg_13, arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__string__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__string__5 :: ErlangFun
erlps__string__5 [_lexers_0, (ErlangEmptyList),
                  (ErlangCons line_1 _rest_2), pos_3, _acc_4]
  =
  let    tup_el_7 = ErlangTuple [line_1, pos_3]
  in let
    tup_el_6 =
      ErlangTuple [tup_el_7, ErlangAtom "scan_error_no_state"]
  in ErlangTuple [ErlangAtom "error", tup_el_6]
erlps__string__5 [_lexers_0, _stack_1, (ErlangEmptyList), _pos_2,
                  acc_3]
  =
  let
    tup_el_5 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_3]
  in ErlangTuple [ErlangAtom "ok", tup_el_5]
erlps__string__5 [lexers_0, (ErlangCons state_1 stack_2),
                  (ErlangCons line_3 lines_4), pos_5, acc_6]
  =
  let   
    lexer_10 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [state_1, lexers_0, state_1]
  in let
    case_11 =
      BIF.erlang__apply__2
        [lexer_10, ErlangCons line_3 (ErlangCons pos_5 ErlangEmptyList)]
  in
    case case_11 of
      (ErlangTuple [(ErlangAtom "ok"),
                    (ErlangTuple [res_15, statechange_16]), line1_17,
                    pos1_18]) ->
        let   
          acc1_23 =
            case res_15 of
              (ErlangTuple [(ErlangAtom "token"), tok_20]) ->
                ErlangCons tok_20 acc_6
              (ErlangAtom "skip") -> acc_6
              something_else -> EXC.case_clause something_else
        in let
          stack1_32 =
            case statechange_16 of
              (ErlangAtom "none") -> ErlangCons state_1 stack_2
              (ErlangAtom "pop") -> stack_2
              (ErlangTuple [(ErlangAtom "push"), state1_27]) ->
                ErlangCons state1_27 (ErlangCons state_1 stack_2)
              something_else -> EXC.case_clause something_else
        in
          erlps__string__5
            [lexers_0, stack1_32, ErlangCons line1_17 lines_4, pos1_18,
             acc1_23]
      (ErlangAtom "end_of_file") ->
        let    arg_46 = toErl "\n"
        in let arg_45 = erlps__next_pos__2 [arg_46, pos_5]
        in
          erlps__string__5
            [lexers_0, ErlangCons state_1 stack_2, lines_4, arg_45, acc_6]
      (ErlangAtom "error") ->
        let    tup_el_51 = ErlangTuple [line_3, pos_5]
        in let
          tup_el_50 = ErlangTuple [tup_el_51, ErlangAtom "scan_error"]
        in ErlangTuple [ErlangAtom "error", tup_el_50]
      something_else -> EXC.case_clause something_else
erlps__string__5 [arg_55, arg_56, arg_57, arg_58, arg_59] =
  EXC.function_clause unit
erlps__string__5 args =
  EXC.badarity (ErlangFun 5 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__name__1 :: ErlangFun
erlps__name__1 [i_0] =
  let arg_1 = toErl "?<A~3.10.0b>"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons i_0 ErlangEmptyList]
erlps__name__1 [arg_5] = EXC.function_clause unit
erlps__name__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__next_pos__2 :: ErlangFun
erlps__next_pos__2 [(ErlangEmptyList), p_0] = p_0
erlps__next_pos__2 [(ErlangCons (ErlangInt num_0) s_1),
                    (ErlangTuple [l_2, _])]
  | ((ErlangInt num_0) == (toErl 10)) =
  let    rop_7 = toErl 1
  in let tup_el_5 = BIF.erlang__op_plus [l_2, rop_7]
  in let tup_el_8 = toErl 1
  in let arg_4 = ErlangTuple [tup_el_5, tup_el_8]
  in erlps__next_pos__2 [s_1, arg_4]
erlps__next_pos__2 [(ErlangCons (ErlangInt num_0) s_1),
                    (ErlangTuple [l_2, c_3])]
  | ((ErlangInt num_0) == (toErl 9)) =
  let    rop_13 = toErl 8
  in let lop_11 = BIF.erlang__op_plus [c_3, rop_13]
  in let rop_14 = toErl 1
  in let lop_10 = BIF.erlang__op_minus [lop_11, rop_14]
  in let rop_15 = toErl 8
  in let lop_9 = BIF.erlang__op_div_strict [lop_10, rop_15]
  in let rop_16 = toErl 8
  in let lop_8 = BIF.erlang__op_mult [lop_9, rop_16]
  in let rop_17 = toErl 1
  in let tup_el_7 = BIF.erlang__op_plus [lop_8, rop_17]
  in let arg_5 = ErlangTuple [l_2, tup_el_7]
  in erlps__next_pos__2 [s_1, arg_5]
erlps__next_pos__2 [(ErlangCons _ s_0), (ErlangTuple [l_1, c_2])]
  =
  let    rop_8 = toErl 1
  in let tup_el_6 = BIF.erlang__op_plus [c_2, rop_8]
  in let arg_4 = ErlangTuple [l_1, tup_el_6]
  in erlps__next_pos__2 [s_0, arg_4]
erlps__next_pos__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__next_pos__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args