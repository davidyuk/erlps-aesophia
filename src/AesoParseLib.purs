module Aeso.Parse.Lib(erlps__parse__2, erlps__return__1,
                      erlps__fail__0, erlps__fail__1, erlps__fail__2,
                      erlps__map__2, erlps__bind__2, erlps__lazy__1,
                      erlps__choice__1, erlps__choice__2, erlps__tok__1,
                      erlps__layout__0, erlps__left__2, erlps__right__2,
                      erlps__between__3, erlps__optional__1, erlps__many__1,
                      erlps__many1__1, erlps__sep__2, erlps__sep1__2,
                      erlps__infixl__2, erlps__infixr__2,
                      erlps__current_file__0, erlps__set_current_file__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__trampoline__1 :: ErlangFun
erlps__trampoline__1 [(ErlangTuple [(ErlangAtom "bounce"),
                                    cont_0])]
  | isEFunA cont_0 (toErl 0) =
  let arg_1 = BIF.erlang__apply__2 [cont_0, ErlangEmptyList]
  in erlps__trampoline__1 [arg_1]
erlps__trampoline__1 [res_0] = res_0
erlps__trampoline__1 [arg_1] = EXC.function_clause unit
erlps__trampoline__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__apply_p__2 :: ErlangFun
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_lazy"),
                                 f_0]),
                   k_1]
  =
  let arg_2 = BIF.erlang__apply__2 [f_0, ErlangEmptyList]
  in erlps__apply_p__2 [arg_2, k_1]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_fail"),
                                 err_0]),
                   _]
  =
  ErlangTuple [ErlangAtom "fail", err_0]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_choice"),
                                 (ErlangCons p_0 ps_1)]),
                   k_2]
  =
  let   
    arg_3 =
      ErlangFun 2
        (let
           lambda_4 [q_7, r_8] =
             let    arg_10 = erlps__apply_p__2 [q_7, k_2]
             in let arg_9 = erlps__trampoline__1 [arg_10]
             in erlps__choice1__2 [arg_9, r_8]
           lambda_4 [arg_5, arg_6] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 2 lambda_4) args
         in lambda_4)
  in let arg_15 = erlps__apply_p__2 [p_0, k_2]
  in let arg_14 = erlps__trampoline__1 [arg_15]
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_3, arg_14, ps_1]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_bind"),
                                 p_0, f_1]),
                   k_2]
  =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let
               arg_8 =
                 BIF.erlang__apply__2 [f_1, ErlangCons x_7 ErlangEmptyList]
             in erlps__apply_p__2 [arg_8, k_2]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__apply_p__2 [p_0, arg_4]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_right"),
                                 p_0, q_1]),
                   k_2]
  =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [_] = erlps__apply_p__2 [q_1, k_2]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__apply_p__2 [p_0, arg_4]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_left"),
                                 p_0, q_1]),
                   k_2]
  =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let
               arg_9 =
                 ErlangFun 1
                   (let
                      lambda_10 [_] =
                        BIF.erlang__apply__2
                          [k_2, ErlangCons x_7 ErlangEmptyList]
                      lambda_10 [arg_11] = EXC.function_clause unit
                      lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
                    in lambda_10)
             in erlps__apply_p__2 [q_1, arg_9]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__apply_p__2 [p_0, arg_4]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_map"),
                                 f_0, p_1]),
                   k_2]
  =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let
               arg_8 =
                 BIF.erlang__apply__2 [f_0, ErlangCons x_7 ErlangEmptyList]
             in BIF.erlang__apply__2 [k_2, ErlangCons arg_8 ErlangEmptyList]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__apply_p__2 [p_1, arg_4]
erlps__apply_p__2 [(ErlangAtom "aeso_parse_layout"), k_0] =
  let   
    tup_el_5 =
      ErlangTuple [ErlangAtom "expected", ErlangAtom "layout_block"]
  in let tup_el_3 = ErlangTuple [ErlangAtom "fail", tup_el_5]
  in ErlangTuple [ErlangAtom "layout", k_0, tup_el_3]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_tok"),
                                 atom_0]),
                   k_1]
  =
  let tup_el_3 = ErlangMap (Map.singleton atom_0 k_1)
  in ErlangTuple [ErlangAtom "tok_bind", tup_el_3]
erlps__apply_p__2 [(ErlangTuple [(ErlangAtom "aeso_parse_return"),
                                 x_0]),
                   k_1]
  =
  let
    tup_el_3 =
      ErlangFun 0
        (let
           lambda_4 [] =
             BIF.erlang__apply__2 [k_1, ErlangCons x_0 ErlangEmptyList]
           lambda_4 [] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 0 lambda_4) args
         in lambda_4)
  in ErlangTuple [ErlangAtom "bounce", tup_el_3]
erlps__apply_p__2 [(ErlangCons p_0 q_1), k_2] =
  let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [h_7] =
             let
               arg_9 =
                 ErlangFun 1
                   (let
                      lambda_10 [t_12] =
                        BIF.erlang__apply__2
                          [k_2,
                           ErlangCons (ErlangCons h_7 t_12) ErlangEmptyList]
                      lambda_10 [arg_11] = EXC.function_clause unit
                      lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
                    in lambda_10)
             in erlps__apply_p__2 [q_1, arg_9]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__apply_p__2 [p_0, arg_4]
erlps__apply_p__2 [t_0, k_1] | isETuple t_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [t_0]
  in let
    arg_4 =
      ErlangFun 1
        (let
           lambda_5 [xs_7] =
             let arg_8 = BIF.erlang__list_to_tuple__1 [xs_7]
             in BIF.erlang__apply__2 [k_1, ErlangCons arg_8 ErlangEmptyList]
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in erlps__apply_p__2 [arg_2, arg_4]
erlps__apply_p__2 [m_0, k_1] | isEMap m_0 =
  let    arg_2 = BIF.maps__to_list__1 [m_0]
  in let
    matchExpr_6 =
      BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_2]
  in
    case matchExpr_6 of
      (ErlangTuple [keys_4, ps_5]) ->
        let
          arg_8 =
            ErlangFun 1
              (let
                 lambda_9 [vals_11] =
                   let   
                     arg_13 =
                       BIF.do_remote_fun_call "Lists" "erlps__zip__2"
                         [keys_4, vals_11]
                   in let arg_12 = BIF.maps__from_list__1 [arg_13]
                   in
                     BIF.erlang__apply__2
                       [k_1, ErlangCons arg_12 ErlangEmptyList]
                 lambda_9 [arg_10] = EXC.function_clause unit
                 lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
               in lambda_9)
        in erlps__apply_p__2 [ps_5, arg_8]
      _ -> EXC.badmatch matchExpr_6
erlps__apply_p__2 [x_0, k_1] =
  let
    tup_el_3 =
      ErlangFun 0
        (let
           lambda_4 [] =
             BIF.erlang__apply__2 [k_1, ErlangCons x_0 ErlangEmptyList]
           lambda_4 [] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 0 lambda_4) args
         in lambda_4)
  in ErlangTuple [ErlangAtom "bounce", tup_el_3]
erlps__apply_p__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__apply_p__2 args =
  EXC.badarity (ErlangFun 2 erlps__apply_p__2) args

erlps__lazy__1 :: ErlangFun
erlps__lazy__1 [delayed_0] =
  ErlangTuple [ErlangAtom "aeso_parse_lazy", delayed_0]
erlps__lazy__1 [arg_3] = EXC.function_clause unit
erlps__lazy__1 args =
  EXC.badarity (ErlangFun 1 erlps__lazy__1) args

erlps__fail__2 :: ErlangFun
erlps__fail__2 [pos_0, err_1] =
  let tup_el_3 = ErlangTuple [pos_0, err_1]
  in ErlangTuple [ErlangAtom "aeso_parse_fail", tup_el_3]
erlps__fail__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__fail__2 args =
  EXC.badarity (ErlangFun 2 erlps__fail__2) args

erlps__fail__1 :: ErlangFun
erlps__fail__1 [err_0] =
  ErlangTuple [ErlangAtom "aeso_parse_fail", err_0]
erlps__fail__1 [arg_3] = EXC.function_clause unit
erlps__fail__1 args =
  EXC.badarity (ErlangFun 1 erlps__fail__1) args

erlps__fail__0 :: ErlangFun
erlps__fail__0 [] = erlps__fail__1 [ErlangAtom "no_error"]
erlps__fail__0 args =
  EXC.badarity (ErlangFun 0 erlps__fail__0) args

erlps__choice__2 :: ErlangFun
erlps__choice__2 [(ErlangTuple [(ErlangAtom "aeso_parse_choice"),
                                ps_0]),
                  (ErlangTuple [(ErlangAtom "aeso_parse_choice"), qs_1])]
  =
  let tup_el_3 = BIF.erlang__op_append [ps_0, qs_1]
  in ErlangTuple [ErlangAtom "aeso_parse_choice", tup_el_3]
erlps__choice__2 [(ErlangTuple [(ErlangAtom "aeso_parse_choice"),
                                ps_0]),
                  q_1]
  =
  ErlangTuple [ErlangAtom "aeso_parse_choice", ErlangCons q_1 ps_0]
erlps__choice__2 [p_0,
                  (ErlangTuple [(ErlangAtom "aeso_parse_choice"), qs_1])]
  =
  ErlangTuple [ErlangAtom "aeso_parse_choice", ErlangCons p_0 qs_1]
erlps__choice__2 [p_0, q_1] =
  ErlangTuple
    [ErlangAtom "aeso_parse_choice",
     ErlangCons p_0 (ErlangCons q_1 ErlangEmptyList)]
erlps__choice__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__choice__2 args =
  EXC.badarity (ErlangFun 2 erlps__choice__2) args

erlps__choice__1 :: ErlangFun
erlps__choice__1 [(ErlangEmptyList)] =
  erlps__fail__1 [ErlangAtom "empty_choice"]
erlps__choice__1 [(ErlangCons p_0 (ErlangEmptyList))] = p_0
erlps__choice__1 [(ErlangCons p_0 ps_1)] =
  let arg_3 = erlps__choice__1 [ps_1]
  in erlps__choice__2 [p_0, arg_3]
erlps__choice__1 [arg_5] = EXC.function_clause unit
erlps__choice__1 args =
  EXC.badarity (ErlangFun 1 erlps__choice__1) args

erlps__tok__1 :: ErlangFun
erlps__tok__1 [atom_0] =
  ErlangTuple [ErlangAtom "aeso_parse_tok", atom_0]
erlps__tok__1 [arg_3] = EXC.function_clause unit
erlps__tok__1 args =
  EXC.badarity (ErlangFun 1 erlps__tok__1) args

erlps__left__2 :: ErlangFun
erlps__left__2 [p_0, q_1] =
  ErlangTuple [ErlangAtom "aeso_parse_left", p_0, q_1]
erlps__left__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__left__2 args =
  EXC.badarity (ErlangFun 2 erlps__left__2) args

erlps__right__2 :: ErlangFun
erlps__right__2 [p_0, q_1] =
  ErlangTuple [ErlangAtom "aeso_parse_right", p_0, q_1]
erlps__right__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__right__2 args =
  EXC.badarity (ErlangFun 2 erlps__right__2) args

erlps__return__1 :: ErlangFun
erlps__return__1 [x_0] =
  ErlangTuple [ErlangAtom "aeso_parse_return", x_0]
erlps__return__1 [arg_3] = EXC.function_clause unit
erlps__return__1 args =
  EXC.badarity (ErlangFun 1 erlps__return__1) args

erlps__bind__2 :: ErlangFun
erlps__bind__2 [(ErlangTuple [(ErlangAtom "aeso_parse_return"),
                              x_0]),
                f_1]
  =
  BIF.erlang__apply__2 [f_1, ErlangCons x_0 ErlangEmptyList]
erlps__bind__2 [p_0, f_1] =
  ErlangTuple [ErlangAtom "aeso_parse_bind", p_0, f_1]
erlps__bind__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__bind__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind__2) args

erlps__map__2 :: ErlangFun
erlps__map__2 [fun_0, p_1] =
  ErlangTuple [ErlangAtom "aeso_parse_map", fun_0, p_1]
erlps__map__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__map__2 args =
  EXC.badarity (ErlangFun 2 erlps__map__2) args

erlps__layout__0 :: ErlangFun
erlps__layout__0 [] = ErlangAtom "aeso_parse_layout"
erlps__layout__0 args =
  EXC.badarity (ErlangFun 0 erlps__layout__0) args

erlps__parse__2 :: ErlangFun
erlps__parse__2 [p_0, s_1] =
  let   
    arg_6 =
      ErlangFun 1
        (let
           lambda_7 [x_9] =
             let
               tup_el_12 =
                 ErlangTuple [ErlangAtom "fail", ErlangAtom "no_error"]
             in ErlangTuple [ErlangAtom "return_plus", x_9, tup_el_12]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let arg_4 = erlps__apply_p__2 [p_0, arg_6]
  in let arg_3 = erlps__trampoline__1 [arg_4]
  in let case_2 = erlps__parse1__2 [arg_3, s_1]
  in
    case case_2 of
      (ErlangTuple [(ErlangEmptyList),
                    (ErlangTuple [pos_16, err_17])]) ->
        let    tup_el_20 = erlps__add_current_file__1 [pos_16]
        in let tup_el_23 = erlps__flatten_error__1 [err_17]
        in let
          tup_el_19 =
            ErlangTuple [tup_el_20, ErlangAtom "parse_error", tup_el_23]
        in ErlangTuple [ErlangAtom "error", tup_el_19]
      (ErlangTuple [(ErlangCons a_25 (ErlangEmptyList)), _]) ->
        ErlangTuple [ErlangAtom "ok", a_25]
      (ErlangTuple [as_28, _]) ->
        let    tup_el_32 = toErl 1
        in let tup_el_33 = toErl 1
        in let tup_el_31 = ErlangTuple [tup_el_32, tup_el_33]
        in let
          tup_el_30 =
            ErlangTuple [tup_el_31, ErlangAtom "ambiguous_parse", as_28]
        in ErlangTuple [ErlangAtom "error", tup_el_30]
      something_else -> EXC.case_clause something_else
erlps__parse__2 [arg_36, arg_37] = EXC.function_clause unit
erlps__parse__2 args =
  EXC.badarity (ErlangFun 2 erlps__parse__2) args

erlps__flatten_error__1 :: ErlangFun
erlps__flatten_error__1 [(ErlangAtom "no_error")] =
  toErl "Unspecified error"
erlps__flatten_error__1 [err_0] =
  BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [err_0]
erlps__flatten_error__1 [arg_2] = EXC.function_clause unit
erlps__flatten_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__flatten_error__1) args

erlps__many__1 :: ErlangFun
erlps__many__1 [p_0] =
  let arg_2 = erlps__many1__1 [p_0]
  in erlps__choice__2 [ErlangEmptyList, arg_2]
erlps__many__1 [arg_4] = EXC.function_clause unit
erlps__many__1 args =
  EXC.badarity (ErlangFun 1 erlps__many__1) args

erlps__many1__1 :: ErlangFun
erlps__many1__1 [p_0] =
  let   
    arg_3 =
      ErlangFun 0
        (let
           lambda_4 [] = erlps__many__1 [p_0]
           lambda_4 [] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 0 lambda_4) args
         in lambda_4)
  in let tail_2 = erlps__lazy__1 [arg_3]
  in ErlangCons p_0 tail_2
erlps__many1__1 [arg_6] = EXC.function_clause unit
erlps__many1__1 args =
  EXC.badarity (ErlangFun 1 erlps__many1__1) args

erlps__sep__2 :: ErlangFun
erlps__sep__2 [p_0, sep_1] =
  let arg_3 = erlps__sep1__2 [p_0, sep_1]
  in erlps__choice__2 [ErlangEmptyList, arg_3]
erlps__sep__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__sep__2 args =
  EXC.badarity (ErlangFun 2 erlps__sep__2) args

erlps__sep1__2 :: ErlangFun
erlps__sep1__2 [p_0, sep_1] =
  let    arg_4 = erlps__right__2 [sep_1, p_0]
  in let tail_3 = erlps__many__1 [arg_4]
  in ErlangCons p_0 tail_3
erlps__sep1__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__sep1__2 args =
  EXC.badarity (ErlangFun 2 erlps__sep1__2) args

erlps__infixl__2 :: ErlangFun
erlps__infixl__2 [elem_0, op_1] =
  let
    arg_3 =
      ErlangFun 1
        (let
           lambda_4 [a_6] =
             let    arg_8 = ErlangTuple [op_1, elem_0]
             in let arg_7 = erlps__many__1 [arg_8]
             in let
               arg_11 =
                 ErlangFun 1
                   (let
                      lambda_12 [ops_14] =
                        let arg_15 = erlps__build_infixl__2 [a_6, ops_14]
                        in erlps__return__1 [arg_15]
                      lambda_12 [arg_13] = EXC.function_clause unit
                      lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
                    in lambda_12)
             in erlps__bind__2 [arg_7, arg_11]
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in erlps__bind__2 [elem_0, arg_3]
erlps__infixl__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__infixl__2 args =
  EXC.badarity (ErlangFun 2 erlps__infixl__2) args

erlps__infixr__2 :: ErlangFun
erlps__infixr__2 [elem_0, op_1] =
  let
    arg_3 =
      ErlangFun 1
        (let
           lambda_4 [a_6] =
             let    arg_8 = ErlangTuple [op_1, elem_0]
             in let arg_7 = erlps__many__1 [arg_8]
             in let
               arg_11 =
                 ErlangFun 1
                   (let
                      lambda_12 [ops_14] =
                        let arg_15 = erlps__build_infixr__2 [a_6, ops_14]
                        in erlps__return__1 [arg_15]
                      lambda_12 [arg_13] = EXC.function_clause unit
                      lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
                    in lambda_12)
             in erlps__bind__2 [arg_7, arg_11]
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in erlps__bind__2 [elem_0, arg_3]
erlps__infixr__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__infixr__2 args =
  EXC.badarity (ErlangFun 2 erlps__infixr__2) args

erlps__build_infixl__2 :: ErlangFun
erlps__build_infixl__2 [a_0, (ErlangEmptyList)] = a_0
erlps__build_infixl__2 [a_0,
                        (ErlangCons (ErlangTuple [op_1, b_2]) ops_3)]
  =
  let
    arg_4 =
      BIF.erlang__apply__2
        [op_1, ErlangCons a_0 (ErlangCons b_2 ErlangEmptyList)]
  in erlps__build_infixl__2 [arg_4, ops_3]
erlps__build_infixl__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__build_infixl__2 args =
  EXC.badarity (ErlangFun 2 erlps__build_infixl__2) args

erlps__build_infixr__2 :: ErlangFun
erlps__build_infixr__2 [a_0, (ErlangEmptyList)] = a_0
erlps__build_infixr__2 [a_0,
                        (ErlangCons (ErlangTuple [op_1, b_2]) ops_3)]
  =
  let arg_5 = erlps__build_infixr__2 [b_2, ops_3]
  in
    BIF.erlang__apply__2
      [op_1, ErlangCons a_0 (ErlangCons arg_5 ErlangEmptyList)]
erlps__build_infixr__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__build_infixr__2 args =
  EXC.badarity (ErlangFun 2 erlps__build_infixr__2) args

erlps__between__3 :: ErlangFun
erlps__between__3 [l_0, p_1, r_2] =
  let arg_4 = erlps__left__2 [p_1, r_2]
  in erlps__right__2 [l_0, arg_4]
erlps__between__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__between__3 args =
  EXC.badarity (ErlangFun 3 erlps__between__3) args

erlps__optional__1 :: ErlangFun
erlps__optional__1 [p_0] =
  let arg_2 = ErlangTuple [ErlangAtom "ok", p_0]
  in erlps__choice__2 [ErlangAtom "none", arg_2]
erlps__optional__1 [arg_5] = EXC.function_clause unit
erlps__optional__1 args =
  EXC.badarity (ErlangFun 1 erlps__optional__1) args

erlps__tag__1 :: ErlangFun
erlps__tag__1 [t_0] | isETuple t_0 =
  let arg_1 = toErl 1
  in BIF.erlang__element__2 [arg_1, t_0]
erlps__tag__1 [arg_3] = EXC.function_clause unit
erlps__tag__1 args =
  EXC.badarity (ErlangFun 1 erlps__tag__1) args

erlps__pos__1 :: ErlangFun
erlps__pos__1 [t_0] | isETuple t_0 =
  let arg_1 = toErl 2
  in BIF.erlang__element__2 [arg_1, t_0]
erlps__pos__1 [arg_3] = EXC.function_clause unit
erlps__pos__1 args =
  EXC.badarity (ErlangFun 1 erlps__pos__1) args

erlps__line__1 :: ErlangFun
erlps__line__1 [t_0] | isETuple t_0 =
  let    arg_1 = toErl 1
  in let arg_2 = erlps__pos__1 [t_0]
  in BIF.erlang__element__2 [arg_1, arg_2]
erlps__line__1 [arg_4] = EXC.function_clause unit
erlps__line__1 args =
  EXC.badarity (ErlangFun 1 erlps__line__1) args

erlps__col__1 :: ErlangFun
erlps__col__1 [t_0] | isETuple t_0 =
  let    arg_1 = toErl 2
  in let arg_2 = erlps__pos__1 [t_0]
  in BIF.erlang__element__2 [arg_1, arg_2]
erlps__col__1 [arg_4] = EXC.function_clause unit
erlps__col__1 args =
  EXC.badarity (ErlangFun 1 erlps__col__1) args

erlps__choice1__2 :: ErlangFun
erlps__choice1__2 [(ErlangTuple [(ErlangAtom "tok_bind"),
                                 map1_0]),
                   (ErlangTuple [(ErlangAtom "tok_bind"), map2_1])]
  =
  let   
    arg_4 =
      ErlangFun 2
        (let
           lambda_5 [f_8, g_9] =
             ErlangFun 1
               (let
                  lambda_10 [t_12] =
                    let   
                      arg_14 =
                        BIF.erlang__apply__2
                          [f_8, ErlangCons t_12 ErlangEmptyList]
                    in let arg_13 = erlps__trampoline__1 [arg_14]
                    in let
                      arg_18 =
                        BIF.erlang__apply__2
                          [g_9, ErlangCons t_12 ErlangEmptyList]
                    in let arg_17 = erlps__trampoline__1 [arg_18]
                    in erlps__choice1__2 [arg_13, arg_17]
                  lambda_10 [arg_11] = EXC.function_clause unit
                  lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
                in lambda_10)
           lambda_5 [arg_6, arg_7] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
         in lambda_5)
  in let tup_el_3 = erlps__merge_with__3 [arg_4, map1_0, map2_1]
  in ErlangTuple [ErlangAtom "tok_bind", tup_el_3]
erlps__choice1__2 [(ErlangTuple [(ErlangAtom "fail"), e1_0]),
                   (ErlangTuple [(ErlangAtom "fail"), e2_1])]
  =
  let tup_el_3 = erlps__add_error__2 [e1_0, e2_1]
  in ErlangTuple [ErlangAtom "fail", tup_el_3]
erlps__choice1__2 [(ErlangTuple [(ErlangAtom "fail"), _]), q_0] =
  q_0
erlps__choice1__2 [p_0, (ErlangTuple [(ErlangAtom "fail"), _])] =
  p_0
erlps__choice1__2 [(ErlangTuple [(ErlangAtom "return_plus"), x_0,
                                 p_1]),
                   q_2]
  =
  let tup_el_5 = erlps__choice1__2 [p_1, q_2]
  in ErlangTuple [ErlangAtom "return_plus", x_0, tup_el_5]
erlps__choice1__2 [p_0,
                   (ErlangTuple [(ErlangAtom "return_plus"), x_1, q_2])]
  =
  let tup_el_5 = erlps__choice1__2 [p_0, q_2]
  in ErlangTuple [ErlangAtom "return_plus", x_1, tup_el_5]
erlps__choice1__2 [(ErlangTuple [(ErlangAtom "layout"), f_0,
                                 p_1]),
                   (ErlangTuple [(ErlangAtom "layout"), g_2, q_3])]
  =
  let   
    tup_el_5 =
      ErlangFun 1
        (let
           lambda_6 [n_8] =
             let   
               arg_10 =
                 BIF.erlang__apply__2 [f_0, ErlangCons n_8 ErlangEmptyList]
             in let arg_9 = erlps__trampoline__1 [arg_10]
             in let
               arg_14 =
                 BIF.erlang__apply__2 [g_2, ErlangCons n_8 ErlangEmptyList]
             in let arg_13 = erlps__trampoline__1 [arg_14]
             in erlps__choice1__2 [arg_9, arg_13]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let tup_el_17 = erlps__choice1__2 [p_1, q_3]
  in ErlangTuple [ErlangAtom "layout", tup_el_5, tup_el_17]
erlps__choice1__2 [(ErlangTuple [(ErlangAtom "layout"), f_0,
                                 p_1]),
                   q_2]
  =
  let tup_el_5 = erlps__choice1__2 [p_1, q_2]
  in ErlangTuple [ErlangAtom "layout", f_0, tup_el_5]
erlps__choice1__2 [p_0,
                   (ErlangTuple [(ErlangAtom "layout"), g_1, q_2])]
  =
  let tup_el_5 = erlps__choice1__2 [p_0, q_2]
  in ErlangTuple [ErlangAtom "layout", g_1, tup_el_5]
erlps__choice1__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__choice1__2 args =
  EXC.badarity (ErlangFun 2 erlps__choice1__2) args

erlps__ts__1 :: ErlangFun
erlps__ts__1 [s_0] =
  let    tup_el_6 = toErl 0
  in let tup_el_7 = toErl 0
  in let tup_el_5 = ErlangTuple [tup_el_6, tup_el_7]
  in let tup_el_3 = ErlangTuple [ErlangAtom "bof", tup_el_5]
  in
    ErlangTuple
      [ErlangAtom "ts", ErlangEmptyList, tup_el_3, ErlangEmptyList,
       s_0]
erlps__ts__1 [arg_10] = EXC.function_clause unit
erlps__ts__1 args = EXC.badarity (ErlangFun 1 erlps__ts__1) args

erlps__parse1__2 :: ErlangFun
erlps__parse1__2 [p_0, s_1] =
  let arg_3 = erlps__ts__1 [s_1]
  in
    erlps__parse1__4
      [p_0, arg_3, ErlangEmptyList, ErlangAtom "no_error"]
erlps__parse1__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__parse1__2 args =
  EXC.badarity (ErlangFun 2 erlps__parse1__2) args

erlps__parse1__4 :: ErlangFun
erlps__parse1__4 [(ErlangTuple [(ErlangAtom "bounce"), f_0]),
                  ts_1, acc_2, err_3]
  =
  let arg_4 = BIF.erlang__apply__2 [f_0, ErlangEmptyList]
  in erlps__parse1__4 [arg_4, ts_1, acc_2, err_3]
erlps__parse1__4 [(ErlangTuple [(ErlangAtom "tok_bind"), map_0]),
                  ts_1, acc_2, err_3]
  =
  let case_4 = erlps__next_token__1 [ts_1]
  in
    case case_4 of
      (ErlangTuple [t_6, ts1_7]) ->
        let    arg_9 = erlps__tag__1 [t_6]
        in let
          case_8 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [arg_9, map_0, ErlangAtom "$not_found"]
        in
          case case_8 of
            (ErlangAtom "$not_found") ->
              let
                case_13 =
                  BIF.do_remote_fun_call "Maps" "erlps__get__3"
                    [ErlangAtom "vclose", map_0, ErlangAtom "$not_found"]
              in
                case case_13 of
                  (ErlangAtom "$not_found") ->
                    let    arg_20 = BIF.maps__keys__1 [map_0]
                    in let
                      tup_el_18 =
                        erlps__unexpected_token_error__3 [ts_1, arg_20, t_6]
                    in ErlangTuple [acc_2, tup_el_18]
                  f_23 ->
                    let    tup_el_25 = erlps__pos__1 [t_6]
                    in let
                      vclose_27 = ErlangTuple [ErlangAtom "vclose", tup_el_25]
                    in let
                      arg_29 =
                        case ts_1 of
                          (ErlangTuple [(ErlangAtom "ts"), layout_32, last_33,
                                        inserted_34, tokens_35]) ->
                            ErlangTuple
                              [ErlangAtom "ts", layout_32, vclose_27,
                               inserted_34, tokens_35]
                          _ -> EXC.badrecord (ErlangAtom "ts")
                    in let ts2_36 = erlps__pop_layout__2 [vclose_27, arg_29]
                    in let
                      arg_37 =
                        BIF.erlang__apply__2
                          [f_23, ErlangCons vclose_27 ErlangEmptyList]
                    in erlps__parse1__4 [arg_37, ts2_36, acc_2, err_3]
            f_43 ->
              let
                arg_44 =
                  BIF.erlang__apply__2 [f_43, ErlangCons t_6 ErlangEmptyList]
              in erlps__parse1__4 [arg_44, ts1_7, acc_2, err_3]
      (ErlangAtom "false") ->
        let   
          arg_54 = toErl "Unexpected end of file. Expected one of ~p."
        in let head_56 = BIF.maps__keys__1 [map_0]
        in let
          arg_53 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_54, ErlangCons head_56 ErlangEmptyList]
        in let tup_el_51 = erlps__mk_error__2 [ts_1, arg_53]
        in ErlangTuple [acc_2, tup_el_51]
      something_else -> EXC.case_clause something_else
erlps__parse1__4 [(ErlangTuple [(ErlangAtom "layout"), f_0,
                                p_1]),
                  ts_2, acc_3, err_4]
  =
  let case_5 = erlps__start_layout__1 [ts_2]
  in
    case case_5 of
      (ErlangTuple [col_7, ts1_8]) ->
        let
          arg_9 =
            BIF.erlang__apply__2 [f_0, ErlangCons col_7 ErlangEmptyList]
        in erlps__parse1__4 [arg_9, ts1_8, acc_3, err_4]
      (ErlangAtom "false") ->
        let    arg_20 = toErl "Expected layout block."
        in let arg_18 = erlps__mk_error__2 [ts_2, arg_20]
        in erlps__parse1__4 [p_1, ts_2, acc_3, arg_18]
      something_else -> EXC.case_clause something_else
erlps__parse1__4 [(ErlangTuple [(ErlangAtom "return_plus"), x_0,
                                p_1]),
                  ts_2, acc_3, err_4]
  =
  let case_5 = erlps__next_token__1 [ts_2]
  in
    case case_5 of
      (ErlangAtom "false") ->
        erlps__parse1__4 [p_1, ts_2, ErlangCons x_0 acc_3, err_4]
      (ErlangTuple [t_13, _]) ->
        let arg_17 = erlps__unexpected_token_error__2 [ts_2, t_13]
        in erlps__parse1__4 [p_1, ts_2, acc_3, arg_17]
      something_else -> EXC.case_clause something_else
erlps__parse1__4 [(ErlangTuple [(ErlangAtom "fail"), err_0]),
                  ts_1, acc_2, err1_3]
  =
  let    case_4 = erlps__next_token__1 [ts_1]
  in let
    err2_9 =
      case case_4 of
        (ErlangTuple [t_6, _]) ->
          erlps__unexpected_token_error__2 [ts_1, t_6]
        _ -> ErlangAtom "no_error"
  in let arg_13 = erlps__mk_error__2 [ts_1, err_0]
  in let arg_12 = erlps__add_error__2 [arg_13, err2_9]
  in let tup_el_11 = erlps__add_error__2 [arg_12, err1_3]
  in ErlangTuple [acc_2, tup_el_11]
erlps__parse1__4 [arg_18, arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__parse1__4 args =
  EXC.badarity (ErlangFun 4 erlps__parse1__4) args

erlps__current_pos__1 :: ErlangFun
erlps__current_pos__1 [(ErlangTuple [(ErlangAtom "ts"), _, _,
                                     (ErlangCons t_0 _), _])]
  =
  erlps__pos__1 [t_0]
erlps__current_pos__1 [(ErlangTuple [(ErlangAtom "ts"), _, _, _,
                                     (ErlangCons t_0 _)])]
  =
  erlps__pos__1 [t_0]
erlps__current_pos__1 [(ErlangTuple [(ErlangAtom "ts"), _, t_0,
                                     _, _])]
  =
  let arg_1 = erlps__pos__1 [t_0]
  in erlps__end_pos__1 [arg_1]
erlps__current_pos__1 [arg_3] = EXC.function_clause unit
erlps__current_pos__1 args =
  EXC.badarity (ErlangFun 1 erlps__current_pos__1) args

erlps__mk_error__2 :: ErlangFun
erlps__mk_error__2 [_ts_0, (ErlangTuple [pos_1, err_2])] =
  ErlangTuple [pos_1, err_2]
erlps__mk_error__2 [ts_0, err_1] =
  let tup_el_2 = erlps__current_pos__1 [ts_0]
  in ErlangTuple [tup_el_2, err_1]
erlps__mk_error__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__mk_error__2 args =
  EXC.badarity (ErlangFun 2 erlps__mk_error__2) args

erlps__unexpected_token_error__2 :: ErlangFun
erlps__unexpected_token_error__2 [ts_0, t_1] =
  erlps__unexpected_token_error__3 [ts_0, ErlangEmptyList, t_1]
erlps__unexpected_token_error__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__unexpected_token_error__2 args =
  EXC.badarity (ErlangFun 2 erlps__unexpected_token_error__2) args

erlps__unexpected_token_error__3 :: ErlangFun
erlps__unexpected_token_error__3 [ts_0, expect_1,
                                  (ErlangTuple [tag_2, _])]
  | (weakEq tag_2 (ErlangAtom "vclose")) ||
      (weakEq tag_2 (ErlangAtom "vsemi")) =
  let   
    arg_11 =
      ErlangFun 1
        (let
           lambda_12 [t_14] =
             BIF.lists__member__2
               [t_14,
                ErlangCons (ErlangAtom ")")
                  (ErlangCons (ErlangAtom "]")
                     (ErlangCons (ErlangAtom "}") ErlangEmptyList))]
           lambda_12 [arg_13] = EXC.function_clause unit
           lambda_12 args = EXC.badarity (ErlangFun 1 lambda_12) args
         in lambda_12)
  in let
    case_10 =
      BIF.do_remote_fun_call "Lists" "erlps__filter__2"
        [arg_11, expect_1]
  in let
    fix_23 =
      case case_10 of
        (ErlangEmptyList) ->
          toErl
            " Probable causes:\n  - something is missing in the previous statement, or\n  - this line should be indented more."
        (ErlangCons t_18 _) ->
          let arg_19 = toErl " Did you forget a ~p?"
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_19, ErlangCons t_18 ErlangEmptyList]
        something_else -> EXC.case_clause something_else
  in let arg_24 = toErl "Unexpected indentation.~s"
  in let
    msg_28 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_24, ErlangCons fix_23 ErlangEmptyList]
  in erlps__mk_error__2 [ts_0, msg_28]
erlps__unexpected_token_error__3 [ts_0, expect_1, t_2] =
  let   
    expectcon_5 = BIF.lists__member__2 [ErlangAtom "con", expect_1]
  in let
    expectid_8 = BIF.lists__member__2 [ErlangAtom "id", expect_1]
  in let
    fix_38 =
      case t_2 of
        (ErlangTuple [(ErlangAtom "id"), _, x_10]) | (ErlangAtom
                                                        "true") ==
                                                       (falsifyErrors
                                                          (\ _ ->
                                                             case expectcon_5 of
                                                               (ErlangAtom "false") ->
                                                                 ErlangAtom
                                                                   "false"
                                                               (ErlangAtom "true") ->
                                                                 let   
                                                                   lop_12 =
                                                                     BIF.erlang__hd__1
                                                                       [x_10]
                                                                 in let
                                                                   rop_14 =
                                                                     toErl 95
                                                                 in
                                                                   BIF.erlang__op_neq
                                                                     [lop_12,
                                                                      rop_14]
                                                               _ ->
                                                                 EXC.badarg1
                                                                   expectcon_5)) ->
          let    arg_15 = toErl " Did you mean ~s?"
          in let head_17 = erlps__mk_upper__1 [x_10]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_15, ErlangCons head_17 ErlangEmptyList]
        (ErlangTuple [(ErlangAtom "con"), _, x_20]) | (==)
                                                        (ErlangAtom "true")
                                                        expectid_8 ->
          let    arg_21 = toErl " Did you mean ~s?"
          in let head_23 = erlps__mk_lower__1 [x_20]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_21, ErlangCons head_23 ErlangEmptyList]
        (ErlangTuple [(ErlangAtom "qcon"), _, xs_26]) | (==)
                                                          (ErlangAtom "true")
                                                          expectcon_5 ->
          let    arg_27 = toErl " Did you mean ~s?"
          in let
            head_29 = BIF.do_remote_fun_call "Lists" "erlps__last__1" [xs_26]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_27, ErlangCons head_29 ErlangEmptyList]
        (ErlangTuple [(ErlangAtom "qid"), _, xs_32]) | (==)
                                                         (ErlangAtom "true")
                                                         expectid_8 ->
          let    arg_33 = toErl " Did you mean ~s?"
          in let
            head_35 = BIF.do_remote_fun_call "Lists" "erlps__last__1" [xs_32]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_33, ErlangCons head_35 ErlangEmptyList]
        _ -> toErl ""
  in let arg_41 = toErl "Unexpected ~s.~s"
  in let head_43 = erlps__describe__1 [t_2]
  in let
    arg_40 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_41, ErlangCons head_43 (ErlangCons fix_38 ErlangEmptyList)]
  in erlps__mk_error__2 [ts_0, arg_40]
erlps__unexpected_token_error__3 [arg_48, arg_49, arg_50] =
  EXC.function_clause unit
erlps__unexpected_token_error__3 args =
  EXC.badarity (ErlangFun 3 erlps__unexpected_token_error__3) args

erlps__mk_upper__1 :: ErlangFun
erlps__mk_upper__1 [(ErlangCons c_0 rest_1)] =
  let
    lop_2 =
      BIF.do_remote_fun_call "String" "erlps__to_upper__1"
        [ErlangCons c_0 ErlangEmptyList]
  in BIF.erlang__op_append [lop_2, rest_1]
erlps__mk_upper__1 [arg_7] = EXC.function_clause unit
erlps__mk_upper__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_upper__1) args

erlps__mk_lower__1 :: ErlangFun
erlps__mk_lower__1 [(ErlangCons c_0 rest_1)] =
  let
    lop_2 =
      BIF.do_remote_fun_call "String" "erlps__to_lower__1"
        [ErlangCons c_0 ErlangEmptyList]
  in BIF.erlang__op_append [lop_2, rest_1]
erlps__mk_lower__1 [arg_7] = EXC.function_clause unit
erlps__mk_lower__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_lower__1) args

erlps__describe__1 :: ErlangFun
erlps__describe__1 [(ErlangTuple [(ErlangAtom "id"), _, x_0])] =
  let arg_1 = toErl "identifier ~s"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons x_0 ErlangEmptyList]
erlps__describe__1 [(ErlangTuple [(ErlangAtom "con"), _, x_0])] =
  let arg_1 = toErl "identifier ~s"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons x_0 ErlangEmptyList]
erlps__describe__1 [(ErlangTuple [(ErlangAtom "qid"), _, xs_0])]
  =
  let    arg_1 = toErl "qualified identifier ~s"
  in let arg_5 = toErl "."
  in let
    head_3 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [xs_0, arg_5]
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons head_3 ErlangEmptyList]
erlps__describe__1 [(ErlangTuple [(ErlangAtom "qcon"), _, xs_0])]
  =
  let    arg_1 = toErl "qualified identifier ~s"
  in let arg_5 = toErl "."
  in let
    head_3 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [xs_0, arg_5]
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons head_3 ErlangEmptyList]
erlps__describe__1 [(ErlangTuple [(ErlangAtom "tvar"), _, x_0])]
  =
  let arg_1 = toErl "type variable ~s"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons x_0 ErlangEmptyList]
erlps__describe__1 [(ErlangTuple [(ErlangAtom "char"), _, _])] =
  toErl "character literal"
erlps__describe__1 [(ErlangTuple [(ErlangAtom "string"), _, _])]
  =
  toErl "string literal"
erlps__describe__1 [(ErlangTuple [(ErlangAtom "hex"), _, _])] =
  toErl "integer literal"
erlps__describe__1 [(ErlangTuple [(ErlangAtom "int"), _, _])] =
  toErl "integer literal"
erlps__describe__1 [(ErlangTuple [(ErlangAtom "bytes"), _, _])] =
  toErl "bytes literal"
erlps__describe__1 [t_0] =
  let    arg_1 = toErl "token \'~s\'"
  in let head_3 = erlps__tag__1 [t_0]
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons head_3 ErlangEmptyList]
erlps__describe__1 [arg_6] = EXC.function_clause unit
erlps__describe__1 args =
  EXC.badarity (ErlangFun 1 erlps__describe__1) args

erlps__next_token__1 :: ErlangFun
erlps__next_token__1 [ts_0] =
  let case_1 = erlps__insert_layout_tokens__1 [ts_0]
  in
    case case_1 of
      ts1_5@(ErlangTuple [(ErlangAtom "ts"), _, _,
                          (ErlangCons l_3 ls_4), _]) ->
        let   
          arg_9 =
            case ts1_5 of
              (ErlangTuple [(ErlangAtom "ts"), layout_13, last_14, inserted_15,
                            tokens_16]) ->
                ErlangTuple [ErlangAtom "ts", layout_13, l_3, ls_4, tokens_16]
              _ -> EXC.badrecord (ErlangAtom "ts")
        in let tup_el_7 = erlps__pop_layout__2 [l_3, arg_9]
        in ErlangTuple [l_3, tup_el_7]
      ts1_19@(ErlangTuple [(ErlangAtom "ts"), _, _, _,
                           (ErlangCons t_17 s_18)]) ->
        let
          tup_el_21 =
            case ts1_19 of
              (ErlangTuple [(ErlangAtom "ts"), layout_25, last_26, inserted_27,
                            tokens_28]) ->
                ErlangTuple
                  [ErlangAtom "ts", layout_25, t_17, inserted_27, s_18]
              _ -> EXC.badrecord (ErlangAtom "ts")
        in ErlangTuple [t_17, tup_el_21]
      (ErlangTuple [(ErlangAtom "ts"), _, _, (ErlangEmptyList),
                    (ErlangEmptyList)]) ->
        ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__next_token__1 [arg_29] = EXC.function_clause unit
erlps__next_token__1 args =
  EXC.badarity (ErlangFun 1 erlps__next_token__1) args

erlps__pop_layout__2 :: ErlangFun
erlps__pop_layout__2 [(ErlangTuple [(ErlangAtom "vclose"), _]),
                      ts_1@(ErlangTuple [(ErlangAtom "ts"),
                                         (ErlangCons _ layout_0), _, _, _])]
  =
  case ts_1 of
    (ErlangTuple [(ErlangAtom "ts"), layout_4, last_5, inserted_6,
                  tokens_7]) ->
      ErlangTuple
        [ErlangAtom "ts", layout_0, last_5, inserted_6, tokens_7]
    _ -> EXC.badrecord (ErlangAtom "ts")
erlps__pop_layout__2 [_, ts_0] = ts_0
erlps__pop_layout__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__pop_layout__2 args =
  EXC.badarity (ErlangFun 2 erlps__pop_layout__2) args

erlps__start_layout__1 :: ErlangFun
erlps__start_layout__1 [(ErlangTuple [(ErlangAtom "ts"), _, _,
                                      (ErlangCons _ _), _])]
  =
  ErlangAtom "false"
erlps__start_layout__1 [(ErlangTuple [(ErlangAtom "ts"), _, _, _,
                                      (ErlangEmptyList)])]
  =
  ErlangAtom "false"
erlps__start_layout__1 [ts_3@(ErlangTuple [(ErlangAtom "ts"),
                                           layout_0, last_1, _,
                                           (ErlangCons t_2 _)])]
  =
  let    col_5 = erlps__col__1 [t_2]
  in let
    valid_19 =
      case layout_0 of
        (ErlangEmptyList) ->
          let    lop_7 = erlps__line__1 [last_1]
          in let rop_9 = erlps__line__1 [t_2]
          in BIF.erlang__op_lesser [lop_7, rop_9]
        (ErlangCons c1_11 _) ->
          let    lop_13 = erlps__line__1 [last_1]
          in let rop_15 = erlps__line__1 [t_2]
          in let lop_12 = BIF.erlang__op_lesser [lop_13, rop_15]
          in
            case lop_12 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") -> BIF.erlang__op_lesser [c1_11, col_5]
              _ -> EXC.badarg1 lop_12
        something_else -> EXC.case_clause something_else
  in
    case valid_19 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") ->
        let    tup_el_29 = erlps__pos__1 [t_2]
        in let
          record_updt_27 = ErlangTuple [ErlangAtom "vopen", tup_el_29]
        in let
          tup_el_22 =
            case ts_3 of
              (ErlangTuple [(ErlangAtom "ts"), layout_31, last_32, inserted_33,
                            tokens_34]) ->
                ErlangTuple
                  [ErlangAtom "ts", ErlangCons col_5 layout_0, record_updt_27,
                   inserted_33, tokens_34]
              _ -> EXC.badrecord (ErlangAtom "ts")
        in ErlangTuple [col_5, tup_el_22]
      _ -> EXC.badarg1 valid_19
erlps__start_layout__1 [arg_35] = EXC.function_clause unit
erlps__start_layout__1 args =
  EXC.badarity (ErlangFun 1 erlps__start_layout__1) args

erlps__insert_layout_tokens__1 :: ErlangFun
erlps__insert_layout_tokens__1 [ts_0@(ErlangTuple [(ErlangAtom "ts"),
                                                   _, _, (ErlangCons _ _), _])]
  =
  ts_0
erlps__insert_layout_tokens__1 [ts_3@(ErlangTuple [(ErlangAtom "ts"),
                                                   layout_0, last_1, _, s_2])]
  =
  let
    toinsert_8 =
      erlps__insert_layout_tokens__4
        [layout_0, last_1, s_2, ErlangEmptyList]
  in
    case ts_3 of
      (ErlangTuple [(ErlangAtom "ts"), layout_11, last_12, inserted_13,
                    tokens_14]) ->
        ErlangTuple
          [ErlangAtom "ts", layout_11, last_12, toinsert_8, tokens_14]
      _ -> EXC.badrecord (ErlangAtom "ts")
erlps__insert_layout_tokens__1 [arg_15] =
  EXC.function_clause unit
erlps__insert_layout_tokens__1 args =
  EXC.badarity (ErlangFun 1 erlps__insert_layout_tokens__1) args

erlps__insert_layout_tokens__4 :: ErlangFun
erlps__insert_layout_tokens__4 [(ErlangCons _ layout_0), last_1,
                                (ErlangEmptyList), acc_2]
  =
  let    arg_5 = erlps__pos__1 [last_1]
  in let tup_el_4 = erlps__end_pos__1 [arg_5]
  in let vclose_7 = ErlangTuple [ErlangAtom "vclose", tup_el_4]
  in
    erlps__insert_layout_tokens__4
      [layout_0, last_1, ErlangEmptyList, ErlangCons vclose_7 acc_2]
erlps__insert_layout_tokens__4 [(ErlangCons n_0 layout1_1),
                                last_2, s_4@(ErlangCons t_3 _), acc_5]
  =
  let    col_7 = erlps__col__1 [t_3]
  in let arg_9 = erlps__tag__1 [last_2]
  in let
    lop_8 =
      BIF.lists__member__2
        [arg_9,
         ErlangCons (ErlangAtom "vsemi")
           (ErlangCons (ErlangAtom "vopen") ErlangEmptyList)]
  in let
    alreadysemi_19 =
      case lop_8 of
        (ErlangAtom "false") -> ErlangAtom "false"
        (ErlangAtom "true") ->
          let lop_16 = erlps__col__1 [last_2]
          in BIF.erlang__op_eq [lop_16, n_0]
        _ -> EXC.badarg1 lop_8
  in
    case ErlangAtom "true" of
      _ | (ErlangAtom "true") ==
            (falsifyErrors
               (\ _ ->
                  let lop_20 = BIF.erlang__op_eq [col_7, n_0]
                  in
                    case lop_20 of
                      (ErlangAtom "false") -> ErlangAtom "false"
                      (ErlangAtom "true") -> BIF.erlang__not__1 [alreadysemi_19]
                      _ -> EXC.badarg1 lop_20)) ->
        let    tup_el_27 = erlps__pos__1 [t_3]
        in let head_25 = ErlangTuple [ErlangAtom "vsemi", tup_el_27]
        in
          BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
            [ErlangCons head_25 acc_5]
      _ | weakLt col_7 n_0 ->
        let    tup_el_31 = erlps__pos__1 [t_3]
        in let vclose_33 = ErlangTuple [ErlangAtom "vclose", tup_el_31]
        in
          erlps__insert_layout_tokens__4
            [layout1_1, vclose_33, s_4, ErlangCons vclose_33 acc_5]
      _ -> BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_5]
erlps__insert_layout_tokens__4 [(ErlangEmptyList), _last_0, _s_1,
                                acc_2]
  =
  BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
erlps__insert_layout_tokens__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__insert_layout_tokens__4 args =
  EXC.badarity (ErlangFun 4 erlps__insert_layout_tokens__4) args

erlps__end_pos__1 :: ErlangFun
erlps__end_pos__1 [(ErlangTuple [l_0, _])] =
  let    rop_3 = toErl 1
  in let tup_el_1 = BIF.erlang__op_plus [l_0, rop_3]
  in let tup_el_4 = toErl 1
  in ErlangTuple [tup_el_1, tup_el_4]
erlps__end_pos__1 [arg_5] = EXC.function_clause unit
erlps__end_pos__1 args =
  EXC.badarity (ErlangFun 1 erlps__end_pos__1) args

erlps__add_error__2 :: ErlangFun
erlps__add_error__2 [(ErlangAtom "no_error"), err_0] = err_0
erlps__add_error__2 [(ErlangTuple [_, (ErlangAtom "no_error")]),
                     err_0]
  =
  err_0
erlps__add_error__2 [err_0, (ErlangAtom "no_error")] = err_0
erlps__add_error__2 [err_0,
                     (ErlangTuple [_, (ErlangAtom "no_error")])]
  =
  err_0
erlps__add_error__2 [err_0, _err1_1] = err_0
erlps__add_error__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__add_error__2 args =
  EXC.badarity (ErlangFun 2 erlps__add_error__2) args

erlps__merge_with__3 :: ErlangFun
erlps__merge_with__3 [fun_0, map1_1, map2_2] =
  let   
    lop_4 = BIF.do_remote_fun_call "Maps" "erlps__size__1" [map1_1]
  in let
    rop_6 = BIF.do_remote_fun_call "Maps" "erlps__size__1" [map2_2]
  in let case_3 = BIF.erlang__op_greater [lop_4, rop_6]
  in
    case case_3 of
      (ErlangAtom "true") ->
        let   
          arg_8 =
            ErlangFun 2
              (let
                 lambda_9 [(ErlangTuple [k_12, r_13]), m_14] =
                   let
                     arg_16 =
                       ErlangFun 1
                         (let
                            lambda_17 [l_19] =
                              BIF.erlang__apply__2
                                [fun_0,
                                 ErlangCons l_19
                                   (ErlangCons r_13 ErlangEmptyList)]
                            lambda_17 [arg_18] = EXC.function_clause unit
                            lambda_17 args =
                              EXC.badarity (ErlangFun 1 lambda_17) args
                          in lambda_17)
                   in
                     BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
                       [k_12, arg_16, r_13, m_14]
                 lambda_9 [arg_10, arg_11] = EXC.function_clause unit
                 lambda_9 args = EXC.badarity (ErlangFun 2 lambda_9) args
               in lambda_9)
        in let arg_26 = BIF.maps__to_list__1 [map2_2]
        in
          BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
            [arg_8, map1_1, arg_26]
      (ErlangAtom "false") ->
        let   
          arg_28 =
            ErlangFun 2
              (let
                 lambda_29 [(ErlangTuple [k_32, l_33]), m_34] =
                   let
                     arg_36 =
                       ErlangFun 1
                         (let
                            lambda_37 [r_39] =
                              BIF.erlang__apply__2
                                [fun_0,
                                 ErlangCons l_33
                                   (ErlangCons r_39 ErlangEmptyList)]
                            lambda_37 [arg_38] = EXC.function_clause unit
                            lambda_37 args =
                              EXC.badarity (ErlangFun 1 lambda_37) args
                          in lambda_37)
                   in
                     BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
                       [k_32, arg_36, l_33, m_34]
                 lambda_29 [arg_30, arg_31] = EXC.function_clause unit
                 lambda_29 args = EXC.badarity (ErlangFun 2 lambda_29) args
               in lambda_29)
        in let arg_46 = BIF.maps__to_list__1 [map1_1]
        in
          BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
            [arg_28, map2_2, arg_46]
      something_else -> EXC.case_clause something_else
erlps__merge_with__3 [arg_48, arg_49, arg_50] =
  EXC.function_clause unit
erlps__merge_with__3 args =
  EXC.badarity (ErlangFun 3 erlps__merge_with__3) args

erlps__current_file__0 :: ErlangFun
erlps__current_file__0 [] =
  BIF.erlang__get__1 [ErlangAtom "$current_file"]
erlps__current_file__0 args =
  EXC.badarity (ErlangFun 0 erlps__current_file__0) args

erlps__set_current_file__1 :: ErlangFun
erlps__set_current_file__1 [file_0] =
  BIF.erlang__put__2 [ErlangAtom "$current_file", file_0]
erlps__set_current_file__1 [arg_3] = EXC.function_clause unit
erlps__set_current_file__1 args =
  EXC.badarity (ErlangFun 1 erlps__set_current_file__1) args

erlps__add_current_file__1 :: ErlangFun
erlps__add_current_file__1 [(ErlangTuple [l_0, c_1])] =
  let tup_el_2 = erlps__current_file__0 []
  in ErlangTuple [tup_el_2, l_0, c_1]
erlps__add_current_file__1 [pos_0] = pos_0
erlps__add_current_file__1 [arg_1] = EXC.function_clause unit
erlps__add_current_file__1 args =
  EXC.badarity (ErlangFun 1 erlps__add_current_file__1) args