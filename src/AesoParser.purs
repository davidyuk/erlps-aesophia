module Aeso.Parser(erlps__string__1, erlps__string__2,
                   erlps__string__3, erlps__auto_imports__1,
                   erlps__hash_include__2, erlps__decl__0, erlps__type__0,
                   erlps__body__0, erlps__maybe_block__1, erlps__run_parser__2,
                   erlps__run_parser__3) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__escape_errors__1 :: ErlangFun
erlps__escape_errors__1 [(ErlangTuple [(ErlangAtom "ok"), ok_0])]
  =
  ok_0
erlps__escape_errors__1 [(ErlangTuple [(ErlangAtom "error"),
                                       err_0])]
  =
  erlps__parse_error__1 [err_0]
erlps__escape_errors__1 [arg_2] = EXC.function_clause unit
erlps__escape_errors__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__string__1 :: ErlangFun
erlps__string__1 [string_0] =
  let arg_2 = BIF.do_remote_fun_call "Sets" "erlps__new__0" []
  in erlps__string__3 [string_0, arg_2, ErlangEmptyList]
erlps__string__1 [arg_4] = EXC.function_clause unit
erlps__string__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__string__2 :: ErlangFun
erlps__string__2 [string_0, opts_1] =
  let    arg_4 = toErl 1
  in let
    case_2 =
      BIF.lists__keyfind__3 [ErlangAtom "src_file", arg_4, opts_1]
  in
    case case_2 of
      (ErlangTuple [(ErlangAtom "src_file"), file_6]) ->
        let    arg_10 = BIF.do_remote_fun_call "Sets" "erlps__new__0" []
        in let
          arg_8 =
            BIF.do_remote_fun_call "Sets" "erlps__add_element__2"
              [file_6, arg_10]
        in erlps__string__3 [string_0, arg_8, opts_1]
      (ErlangAtom "false") ->
        let arg_13 = BIF.do_remote_fun_call "Sets" "erlps__new__0" []
        in erlps__string__3 [string_0, arg_13, opts_1]
      something_else -> EXC.case_clause something_else
erlps__string__2 [arg_15, arg_16] = EXC.function_clause unit
erlps__string__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__string__3 :: ErlangFun
erlps__string__3 [string_0, included_1, opts_2] =
  let    arg_3 = erlps__file__0 []
  in let ast_6 = erlps__run_parser__3 [arg_3, string_0, opts_2]
  in let
    case_7 = erlps__expand_includes__3 [ast_6, included_1, opts_2]
  in
    case case_7 of
      (ErlangTuple [(ErlangAtom "ok"), ast1_11]) -> ast1_11
      (ErlangTuple [(ErlangAtom "error"), err_12]) ->
        erlps__parse_error__1 [err_12]
      something_else -> EXC.case_clause something_else
erlps__string__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__string__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__run_parser__2 :: ErlangFun
erlps__run_parser__2 [p_0, inp_1] =
  let
    arg_2 = erlps__parse_and_scan__3 [p_0, inp_1, ErlangEmptyList]
  in erlps__escape_errors__1 [arg_2]
erlps__run_parser__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__run_parser__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__run_parser__3 :: ErlangFun
erlps__run_parser__3 [p_0, inp_1, opts_2] =
  let arg_3 = erlps__parse_and_scan__3 [p_0, inp_1, opts_2]
  in erlps__escape_errors__1 [arg_3]
erlps__run_parser__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__run_parser__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_and_scan__3 :: ErlangFun
erlps__parse_and_scan__3 [p_0, s_1, opts_2] =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "src_file", opts_2, ErlangAtom "no_file"]
  in let
    _ =
      BIF.do_remote_fun_call "Aeso.Parse.Lib"
        "erlps__set_current_file__1" [arg_3]
  in let
    case_7 =
      BIF.do_remote_fun_call "Aeso.Scan" "erlps__scan__1" [s_1]
  in
    case case_7 of
      (ErlangTuple [(ErlangAtom "ok"), tokens_9]) ->
        BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__parse__2"
          [p_0, tokens_9]
      (ErlangTuple [(ErlangAtom "error"),
                    (ErlangTuple [(ErlangTuple [input_12, pos_13]), _])]) ->
        let
          tup_el_15 =
            ErlangTuple [pos_13, ErlangAtom "scan_error", input_12]
        in ErlangTuple [ErlangAtom "error", tup_el_15]
      something_else -> EXC.case_clause something_else
erlps__parse_and_scan__3 [arg_19, arg_20, arg_21] =
  EXC.function_clause unit
erlps__parse_and_scan__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_error__1 :: ErlangFun
erlps__parse_error__1 [err_0] =
  let arg_1 = erlps__mk_error__1 [err_0]
  in BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1" [arg_1]
erlps__parse_error__1 [arg_3] = EXC.function_clause unit
erlps__parse_error__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__mk_p_err__2 :: ErlangFun
erlps__mk_p_err__2 [pos_0, msg_1] =
  let    arg_3 = erlps__mk_pos__1 [pos_0]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [msg_1]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__3"
      [ErlangAtom "parse_error", arg_3, arg_5]
erlps__mk_p_err__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__mk_p_err__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__mk_error__1 :: ErlangFun
erlps__mk_error__1 [(ErlangTuple [pos_0,
                                  (ErlangAtom "scan_error"), input_1])]
  =
  let    arg_4 = toErl "Lexical error on input: ~s\n"
  in let
    arg_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons input_1 ErlangEmptyList]
  in erlps__mk_p_err__2 [pos_0, arg_3]
erlps__mk_error__1 [(ErlangTuple [pos_0,
                                  (ErlangAtom "parse_error"), err_1])]
  =
  let    arg_2 = toErl "~s\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons err_1 ErlangEmptyList]
  in erlps__mk_p_err__2 [pos_0, msg_6]
erlps__mk_error__1 [(ErlangTuple [pos_0,
                                  (ErlangAtom "ambiguous_parse"), as_1])]
  =
  let    arg_2 = toErl "Ambiguous parse result: ~p\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons as_1 ErlangEmptyList]
  in erlps__mk_p_err__2 [pos_0, msg_6]
erlps__mk_error__1 [(ErlangTuple [pos_0,
                                  (ErlangAtom "include_error"), file_1])]
  =
  let    arg_2 = toErl "Couldn\'t find include file \'~s\'\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons file_1 ErlangEmptyList]
  in erlps__mk_p_err__2 [pos_0, msg_6]
erlps__mk_error__1 [arg_9] = EXC.function_clause unit
erlps__mk_error__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__mk_pos__1 :: ErlangFun
erlps__mk_pos__1 [(ErlangTuple [line_0, col_1])] =
  BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__2"
    [line_0, col_1]
erlps__mk_pos__1 [(ErlangTuple [file_0, line_1, col_2])] =
  BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__3"
    [file_0, line_1, col_2]
erlps__mk_pos__1 [arg_6] = EXC.function_clause unit
erlps__mk_pos__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__file__0 :: ErlangFun
erlps__file__0 [] =
  let    arg_2 = erlps__decl__0 []
  in let arg_1 = erlps__block__1 [arg_2]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__2"
      [ErlangEmptyList, arg_1]
erlps__file__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__decl__0 :: ErlangFun
erlps__decl__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let   
               arg_4 =
                 ErlangFun 1
                   (let
                      lambda_5 [(ErlangTuple [_1_7, _2_8, _3_9, _4_10])] =
                        ErlangTuple [ErlangAtom "contract", _1_7, _2_8, _4_10]
                      lambda_5 [arg_6] = EXC.function_clause unit
                      lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
                    in lambda_5)
             in let tup_el_16 = erlps__keyword__1 [ErlangAtom "contract"]
             in let tup_el_18 = erlps__con__0 []
             in let
               tup_el_19 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let arg_22 = erlps__decl__0 []
             in let tup_el_21 = erlps__maybe_block__1 [arg_22]
             in let
               arg_15 = ErlangTuple [tup_el_16, tup_el_18, tup_el_19, tup_el_21]
             in let
               head_3 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_4, arg_15]
             in let
               arg_25 =
                 ErlangFun 1
                   (let
                      lambda_26 [(ErlangTuple [_1_28, _2_29, _3_30, _4_31,
                                               _5_32])]
                        =
                        let
                          arg_36 =
                            ErlangTuple
                              [ErlangAtom "contract", _2_29, _3_30, _5_32]
                        in
                          erlps__add_modifiers__2
                            [ErlangCons _1_28 ErlangEmptyList, arg_36]
                      lambda_26 [arg_27] = EXC.function_clause unit
                      lambda_26 args = EXC.badarity (ErlangFun 1 lambda_26) args
                    in lambda_26)
             in let tup_el_42 = erlps__token__1 [ErlangAtom "payable"]
             in let tup_el_44 = erlps__keyword__1 [ErlangAtom "contract"]
             in let tup_el_46 = erlps__con__0 []
             in let
               tup_el_47 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let arg_50 = erlps__decl__0 []
             in let tup_el_49 = erlps__maybe_block__1 [arg_50]
             in let
               arg_41 =
                 ErlangTuple
                   [tup_el_42, tup_el_44, tup_el_46, tup_el_47, tup_el_49]
             in let
               head_24 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_25, arg_41]
             in let
               arg_53 =
                 ErlangFun 1
                   (let
                      lambda_54 [(ErlangTuple [_1_56, _2_57, _3_58, _4_59])] =
                        ErlangTuple
                          [ErlangAtom "namespace", _1_56, _2_57, _4_59]
                      lambda_54 [arg_55] = EXC.function_clause unit
                      lambda_54 args = EXC.badarity (ErlangFun 1 lambda_54) args
                    in lambda_54)
             in let tup_el_65 = erlps__keyword__1 [ErlangAtom "namespace"]
             in let tup_el_67 = erlps__con__0 []
             in let
               tup_el_68 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let arg_71 = erlps__decl__0 []
             in let tup_el_70 = erlps__maybe_block__1 [arg_71]
             in let
               arg_64 = ErlangTuple [tup_el_65, tup_el_67, tup_el_68, tup_el_70]
             in let
               head_52 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_53, arg_64]
             in let
               arg_74 =
                 ErlangFun 1
                   (let
                      lambda_75 [(ErlangTuple [_1_77, _2_78])] =
                        let tup_el_80 = erlps__get_ann__1 [_1_77]
                        in ErlangTuple [ErlangAtom "include", tup_el_80, _2_78]
                      lambda_75 [arg_76] = EXC.function_clause unit
                      lambda_75 args = EXC.badarity (ErlangFun 1 lambda_75) args
                    in lambda_75)
             in let tup_el_84 = erlps__keyword__1 [ErlangAtom "include"]
             in let tup_el_86 = erlps__str__0 []
             in let arg_83 = ErlangTuple [tup_el_84, tup_el_86]
             in let
               head_73 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_74, arg_83]
             in let head_88 = erlps__pragma__0 []
             in let
               arg_91 =
                 ErlangFun 1
                   (let
                      lambda_92 [(ErlangTuple [_1_94, _2_95])] =
                        ErlangTuple
                          [ErlangAtom "type_decl", _1_94, _2_95,
                           ErlangEmptyList]
                      lambda_92 [arg_93] = EXC.function_clause unit
                      lambda_92 args = EXC.badarity (ErlangFun 1 lambda_92) args
                    in lambda_92)
             in let tup_el_101 = erlps__keyword__1 [ErlangAtom "type"]
             in let tup_el_103 = erlps__id__0 []
             in let arg_100 = ErlangTuple [tup_el_101, tup_el_103]
             in let
               head_90 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_91, arg_100]
             in let
               arg_106 =
                 ErlangFun 1
                   (let
                      lambda_107 [(ErlangTuple [_1_109, _2_110, _3_111])] =
                        ErlangTuple
                          [ErlangAtom "type_decl", _1_109, _2_110, _3_111]
                      lambda_107 [arg_108] = EXC.function_clause unit
                      lambda_107 args =
                        EXC.badarity (ErlangFun 1 lambda_107) args
                    in lambda_107)
             in let tup_el_117 = erlps__keyword__1 [ErlangAtom "type"]
             in let tup_el_119 = erlps__id__0 []
             in let tup_el_120 = erlps__type_vars__0 []
             in let arg_116 = ErlangTuple [tup_el_117, tup_el_119, tup_el_120]
             in let
               head_105 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_106, arg_116]
             in let
               arg_123 =
                 ErlangFun 1
                   (let
                      lambda_124 [(ErlangTuple [_1_126, _2_127, _3_128,
                                                _4_129])]
                        =
                        ErlangTuple
                          [ErlangAtom "type_def", _1_126, _2_127,
                           ErlangEmptyList, _4_129]
                      lambda_124 [arg_125] = EXC.function_clause unit
                      lambda_124 args =
                        EXC.badarity (ErlangFun 1 lambda_124) args
                    in lambda_124)
             in let tup_el_136 = erlps__keyword__1 [ErlangAtom "type"]
             in let tup_el_138 = erlps__id__0 []
             in let
               tup_el_139 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_141 = erlps__typedef__1 [ErlangAtom "type"]
             in let
               arg_135 =
                 ErlangTuple [tup_el_136, tup_el_138, tup_el_139, tup_el_141]
             in let
               head_122 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_123, arg_135]
             in let
               arg_145 =
                 ErlangFun 1
                   (let
                      lambda_146 [(ErlangTuple [_1_148, _2_149, _3_150, _4_151,
                                                _5_152])]
                        =
                        ErlangTuple
                          [ErlangAtom "type_def", _1_148, _2_149, _3_150,
                           _5_152]
                      lambda_146 [arg_147] = EXC.function_clause unit
                      lambda_146 args =
                        EXC.badarity (ErlangFun 1 lambda_146) args
                    in lambda_146)
             in let tup_el_159 = erlps__keyword__1 [ErlangAtom "type"]
             in let tup_el_161 = erlps__id__0 []
             in let tup_el_162 = erlps__type_vars__0 []
             in let
               tup_el_163 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_165 = erlps__typedef__1 [ErlangAtom "type"]
             in let
               arg_158 =
                 ErlangTuple
                   [tup_el_159, tup_el_161, tup_el_162, tup_el_163, tup_el_165]
             in let
               head_144 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_145, arg_158]
             in let
               arg_169 =
                 ErlangFun 1
                   (let
                      lambda_170 [(ErlangTuple [_1_172, _2_173, _3_174,
                                                _4_175])]
                        =
                        ErlangTuple
                          [ErlangAtom "type_def", _1_172, _2_173,
                           ErlangEmptyList, _4_175]
                      lambda_170 [arg_171] = EXC.function_clause unit
                      lambda_170 args =
                        EXC.badarity (ErlangFun 1 lambda_170) args
                    in lambda_170)
             in let tup_el_182 = erlps__keyword__1 [ErlangAtom "record"]
             in let tup_el_184 = erlps__id__0 []
             in let
               tup_el_185 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_187 = erlps__typedef__1 [ErlangAtom "record"]
             in let
               arg_181 =
                 ErlangTuple [tup_el_182, tup_el_184, tup_el_185, tup_el_187]
             in let
               head_168 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_169, arg_181]
             in let
               arg_191 =
                 ErlangFun 1
                   (let
                      lambda_192 [(ErlangTuple [_1_194, _2_195, _3_196, _4_197,
                                                _5_198])]
                        =
                        ErlangTuple
                          [ErlangAtom "type_def", _1_194, _2_195, _3_196,
                           _5_198]
                      lambda_192 [arg_193] = EXC.function_clause unit
                      lambda_192 args =
                        EXC.badarity (ErlangFun 1 lambda_192) args
                    in lambda_192)
             in let tup_el_205 = erlps__keyword__1 [ErlangAtom "record"]
             in let tup_el_207 = erlps__id__0 []
             in let tup_el_208 = erlps__type_vars__0 []
             in let
               tup_el_209 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_211 = erlps__typedef__1 [ErlangAtom "record"]
             in let
               arg_204 =
                 ErlangTuple
                   [tup_el_205, tup_el_207, tup_el_208, tup_el_209, tup_el_211]
             in let
               head_190 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_191, arg_204]
             in let
               arg_215 =
                 ErlangFun 1
                   (let
                      lambda_216 [(ErlangTuple [_1_218, _2_219, _3_220,
                                                _4_221])]
                        =
                        ErlangTuple
                          [ErlangAtom "type_def", _1_218, _2_219,
                           ErlangEmptyList, _4_221]
                      lambda_216 [arg_217] = EXC.function_clause unit
                      lambda_216 args =
                        EXC.badarity (ErlangFun 1 lambda_216) args
                    in lambda_216)
             in let tup_el_228 = erlps__keyword__1 [ErlangAtom "datatype"]
             in let tup_el_230 = erlps__id__0 []
             in let
               tup_el_231 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_233 = erlps__typedef__1 [ErlangAtom "variant"]
             in let
               arg_227 =
                 ErlangTuple [tup_el_228, tup_el_230, tup_el_231, tup_el_233]
             in let
               head_214 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_215, arg_227]
             in let
               arg_237 =
                 ErlangFun 1
                   (let
                      lambda_238 [(ErlangTuple [_1_240, _2_241, _3_242, _4_243,
                                                _5_244])]
                        =
                        ErlangTuple
                          [ErlangAtom "type_def", _1_240, _2_241, _3_242,
                           _5_244]
                      lambda_238 [arg_239] = EXC.function_clause unit
                      lambda_238 args =
                        EXC.badarity (ErlangFun 1 lambda_238) args
                    in lambda_238)
             in let tup_el_251 = erlps__keyword__1 [ErlangAtom "datatype"]
             in let tup_el_253 = erlps__id__0 []
             in let tup_el_254 = erlps__type_vars__0 []
             in let
               tup_el_255 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_257 = erlps__typedef__1 [ErlangAtom "variant"]
             in let
               arg_250 =
                 ErlangTuple
                   [tup_el_251, tup_el_253, tup_el_254, tup_el_255, tup_el_257]
             in let
               head_236 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_237, arg_250]
             in let
               arg_261 =
                 ErlangFun 1
                   (let
                      lambda_262 [(ErlangTuple [_1_264, _2_265, _3_266])] =
                        erlps__fun_block__3 [_1_264, _2_265, _3_266]
                      lambda_262 [arg_263] = EXC.function_clause unit
                      lambda_262 args =
                        EXC.badarity (ErlangFun 1 lambda_262) args
                    in lambda_262)
             in let tup_el_271 = erlps__modifiers__0 []
             in let tup_el_272 = erlps__fun_or_entry__0 []
             in let arg_274 = erlps__fundef_or_decl__0 []
             in let tup_el_273 = erlps__maybe_block__1 [arg_274]
             in let arg_270 = ErlangTuple [tup_el_271, tup_el_272, tup_el_273]
             in let
               head_260 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_261, arg_270]
             in let
               arg_277 =
                 ErlangFun 1
                   (let
                      lambda_278 [(ErlangTuple [_1_280, _2_281])] =
                        let arg_282 = erlps__get_pos__1 [_1_280]
                        in erlps__set_pos__2 [arg_282, _2_281]
                      lambda_278 [arg_279] = EXC.function_clause unit
                      lambda_278 args =
                        EXC.badarity (ErlangFun 1 lambda_278) args
                    in lambda_278)
             in let tup_el_286 = erlps__keyword__1 [ErlangAtom "let"]
             in let tup_el_288 = erlps__valdef__0 []
             in let arg_285 = ErlangTuple [tup_el_286, tup_el_288]
             in let
               head_276 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_277, arg_285]
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3
                    (ErlangCons head_24
                       (ErlangCons head_52
                          (ErlangCons head_73
                             (ErlangCons head_88
                                (ErlangCons head_90
                                   (ErlangCons head_105
                                      (ErlangCons head_122
                                         (ErlangCons head_144
                                            (ErlangCons head_168
                                               (ErlangCons head_190
                                                  (ErlangCons head_214
                                                     (ErlangCons head_236
                                                        (ErlangCons head_260
                                                           (ErlangCons head_276
                                                              ErlangEmptyList))))))))))))))]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__decl__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fun_block__3 :: ErlangFun
erlps__fun_block__3 [mods_0, kind_1,
                     (ErlangCons decl_2 (ErlangEmptyList))]
  =
  let    arg_6 = erlps__get_pos__1 [kind_1]
  in let arg_5 = erlps__set_pos__2 [arg_6, decl_2]
  in erlps__add_modifiers__3 [mods_0, kind_1, arg_5]
erlps__fun_block__3 [mods_0, kind_1, decls_2] =
  let    tup_el_4 = erlps__get_ann__1 [kind_1]
  in let
    tup_el_6 =
      flmap
        (\ lc_9 ->
           let lcRet_10 = erlps__add_modifiers__3 [mods_0, kind_1, lc_9]
           in ErlangCons lcRet_10 ErlangEmptyList)
        decls_2
  in ErlangTuple [ErlangAtom "block", tup_el_4, tup_el_6]
erlps__fun_block__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__fun_block__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fundef_or_decl__0 :: ErlangFun
erlps__fundef_or_decl__0 [] =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [_1_5, _2_6, _3_7])] =
             let tup_el_9 = erlps__get_ann__1 [_1_5]
             in ErlangTuple [ErlangAtom "fun_decl", tup_el_9, _1_5, _3_7]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let tup_el_14 = erlps__id__0 []
  in let
    tup_el_15 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ":"]
  in let tup_el_17 = erlps__type__0 []
  in let arg_13 = ErlangTuple [tup_el_14, tup_el_15, tup_el_17]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_2, arg_13]
  in let head_19 = erlps__fundef__0 []
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
      [ErlangCons head_1 (ErlangCons head_19 ErlangEmptyList)]
erlps__fundef_or_decl__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pragma__0 :: ErlangFun
erlps__pragma__0 [] =
  let   
    arg_0 =
      flmap
        (\ lc_13 ->
           let lcRet_14 = erlps__token__1 [lc_13]
           in ErlangCons lcRet_14 ErlangEmptyList)
        (ErlangCons (ErlangAtom "<")
           (ErlangCons (ErlangAtom "=<")
              (ErlangCons (ErlangAtom "==")
                 (ErlangCons (ErlangAtom ">=")
                    (ErlangCons (ErlangAtom ">") ErlangEmptyList)))))
  in let
    op_16 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
        [arg_0]
  in let
    arg_17 =
      ErlangFun 1
        (let
           lambda_18 [(ErlangTuple [_1_20, _2_21, _3_22, _4_23])] =
             let    tup_el_25 = erlps__get_ann__1 [_1_20]
             in let arg_30 = toErl 1
             in let tup_el_29 = BIF.erlang__element__2 [arg_30, _3_22]
             in let
               tup_el_27 = ErlangTuple [ErlangAtom "compiler", tup_el_29, _4_23]
             in ErlangTuple [ErlangAtom "pragma", tup_el_25, tup_el_27]
           lambda_18 [arg_19] = EXC.function_clause unit
           lambda_18 args = EXC.badarity (ErlangFun 1 lambda_18) args
         in lambda_18)
  in let
    tup_el_34 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "@"]
  in let arg_37 = toErl "compiler"
  in let tup_el_36 = erlps__id__1 [arg_37]
  in let tup_el_39 = erlps__version__0 []
  in let
    arg_33 = ErlangTuple [tup_el_34, tup_el_36, op_16, tup_el_39]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_17, arg_33]
erlps__pragma__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__version__0 :: ErlangFun
erlps__version__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             erlps__mk_version__2 [_1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_8 = erlps__token__1 [ErlangAtom "int"]
  in let
    tup_el_12 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "."]
  in let tup_el_14 = erlps__token__1 [ErlangAtom "int"]
  in let arg_11 = ErlangTuple [tup_el_12, tup_el_14]
  in let
    tup_el_10 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_11]
  in let arg_7 = ErlangTuple [tup_el_8, tup_el_10]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_7]
erlps__version__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__mk_version__2 :: ErlangFun
erlps__mk_version__2 [(ErlangTuple [(ErlangAtom "int"), _,
                                    maj_0]),
                      rest_1]
  =
  let
    tail_3 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [_, (ErlangTuple [(ErlangAtom "int"), _, n_5])]) ->
               ErlangCons n_5 ErlangEmptyList
             _ -> ErlangEmptyList)
        rest_1
  in ErlangCons maj_0 tail_3
erlps__mk_version__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__mk_version__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fun_or_entry__0 :: ErlangFun
erlps__fun_or_entry__0 [] =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [_1_5] = ErlangTuple [ErlangAtom "function", _1_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let arg_8 = erlps__keyword__1 [ErlangAtom "function"]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_2, arg_8]
  in let
    arg_12 =
      ErlangFun 1
        (let
           lambda_13 [_1_15] = ErlangTuple [ErlangAtom "entrypoint", _1_15]
           lambda_13 [arg_14] = EXC.function_clause unit
           lambda_13 args = EXC.badarity (ErlangFun 1 lambda_13) args
         in lambda_13)
  in let arg_18 = erlps__keyword__1 [ErlangAtom "entrypoint"]
  in let
    head_11 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_12, arg_18]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
      [ErlangCons head_1 (ErlangCons head_11 ErlangEmptyList)]
erlps__fun_or_entry__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__modifiers__0 :: ErlangFun
erlps__modifiers__0 [] =
  let    head_2 = erlps__token__1 [ErlangAtom "stateful"]
  in let head_5 = erlps__token__1 [ErlangAtom "payable"]
  in let head_8 = erlps__token__1 [ErlangAtom "private"]
  in let head_11 = erlps__token__1 [ErlangAtom "public"]
  in let
    arg_0 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
        [ErlangCons head_2
           (ErlangCons head_5
              (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList)))]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_0]
erlps__modifiers__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_modifiers__3 :: ErlangFun
erlps__add_modifiers__3 [mods_0,
                         entry_1@(ErlangTuple [(ErlangAtom "entrypoint"), _]),
                         node_2]
  =
  let
    arg_3 =
      BIF.erlang__op_append
        [mods_0, ErlangCons entry_1 ErlangEmptyList]
  in erlps__add_modifiers__2 [arg_3, node_2]
erlps__add_modifiers__3 [mods_0,
                         (ErlangTuple [(ErlangAtom "function"), _]), node_1]
  =
  erlps__add_modifiers__2 [mods_0, node_1]
erlps__add_modifiers__3 [arg_4, arg_5, arg_6] =
  EXC.function_clause unit
erlps__add_modifiers__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__add_modifiers__2 :: ErlangFun
erlps__add_modifiers__2 [(ErlangEmptyList), node_0] = node_0
erlps__add_modifiers__2 [mods_1@(ErlangCons tok_0 _), node_2] =
  let    arg_3 = erlps__get_pos__1 [tok_0]
  in let
    arg_6 =
      ErlangFun 2
        (let
           lambda_7 [(ErlangTuple [mod_10, _]), x_11] =
             erlps__set_ann__3 [mod_10, ErlangAtom "true", x_11]
           lambda_7 [arg_8, arg_9] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 2 lambda_7) args
         in lambda_7)
  in let
    arg_5 =
      BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
        [arg_6, node_2, mods_1]
  in erlps__set_pos__2 [arg_3, arg_5]
erlps__add_modifiers__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__add_modifiers__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__typedef__1 :: ErlangFun
erlps__typedef__1 [(ErlangAtom "type")] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [_1_3] = ErlangTuple [ErlangAtom "alias_t", _1_3]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_6 = erlps__type__0 []
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_6]
erlps__typedef__1 [(ErlangAtom "record")] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [_1_3] = ErlangTuple [ErlangAtom "record_t", _1_3]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_7 = erlps__field_type__0 []
  in let arg_6 = erlps__brace_list__1 [arg_7]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_6]
erlps__typedef__1 [(ErlangAtom "variant")] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [_1_3] = ErlangTuple [ErlangAtom "variant_t", _1_3]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_6 = erlps__constructors__0 []
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_6]
erlps__typedef__1 [arg_7] = EXC.function_clause unit
erlps__typedef__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__constructors__0 :: ErlangFun
erlps__constructors__0 [] =
  let    arg_0 = erlps__constructor__0 []
  in let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "|"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__sep1__2"
      [arg_0, arg_1]
erlps__constructors__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__constructor__0 :: ErlangFun
erlps__constructor__0 [] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [_1_4] =
             let tup_el_6 = erlps__get_ann__1 [_1_4]
             in
               ErlangTuple
                 [ErlangAtom "constr_t", tup_el_6, _1_4, ErlangEmptyList]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_10 = erlps__con__0 []
  in let
    arg_0 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_1, arg_10]
  in let
    arg_12 =
      ErlangFun 1
        (let
           lambda_13 [(ErlangTuple [_1_15, _2_16])] =
             let tup_el_18 = erlps__get_ann__1 [_1_15]
             in ErlangTuple [ErlangAtom "constr_t", tup_el_18, _1_15, _2_16]
           lambda_13 [arg_14] = EXC.function_clause unit
           lambda_13 args = EXC.badarity (ErlangFun 1 lambda_13) args
         in lambda_13)
  in let tup_el_23 = erlps__con__0 []
  in let tup_el_24 = erlps__con_args__0 []
  in let arg_22 = ErlangTuple [tup_el_23, tup_el_24]
  in let
    arg_11 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_12, arg_22]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__2"
      [arg_0, arg_11]
erlps__constructor__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__con_args__0 :: ErlangFun
erlps__con_args__0 [] =
  let arg_0 = erlps__con_arg__0 []
  in erlps__paren_list__1 [arg_0]
erlps__con_args__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type_args__0 :: ErlangFun
erlps__type_args__0 [] =
  let arg_0 = erlps__type__0 []
  in erlps__paren_list__1 [arg_0]
erlps__type_args__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__field_type__0 :: ErlangFun
erlps__field_type__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4, _3_5])] =
             let tup_el_7 = erlps__get_ann__1 [_1_3]
             in ErlangTuple [ErlangAtom "field_t", tup_el_7, _1_3, _3_5]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_12 = erlps__id__0 []
  in let
    tup_el_13 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ":"]
  in let tup_el_15 = erlps__type__0 []
  in let arg_11 = ErlangTuple [tup_el_12, tup_el_13, tup_el_15]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_11]
erlps__field_type__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__con_arg__0 :: ErlangFun
erlps__con_arg__0 [] =
  let    arg_0 = erlps__type__0 []
  in let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [_1_5, _2_6])] =
             erlps__set_ann__3 [ErlangAtom "indexed", ErlangAtom "true", _2_6]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let tup_el_11 = erlps__keyword__1 [ErlangAtom "indexed"]
  in let tup_el_13 = erlps__type__0 []
  in let arg_10 = ErlangTuple [tup_el_11, tup_el_13]
  in let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_2, arg_10]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__2"
      [arg_0, arg_1]
erlps__con_arg__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__letdecl__0 :: ErlangFun
erlps__letdecl__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             let arg_5 = erlps__get_pos__1 [_1_3]
             in erlps__set_pos__2 [arg_5, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_9 = erlps__keyword__1 [ErlangAtom "let"]
  in let tup_el_11 = erlps__letdef__0 []
  in let arg_8 = ErlangTuple [tup_el_9, tup_el_11]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_8]
erlps__letdecl__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__letdef__0 :: ErlangFun
erlps__letdef__0 [] =
  let    arg_0 = erlps__valdef__0 []
  in let arg_1 = erlps__fundef__0 []
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__2"
      [arg_0, arg_1]
erlps__letdef__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__valdef__0 :: ErlangFun
erlps__valdef__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4, _3_5])] =
             ErlangTuple [ErlangAtom "letval", ErlangEmptyList, _1_3, _3_5]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_11 = erlps__pattern__0 []
  in let
    tup_el_12 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "="]
  in let tup_el_14 = erlps__body__0 []
  in let arg_10 = ErlangTuple [tup_el_11, tup_el_12, tup_el_14]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_10]
erlps__valdef__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fundef__0 :: ErlangFun
erlps__fundef__0 [] =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [_1_5, _2_6, _3_7, _4_8])] =
             let    tup_el_10 = erlps__get_ann__1 [_1_5]
             in let arg_15 = erlps__get_ann__1 [_1_5]
             in let tup_el_14 = erlps__type_wildcard__1 [arg_15]
             in
               ErlangTuple
                 [ErlangAtom "letfun", tup_el_10, _1_5, _2_6, tup_el_14, _4_8]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let tup_el_19 = erlps__id__0 []
  in let tup_el_20 = erlps__args__0 []
  in let
    tup_el_21 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "="]
  in let tup_el_23 = erlps__body__0 []
  in let
    arg_18 = ErlangTuple [tup_el_19, tup_el_20, tup_el_21, tup_el_23]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_2, arg_18]
  in let
    arg_26 =
      ErlangFun 1
        (let
           lambda_27 [(ErlangTuple [_1_29, _2_30, _3_31, _4_32, _5_33,
                                    _6_34])]
             =
             let tup_el_36 = erlps__get_ann__1 [_1_29]
             in
               ErlangTuple
                 [ErlangAtom "letfun", tup_el_36, _1_29, _2_30, _4_32, _6_34]
           lambda_27 [arg_28] = EXC.function_clause unit
           lambda_27 args = EXC.badarity (ErlangFun 1 lambda_27) args
         in lambda_27)
  in let tup_el_43 = erlps__id__0 []
  in let tup_el_44 = erlps__args__0 []
  in let
    tup_el_45 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ":"]
  in let tup_el_47 = erlps__type__0 []
  in let
    tup_el_48 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "="]
  in let tup_el_50 = erlps__body__0 []
  in let
    arg_42 =
      ErlangTuple
        [tup_el_43, tup_el_44, tup_el_45, tup_el_47, tup_el_48,
         tup_el_50]
  in let
    head_25 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_26, arg_42]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
      [ErlangCons head_1 (ErlangCons head_25 ErlangEmptyList)]
erlps__fundef__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__args__0 :: ErlangFun
erlps__args__0 [] =
  let arg_0 = erlps__pattern__0 []
  in erlps__paren_list__1 [arg_0]
erlps__args__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lam_args__0 :: ErlangFun
erlps__lam_args__0 [] =
  let arg_0 = erlps__arg__0 []
  in erlps__paren_list__1 [arg_0]
erlps__lam_args__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__arg__0 :: ErlangFun
erlps__arg__0 [] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [_1_4] =
             let    tup_el_6 = erlps__get_ann__1 [_1_4]
             in let arg_10 = erlps__get_ann__1 [_1_4]
             in let tup_el_9 = erlps__type_wildcard__1 [arg_10]
             in ErlangTuple [ErlangAtom "arg", tup_el_6, _1_4, tup_el_9]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_12 = erlps__id__0 []
  in let
    arg_0 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_1, arg_12]
  in let
    arg_14 =
      ErlangFun 1
        (let
           lambda_15 [(ErlangTuple [_1_17, _2_18, _3_19])] =
             let tup_el_21 = erlps__get_ann__1 [_1_17]
             in ErlangTuple [ErlangAtom "arg", tup_el_21, _1_17, _3_19]
           lambda_15 [arg_16] = EXC.function_clause unit
           lambda_15 args = EXC.badarity (ErlangFun 1 lambda_15) args
         in lambda_15)
  in let tup_el_26 = erlps__id__0 []
  in let
    tup_el_27 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ":"]
  in let tup_el_29 = erlps__type__0 []
  in let arg_25 = ErlangTuple [tup_el_26, tup_el_27, tup_el_29]
  in let
    arg_13 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_14, arg_25]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__2"
      [arg_0, arg_13]
erlps__arg__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type_vars__0 :: ErlangFun
erlps__type_vars__0 [] =
  let arg_0 = erlps__tvar__0 []
  in erlps__paren_list__1 [arg_0]
erlps__type_vars__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type__0 :: ErlangFun
erlps__type__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] = erlps__type100__0 []
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__type__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type100__0 :: ErlangFun
erlps__type100__0 [] = erlps__type200__0 []
erlps__type100__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type200__0 :: ErlangFun
erlps__type200__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             erlps__fun_t__2 [_1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_10 = erlps__type300__0 []
  in let tup_el_11 = erlps__keyword__1 [ErlangAtom "=>"]
  in let arg_9 = ErlangTuple [tup_el_10, tup_el_11]
  in let
    tup_el_8 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_9]
  in let tup_el_13 = erlps__type300__0 []
  in let arg_7 = ErlangTuple [tup_el_8, tup_el_13]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_7]
erlps__type200__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type300__0 :: ErlangFun
erlps__type300__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [_1_3] =
             let    arg_6 = toErl 1
             in let
               arg_5 =
                 BIF.do_remote_fun_call "Lists" "erlps__nth__2" [arg_6, _1_3]
             in let arg_4 = erlps__get_ann__1 [arg_5]
             in erlps__tuple_t__2 [arg_4, _1_3]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_10 = erlps__type400__0 []
  in let
    arg_11 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "*"]
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__sep1__2"
        [arg_10, arg_11]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_9]
erlps__type300__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type400__0 :: ErlangFun
erlps__type400__0 [] =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [_1_5, _2_6])] =
             case _2_6 of
               (ErlangAtom "none") -> _1_5
               (ErlangTuple [(ErlangAtom "ok"), args_8]) ->
                 let tup_el_10 = erlps__get_ann__1 [_1_5]
                 in ErlangTuple [ErlangAtom "app_t", tup_el_10, _1_5, args_8]
               something_else -> EXC.case_clause something_else
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let tup_el_15 = erlps__typeAtom__0 []
  in let arg_17 = erlps__type_args__0 []
  in let
    tup_el_16 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__optional__1"
        [arg_17]
  in let arg_14 = ErlangTuple [tup_el_15, tup_el_16]
  in let
    head_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_2, arg_14]
  in let
    arg_20 =
      ErlangFun 1
        (let
           lambda_21 [(ErlangTuple [_1_23, _2_24])] =
             let    tup_el_26 = erlps__get_ann__1 [_1_23]
             in let arg_29 = toErl 3
             in let tup_el_28 = BIF.erlang__element__2 [arg_29, _2_24]
             in ErlangTuple [ErlangAtom "bytes_t", tup_el_26, tup_el_28]
           lambda_21 [arg_22] = EXC.function_clause unit
           lambda_21 args = EXC.badarity (ErlangFun 1 lambda_21) args
         in lambda_21)
  in let arg_33 = toErl "bytes"
  in let tup_el_32 = erlps__id__1 [arg_33]
  in let arg_35 = erlps__token__1 [ErlangAtom "int"]
  in let tup_el_34 = erlps__parens__1 [arg_35]
  in let arg_31 = ErlangTuple [tup_el_32, tup_el_34]
  in let
    head_19 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_20, arg_31]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
      [ErlangCons head_1 (ErlangCons head_19 ErlangEmptyList)]
erlps__type400__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__typeAtom__0 :: ErlangFun
erlps__typeAtom__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let    arg_4 = erlps__type__0 []
             in let head_3 = erlps__parens__1 [arg_4]
             in let head_6 = erlps__args_t__0 []
             in let head_8 = erlps__id__0 []
             in let head_10 = erlps__token__1 [ErlangAtom "con"]
             in let head_13 = erlps__token__1 [ErlangAtom "qcon"]
             in let head_16 = erlps__token__1 [ErlangAtom "qid"]
             in let head_19 = erlps__tvar__0 []
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3
                    (ErlangCons head_6
                       (ErlangCons head_8
                          (ErlangCons head_10
                             (ErlangCons head_13
                                (ErlangCons head_16
                                   (ErlangCons head_19 ErlangEmptyList))))))]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__typeAtom__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__args_t__0 :: ErlangFun
erlps__args_t__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let   
               arg_4 =
                 ErlangFun 1
                   (let
                      lambda_5 [(ErlangTuple [_1_7, _2_8])] =
                        let tup_el_10 = erlps__get_ann__1 [_1_7]
                        in
                          ErlangTuple
                            [ErlangAtom "args_t", tup_el_10, ErlangEmptyList]
                      lambda_5 [arg_6] = EXC.function_clause unit
                      lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
                    in lambda_5)
             in let
               tup_el_14 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "("]
             in let
               tup_el_16 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom ")"]
             in let arg_13 = ErlangTuple [tup_el_14, tup_el_16]
             in let
               head_3 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_4, arg_13]
             in let
               arg_20 =
                 ErlangFun 1
                   (let
                      lambda_21 [(ErlangTuple [_1_23, _2_24, _3_25, _4_26,
                                               _5_27])]
                        =
                        let tup_el_29 = erlps__get_ann__1 [_1_23]
                        in
                          ErlangTuple
                            [ErlangAtom "args_t", tup_el_29,
                             ErlangCons _2_24 _4_26]
                      lambda_21 [arg_22] = EXC.function_clause unit
                      lambda_21 args = EXC.badarity (ErlangFun 1 lambda_21) args
                    in lambda_21)
             in let
               tup_el_35 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "("]
             in let tup_el_37 = erlps__type__0 []
             in let
               tup_el_38 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom ","]
             in let arg_41 = erlps__type__0 []
             in let
               arg_42 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom ","]
             in let
               tup_el_40 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__sep1__2"
                   [arg_41, arg_42]
             in let
               tup_el_44 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom ")"]
             in let
               arg_34 =
                 ErlangTuple
                   [tup_el_35, tup_el_37, tup_el_38, tup_el_40, tup_el_44]
             in let
               head_19 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_20, arg_34]
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3 (ErlangCons head_19 ErlangEmptyList)]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__args_t__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__body__0 :: ErlangFun
erlps__body__0 [] =
  let    arg_1 = erlps__stmt__0 []
  in let arg_0 = erlps__maybe_block__1 [arg_1]
  in let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [stmts_5] = erlps__block_e__1 [stmts_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__bind__2"
      [arg_0, arg_2]
erlps__body__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__stmt__0 :: ErlangFun
erlps__stmt__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let    head_3 = erlps__expr__0 []
             in let head_5 = erlps__letdecl__0 []
             in let tup_el_9 = erlps__keyword__1 [ErlangAtom "switch"]
             in let arg_12 = erlps__expr__0 []
             in let tup_el_11 = erlps__parens__1 [arg_12]
             in let arg_14 = erlps__branch__0 []
             in let tup_el_13 = erlps__maybe_block__1 [arg_14]
             in let
               head_7 =
                 ErlangTuple
                   [ErlangAtom "switch", tup_el_9, tup_el_11, tup_el_13]
             in let tup_el_18 = erlps__keyword__1 [ErlangAtom "if"]
             in let arg_21 = erlps__expr__0 []
             in let tup_el_20 = erlps__parens__1 [arg_21]
             in let tup_el_22 = erlps__body__0 []
             in let
               head_16 =
                 ErlangTuple [ErlangAtom "if", tup_el_18, tup_el_20, tup_el_22]
             in let tup_el_26 = erlps__keyword__1 [ErlangAtom "elif"]
             in let arg_29 = erlps__expr__0 []
             in let tup_el_28 = erlps__parens__1 [arg_29]
             in let tup_el_30 = erlps__body__0 []
             in let
               head_24 =
                 ErlangTuple
                   [ErlangAtom "elif", tup_el_26, tup_el_28, tup_el_30]
             in let tup_el_34 = erlps__keyword__1 [ErlangAtom "else"]
             in let tup_el_36 = erlps__body__0 []
             in let
               head_32 = ErlangTuple [ErlangAtom "else", tup_el_34, tup_el_36]
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3
                    (ErlangCons head_5
                       (ErlangCons head_7
                          (ErlangCons head_16
                             (ErlangCons head_24
                                (ErlangCons head_32 ErlangEmptyList)))))]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__stmt__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__branch__0 :: ErlangFun
erlps__branch__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4, _3_5])] =
             ErlangTuple [ErlangAtom "case", _2_4, _1_3, _3_5]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_11 = erlps__pattern__0 []
  in let tup_el_12 = erlps__keyword__1 [ErlangAtom "=>"]
  in let tup_el_14 = erlps__body__0 []
  in let arg_10 = ErlangTuple [tup_el_11, tup_el_12, tup_el_14]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_10]
erlps__branch__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pattern__0 :: ErlangFun
erlps__pattern__0 [] =
  let    arg_0 = erlps__expr__0 []
  in let
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [e_4] = erlps__parse_pattern__1 [e_4]
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__bind__2"
      [arg_0, arg_1]
erlps__pattern__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr__0 :: ErlangFun
erlps__expr__0 [] = erlps__expr100__0 []
erlps__expr__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr100__0 :: ErlangFun
erlps__expr100__0 [] =
  let   
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] = erlps__expr100__0 []
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in let
    expr100_2 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
  in let
    arg_3 =
      ErlangFun 0
        (let
           lambda_4 [] = erlps__expr200__0 []
           lambda_4 [] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 0 lambda_4) args
         in lambda_4)
  in let
    expr200_5 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_3]
  in let
    arg_8 =
      ErlangFun 1
        (let
           lambda_9 [(ErlangTuple [_1_11, _2_12, _3_13])] =
             ErlangTuple [ErlangAtom "lam", _2_12, _1_11, _3_13]
           lambda_9 [arg_10] = EXC.function_clause unit
           lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
         in lambda_9)
  in let tup_el_19 = erlps__lam_args__0 []
  in let tup_el_20 = erlps__keyword__1 [ErlangAtom "=>"]
  in let tup_el_22 = erlps__body__0 []
  in let arg_18 = ErlangTuple [tup_el_19, tup_el_20, tup_el_22]
  in let
    head_7 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_8, arg_18]
  in let tup_el_26 = erlps__keyword__1 [ErlangAtom "if"]
  in let tup_el_28 = erlps__parens__1 [expr100_2]
  in let
    arg_32 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "else"]
  in let
    tup_el_31 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__right__2"
        [arg_32, expr100_2]
  in let
    head_24 =
      ErlangTuple
        [ErlangAtom "if", tup_el_26, tup_el_28, expr200_5, tup_el_31]
  in let
    arg_37 =
      ErlangFun 1
        (let
           lambda_38 [(ErlangTuple [_1_40, _2_41])] =
             case _2_41 of
               (ErlangAtom "none") -> _1_40
               (ErlangTuple [(ErlangAtom "ok"), type_43]) ->
                 let tup_el_45 = erlps__get_ann__1 [_1_40]
                 in ErlangTuple [ErlangAtom "typed", tup_el_45, _1_40, type_43]
               something_else -> EXC.case_clause something_else
           lambda_38 [arg_39] = EXC.function_clause unit
           lambda_38 args = EXC.badarity (ErlangFun 1 lambda_38) args
         in lambda_38)
  in let
    arg_53 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ":"]
  in let arg_55 = erlps__type__0 []
  in let
    arg_52 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__right__2"
        [arg_53, arg_55]
  in let
    tup_el_51 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__optional__1"
        [arg_52]
  in let arg_49 = ErlangTuple [expr200_5, tup_el_51]
  in let
    head_36 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
        [arg_37, arg_49]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
      [ErlangCons head_7
         (ErlangCons head_24 (ErlangCons head_36 ErlangEmptyList))]
erlps__expr100__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr200__0 :: ErlangFun
erlps__expr200__0 [] =
  let    arg_0 = erlps__expr300__0 []
  in let arg_1 = erlps__binop__1 [ErlangAtom "||"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__infixr__2"
      [arg_0, arg_1]
erlps__expr200__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr300__0 :: ErlangFun
erlps__expr300__0 [] =
  let    arg_0 = erlps__expr400__0 []
  in let arg_1 = erlps__binop__1 [ErlangAtom "&&"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__infixr__2"
      [arg_0, arg_1]
erlps__expr300__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr400__0 :: ErlangFun
erlps__expr400__0 [] =
  let    arg_0 = erlps__expr500__0 []
  in let
    arg_1 =
      erlps__binop__1
        [ErlangCons (ErlangAtom "<")
           (ErlangCons (ErlangAtom ">")
              (ErlangCons (ErlangAtom "=<")
                 (ErlangCons (ErlangAtom ">=")
                    (ErlangCons (ErlangAtom "==")
                       (ErlangCons (ErlangAtom "!=") ErlangEmptyList)))))]
  in erlps__infix__2 [arg_0, arg_1]
erlps__expr400__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr500__0 :: ErlangFun
erlps__expr500__0 [] =
  let    arg_0 = erlps__expr600__0 []
  in let
    arg_1 =
      erlps__binop__1
        [ErlangCons (ErlangAtom "::")
           (ErlangCons (ErlangAtom "++") ErlangEmptyList)]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__infixr__2"
      [arg_0, arg_1]
erlps__expr500__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr600__0 :: ErlangFun
erlps__expr600__0 [] =
  let    arg_0 = erlps__expr650__0 []
  in let
    arg_1 =
      erlps__binop__1
        [ErlangCons (ErlangAtom "+")
           (ErlangCons (ErlangAtom "-") ErlangEmptyList)]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__infixl__2"
      [arg_0, arg_1]
erlps__expr600__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr650__0 :: ErlangFun
erlps__expr650__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             erlps__prefixes__2 [_1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_9 = erlps__token__1 [ErlangAtom "-"]
  in let
    tup_el_8 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_9]
  in let tup_el_11 = erlps__expr700__0 []
  in let arg_7 = ErlangTuple [tup_el_8, tup_el_11]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_7]
erlps__expr650__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr700__0 :: ErlangFun
erlps__expr700__0 [] =
  let    arg_0 = erlps__expr750__0 []
  in let
    arg_1 =
      erlps__binop__1
        [ErlangCons (ErlangAtom "*")
           (ErlangCons (ErlangAtom "/")
              (ErlangCons (ErlangAtom "mod") ErlangEmptyList))]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__infixl__2"
      [arg_0, arg_1]
erlps__expr700__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr750__0 :: ErlangFun
erlps__expr750__0 [] =
  let    arg_0 = erlps__expr800__0 []
  in let
    arg_1 =
      erlps__binop__1 [ErlangCons (ErlangAtom "^") ErlangEmptyList]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__infixl__2"
      [arg_0, arg_1]
erlps__expr750__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr800__0 :: ErlangFun
erlps__expr800__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             erlps__prefixes__2 [_1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_9 = erlps__token__1 [ErlangAtom "!"]
  in let
    tup_el_8 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_9]
  in let tup_el_11 = erlps__expr900__0 []
  in let arg_7 = ErlangTuple [tup_el_8, tup_el_11]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_7]
erlps__expr800__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expr900__0 :: ErlangFun
erlps__expr900__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             erlps__elim__2 [_1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_8 = erlps__exprAtom__0 []
  in let arg_10 = erlps__elim__0 []
  in let
    tup_el_9 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_10]
  in let arg_7 = ErlangTuple [tup_el_8, tup_el_9]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_7]
erlps__expr900__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__exprAtom__0 :: ErlangFun
erlps__exprAtom__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let   
               arg_2 =
                 ErlangFun 0
                   (let
                      lambda_3 [] = erlps__expr__0 []
                      lambda_3 [] = EXC.function_clause unit
                      lambda_3 args = EXC.badarity (ErlangFun 0 lambda_3) args
                    in lambda_3)
             in let
               expr_4 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1"
                   [arg_2]
             in let head_6 = erlps__id_or_addr__0 []
             in let head_8 = erlps__con__0 []
             in let head_10 = erlps__token__1 [ErlangAtom "qid"]
             in let head_13 = erlps__token__1 [ErlangAtom "qcon"]
             in let head_16 = erlps__token__1 [ErlangAtom "bytes"]
             in let head_19 = erlps__token__1 [ErlangAtom "string"]
             in let head_22 = erlps__token__1 [ErlangAtom "char"]
             in let head_25 = erlps__token__1 [ErlangAtom "int"]
             in let
               arg_29 =
                 ErlangFun 1
                   (let
                      lambda_30 [_1_32] =
                        let    arg_36 = toErl 1
                        in let
                          arg_35 =
                            BIF.erlang__setelement__3
                              [arg_36, _1_32, ErlangAtom "int"]
                        in
                          erlps__set_ann__3
                            [ErlangAtom "format", ErlangAtom "hex", arg_35]
                      lambda_30 [arg_31] = EXC.function_clause unit
                      lambda_30 args = EXC.badarity (ErlangFun 1 lambda_30) args
                    in lambda_30)
             in let arg_39 = erlps__token__1 [ErlangAtom "hex"]
             in let
               head_28 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_29, arg_39]
             in let tup_el_44 = erlps__keyword__1 [ErlangAtom "true"]
             in let
               head_42 =
                 ErlangTuple [ErlangAtom "bool", tup_el_44, ErlangAtom "true"]
             in let tup_el_50 = erlps__keyword__1 [ErlangAtom "false"]
             in let
               head_48 =
                 ErlangTuple [ErlangAtom "bool", tup_el_50, ErlangAtom "false"]
             in let
               arg_57 =
                 ErlangFun 0
                   (let
                      lambda_58 [] = erlps__field_assignment__0 []
                      lambda_58 [] = EXC.function_clause unit
                      lambda_58 args = EXC.badarity (ErlangFun 0 lambda_58) args
                    in lambda_58)
             in let
               arg_56 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1"
                   [arg_57]
             in let arg_55 = erlps__brace_list__1 [arg_56]
             in let
               arg_59 =
                 ErlangFun 1
                   (let
                      lambda_60 [fs_62] = erlps__record__1 [fs_62]
                      lambda_60 [arg_61] = EXC.function_clause unit
                      lambda_60 args = EXC.badarity (ErlangFun 1 lambda_60) args
                    in lambda_60)
             in let
               head_54 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__bind__2"
                   [arg_55, arg_59]
             in let tup_el_68 = erlps__bracket_list__1 [expr_4]
             in let
               head_65 =
                 ErlangTuple [ErlangAtom "list", ErlangEmptyList, tup_el_68]
             in let
               arg_72 =
                 ErlangFun 1
                   (let
                      lambda_73 [(ErlangTuple [_1_75, _2_76, _3_77, _4_78,
                                               _5_79])]
                        =
                        erlps__list_comp_e__3 [_1_75, _2_76, _4_78]
                      lambda_73 [arg_74] = EXC.function_clause unit
                      lambda_73 args = EXC.badarity (ErlangFun 1 lambda_73) args
                    in lambda_73)
             in let tup_el_84 = erlps__keyword__1 [ErlangAtom "["]
             in let tup_el_87 = erlps__token__1 [ErlangAtom "|"]
             in let arg_90 = erlps__comprehension_exp__0 []
             in let tup_el_89 = erlps__comma_sep__1 [arg_90]
             in let
               tup_el_91 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "]"]
             in let
               arg_83 =
                 ErlangTuple
                   [tup_el_84, expr_4, tup_el_87, tup_el_89, tup_el_91]
             in let
               head_71 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_72, arg_83]
             in let
               arg_95 =
                 ErlangFun 1
                   (let
                      lambda_96 [(ErlangTuple [_1_98, _2_99, _3_100, _4_101,
                                               _5_102])]
                        =
                        BIF.erlang__apply__2
                          [_3_100,
                           ErlangCons _2_99 (ErlangCons _4_101 ErlangEmptyList)]
                      lambda_96 [arg_97] = EXC.function_clause unit
                      lambda_96 args = EXC.badarity (ErlangFun 1 lambda_96) args
                    in lambda_96)
             in let
               tup_el_107 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "["]
             in let tup_el_110 = erlps__binop__1 [ErlangAtom ".."]
             in let
               tup_el_113 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "]"]
             in let
               arg_106 =
                 ErlangTuple
                   [tup_el_107, expr_4, tup_el_110, expr_4, tup_el_113]
             in let
               head_94 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_95, arg_106]
             in let
               arg_117 =
                 ErlangFun 1
                   (let
                      lambda_118 [(ErlangTuple [_1_120, _2_121, _3_122])] =
                        erlps__tuple_e__2 [_1_120, _2_121]
                      lambda_118 [arg_119] = EXC.function_clause unit
                      lambda_118 args =
                        EXC.badarity (ErlangFun 1 lambda_118) args
                    in lambda_118)
             in let tup_el_126 = erlps__keyword__1 [ErlangAtom "("]
             in let tup_el_128 = erlps__comma_sep__1 [expr_4]
             in let
               tup_el_130 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom ")"]
             in let arg_125 = ErlangTuple [tup_el_126, tup_el_128, tup_el_130]
             in let
               head_116 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_117, arg_125]
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_6
                    (ErlangCons head_8
                       (ErlangCons head_10
                          (ErlangCons head_13
                             (ErlangCons head_16
                                (ErlangCons head_19
                                   (ErlangCons head_22
                                      (ErlangCons head_25
                                         (ErlangCons head_28
                                            (ErlangCons head_42
                                               (ErlangCons head_48
                                                  (ErlangCons head_54
                                                     (ErlangCons head_65
                                                        (ErlangCons head_71
                                                           (ErlangCons head_94
                                                              (ErlangCons
                                                                 head_116
                                                                 ErlangEmptyList)))))))))))))))]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__exprAtom__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__comprehension_exp__0 :: ErlangFun
erlps__comprehension_exp__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let    head_3 = erlps__comprehension_bind__0 []
             in let head_5 = erlps__letdecl__0 []
             in let head_7 = erlps__comprehension_if__0 []
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3
                    (ErlangCons head_5 (ErlangCons head_7 ErlangEmptyList))]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__comprehension_exp__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__comprehension_if__0 :: ErlangFun
erlps__comprehension_if__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             ErlangTuple [ErlangAtom "comprehension_if", _1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_9 = erlps__keyword__1 [ErlangAtom "if"]
  in let arg_12 = erlps__expr__0 []
  in let tup_el_11 = erlps__parens__1 [arg_12]
  in let arg_8 = ErlangTuple [tup_el_9, tup_el_11]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_8]
erlps__comprehension_if__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__comprehension_bind__0 :: ErlangFun
erlps__comprehension_bind__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4, _3_5])] =
             ErlangTuple [ErlangAtom "comprehension_bind", _1_3, _3_5]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_10 = erlps__pattern__0 []
  in let
    tup_el_11 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "<-"]
  in let tup_el_13 = erlps__expr__0 []
  in let arg_9 = ErlangTuple [tup_el_10, tup_el_11, tup_el_13]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_9]
erlps__comprehension_bind__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__arg_expr__0 :: ErlangFun
erlps__arg_expr__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let   
               arg_4 =
                 ErlangFun 1
                   (let
                      lambda_5 [(ErlangTuple [_1_7, _2_8, _3_9])] =
                        ErlangTuple
                          [ErlangAtom "named_arg", ErlangEmptyList, _1_7, _3_9]
                      lambda_5 [arg_6] = EXC.function_clause unit
                      lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
                    in lambda_5)
             in let tup_el_15 = erlps__id__0 []
             in let
               tup_el_16 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "="]
             in let tup_el_18 = erlps__expr__0 []
             in let arg_14 = ErlangTuple [tup_el_15, tup_el_16, tup_el_18]
             in let
               head_3 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_4, arg_14]
             in let head_20 = erlps__expr__0 []
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3 (ErlangCons head_20 ErlangEmptyList)]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__arg_expr__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__elim__0 :: ErlangFun
erlps__elim__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let    tup_el_5 = erlps__keyword__1 [ErlangAtom "."]
             in let tup_el_7 = erlps__id__0 []
             in let
               head_3 = ErlangTuple [ErlangAtom "proj", tup_el_5, tup_el_7]
             in let
               arg_10 =
                 ErlangFun 1
                   (let
                      lambda_11 [_1_13] =
                        ErlangTuple [ErlangAtom "app", ErlangEmptyList, _1_13]
                      lambda_11 [arg_12] = EXC.function_clause unit
                      lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
                    in lambda_11)
             in let arg_18 = erlps__arg_expr__0 []
             in let arg_17 = erlps__paren_list__1 [arg_18]
             in let
               head_9 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_10, arg_17]
             in let
               arg_21 =
                 ErlangFun 1
                   (let
                      lambda_22 [(ErlangTuple [_1_24, _2_25, _3_26])] =
                        ErlangTuple [ErlangAtom "rec_upd", _1_24, _2_25]
                      lambda_22 [arg_23] = EXC.function_clause unit
                      lambda_22 args = EXC.badarity (ErlangFun 1 lambda_22) args
                    in lambda_22)
             in let tup_el_31 = erlps__keyword__1 [ErlangAtom "{"]
             in let arg_34 = erlps__field_assignment__0 []
             in let tup_el_33 = erlps__comma_sep__1 [arg_34]
             in let
               tup_el_35 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
                   [ErlangAtom "}"]
             in let arg_30 = ErlangTuple [tup_el_31, tup_el_33, tup_el_35]
             in let
               head_20 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_21, arg_30]
             in let
               arg_39 =
                 ErlangFun 1
                   (let
                      lambda_40 [(ErlangTuple [_1_42, _2_43, _3_44])] =
                        erlps__map_get__2 [_1_42, _2_43]
                      lambda_40 [arg_41] = EXC.function_clause unit
                      lambda_40 args = EXC.badarity (ErlangFun 1 lambda_40) args
                    in lambda_40)
             in let tup_el_48 = erlps__keyword__1 [ErlangAtom "["]
             in let tup_el_50 = erlps__map_key__0 []
             in let tup_el_51 = erlps__keyword__1 [ErlangAtom "]"]
             in let arg_47 = ErlangTuple [tup_el_48, tup_el_50, tup_el_51]
             in let
               head_38 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_39, arg_47]
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3
                    (ErlangCons head_9
                       (ErlangCons head_20
                          (ErlangCons head_38 ErlangEmptyList)))]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__elim__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__map_get__2 :: ErlangFun
erlps__map_get__2 [ann_0,
                   (ErlangTuple [(ErlangAtom "map_key"), key_1])]
  =
  ErlangTuple [ErlangAtom "map_get", ann_0, key_1]
erlps__map_get__2 [ann_0,
                   (ErlangTuple [(ErlangAtom "map_key"), key_1, val_2])]
  =
  ErlangTuple [ErlangAtom "map_get", ann_0, key_1, val_2]
erlps__map_get__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__map_get__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__map_key__0 :: ErlangFun
erlps__map_key__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             erlps__map_key__2 [_1_3, _2_4]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_8 = erlps__expr__0 []
  in let
    tup_el_11 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "="]
  in let tup_el_13 = erlps__expr__0 []
  in let arg_10 = ErlangTuple [tup_el_11, tup_el_13]
  in let
    tup_el_9 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__optional__1"
        [arg_10]
  in let arg_7 = ErlangTuple [tup_el_8, tup_el_9]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_7]
erlps__map_key__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__map_key__2 :: ErlangFun
erlps__map_key__2 [key_0, (ErlangAtom "none")] =
  ErlangTuple [ErlangAtom "map_key", key_0]
erlps__map_key__2 [key_0,
                   (ErlangTuple [(ErlangAtom "ok"), (ErlangTuple [_, val_1])])]
  =
  ErlangTuple [ErlangAtom "map_key", key_0, val_1]
erlps__map_key__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__map_key__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__elim__2 :: ErlangFun
erlps__elim__2 [e_0, (ErlangEmptyList)] = e_0
erlps__elim__2 [e_0,
                (ErlangCons (ErlangTuple [(ErlangAtom "proj"), ann_1,
                                          p_2]) es_3)]
  =
  let arg_4 = ErlangTuple [ErlangAtom "proj", ann_1, e_0, p_2]
  in erlps__elim__2 [arg_4, es_3]
erlps__elim__2 [e_0,
                (ErlangCons (ErlangTuple [(ErlangAtom "app"), _ann_1,
                                          args_2]) es_3)]
  =
  let   
    tup_el_6 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [e_0]
  in let
    arg_4 = ErlangTuple [ErlangAtom "app", tup_el_6, e_0, args_2]
  in erlps__elim__2 [arg_4, es_3]
erlps__elim__2 [e_0,
                (ErlangCons (ErlangTuple [(ErlangAtom "rec_upd"), ann_1,
                                          flds_2]) es_3)]
  =
  let arg_4 = erlps__record_update__3 [ann_1, e_0, flds_2]
  in erlps__elim__2 [arg_4, es_3]
erlps__elim__2 [e_0,
                (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), ann_1,
                                          key_2]) es_3)]
  =
  let arg_4 = ErlangTuple [ErlangAtom "map_get", ann_1, e_0, key_2]
  in erlps__elim__2 [arg_4, es_3]
erlps__elim__2 [e_0,
                (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), ann_1, key_2,
                                          val_3]) es_4)]
  =
  let
    arg_5 =
      ErlangTuple [ErlangAtom "map_get", ann_1, e_0, key_2, val_3]
  in erlps__elim__2 [arg_5, es_4]
erlps__elim__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__elim__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__record_update__3 :: ErlangFun
erlps__record_update__3 [ann_0, e_1, flds_2] =
  let tup_el_3 = erlps__record_or_map__1 [flds_2]
  in ErlangTuple [tup_el_3, ann_0, e_1, flds_2]
erlps__record_update__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__record_update__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__record__1 :: ErlangFun
erlps__record__1 [(ErlangEmptyList)] =
  ErlangTuple [ErlangAtom "map", ErlangEmptyList, ErlangEmptyList]
erlps__record__1 [fs_0] =
  let case_1 = erlps__record_or_map__1 [fs_0]
  in
    case case_1 of
      (ErlangAtom "record") ->
        let   
          fld_26 =
            ErlangFun 1
              (let
                 lambda_3 [f_5@(ErlangTuple [(ErlangAtom "field"), _,
                                             (ErlangCons _ (ErlangEmptyList)),
                                             _])]
                   =
                   f_5
                 lambda_3 [(ErlangTuple [(ErlangAtom "field"), ann_6, lv_7,
                                         id_8, _])]
                   =
                   let   
                     arg_9 = toErl "Cannot use \'@\' in record construction"
                   in let
                     arg_11 = ErlangTuple [ErlangAtom "lvalue", ann_6, lv_7]
                   in let arg_15 = ErlangTuple [ErlangAtom "@", ann_6]
                   in let arg_10 = erlps__infix__3 [arg_11, arg_15, id_8]
                   in erlps__bad_expr_err__2 [arg_9, arg_10]
                 lambda_3 [(ErlangTuple [(ErlangAtom "field"), ann_19, lv_20,
                                         _])]
                   =
                   let   
                     arg_21 =
                       toErl
                         "Cannot use nested fields or keys in record construction"
                   in let
                     arg_22 = ErlangTuple [ErlangAtom "lvalue", ann_19, lv_20]
                   in erlps__bad_expr_err__2 [arg_21, arg_22]
                 lambda_3 [arg_4] = EXC.function_clause unit
                 lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
               in lambda_3)
        in let arg_29 = BIF.erlang__hd__1 [fs_0]
        in let tup_el_28 = erlps__get_ann__1 [arg_29]
        in let
          tup_el_31 =
            BIF.do_remote_fun_call "Lists" "erlps__map__2" [fld_26, fs_0]
        in ErlangTuple [ErlangAtom "record", tup_el_28, tup_el_31]
      (ErlangAtom "map") ->
        let   
          head_38 = ErlangTuple [ErlangAtom "empty", ErlangEmptyList]
        in let
          arg_35 =
            BIF.erlang__op_append [fs_0, ErlangCons head_38 ErlangEmptyList]
        in let arg_34 = BIF.erlang__hd__1 [arg_35]
        in let ann_42 = erlps__get_ann__1 [arg_34]
        in let
          kv_69 =
            ErlangFun 1
              (let
                 lambda_43 [(ErlangTuple [(ErlangAtom "field"), _,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    _,
                                                                    key_45]) (ErlangEmptyList)),
                                          val_46])]
                   =
                   ErlangTuple [key_45, val_46]
                 lambda_43 [(ErlangTuple [(ErlangAtom "field"), fann_49, lv_50,
                                          id_51, _])]
                   =
                   let    arg_52 = toErl "Cannot use \'@\' in map construction"
                   in let
                     arg_54 = ErlangTuple [ErlangAtom "lvalue", fann_49, lv_50]
                   in let arg_58 = ErlangTuple [ErlangAtom "@", ann_42]
                   in let arg_53 = erlps__infix__3 [arg_54, arg_58, id_51]
                   in erlps__bad_expr_err__2 [arg_52, arg_53]
                 lambda_43 [(ErlangTuple [(ErlangAtom "field"), fann_62, lv_63,
                                          _])]
                   =
                   let   
                     arg_64 =
                       toErl
                         "Cannot use nested fields or keys in map construction"
                   in let
                     arg_65 = ErlangTuple [ErlangAtom "lvalue", fann_62, lv_63]
                   in erlps__bad_expr_err__2 [arg_64, arg_65]
                 lambda_43 [arg_44] = EXC.function_clause unit
                 lambda_43 args = EXC.badarity (ErlangFun 1 lambda_43) args
               in lambda_43)
        in let
          tup_el_72 =
            BIF.do_remote_fun_call "Lists" "erlps__map__2" [kv_69, fs_0]
        in ErlangTuple [ErlangAtom "map", ann_42, tup_el_72]
      (ErlangAtom "record_or_map_error") ->
        let    arg_77 = BIF.erlang__hd__1 [fs_0]
        in let tup_el_76 = erlps__get_ann__1 [arg_77]
        in
          ErlangTuple [ErlangAtom "record_or_map_error", tup_el_76, fs_0]
      something_else -> EXC.case_clause something_else
erlps__record__1 [arg_80] = EXC.function_clause unit
erlps__record__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__record_or_map__1 :: ErlangFun
erlps__record_or_map__1 [fields_0] =
  let   
    kind_7 =
      ErlangFun 1
        (let
           lambda_1 [fld_3] =
             let    arg_5 = toErl 3
             in let case_4 = BIF.erlang__element__2 [arg_5, fld_3]
             in
               case case_4 of
                 (ErlangCons (ErlangTuple [(ErlangAtom "proj"), _, _]) _) ->
                   ErlangAtom "proj"
                 (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), _, _]) _) ->
                   ErlangAtom "map_get"
                 (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), _, _,
                                           _]) _) ->
                   ErlangAtom "map_get"
                 something_else -> EXC.case_clause something_else
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let
    arg_9 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [kind_7, fields_0]
  in let
    case_8 = BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_9]
  in
    case case_8 of
      (ErlangCons (ErlangAtom "proj") (ErlangEmptyList)) ->
        ErlangAtom "record"
      (ErlangCons (ErlangAtom "map_get") (ErlangEmptyList)) ->
        ErlangAtom "map"
      _ -> ErlangAtom "record_or_map_error"
erlps__record_or_map__1 [arg_12] = EXC.function_clause unit
erlps__record_or_map__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__field_assignment__0 :: ErlangFun
erlps__field_assignment__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4, _3_5, _4_6])] =
             let arg_7 = erlps__get_ann__1 [_3_5]
             in erlps__field_assignment__4 [arg_7, _1_3, _2_4, _4_6]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_13 = erlps__lvalue__0 []
  in let
    tup_el_16 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "@"]
  in let tup_el_18 = erlps__id__0 []
  in let arg_15 = ErlangTuple [tup_el_16, tup_el_18]
  in let
    tup_el_14 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__optional__1"
        [arg_15]
  in let
    tup_el_19 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "="]
  in let tup_el_21 = erlps__expr__0 []
  in let
    arg_12 = ErlangTuple [tup_el_13, tup_el_14, tup_el_19, tup_el_21]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_12]
erlps__field_assignment__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__field_assignment__4 :: ErlangFun
erlps__field_assignment__4 [ann_0, lv_1, (ErlangAtom "none"),
                            e_2]
  =
  ErlangTuple [ErlangAtom "field", ann_0, lv_1, e_2]
erlps__field_assignment__4 [ann_0, lv_1,
                            (ErlangTuple [(ErlangAtom "ok"),
                                          (ErlangTuple [_, id_2])]),
                            e_3]
  =
  ErlangTuple [ErlangAtom "field", ann_0, lv_1, id_2, e_3]
erlps__field_assignment__4 [arg_9, arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__field_assignment__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lvalue__0 :: ErlangFun
erlps__lvalue__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [(ErlangTuple [_1_3, _2_4])] =
             let arg_5 = erlps__elim__2 [_1_3, _2_4]
             in erlps__lvalue__1 [arg_5]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let tup_el_9 = erlps__lvalueAtom__0 []
  in let arg_11 = erlps__elim__0 []
  in let
    tup_el_10 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__many__1" [arg_11]
  in let arg_8 = ErlangTuple [tup_el_9, tup_el_10]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_8]
erlps__lvalue__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lvalueAtom__0 :: ErlangFun
erlps__lvalueAtom__0 [] =
  let
    arg_0 =
      ErlangFun 0
        (let
           lambda_1 [] =
             let    head_3 = erlps__id__0 []
             in let
               arg_6 =
                 ErlangFun 1
                   (let
                      lambda_7 [(ErlangTuple [_1_9, _2_10, _3_11])] = _2_10
                      lambda_7 [arg_8] = EXC.function_clause unit
                      lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
                    in lambda_7)
             in let tup_el_13 = erlps__keyword__1 [ErlangAtom "["]
             in let tup_el_15 = erlps__map_key__0 []
             in let tup_el_16 = erlps__keyword__1 [ErlangAtom "]"]
             in let arg_12 = ErlangTuple [tup_el_13, tup_el_15, tup_el_16]
             in let
               head_5 =
                 BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
                   [arg_6, arg_12]
             in
               BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
                 [ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)]
           lambda_1 [] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 0 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__lazy__1" [arg_0]
erlps__lvalueAtom__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lvalue__1 :: ErlangFun
erlps__lvalue__1 [e_0] = erlps__lvalue__2 [e_0, ErlangEmptyList]
erlps__lvalue__1 [arg_3] = EXC.function_clause unit
erlps__lvalue__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__lvalue__2 :: ErlangFun
erlps__lvalue__2 [x_1@(ErlangTuple [(ErlangAtom "id"), ann_0,
                                    _]),
                  lv_2]
  =
  let head_3 = ErlangTuple [ErlangAtom "proj", ann_0, x_1]
  in ErlangCons head_3 lv_2
erlps__lvalue__2 [(ErlangTuple [(ErlangAtom "map_key"), k_0]),
                  lv_1]
  =
  let    tup_el_4 = erlps__get_ann__1 [k_0]
  in let head_2 = ErlangTuple [ErlangAtom "map_get", tup_el_4, k_0]
  in ErlangCons head_2 lv_1
erlps__lvalue__2 [(ErlangTuple [(ErlangAtom "map_key"), k_0,
                                v_1]),
                  lv_2]
  =
  let    tup_el_5 = erlps__get_ann__1 [k_0]
  in let
    head_3 = ErlangTuple [ErlangAtom "map_get", tup_el_5, k_0, v_1]
  in ErlangCons head_3 lv_2
erlps__lvalue__2 [(ErlangTuple [(ErlangAtom "proj"), ann_0, e_1,
                                p_2]),
                  lv_3]
  =
  let head_6 = ErlangTuple [ErlangAtom "proj", ann_0, p_2]
  in erlps__lvalue__2 [e_1, ErlangCons head_6 lv_3]
erlps__lvalue__2 [(ErlangTuple [(ErlangAtom "map_get"), ann_0,
                                e_1, k_2]),
                  lv_3]
  =
  let head_6 = ErlangTuple [ErlangAtom "map_get", ann_0, k_2]
  in erlps__lvalue__2 [e_1, ErlangCons head_6 lv_3]
erlps__lvalue__2 [(ErlangTuple [(ErlangAtom "map_get"), ann_0,
                                e_1, k_2, v_3]),
                  lv_4]
  =
  let head_7 = ErlangTuple [ErlangAtom "map_get", ann_0, k_2, v_3]
  in erlps__lvalue__2 [e_1, ErlangCons head_7 lv_4]
erlps__lvalue__2 [e_0, _] =
  let arg_1 = toErl "Not a valid lvalue"
  in erlps__bad_expr_err__2 [arg_1, e_0]
erlps__lvalue__2 [arg_3, arg_4] = EXC.function_clause unit
erlps__lvalue__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__infix__2 :: ErlangFun
erlps__infix__2 [e_0, op_1] =
  let   
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [_1_5, _2_6])] =
             case _2_6 of
               (ErlangAtom "none") -> _1_5
               (ErlangTuple [(ErlangAtom "ok"), (ErlangTuple [f_8, arg_9])]) ->
                 BIF.erlang__apply__2
                   [f_8, ErlangCons _1_5 (ErlangCons arg_9 ErlangEmptyList)]
               something_else -> EXC.case_clause something_else
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let arg_16 = ErlangTuple [op_1, e_0]
  in let
    tup_el_15 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__optional__1"
        [arg_16]
  in let arg_13 = ErlangTuple [e_0, tup_el_15]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_2, arg_13]
erlps__infix__2 [arg_19, arg_20] = EXC.function_clause unit
erlps__infix__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__binop__1 :: ErlangFun
erlps__binop__1 [op_0] | isEAtom op_0 =
  erlps__binop__1 [ErlangCons op_0 ErlangEmptyList]
erlps__binop__1 [ops_0] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [_1_4] =
             ErlangFun 2
               (let
                  lambda_5 [a_8, b_9] = erlps__infix__3 [a_8, _1_4, b_9]
                  lambda_5 [arg_6, arg_7] = EXC.function_clause unit
                  lambda_5 args = EXC.badarity (ErlangFun 2 lambda_5) args
                in lambda_5)
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    arg_14 =
      flmap
        (\ lc_17 ->
           let lcRet_18 = erlps__token__1 [lc_17]
           in ErlangCons lcRet_18 ErlangEmptyList)
        ops_0
  in let
    arg_13 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__1"
        [arg_14]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_1, arg_13]
erlps__binop__1 [arg_20] = EXC.function_clause unit
erlps__binop__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__con__0 :: ErlangFun
erlps__con__0 [] = erlps__token__1 [ErlangAtom "con"]
erlps__con__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__id__0 :: ErlangFun
erlps__id__0 [] = erlps__token__1 [ErlangAtom "id"]
erlps__id__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tvar__0 :: ErlangFun
erlps__tvar__0 [] = erlps__token__1 [ErlangAtom "tvar"]
erlps__tvar__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__str__0 :: ErlangFun
erlps__str__0 [] = erlps__token__1 [ErlangAtom "string"]
erlps__str__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__token__1 :: ErlangFun
erlps__token__1 [tag_0] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [_1_4] =
             case _1_4 of
               (ErlangTuple [tok_6, (ErlangTuple [line_7, col_8])]) ->
                 let tup_el_10 = erlps__pos_ann__2 [line_7, col_8]
                 in ErlangTuple [tok_6, tup_el_10]
               (ErlangTuple [tok_13, (ErlangTuple [line_14, col_15]),
                             val_16]) ->
                 let tup_el_18 = erlps__pos_ann__2 [line_14, col_15]
                 in ErlangTuple [tok_13, tup_el_18, val_16]
               something_else -> EXC.case_clause something_else
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    arg_22 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1" [tag_0]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_1, arg_22]
erlps__token__1 [arg_24] = EXC.function_clause unit
erlps__token__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__id__1 :: ErlangFun
erlps__id__1 [id_0] =
  let    arg_1 = erlps__id__0 []
  in let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [y_7@(ErlangTuple [(ErlangAtom "id"), a_5, x_6])] =
             case ErlangAtom "true" of
               _ | weakEq x_6 id_0 -> y_7
               _ ->
                 let    lop_11 = toErl "expected \'"
                 in let rop_14 = toErl "\'"
                 in let rop_12 = BIF.erlang__op_append [id_0, rop_14]
                 in let tup_el_10 = BIF.erlang__op_append [lop_11, rop_12]
                 in let arg_8 = ErlangTuple [a_5, tup_el_10]
                 in
                   BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__fail__1"
                     [arg_8]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__bind__2"
      [arg_1, arg_2]
erlps__id__1 [arg_15] = EXC.function_clause unit
erlps__id__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__id_or_addr__0 :: ErlangFun
erlps__id_or_addr__0 [] =
  let   
    arg_0 =
      ErlangFun 1
        (let
           lambda_1 [_1_3] = erlps__parse_addr_literal__1 [_1_3]
           lambda_1 [arg_2] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 1 lambda_1) args
         in lambda_1)
  in let arg_5 = erlps__id__0 []
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_0, arg_5]
erlps__id_or_addr__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_addr_literal__1 :: ErlangFun
erlps__parse_addr_literal__1 [id_2@(ErlangTuple [(ErlangAtom "id"),
                                                 ann_0, name_1])]
  =
  let    arg_6 = toErl 3
  in let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__sublist__2"
        [name_1, arg_6]
  in let head_8 = toErl "ak_"
  in let head_10 = toErl "ok_"
  in let head_12 = toErl "oq_"
  in let head_14 = toErl "ct_"
  in let
    case_3 =
      BIF.lists__member__2
        [arg_4,
         ErlangCons head_8
           (ErlangCons head_10
              (ErlangCons head_12 (ErlangCons head_14 ErlangEmptyList)))]
  in
    case case_3 of
      (ErlangAtom "false") -> id_2
      (ErlangAtom "true") ->
        EXC.tryOfCatch
          (\ _ ->
             let arg_16 = BIF.erlang__list_to_binary__1 [name_1]
             in
               BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__decode__1"
                 [arg_16])
          (\ of_18 ->
             case of_18 of
               (ErlangTuple [type_21, bin_22]) ->
                 ErlangTuple [type_21, ann_0, bin_22]
               something_else -> EXC.try_clause something_else)
          (\ ex_19 ->
             case ex_19 of
               (ErlangTuple [_, _, _]) -> id_2
               ex_20 -> EXC.raise ex_20)
      something_else -> EXC.case_clause something_else
erlps__parse_addr_literal__1 [arg_26] = EXC.function_clause unit
erlps__parse_addr_literal__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__keyword__1 :: ErlangFun
erlps__keyword__1 [k_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1" [k_0]
  in erlps__ann__1 [arg_1]
erlps__keyword__1 [arg_3] = EXC.function_clause unit
erlps__keyword__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__ann__1 :: ErlangFun
erlps__ann__1 [p_0] =
  let arg_1 = ErlangFun 1 erlps__get_ann__1
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__map__2"
      [arg_1, p_0]
erlps__ann__1 [arg_3] = EXC.function_clause unit
erlps__ann__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__block__1 :: ErlangFun
erlps__block__1 [p_0] =
  let   
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__layout__0" []
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "vsemi"]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__sep1__2"
        [p_0, arg_4]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "vclose"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__between__3"
      [arg_1, arg_2, arg_6]
erlps__block__1 [arg_8] = EXC.function_clause unit
erlps__block__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__maybe_block__1 :: ErlangFun
erlps__maybe_block__1 [p_0] =
  let arg_1 = erlps__block__1 [p_0]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__choice__2"
      [arg_1, ErlangCons p_0 ErlangEmptyList]
erlps__maybe_block__1 [arg_6] = EXC.function_clause unit
erlps__maybe_block__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parens__1 :: ErlangFun
erlps__parens__1 [p_0] =
  let   
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "("]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ")"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__between__3"
      [arg_1, p_0, arg_4]
erlps__parens__1 [arg_6] = EXC.function_clause unit
erlps__parens__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__braces__1 :: ErlangFun
erlps__braces__1 [p_0] =
  let   
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "{"]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "}"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__between__3"
      [arg_1, p_0, arg_4]
erlps__braces__1 [arg_6] = EXC.function_clause unit
erlps__braces__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__brackets__1 :: ErlangFun
erlps__brackets__1 [p_0] =
  let   
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "["]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom "]"]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__between__3"
      [arg_1, p_0, arg_4]
erlps__brackets__1 [arg_6] = EXC.function_clause unit
erlps__brackets__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__comma_sep__1 :: ErlangFun
erlps__comma_sep__1 [p_0] =
  let
    arg_2 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__tok__1"
        [ErlangAtom ","]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__sep__2"
      [p_0, arg_2]
erlps__comma_sep__1 [arg_4] = EXC.function_clause unit
erlps__comma_sep__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__paren_list__1 :: ErlangFun
erlps__paren_list__1 [p_0] =
  let arg_1 = erlps__comma_sep__1 [p_0]
  in erlps__parens__1 [arg_1]
erlps__paren_list__1 [arg_3] = EXC.function_clause unit
erlps__paren_list__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__brace_list__1 :: ErlangFun
erlps__brace_list__1 [p_0] =
  let arg_1 = erlps__comma_sep__1 [p_0]
  in erlps__braces__1 [arg_1]
erlps__brace_list__1 [arg_3] = EXC.function_clause unit
erlps__brace_list__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__bracket_list__1 :: ErlangFun
erlps__bracket_list__1 [p_0] =
  let arg_1 = erlps__comma_sep__1 [p_0]
  in erlps__brackets__1 [arg_1]
erlps__bracket_list__1 [arg_3] = EXC.function_clause unit
erlps__bracket_list__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__pos_ann__2 :: ErlangFun
erlps__pos_ann__2 [line_0, col_1] =
  let   
    tup_el_4 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__current_file__0"
        []
  in let head_2 = ErlangTuple [ErlangAtom "file", tup_el_4]
  in let head_6 = ErlangTuple [ErlangAtom "line", line_0]
  in let head_10 = ErlangTuple [ErlangAtom "col", col_1]
  in
    ErlangCons head_2
      (ErlangCons head_6 (ErlangCons head_10 ErlangEmptyList))
erlps__pos_ann__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__pos_ann__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__ann_pos__1 :: ErlangFun
erlps__ann_pos__1 [ann_0] =
  let   
    tup_el_1 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [ErlangAtom "file", ann_0]
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [ErlangAtom "line", ann_0]
  in let
    tup_el_7 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [ErlangAtom "col", ann_0]
  in ErlangTuple [tup_el_1, tup_el_4, tup_el_7]
erlps__ann_pos__1 [arg_10] = EXC.function_clause unit
erlps__ann_pos__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_ann__1 :: ErlangFun
erlps__get_ann__1 [ann_0] | isEList ann_0 = ann_0
erlps__get_ann__1 [node_0] =
  let    arg_2 = toErl 2
  in let case_1 = BIF.erlang__element__2 [arg_2, node_0]
  in
    case case_1 of
      (ErlangTuple [line_4, col_5]) | ((isEInt line_4) &&
                                         (isEInt col_5)) ->
        erlps__pos_ann__2 [line_4, col_5]
      ann_8 -> ann_8
erlps__get_ann__1 [arg_9] = EXC.function_clause unit
erlps__get_ann__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_ann__2 :: ErlangFun
erlps__get_ann__2 [key_0, node_1] =
  let arg_3 = erlps__get_ann__1 [node_1]
  in
    BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
      [key_0, arg_3]
erlps__get_ann__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__get_ann__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__set_ann__3 :: ErlangFun
erlps__set_ann__3 [key_0, val_1, node_2] =
  let    ann_4 = erlps__get_ann__1 [node_2]
  in let arg_5 = toErl 2
  in let arg_9 = toErl 1
  in let arg_11 = ErlangTuple [key_0, val_1]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Lists" "erlps__keystore__4"
        [key_0, arg_9, ann_4, arg_11]
  in BIF.erlang__setelement__3 [arg_5, node_2, arg_7]
erlps__set_ann__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__set_ann__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_pos__1 :: ErlangFun
erlps__get_pos__1 [node_0] =
  let   
    tup_el_1 =
      BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__current_file__0"
        []
  in let tup_el_2 = erlps__get_ann__2 [ErlangAtom "line", node_0]
  in let tup_el_5 = erlps__get_ann__2 [ErlangAtom "col", node_0]
  in ErlangTuple [tup_el_1, tup_el_2, tup_el_5]
erlps__get_pos__1 [arg_8] = EXC.function_clause unit
erlps__get_pos__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__set_pos__2 :: ErlangFun
erlps__set_pos__2 [(ErlangTuple [f_0, l_1, c_2]), node_3] =
  let    arg_9 = erlps__set_ann__3 [ErlangAtom "col", c_2, node_3]
  in let arg_6 = erlps__set_ann__3 [ErlangAtom "line", l_1, arg_9]
  in erlps__set_ann__3 [ErlangAtom "file", f_0, arg_6]
erlps__set_pos__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__set_pos__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__infix__3 :: ErlangFun
erlps__infix__3 [l_0, op_1, r_2] =
  let    tup_el_7 = erlps__get_ann__1 [l_0]
  in let
    arg_5 =
      ErlangTuple
        [ErlangAtom "app", tup_el_7, op_1,
         ErlangCons l_0 (ErlangCons r_2 ErlangEmptyList)]
  in
    erlps__set_ann__3
      [ErlangAtom "format", ErlangAtom "infix", arg_5]
erlps__infix__3 [arg_15, arg_16, arg_17] =
  EXC.function_clause unit
erlps__infix__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__prefixes__2 :: ErlangFun
erlps__prefixes__2 [ops_0, e_1] =
  let arg_2 = ErlangFun 2 erlps__prefix__2
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_2, e_1, ops_0]
erlps__prefixes__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__prefixes__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__prefix__2 :: ErlangFun
erlps__prefix__2 [op_0, e_1] =
  let    tup_el_6 = erlps__get_ann__1 [op_0]
  in let
    arg_4 =
      ErlangTuple
        [ErlangAtom "app", tup_el_6, op_0,
         ErlangCons e_1 ErlangEmptyList]
  in
    erlps__set_ann__3
      [ErlangAtom "format", ErlangAtom "prefix", arg_4]
erlps__prefix__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__prefix__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__type_wildcard__1 :: ErlangFun
erlps__type_wildcard__1 [ann_0] =
  let   
    head_3 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let tup_el_7 = toErl "_"
  in
    ErlangTuple [ErlangAtom "id", ErlangCons head_3 ann_0, tup_el_7]
erlps__type_wildcard__1 [arg_8] = EXC.function_clause unit
erlps__type_wildcard__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__block_e__1 :: ErlangFun
erlps__block_e__1 [stmts_0] =
  erlps__group_ifs__2 [stmts_0, ErlangEmptyList]
erlps__block_e__1 [arg_3] = EXC.function_clause unit
erlps__block_e__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__group_ifs__2 :: ErlangFun
erlps__group_ifs__2 [(ErlangEmptyList),
                     (ErlangCons stmt_0 (ErlangEmptyList))]
  =
  BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__return__1"
    [stmt_0]
erlps__group_ifs__2 [(ErlangEmptyList), acc_0] =
  let
    matchExpr_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_0]
  in
    case matchExpr_3 of
      (ErlangCons stmt_2 _) ->
        let tup_el_6 = erlps__get_ann__1 [stmt_2]
        in ErlangTuple [ErlangAtom "block", tup_el_6, matchExpr_3]
      _ -> EXC.badmatch matchExpr_3
erlps__group_ifs__2 [(ErlangCons (ErlangTuple [(ErlangAtom "if"),
                                               ann_0, cond_1, then_2]) stmts_3),
                     acc_4]
  =
  let
    matchExpr_9 = erlps__else_branches__2 [stmts_3, ErlangEmptyList]
  in
    case matchExpr_9 of
      (ErlangTuple [elses_7, rest_8]) ->
        let head_12 = erlps__build_if__4 [ann_0, cond_1, then_2, elses_7]
        in erlps__group_ifs__2 [rest_8, ErlangCons head_12 acc_4]
      _ -> EXC.badmatch matchExpr_9
erlps__group_ifs__2 [(ErlangCons (ErlangTuple [(ErlangAtom "else"),
                                               ann_0, _]) _),
                     _]
  =
  let    tup_el_3 = toErl "No matching \'if\' for \'else\'"
  in let arg_1 = ErlangTuple [ann_0, tup_el_3]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__fail__1" [arg_1]
erlps__group_ifs__2 [(ErlangCons (ErlangTuple [(ErlangAtom "elif"),
                                               ann_0, _, _]) _),
                     _]
  =
  let    tup_el_3 = toErl "No matching \'if\' for \'elif\'"
  in let arg_1 = ErlangTuple [ann_0, tup_el_3]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__fail__1" [arg_1]
erlps__group_ifs__2 [(ErlangCons stmt_0 stmts_1), acc_2] =
  erlps__group_ifs__2 [stmts_1, ErlangCons stmt_0 acc_2]
erlps__group_ifs__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__group_ifs__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__build_if__4 :: ErlangFun
erlps__build_if__4 [ann_0, cond_1, then_2,
                    (ErlangCons (ErlangTuple [(ErlangAtom "elif"), ann1_3,
                                              cond1_4, then1_5]) elses_6)]
  =
  let   
    arg_14 = erlps__build_if__4 [ann1_3, cond1_4, then1_5, elses_6]
  in let
    tup_el_11 =
      erlps__set_ann__3
        [ErlangAtom "format", ErlangAtom "elif", arg_14]
  in
    ErlangTuple [ErlangAtom "if", ann_0, cond_1, then_2, tup_el_11]
erlps__build_if__4 [ann_0, cond_1, then_2,
                    (ErlangCons (ErlangTuple [(ErlangAtom "else"), _ann_3,
                                              else_4]) (ErlangEmptyList))]
  =
  ErlangTuple [ErlangAtom "if", ann_0, cond_1, then_2, else_4]
erlps__build_if__4 [ann_0, cond_1, then_2, (ErlangEmptyList)] =
  let   
    head_10 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    tup_el_7 =
      ErlangTuple
        [ErlangAtom "tuple", ErlangCons head_10 ErlangEmptyList,
         ErlangEmptyList]
  in ErlangTuple [ErlangAtom "if", ann_0, cond_1, then_2, tup_el_7]
erlps__build_if__4 [arg_15, arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__build_if__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__else_branches__2 :: ErlangFun
erlps__else_branches__2 [(ErlangCons elif_0@(ErlangTuple [(ErlangAtom "elif"),
                                                          _, _, _]) stmts_1),
                         acc_2]
  =
  erlps__else_branches__2 [stmts_1, ErlangCons elif_0 acc_2]
erlps__else_branches__2 [(ErlangCons else_0@(ErlangTuple [(ErlangAtom "else"),
                                                          _, _]) stmts_1),
                         acc_2]
  =
  let
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
        [ErlangCons else_0 acc_2]
  in ErlangTuple [tup_el_3, stmts_1]
erlps__else_branches__2 [stmts_0, acc_1] =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in ErlangTuple [tup_el_2, stmts_0]
erlps__else_branches__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__else_branches__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tuple_t__2 :: ErlangFun
erlps__tuple_t__2 [_ann_0, (ErlangCons type_1 (ErlangEmptyList))]
  =
  type_1
erlps__tuple_t__2 [ann_0, types_1] =
  ErlangTuple [ErlangAtom "tuple_t", ann_0, types_1]
erlps__tuple_t__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__tuple_t__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__fun_t__2 :: ErlangFun
erlps__fun_t__2 [domains_0, type_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [(ErlangTuple [(ErlangTuple [(ErlangAtom "args_t"), _,
                                                 dom_6]),
                                   ann_7]),
                     t_8]
             =
             ErlangTuple
               [ErlangAtom "fun_t", ann_7, ErlangEmptyList, dom_6, t_8]
           lambda_3 [(ErlangTuple [dom_14, ann_15]), t_16] =
             ErlangTuple
               [ErlangAtom "fun_t", ann_15, ErlangEmptyList,
                ErlangCons dom_14 ErlangEmptyList, t_16]
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
      [arg_2, type_1, domains_0]
erlps__fun_t__2 [arg_26, arg_27] = EXC.function_clause unit
erlps__fun_t__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__tuple_e__2 :: ErlangFun
erlps__tuple_e__2 [_ann_0, (ErlangCons expr_1 (ErlangEmptyList))]
  =
  expr_1
erlps__tuple_e__2 [ann_0, exprs_1] =
  ErlangTuple [ErlangAtom "tuple", ann_0, exprs_1]
erlps__tuple_e__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__tuple_e__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__list_comp_e__3 :: ErlangFun
erlps__list_comp_e__3 [ann_0, expr_1, binds_2] =
  ErlangTuple [ErlangAtom "list_comp", ann_0, expr_1, binds_2]
erlps__list_comp_e__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__list_comp_e__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_pattern__1 :: ErlangFun
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "app"), ann_0,
                                       con_1@(ErlangTuple [(ErlangAtom "::"),
                                                           _]),
                                       es_2])]
  =
  let    arg_7 = ErlangFun 1 erlps__parse_pattern__1
  in let
    tup_el_6 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_7, es_2]
  in ErlangTuple [ErlangAtom "app", ann_0, con_1, tup_el_6]
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "app"), ann_0,
                                       (ErlangTuple [(ErlangAtom "-"), _]),
                                       (ErlangCons (ErlangTuple [(ErlangAtom "int"),
                                                                 _,
                                                                 n_1]) (ErlangEmptyList))])]
  =
  let tup_el_4 = BIF.erlang__op_neg [n_1]
  in ErlangTuple [ErlangAtom "int", ann_0, tup_el_4]
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "app"), ann_0,
                                       con_2@(ErlangTuple [tag_1, _, _]),
                                       es_3])]
  | ((ErlangAtom "true") ==
       (falsifyErrors
          (\ _ ->
             let lop_10 = BIF.erlang__op_eq [tag_1, ErlangAtom "con"]
             in
               case lop_10 of
                 (ErlangAtom "true") -> ErlangAtom "true"
                 (ErlangAtom "false") ->
                   BIF.erlang__op_eq [tag_1, ErlangAtom "qcon"]
                 _ -> EXC.badarg1 lop_10))) =
  let    arg_8 = ErlangFun 1 erlps__parse_pattern__1
  in let
    tup_el_7 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_8, es_3]
  in ErlangTuple [ErlangAtom "app", ann_0, con_2, tup_el_7]
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "tuple"),
                                       ann_0, es_1])]
  =
  let    arg_5 = ErlangFun 1 erlps__parse_pattern__1
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_5, es_1]
  in ErlangTuple [ErlangAtom "tuple", ann_0, tup_el_4]
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "list"),
                                       ann_0, es_1])]
  =
  let    arg_5 = ErlangFun 1 erlps__parse_pattern__1
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_5, es_1]
  in ErlangTuple [ErlangAtom "list", ann_0, tup_el_4]
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "record"),
                                       ann_0, fs_1])]
  =
  let    arg_5 = ErlangFun 1 erlps__parse_field_pattern__1
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_5, fs_1]
  in ErlangTuple [ErlangAtom "record", ann_0, tup_el_4]
erlps__parse_pattern__1 [(ErlangTuple [(ErlangAtom "typed"),
                                       ann_0, e_1, type_2])]
  =
  let tup_el_5 = erlps__parse_pattern__1 [e_1]
  in ErlangTuple [ErlangAtom "typed", ann_0, tup_el_5, type_2]
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "con"), _,
                                           _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "qcon"),
                                           _, _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "id"), _,
                                           _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "int"), _,
                                           _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "bool"),
                                           _, _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "bytes"),
                                           _, _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "string"),
                                           _, _])]
  =
  e_0
erlps__parse_pattern__1 [e_0@(ErlangTuple [(ErlangAtom "char"),
                                           _, _])]
  =
  e_0
erlps__parse_pattern__1 [e_0] =
  let arg_1 = toErl "Not a valid pattern"
  in erlps__bad_expr_err__2 [arg_1, e_0]
erlps__parse_pattern__1 [arg_3] = EXC.function_clause unit
erlps__parse_pattern__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__parse_field_pattern__1 :: ErlangFun
erlps__parse_field_pattern__1 [(ErlangTuple [(ErlangAtom "field"),
                                             ann_0, f_1, e_2])]
  =
  let tup_el_6 = erlps__parse_pattern__1 [e_2]
  in ErlangTuple [ErlangAtom "field", ann_0, f_1, tup_el_6]
erlps__parse_field_pattern__1 [arg_8] = EXC.function_clause unit
erlps__parse_field_pattern__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__ret_doc_err__2 :: ErlangFun
erlps__ret_doc_err__2 [ann_0, doc_1] =
  let    arg_2 = erlps__ann_pos__1 [ann_0]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [doc_1]
  in
    BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__fail__2"
      [arg_2, arg_4]
erlps__ret_doc_err__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__ret_doc_err__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__bad_expr_err__2 :: ErlangFun
erlps__bad_expr_err__2 [reason_0, e_1] =
  let    arg_2 = erlps__get_ann__1 [e_1]
  in let rop_9 = toErl ":"
  in let arg_7 = BIF.erlang__op_append [reason_0, rop_9]
  in let
    head_6 =
      BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [arg_7]
  in let arg_12 = toErl 2
  in let
    arg_13 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__expr__1" [e_1]
  in let
    head_11 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_12, arg_13]
  in let
    arg_4 =
      BIF.do_remote_fun_call "Prettypr" "erlps__sep__1"
        [ErlangCons head_6 (ErlangCons head_11 ErlangEmptyList)]
  in erlps__ret_doc_err__2 [arg_2, arg_4]
erlps__bad_expr_err__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__bad_expr_err__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expand_includes__3 :: ErlangFun
erlps__expand_includes__3 [ast_0, included_1, opts_2] =
  let   
    head_3 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let arg_10 = erlps__auto_imports__1 [ast_0]
  in let
    lcSrc_9 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_10]
  in let
    lop_8 =
      flmap
        (\ lc_13 ->
           let   
             tup_el_17 =
               ErlangTuple
                 [ErlangAtom "string", ErlangCons head_3 ErlangEmptyList, lc_13]
           in let
             lcRet_14 =
               ErlangTuple
                 [ErlangAtom "include", ErlangCons head_3 ErlangEmptyList,
                  tup_el_17]
           in ErlangCons lcRet_14 ErlangEmptyList)
        lcSrc_9
  in let ast1_22 = BIF.erlang__op_append [lop_8, ast_0]
  in
    erlps__expand_includes__4
      [ast1_22, included_1, ErlangEmptyList, opts_2]
erlps__expand_includes__3 [arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__expand_includes__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__expand_includes__4 :: ErlangFun
erlps__expand_includes__4 [(ErlangEmptyList), included_0, acc_1,
                           opts_2]
  =
  let
    case_3 =
      BIF.lists__member__2 [ErlangAtom "keep_included", opts_2]
  in
    case case_3 of
      (ErlangAtom "false") ->
        let
          tup_el_7 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
        in ErlangTuple [ErlangAtom "ok", tup_el_7]
      (ErlangAtom "true") ->
        let   
          tup_el_11 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
        in let tup_el_10 = ErlangTuple [tup_el_11, included_0]
        in ErlangTuple [ErlangAtom "ok", tup_el_10]
      something_else -> EXC.case_clause something_else
erlps__expand_includes__4 [(ErlangCons (ErlangTuple [(ErlangAtom "include"),
                                                     ann_0,
                                                     (ErlangTuple [(ErlangAtom "string"),
                                                                   _sann_1,
                                                                   file_2])]) ast_3),
                           included_4, acc_5, opts_6]
  =
  let case_7 = erlps__get_include_code__3 [file_2, ann_0, opts_6]
  in
    case case_7 of
      (ErlangTuple [(ErlangAtom "ok"), code_11]) ->
        let    hashed_14 = erlps__hash_include__2 [file_2, code_11]
        in let
          case_15 =
            BIF.do_remote_fun_call "Sets" "erlps__is_element__2"
              [hashed_14, included_4]
        in
          case case_15 of
            (ErlangAtom "false") ->
              let    arg_19 = toErl 1
              in let arg_21 = ErlangTuple [ErlangAtom "src_file", file_2]
              in let
                opts1_24 =
                  BIF.do_remote_fun_call "Lists" "erlps__keystore__4"
                    [ErlangAtom "src_file", arg_19, opts_6, arg_21]
              in let
                included1_27 =
                  BIF.do_remote_fun_call "Sets" "erlps__add_element__2"
                    [hashed_14, included_4]
              in let arg_29 = erlps__file__0 []
              in let
                case_28 = erlps__parse_and_scan__3 [arg_29, code_11, opts1_24]
              in
                case case_28 of
                  (ErlangTuple [(ErlangAtom "ok"), ast1_32]) ->
                    let arg_33 = BIF.erlang__op_append [ast1_32, ast_3]
                    in
                      erlps__expand_includes__4
                        [arg_33, included1_27, acc_5, opts_6]
                  err_39@(ErlangTuple [(ErlangAtom "error"), _]) -> err_39
                  something_else -> EXC.case_clause something_else
            (ErlangAtom "true") ->
              erlps__expand_includes__4 [ast_3, included_4, acc_5, opts_6]
            something_else -> EXC.case_clause something_else
      err_44@(ErlangTuple [(ErlangAtom "error"), _]) -> err_44
      something_else -> EXC.case_clause something_else
erlps__expand_includes__4 [(ErlangCons e_0 ast_1), included_2,
                           acc_3, opts_4]
  =
  erlps__expand_includes__4
    [ast_1, included_2, ErlangCons e_0 acc_3, opts_4]
erlps__expand_includes__4 [arg_11, arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__expand_includes__4 args =
  EXC.badarity (ErlangFun 4 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__read_file__2 :: ErlangFun
erlps__read_file__2 [file_0, opts_1] =
  let    tup_el_7 = ErlangMap Map.empty
  in let
    arg_5 = ErlangTuple [ErlangAtom "explicit_files", tup_el_7]
  in let
    case_2 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "include", opts_1, arg_5]
  in
    case case_2 of
      (ErlangTuple [(ErlangAtom "file_system"), paths_8]) ->
        let   
          candidatenames_15 =
            flmap
              (\ lc_11 ->
                 let
                   lcRet_12 =
                     BIF.do_remote_fun_call "Filename" "erlps__join__2"
                       [lc_11, file_0]
                 in ErlangCons lcRet_12 ErlangEmptyList)
              paths_8
        in let
          arg_16 =
            ErlangFun 2
              (let
                 lambda_17 [f_20, (ErlangTuple [(ErlangAtom "error"), _])] =
                   BIF.do_remote_fun_call "File" "erlps__read_file__1" [f_20]
                 lambda_17 [_f_22, ok_23] = ok_23
                 lambda_17 [arg_18, arg_19] = EXC.function_clause unit
                 lambda_17 args = EXC.badarity (ErlangFun 2 lambda_17) args
               in lambda_17)
        in let
          arg_24 = ErlangTuple [ErlangAtom "error", ErlangAtom "not_found"]
        in
          BIF.do_remote_fun_call "Lists" "erlps__foldr__3"
            [arg_16, arg_24, candidatenames_15]
      (ErlangTuple [(ErlangAtom "explicit_files"), files_28]) ->
        let    arg_30 = BIF.erlang__binary_to_list__1 [file_0]
        in let
          case_29 =
            BIF.do_remote_fun_call "Maps" "erlps__get__3"
              [arg_30, files_28, ErlangAtom "not_found"]
        in
          case case_29 of
            (ErlangAtom "not_found") ->
              ErlangTuple [ErlangAtom "error", ErlangAtom "not_found"]
            src_36 -> ErlangTuple [ErlangAtom "ok", src_36]
      (ErlangAtom "escript") ->
        EXC.tryCatch
          (\ _ ->
             let   
               escript_39 =
                 BIF.do_remote_fun_call "Escript" "erlps__script_name__0" []
             in let
               matchExpr_43 =
                 BIF.do_remote_fun_call "Escript" "erlps__extract__2"
                   [escript_39, ErlangEmptyList]
             in
               case matchExpr_43 of
                 (ErlangTuple [(ErlangAtom "ok"), sections_42]) ->
                   let   
                     archive_46 =
                       BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
                         [ErlangAtom "archive", sections_42]
                   in let
                     arg_47 =
                       BIF.do_remote_fun_call "Filename" "erlps__join__1"
                         [ErlangCons (ErlangAtom "aesophia")
                            (ErlangCons (ErlangAtom "priv")
                               (ErlangCons (ErlangAtom "stdlib")
                                  (ErlangCons file_0 ErlangEmptyList)))]
                   in let filename_57 = BIF.erlang__binary_to_list__1 [arg_47]
                   in let
                     head_61 =
                       ErlangTuple
                         [ErlangAtom "file_list",
                          ErlangCons filename_57 ErlangEmptyList]
                   in let
                     case_58 =
                       BIF.do_remote_fun_call "Zip" "erlps__extract__2"
                         [archive_46,
                          ErlangCons head_61
                            (ErlangCons (ErlangAtom "memory") ErlangEmptyList)]
                   in
                     case case_58 of
                       (ErlangTuple [(ErlangAtom "ok"),
                                     (ErlangCons (ErlangTuple [_,
                                                               src_69]) (ErlangEmptyList))]) ->
                         ErlangTuple [ErlangAtom "ok", src_69]
                       _ ->
                         ErlangTuple
                           [ErlangAtom "error", ErlangAtom "not_found"]
                 _ -> EXC.badmatch matchExpr_43)
          (\ ex_75 ->
             case ex_75 of
               (ErlangTuple [_, _, _]) ->
                 ErlangTuple [ErlangAtom "error", ErlangAtom "not_found"]
               ex_76 -> EXC.raise ex_76)
      something_else -> EXC.case_clause something_else
erlps__read_file__2 [arg_79, arg_80] = EXC.function_clause unit
erlps__read_file__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__stdlib_options__0 :: ErlangFun
erlps__stdlib_options__0 [] =
  let   
    stdlibdir_0 =
      BIF.do_remote_fun_call "Aeso.Stdlib"
        "erlps__stdlib_include_path__0" []
  in let
    case_1 =
      ErlangAtom "true"
  in
    case case_1 of
      (ErlangAtom "true") ->
        let   
          tup_el_5 =
            ErlangTuple
              [ErlangAtom "file_system",
               ErlangCons stdlibdir_0 ErlangEmptyList]
        in let head_3 = ErlangTuple [ErlangAtom "include", tup_el_5]
        in ErlangCons head_3 ErlangEmptyList
      (ErlangAtom "false") ->
        let
          head_11 =
            ErlangTuple [ErlangAtom "include", ErlangAtom "escript"]
        in ErlangCons head_11 ErlangEmptyList
      something_else -> EXC.case_clause something_else
erlps__stdlib_options__0 args =
  EXC.badarity (ErlangFun 0 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__get_include_code__3 :: ErlangFun
erlps__get_include_code__3 [file_0, ann_1, opts_2] =
  let    tup_el_4 = erlps__read_file__2 [file_0, opts_2]
  in let arg_9 = erlps__stdlib_options__0 []
  in let tup_el_7 = erlps__read_file__2 [file_0, arg_9]
  in let case_3 = ErlangTuple [tup_el_4, tup_el_7]
  in
    case case_3 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "ok"), bin_10]),
                    (ErlangTuple [(ErlangAtom "ok"), _])]) ->
        let   
          lop_12 =
            BIF.do_remote_fun_call "Filename" "erlps__basename__1" [file_0]
        in let case_11 = BIF.erlang__op_eq [lop_12, file_0]
        in
          case case_11 of
            (ErlangAtom "true") ->
              let    arg_17 = erlps__ann_pos__1 [ann_1]
              in let lop_20 = toErl "Illegal redefinition of standard library "
              in let rop_21 = BIF.erlang__binary_to_list__1 [file_0]
              in let arg_19 = BIF.erlang__op_append [lop_20, rop_21]
              in let
                tup_el_16 =
                  BIF.do_remote_fun_call "Aeso.Parse.Lib" "erlps__fail__2"
                    [arg_17, arg_19]
              in ErlangTuple [ErlangAtom "error", tup_el_16]
            (ErlangAtom "false") ->
              let tup_el_24 = BIF.erlang__binary_to_list__1 [bin_10]
              in ErlangTuple [ErlangAtom "ok", tup_el_24]
            something_else -> EXC.case_clause something_else
      (ErlangTuple [_, (ErlangTuple [(ErlangAtom "ok"), bin_26])]) ->
        let tup_el_28 = BIF.erlang__binary_to_list__1 [bin_26]
        in ErlangTuple [ErlangAtom "ok", tup_el_28]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "ok"), bin_30]), _]) ->
        let tup_el_32 = BIF.erlang__binary_to_list__1 [bin_30]
        in ErlangTuple [ErlangAtom "ok", tup_el_32]
      (ErlangTuple [_, _]) ->
        let    tup_el_36 = erlps__ann_pos__1 [ann_1]
        in let
          tup_el_35 =
            ErlangTuple [tup_el_36, ErlangAtom "include_error", file_0]
        in ErlangTuple [ErlangAtom "error", tup_el_35]
      something_else -> EXC.case_clause something_else
erlps__get_include_code__3 [arg_40, arg_41, arg_42] =
  EXC.function_clause unit
erlps__get_include_code__3 args =
  EXC.badarity (ErlangFun 3 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__hash_include__2 :: ErlangFun
erlps__hash_include__2 [file_0, code_1]
  | ((ErlangAtom "true") ==
       (falsifyErrors (\ _ -> BIF.erlang__is_binary__1 [file_0]))) =
  let arg_2 = BIF.erlang__binary_to_list__1 [file_0]
  in erlps__hash_include__2 [arg_2, code_1]
erlps__hash_include__2 [file_0, code_1] | isEList file_0 =
  let   
    tup_el_2 =
      BIF.do_remote_fun_call "Filename" "erlps__basename__1" [file_0]
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Crypto" "erlps__hash__2"
        [ErlangAtom "sha256", code_1]
  in ErlangTuple [tup_el_2, tup_el_4]
erlps__hash_include__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__hash_include__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__auto_imports__1 :: ErlangFun
erlps__auto_imports__1 [(ErlangTuple [(ErlangAtom "comprehension_bind"),
                                      _, _])]
  =
  let    bin_el_1 = toErl 76
  in let bin_el_2 = toErl 105
  in let bin_el_3 = toErl 115
  in let bin_el_4 = toErl 116
  in let bin_el_5 = toErl 73
  in let bin_el_6 = toErl 110
  in let bin_el_7 = toErl 116
  in let bin_el_8 = toErl 101
  in let bin_el_9 = toErl 114
  in let bin_el_10 = toErl 110
  in let bin_el_11 = toErl 97
  in let bin_el_12 = toErl 108
  in let bin_el_13 = toErl 46
  in let bin_el_14 = toErl 97
  in let bin_el_15 = toErl 101
  in let bin_el_16 = toErl 115
  in let
    head_0 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_3 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_4 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_5 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_9 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_10 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_11 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_12 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_13 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_14 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_15 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_16 (toErl 8) 1 BIN.Big])
  in ErlangCons head_0 ErlangEmptyList
erlps__auto_imports__1 [(ErlangTuple [(ErlangAtom ".."), _])] =
  let    bin_el_1 = toErl 76
  in let bin_el_2 = toErl 105
  in let bin_el_3 = toErl 115
  in let bin_el_4 = toErl 116
  in let bin_el_5 = toErl 73
  in let bin_el_6 = toErl 110
  in let bin_el_7 = toErl 116
  in let bin_el_8 = toErl 101
  in let bin_el_9 = toErl 114
  in let bin_el_10 = toErl 110
  in let bin_el_11 = toErl 97
  in let bin_el_12 = toErl 108
  in let bin_el_13 = toErl 46
  in let bin_el_14 = toErl 97
  in let bin_el_15 = toErl 101
  in let bin_el_16 = toErl 115
  in let
    head_0 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_1 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_2 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_3 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_4 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_5 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_6 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_7 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_8 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_9 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_10 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_11 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_12 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_13 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_14 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_15 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_16 (toErl 8) 1 BIN.Big])
  in ErlangCons head_0 ErlangEmptyList
erlps__auto_imports__1 [l_0] | isEList l_0 =
  let arg_1 = ErlangFun 1 erlps__auto_imports__1
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2" [arg_1, l_0]
erlps__auto_imports__1 [t_0] | isETuple t_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [t_0]
  in erlps__auto_imports__1 [arg_1]
erlps__auto_imports__1 [_] = ErlangEmptyList
erlps__auto_imports__1 [arg_0] = EXC.function_clause unit
erlps__auto_imports__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args