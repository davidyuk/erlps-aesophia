module Aeso.Errors(erlps__err_msg__1, erlps__msg__1,
                   erlps__new__2, erlps__new__3, erlps__new__4, erlps__pos__2,
                   erlps__pos__3, erlps__pp__1, erlps__to_json__1,
                   erlps__throw__1, erlps__type__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.1.0
-}

import Prelude
import Data.Array as DA
import Data.List as DL
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as Tup
import Data.BigInt as DBI
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers as H
import Erlang.Exception as EXC
import Erlang.Type (ErlangFun, ErlangTerm(..), weakCmp, weakEq,
                    weakNEq, weakLt, weakLeq, weakGeq, weakGt)
import Effect (Effect)
import Effect.Unsafe (unsafePerformEffect)
import Effect.Exception (throw)
import Partial.Unsafe (unsafePartial)


erlps__new__2 :: ErlangFun
erlps__new__2 [type_0, msg_1] =
  let
    arg_3 =
      (erlps__pos__2
         [(ErlangInt (DBI.fromInt 0)), (ErlangInt (DBI.fromInt 0))])
  in (erlps__new__3 [type_0, arg_3, msg_1])
erlps__new__2 [arg_7, arg_8] = (EXC.function_clause unit)
erlps__new__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__new__3 :: ErlangFun
erlps__new__3 [type_0, pos_1, msg_2] =
  (ErlangTuple
     [(ErlangAtom "err"), pos_1, type_0, msg_2, (ErlangAtom "none")])
erlps__new__3 [arg_8, arg_9, arg_10] = (EXC.function_clause unit)
erlps__new__3 args =
  (EXC.badarity
     (ErlangFun 3 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__new__4 :: ErlangFun
erlps__new__4 [type_0, pos_1, msg_2, ctxt_3] =
  (ErlangTuple [(ErlangAtom "err"), pos_1, type_0, msg_2, ctxt_3])
erlps__new__4 [arg_9, arg_10, arg_11, arg_12] =
  (EXC.function_clause unit)
erlps__new__4 args =
  (EXC.badarity
     (ErlangFun 4 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__pos__2 :: ErlangFun
erlps__pos__2 [line_0, col_1] =
  (ErlangTuple
     [(ErlangAtom "pos"), (ErlangAtom "no_file"), line_0, col_1])
erlps__pos__2 [arg_6, arg_7] = (EXC.function_clause unit)
erlps__pos__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__pos__3 :: ErlangFun
erlps__pos__3 [file_0, line_1, col_2] =
  (ErlangTuple [(ErlangAtom "pos"), file_0, line_1, col_2])
erlps__pos__3 [arg_7, arg_8, arg_9] = (EXC.function_clause unit)
erlps__pos__3 args =
  (EXC.badarity
     (ErlangFun 3 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__throw__1 :: ErlangFun
erlps__throw__1 [(ErlangEmptyList)] = (ErlangAtom "ok")
erlps__throw__1 [errs_0] | (H.isEList errs_0) =
  let   
    arg_1 =
      (ErlangFun 2
         let
           lambda_2 [e1_5, e2_6] =
             let   
               lop_7 =
                 case e1_5 of
                   (ErlangTuple arr_10) | (DM.Just field_9) <-
                                            ((arr_10 DA.!! 1)) ->
                     field_9
                   _ -> (EXC.badrecord (ErlangAtom "err"))
             in let
               rop_11 =
                 case e2_6 of
                   (ErlangTuple arr_14) | (DM.Just field_13) <-
                                            ((arr_14 DA.!! 1)) ->
                     field_13
                   _ -> (EXC.badrecord (ErlangAtom "err"))
             in (BIF.erlang__op_lesserEq [lop_7, rop_11])
           lambda_2 [arg_3, arg_4] = (EXC.function_clause unit)
           lambda_2 args = (EXC.badarity (ErlangFun 2 lambda_2) args)
         in lambda_2)
  in let
    sortederrs_16 =
      (BIF.do_remote_fun_call "Lists" "erlps__sort__2" [arg_1, errs_0])
  in let
    arg_17 = (ErlangTuple [(ErlangAtom "error"), sortederrs_16])
  in (BIF.erlang__throw__1 [arg_17])
erlps__throw__1 [err_0@(ErlangTuple [(ErlangAtom "err"), _, _, _,
                                     _])]
  =
  let
    arg_1 =
      (ErlangTuple
         [(ErlangAtom "error"), (ErlangCons err_0 ErlangEmptyList)])
  in (BIF.erlang__throw__1 [arg_1])
erlps__throw__1 [arg_6] = (EXC.function_clause unit)
erlps__throw__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__msg__1 :: ErlangFun
erlps__msg__1 [(ErlangTuple [(ErlangAtom "err"), _, _, msg_0,
                             (ErlangAtom "none")])]
  =
  msg_0
erlps__msg__1 [(ErlangTuple [(ErlangAtom "err"), _, _, msg_0,
                             ctxt_1])]
  =
  (BIF.erlang__op_append [msg_0, ctxt_1])
erlps__msg__1 [arg_4] = (EXC.function_clause unit)
erlps__msg__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__err_msg__1 :: ErlangFun
erlps__err_msg__1 [err_1@(ErlangTuple [(ErlangAtom "err"), pos_0,
                                       _, _, _])]
  =
  let    arg_3 = (H.make_string "~s~s")
  in let head_5 = (erlps__str_pos__1 [pos_0])
  in let head_8 = (erlps__msg__1 [err_1])
  in let
    arg_2 =
      (BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
         [arg_3, (ErlangCons head_5 (ErlangCons head_8 ErlangEmptyList))])
  in (BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_2])
erlps__err_msg__1 [arg_11] = (EXC.function_clause unit)
erlps__err_msg__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__str_pos__1 :: ErlangFun
erlps__str_pos__1 [(ErlangTuple [(ErlangAtom "pos"),
                                 (ErlangAtom "no_file"), l_0, c_1])]
  =
  let arg_2 = (H.make_string "~p:~p:")
  in
    (BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
       [arg_2, (ErlangCons l_0 (ErlangCons c_1 ErlangEmptyList))])
erlps__str_pos__1 [(ErlangTuple [(ErlangAtom "pos"), f_0, l_1,
                                 c_2])]
  =
  let arg_3 = (H.make_string "~s:~p:~p:")
  in
    (BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
       [arg_3,
        (ErlangCons f_0
           (ErlangCons l_1 (ErlangCons c_2 ErlangEmptyList)))])
erlps__str_pos__1 [arg_11] = (EXC.function_clause unit)
erlps__str_pos__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__type__1 :: ErlangFun
erlps__type__1 [(ErlangTuple [(ErlangAtom "err"), _, type_0, _,
                              _])]
  =
  type_0
erlps__type__1 [arg_1] = (EXC.function_clause unit)
erlps__type__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__pp__1 :: ErlangFun
erlps__pp__1 [err_2@(ErlangTuple [(ErlangAtom "err"), pos_0,
                                  kind_1, _, _])]
  =
  let    arg_4 = (H.make_string "~s~s:\n~s")
  in let head_6 = (erlps__pp_kind__1 [kind_1])
  in let head_9 = (erlps__pp_pos__1 [pos_0])
  in let head_12 = (erlps__msg__1 [err_2])
  in let
    arg_3 =
      (BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
         [arg_4,
          (ErlangCons head_6
             (ErlangCons head_9 (ErlangCons head_12 ErlangEmptyList)))])
  in (BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_3])
erlps__pp__1 [arg_15] = (EXC.function_clause unit)
erlps__pp__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__pp_kind__1 :: ErlangFun
erlps__pp_kind__1 [(ErlangAtom "type_error")] =
  (H.make_string "Type error")
erlps__pp_kind__1 [(ErlangAtom "parse_error")] =
  (H.make_string "Parse error")
erlps__pp_kind__1 [(ErlangAtom "code_error")] =
  (H.make_string "Code generation error")
erlps__pp_kind__1 [(ErlangAtom "file_error")] =
  (H.make_string "File error")
erlps__pp_kind__1 [(ErlangAtom "data_error")] =
  (H.make_string "Data error")
erlps__pp_kind__1 [(ErlangAtom "internal_error")] =
  (H.make_string "Internal error")
erlps__pp_kind__1 [arg_0] = (EXC.function_clause unit)
erlps__pp_kind__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__pp_pos__1 :: ErlangFun
erlps__pp_pos__1 [(ErlangTuple [(ErlangAtom "pos"),
                                (ErlangAtom "no_file"), (ErlangInt num_0),
                                (ErlangInt num_1)])]
  | ((ErlangInt num_0) == (ErlangInt (DBI.fromInt 0)))
  , ((ErlangInt num_1) == (ErlangInt (DBI.fromInt 0))) =
  (H.make_string "")
erlps__pp_pos__1 [(ErlangTuple [(ErlangAtom "pos"),
                                (ErlangAtom "no_file"), l_0, c_1])]
  =
  let arg_2 = (H.make_string " at line ~p, col ~p")
  in
    (BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
       [arg_2, (ErlangCons l_0 (ErlangCons c_1 ErlangEmptyList))])
erlps__pp_pos__1 [(ErlangTuple [(ErlangAtom "pos"), f_0, l_1,
                                c_2])]
  =
  let arg_3 = (H.make_string " in \'~s\' at line ~p, col ~p")
  in
    (BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
       [arg_3,
        (ErlangCons f_0
           (ErlangCons l_1 (ErlangCons c_2 ErlangEmptyList)))])
erlps__pp_pos__1 [arg_11] = (EXC.function_clause unit)
erlps__pp_pos__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__to_json__1 :: ErlangFun
erlps__to_json__1 [(ErlangTuple [(ErlangAtom "err"), pos_0,
                                 type_1, msg_2, cxt_3])]
  =
  let    val_7 = (erlps__pos_to_json__1 [pos_0])
  in let
    val_9 =
      (BIF.erlang__atom_to_binary__2 [type_1, (ErlangAtom "utf8")])
  in let val_12 = (BIF.erlang__iolist_to_binary__1 [msg_2])
  in let
    json_14 =
      (ErlangMap
         (Map.fromFoldable
            [(Tup.Tuple (ErlangAtom "pos") val_7),
             (Tup.Tuple (ErlangAtom "type") val_9),
             (Tup.Tuple (ErlangAtom "message") val_12)]))
  in
    case cxt_3 of
      (ErlangAtom "none") -> json_14
      _ ->
        let    val_18 = (BIF.erlang__iolist_to_binary__1 [cxt_3])
        in let
          map_ext_20 =
            (ErlangMap (Map.singleton (ErlangAtom "context") val_18))
        in (BIF.maps__merge__2 [json_14, map_ext_20])
erlps__to_json__1 [arg_22] = (EXC.function_clause unit)
erlps__to_json__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__pos_to_json__1 :: ErlangFun
erlps__pos_to_json__1 [(ErlangTuple [(ErlangAtom "pos"), file_0,
                                     line_1, col_2])]
  =
  let
    json_7 =
      (ErlangMap
         (Map.fromFoldable
            [(Tup.Tuple (ErlangAtom "line") line_1),
             (Tup.Tuple (ErlangAtom "col") col_2)]))
  in
    case file_0 of
      (ErlangAtom "no_file") -> json_7
      _ ->
        let    val_11 = (BIF.erlang__iolist_to_binary__1 [file_0])
        in let
          map_ext_13 =
            (ErlangMap (Map.singleton (ErlangAtom "file") val_11))
        in (BIF.maps__merge__2 [json_7, map_ext_13])
erlps__pos_to_json__1 [arg_15] = (EXC.function_clause unit)
erlps__pos_to_json__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)