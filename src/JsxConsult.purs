module Jsx.Consult(erlps__consult__2, erlps__init__1,
                   erlps__reset__1, erlps__handle_event__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__opts__1 :: ErlangFun
erlps__opts__1 [opts_0] =
  BIF.erlang__op_append
    [ErlangCons (ErlangAtom "multi_term") ErlangEmptyList, opts_0]
erlps__opts__1 [arg_5] = EXC.function_clause unit
erlps__opts__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__consult__2 :: ErlangFun
erlps__consult__2 [file_0, config_1] | isEList config_1 =
  let
    case_2 =
      BIF.do_remote_fun_call "File" "erlps__read_file__1" [file_0]
  in
    case case_2 of
      (ErlangTuple [(ErlangAtom "ok"), bin_4]) ->
        let    arg_8 = erlps__opts__1 [config_1]
        in let arg_11 = erlps__opts__1 [config_1]
        in let
          arg_10 =
            BIF.do_remote_fun_call "Jsx.Config" "erlps__extract_config__1"
              [arg_11]
        in let
          fun_6 =
            BIF.do_remote_fun_call "Jsx" "erlps__decoder__3"
              [ErlangAtom "jsx_consult", arg_8, arg_10]
        in let
          matchExpr_14 =
            BIF.erlang__apply__2 [fun_6, ErlangCons bin_4 ErlangEmptyList]
        in
          case matchExpr_14 of
            (ErlangTuple [final_13, _, _]) ->
              BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [final_13]
            _ -> EXC.badmatch matchExpr_14
      (ErlangTuple [(ErlangAtom "error"), _]) ->
        BIF.erlang__error__1 [ErlangAtom "badarg"]
      something_else -> EXC.case_clause something_else
erlps__consult__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__consult__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__init__1 :: ErlangFun
erlps__init__1 [config_0] =
  let
    tup_el_3 =
      BIF.do_remote_fun_call "Jsx.To.Term" "erlps__start_term__1"
        [config_0]
  in ErlangTuple [ErlangEmptyList, config_0, tup_el_3]
erlps__init__1 [arg_5] = EXC.function_clause unit
erlps__init__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__reset__1 :: ErlangFun
erlps__reset__1 [(ErlangTuple [acc_0, config_1, _])] =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Jsx.To.Term" "erlps__start_term__1"
        [config_1]
  in ErlangTuple [acc_0, config_1, tup_el_4]
erlps__reset__1 [arg_6] = EXC.function_clause unit
erlps__reset__1 args =
  EXC.badarity (ErlangFun 1 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args

erlps__handle_event__2 :: ErlangFun
erlps__handle_event__2 [(ErlangAtom "end_json"),
                        (ErlangTuple [acc_0, config_1, state_2])]
  =
  let   
    head_5 =
      BIF.do_remote_fun_call "Jsx.To.Term" "erlps__get_value__1"
        [state_2]
  in let
    tup_el_3 =
      BIF.erlang__op_append [ErlangCons head_5 ErlangEmptyList, acc_0]
  in ErlangTuple [tup_el_3, config_1, state_2]
erlps__handle_event__2 [event_0,
                        (ErlangTuple [acc_1, config_2, state_3])]
  =
  let
    tup_el_6 =
      BIF.do_remote_fun_call "Jsx.To.Term" "erlps__handle_event__2"
        [event_0, state_3]
  in ErlangTuple [acc_1, config_2, tup_el_6]
erlps__handle_event__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__handle_event__2 args =
  EXC.badarity (ErlangFun 2 (\ _ -> ErlangAtom "purs_tco_sucks"))
    args