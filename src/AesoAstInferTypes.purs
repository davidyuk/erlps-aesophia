module Aeso.Ast.Infer.Types(erlps__infer__1, erlps__infer__2,
                            erlps__unfold_types_in_type__3,
                            erlps__pp_type__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__push_scope__3 :: ErlangFun
erlps__push_scope__3 [kind_0, con_1, env_2] =
  let   
    ann_4 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [con_1]
  in let name_6 = erlps__name__1 [con_1]
  in let
    lop_7 =
      case env_2 of
        (ErlangTuple arr_10) | (DM.Just field_9) <- (arr_10 DA.!! 5) ->
          field_9
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    new_14 =
      BIF.erlang__op_append [lop_7, ErlangCons name_6 ErlangEmptyList]
  in let
    map_18 =
      case env_2 of
        (ErlangTuple arr_21) | (DM.Just field_20) <- (arr_21 DA.!! 1) ->
          field_20
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    val_23 =
      ErlangTuple
        [ErlangAtom "scope", ErlangEmptyList, ErlangEmptyList,
         ErlangAtom "public", kind_0, ann_4]
  in let mapExt_30 = ErlangMap (Map.singleton new_14 val_23)
  in let record_updt_17 = BIF.maps__merge__2 [map_18, mapExt_30]
  in
    case env_2 of
      (ErlangTuple [(ErlangAtom "env"), scopes_32, vars_33,
                    typevars_34, fields_35, namespace_36, in_pattern_37,
                    stateful_38, current_function_39, what_40]) ->
        ErlangTuple
          [ErlangAtom "env", record_updt_17, vars_33, typevars_34,
           fields_35, new_14, in_pattern_37, stateful_38,
           current_function_39, what_40]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__push_scope__3 [arg_41, arg_42, arg_43] =
  EXC.function_clause unit
erlps__push_scope__3 args =
  EXC.badarity (ErlangFun 3 erlps__push_scope__3) args

erlps__pop_scope__1 :: ErlangFun
erlps__pop_scope__1 [env_0] =
  let   
    arg_3 =
      case env_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 5) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    record_updt_2 =
      BIF.do_remote_fun_call "Lists" "erlps__droplast__1" [arg_3]
  in
    case env_0 of
      (ErlangTuple [(ErlangAtom "env"), scopes_7, vars_8, typevars_9,
                    fields_10, namespace_11, in_pattern_12, stateful_13,
                    current_function_14, what_15]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_7, vars_8, typevars_9, fields_10,
           record_updt_2, in_pattern_12, stateful_13, current_function_14,
           what_15]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__pop_scope__1 [arg_16] = EXC.function_clause unit
erlps__pop_scope__1 args =
  EXC.badarity (ErlangFun 1 erlps__pop_scope__1) args

erlps__get_scope__2 :: ErlangFun
erlps__get_scope__2 [(ErlangTuple [(ErlangAtom "env"), scopes_0,
                                   _, _, _, _, _, _, _, _]),
                     name_1]
  =
  BIF.do_remote_fun_call "Maps" "erlps__get__3"
    [name_1, scopes_0, ErlangAtom "false"]
erlps__get_scope__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__get_scope__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_scope__2) args

erlps__on_current_scope__2 :: ErlangFun
erlps__on_current_scope__2 [env_2@(ErlangTuple [(ErlangAtom "env"),
                                                scopes_0, _, _, _, ns_1, _, _,
                                                _, _]),
                            fun_3]
  =
  let    scope_6 = BIF.maps__get__2 [ns_1, scopes_0]
  in let
    val_11 =
      BIF.erlang__apply__2 [fun_3, ErlangCons scope_6 ErlangEmptyList]
  in let mapExt_14 = ErlangMap (Map.singleton ns_1 val_11)
  in let record_updt_8 = BIF.maps__merge__2 [scopes_0, mapExt_14]
  in
    case env_2 of
      (ErlangTuple [(ErlangAtom "env"), scopes_16, vars_17,
                    typevars_18, fields_19, namespace_20, in_pattern_21,
                    stateful_22, current_function_23, what_24]) ->
        ErlangTuple
          [ErlangAtom "env", record_updt_8, vars_17, typevars_18,
           fields_19, namespace_20, in_pattern_21, stateful_22,
           current_function_23, what_24]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__on_current_scope__2 [arg_25, arg_26] =
  EXC.function_clause unit
erlps__on_current_scope__2 args =
  EXC.badarity (ErlangFun 2 erlps__on_current_scope__2) args

erlps__on_scopes__2 :: ErlangFun
erlps__on_scopes__2 [env_1@(ErlangTuple [(ErlangAtom "env"),
                                         scopes_0, _, _, _, _, _, _, _, _]),
                     fun_2]
  =
  let   
    arg_5 =
      ErlangFun 2
        (let
           lambda_6 [_, scope_9] =
             BIF.erlang__apply__2 [fun_2, ErlangCons scope_9 ErlangEmptyList]
           lambda_6 [arg_7, arg_8] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
         in lambda_6)
  in let
    record_updt_4 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_5, scopes_0]
  in
    case env_1 of
      (ErlangTuple [(ErlangAtom "env"), scopes_13, vars_14,
                    typevars_15, fields_16, namespace_17, in_pattern_18,
                    stateful_19, current_function_20, what_21]) ->
        ErlangTuple
          [ErlangAtom "env", record_updt_4, vars_14, typevars_15,
           fields_16, namespace_17, in_pattern_18, stateful_19,
           current_function_20, what_21]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__on_scopes__2 [arg_22, arg_23] = EXC.function_clause unit
erlps__on_scopes__2 args =
  EXC.badarity (ErlangFun 2 erlps__on_scopes__2) args

erlps__bind_var__3 :: ErlangFun
erlps__bind_var__3 [(ErlangTuple [(ErlangAtom "id"), ann_0,
                                  x_1]),
                    t_2, env_3]
  =
  let    tup_el_8 = ErlangTuple [ann_0, t_2]
  in let head_6 = ErlangTuple [x_1, tup_el_8]
  in let
    tail_11 =
      case env_3 of
        (ErlangTuple arr_14) | (DM.Just field_13) <- (arr_14 DA.!! 2) ->
          field_13
        _ -> EXC.badrecord (ErlangAtom "env")
  in
    case env_3 of
      (ErlangTuple [(ErlangAtom "env"), scopes_15, vars_16,
                    typevars_17, fields_18, namespace_19, in_pattern_20,
                    stateful_21, current_function_22, what_23]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_15, ErlangCons head_6 tail_11,
           typevars_17, fields_18, namespace_19, in_pattern_20, stateful_21,
           current_function_22, what_23]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_var__3 [arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__bind_var__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_var__3) args

erlps__bind_vars__2 :: ErlangFun
erlps__bind_vars__2 [(ErlangEmptyList), env_0] = env_0
erlps__bind_vars__2 [(ErlangCons (ErlangTuple [x_0,
                                               t_1]) vars_2),
                     env_3]
  =
  let arg_5 = erlps__bind_var__3 [x_0, t_1, env_3]
  in erlps__bind_vars__2 [vars_2, arg_5]
erlps__bind_vars__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__bind_vars__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_vars__2) args

erlps__bind_tvars__2 :: ErlangFun
erlps__bind_tvars__2 [xs_0, env_1] =
  let
    record_updt_3 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "tvar"), _, x_5]) ->
               ErlangCons x_5 ErlangEmptyList
             _ -> ErlangEmptyList)
        xs_0
  in
    case env_1 of
      (ErlangTuple [(ErlangAtom "env"), scopes_8, vars_9, typevars_10,
                    fields_11, namespace_12, in_pattern_13, stateful_14,
                    current_function_15, what_16]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_8, vars_9, record_updt_3, fields_11,
           namespace_12, in_pattern_13, stateful_14, current_function_15,
           what_16]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_tvars__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__bind_tvars__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_tvars__2) args

erlps__check_tvar__2 :: ErlangFun
erlps__check_tvar__2 [(ErlangTuple [(ErlangAtom "env"), _, _,
                                    tvars_0, _, _, _, _, _, _]),
                      t_2@(ErlangTuple [(ErlangAtom "tvar"), _, x_1])]
  =
  let   
    lop_4 = BIF.erlang__op_eq [tvars_0, ErlangAtom "unrestricted"]
  in let
    case_3 =
      case lop_4 of
        (ErlangAtom "true") -> ErlangAtom "true"
        (ErlangAtom "false") -> BIF.lists__member__2 [x_1, tvars_0]
        _ -> EXC.badarg1 lop_4
  in let
    _ =
      case case_3 of
        (ErlangAtom "true") -> ErlangAtom "ok"
        (ErlangAtom "false") ->
          let arg_9 = ErlangTuple [ErlangAtom "unbound_type", t_2]
          in erlps__type_error__1 [arg_9]
        something_else -> EXC.case_clause something_else
  in t_2
erlps__check_tvar__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__check_tvar__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_tvar__2) args

erlps__bind_fun__3 :: ErlangFun
erlps__bind_fun__3 [x_0, type_1, env_2] =
  let
    case_3 =
      erlps__lookup_env__4
        [env_2, ErlangAtom "term", ErlangEmptyList,
         ErlangCons x_0 ErlangEmptyList]
  in
    case case_3 of
      (ErlangAtom "false") ->
        erlps__force_bind_fun__3 [x_0, type_1, env_2]
      (ErlangTuple [_qid_13, (ErlangTuple [ann1_14, _])]) ->
        let   
          head_21 =
            BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [type_1]
        in let
          arg_15 =
            ErlangTuple
              [ErlangAtom "duplicate_definition", x_0,
               ErlangCons ann1_14 (ErlangCons head_21 ErlangEmptyList)]
        in let _ = erlps__type_error__1 [arg_15]
        in env_2
      something_else -> EXC.case_clause something_else
erlps__bind_fun__3 [arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__bind_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_fun__3) args

erlps__force_bind_fun__3 :: ErlangFun
erlps__force_bind_fun__3 [x_0, type_1,
                          env_3@(ErlangTuple [(ErlangAtom "env"), _, _, _, _, _,
                                              _, _, _, what_2])]
  =
  let   
    ann_5 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [type_1]
  in let
    nocode_8 =
      erlps__get_option__2 [ErlangAtom "no_code", ErlangAtom "false"]
  in let
    entry_24 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") ==
              (falsifyErrors
                 (\ _ ->
                    let    rop_12 = toErl "init"
                    in let lop_10 = BIF.erlang__op_eq [x_0, rop_12]
                    in let
                      lop_9 =
                        case lop_10 of
                          (ErlangAtom "false") -> ErlangAtom "false"
                          (ErlangAtom "true") ->
                            BIF.erlang__op_eq [what_2, ErlangAtom "contract"]
                          _ -> EXC.badarg1 lop_10
                    in
                      case lop_9 of
                        (ErlangAtom "false") -> ErlangAtom "false"
                        (ErlangAtom "true") -> BIF.erlang__not__1 [nocode_8]
                        _ -> EXC.badarg1 lop_9)) ->
          ErlangTuple [ErlangAtom "reserved_init", ann_5, type_1]
        _ | weakEq what_2 (ErlangAtom "contract_interface") ->
          ErlangTuple [ErlangAtom "contract_fun", ann_5, type_1]
        _ -> ErlangTuple [ann_5, type_1]
  in let
    arg_26 =
      ErlangFun 1
        (let
           lambda_27 [scope_30@(ErlangTuple [(ErlangAtom "scope"), funs_29,
                                             _, _, _, _])]
             =
             let head_33 = ErlangTuple [x_0, entry_24]
             in
               case scope_30 of
                 (ErlangTuple [(ErlangAtom "scope"), funs_37, types_38,
                               access_39, kind_40, ann_41]) ->
                   ErlangTuple
                     [ErlangAtom "scope", ErlangCons head_33 funs_29, types_38,
                      access_39, kind_40, ann_41]
                 _ -> EXC.badrecord (ErlangAtom "scope")
           lambda_27 [arg_28] = EXC.function_clause unit
           lambda_27 args = EXC.badarity (ErlangFun 1 lambda_27) args
         in lambda_27)
  in erlps__on_current_scope__2 [env_3, arg_26]
erlps__force_bind_fun__3 [arg_42, arg_43, arg_44] =
  EXC.function_clause unit
erlps__force_bind_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__force_bind_fun__3) args

erlps__bind_funs__2 :: ErlangFun
erlps__bind_funs__2 [(ErlangEmptyList), env_0] = env_0
erlps__bind_funs__2 [(ErlangCons (ErlangTuple [id_0,
                                               type_1]) rest_2),
                     env_3]
  =
  let arg_5 = erlps__bind_fun__3 [id_0, type_1, env_3]
  in erlps__bind_funs__2 [rest_2, arg_5]
erlps__bind_funs__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__bind_funs__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_funs__2) args

erlps__bind_type__4 :: ErlangFun
erlps__bind_type__4 [x_0, ann_1, def_2, env_3] =
  let
    arg_5 =
      ErlangFun 1
        (let
           lambda_6 [scope_9@(ErlangTuple [(ErlangAtom "scope"), _, types_8,
                                           _, _, _])]
             =
             let    tup_el_14 = ErlangTuple [ann_1, def_2]
             in let head_12 = ErlangTuple [x_0, tup_el_14]
             in
               case scope_9 of
                 (ErlangTuple [(ErlangAtom "scope"), funs_18, types_19,
                               access_20, kind_21, ann_22]) ->
                   ErlangTuple
                     [ErlangAtom "scope", funs_18, ErlangCons head_12 types_8,
                      access_20, kind_21, ann_22]
                 _ -> EXC.badrecord (ErlangAtom "scope")
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in erlps__on_current_scope__2 [env_3, arg_5]
erlps__bind_type__4 [arg_23, arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__bind_type__4 args =
  EXC.badarity (ErlangFun 4 erlps__bind_type__4) args

erlps__bind_state__1 :: ErlangFun
erlps__bind_state__1 [env_0] =
  let   
    head_1 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    unit_9 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_1 ErlangEmptyList,
         ErlangEmptyList]
  in let tup_el_15 = toErl "state"
  in let
    arg_12 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_1 ErlangEmptyList, tup_el_15]
  in let case_10 = erlps__lookup_type__2 [env_0, arg_12]
  in let
    state_20 =
      case case_10 of
        (ErlangTuple [s_16, _]) ->
          ErlangTuple
            [ErlangAtom "qid", ErlangCons head_1 ErlangEmptyList, s_16]
        (ErlangAtom "false") -> unit_9
        something_else -> EXC.case_clause something_else
  in let tup_el_23 = toErl "state"
  in let head_22 = ErlangTuple [tup_el_23, state_20]
  in let tup_el_27 = toErl "put"
  in let
    tup_el_28 =
      ErlangTuple
        [ErlangAtom "type_sig",
         ErlangCons (ErlangAtom "stateful")
           (ErlangCons head_1 ErlangEmptyList),
         ErlangAtom "none", ErlangEmptyList,
         ErlangCons state_20 ErlangEmptyList, unit_9]
  in let head_26 = ErlangTuple [tup_el_27, tup_el_28]
  in let
    env1_41 =
      erlps__bind_funs__2
        [ErlangCons head_22 (ErlangCons head_26 ErlangEmptyList), env_0]
  in let tup_el_47 = toErl "event"
  in let
    arg_44 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_1 ErlangEmptyList, tup_el_47]
  in let case_42 = erlps__lookup_type__2 [env_0, arg_44]
  in
    case case_42 of
      (ErlangTuple [e_48, _]) ->
        let   
          event_52 =
            ErlangTuple
              [ErlangAtom "qid", ErlangCons head_1 ErlangEmptyList, e_48]
        in let arg_54 = toErl "event"
        in let
          arg_55 =
            ErlangTuple
              [ErlangAtom "fun_t", ErlangCons head_1 ErlangEmptyList,
               ErlangEmptyList, ErlangCons event_52 ErlangEmptyList, unit_9]
        in let tup_el_68 = toErl "Chain"
        in let
          arg_65 =
            ErlangTuple
              [ErlangAtom "con", ErlangCons head_1 ErlangEmptyList, tup_el_68]
        in let
          arg_63 =
            erlps__push_scope__3 [ErlangAtom "namespace", arg_65, env1_41]
        in let arg_53 = erlps__bind_fun__3 [arg_54, arg_55, arg_63]
        in erlps__pop_scope__1 [arg_53]
      (ErlangAtom "false") -> env1_41
      something_else -> EXC.case_clause something_else
erlps__bind_state__1 [arg_70] = EXC.function_clause unit
erlps__bind_state__1 args =
  EXC.badarity (ErlangFun 1 erlps__bind_state__1) args

erlps__bind_field__3 :: ErlangFun
erlps__bind_field__3 [x_0, info_1,
                      env_3@(ErlangTuple [(ErlangAtom "env"), _, _, _, fields_2,
                                          _, _, _, _, _])]
  =
  let   
    arg_5 =
      ErlangFun 1
        (let
           lambda_6 [infos_8] = ErlangCons info_1 infos_8
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    fields1_15 =
      BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
        [x_0, arg_5, ErlangCons info_1 ErlangEmptyList, fields_2]
  in
    case env_3 of
      (ErlangTuple [(ErlangAtom "env"), scopes_18, vars_19,
                    typevars_20, fields_21, namespace_22, in_pattern_23,
                    stateful_24, current_function_25, what_26]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_18, vars_19, typevars_20, fields1_15,
           namespace_22, in_pattern_23, stateful_24, current_function_25,
           what_26]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_field__3 [arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__bind_field__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_field__3) args

erlps__bind_fields__2 :: ErlangFun
erlps__bind_fields__2 [(ErlangEmptyList), env_0] = env_0
erlps__bind_fields__2 [(ErlangCons (ErlangTuple [id_0,
                                                 info_1]) rest_2),
                       env_3]
  =
  let arg_5 = erlps__bind_field__3 [id_0, info_1, env_3]
  in erlps__bind_fields__2 [rest_2, arg_5]
erlps__bind_fields__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__bind_fields__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_fields__2) args

erlps__contract_call_type__1 :: ErlangFun
erlps__contract_call_type__1 [(ErlangTuple [(ErlangAtom "fun_t"),
                                            ann_0, (ErlangEmptyList), args_1,
                                            ret_2])]
  =
  let   
    id_9 =
      ErlangFun 1
        (let
           lambda_3 [x_5] = ErlangTuple [ErlangAtom "id", ann_0, x_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let arg_10 = toErl "int"
  in let
    int_12 =
      BIF.erlang__apply__2 [id_9, ErlangCons arg_10 ErlangEmptyList]
  in let
    typed_22 =
      ErlangFun 2
        (let
           lambda_13 [e_16, t_17] =
             ErlangTuple [ErlangAtom "typed", ann_0, e_16, t_17]
           lambda_13 [arg_14, arg_15] = EXC.function_clause unit
           lambda_13 args = EXC.badarity (ErlangFun 2 lambda_13) args
         in lambda_13)
  in let
    named_36 =
      ErlangFun 2
        (let
           lambda_23 [name_26,
                      default_28@(ErlangTuple [(ErlangAtom "typed"), _, _,
                                               t_27])]
             =
             let
               tup_el_31 =
                 BIF.erlang__apply__2 [id_9, ErlangCons name_26 ErlangEmptyList]
             in
               ErlangTuple
                 [ErlangAtom "named_arg_t", ann_0, tup_el_31, t_27, default_28]
           lambda_23 [arg_24, arg_25] = EXC.function_clause unit
           lambda_23 args = EXC.badarity (ErlangFun 2 lambda_23) args
         in lambda_23)
  in let arg_41 = toErl "gas"
  in let head_51 = toErl "Call"
  in let head_53 = toErl "gas_left"
  in let
    arg_47 =
      ErlangTuple
        [ErlangAtom "qid", ann_0,
         ErlangCons head_51 (ErlangCons head_53 ErlangEmptyList)]
  in let
    arg_55 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_0, ErlangEmptyList, ErlangEmptyList,
         int_12]
  in let
    tup_el_46 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_47 (ErlangCons arg_55 ErlangEmptyList)]
  in let
    arg_43 =
      ErlangTuple [ErlangAtom "app", ann_0, tup_el_46, ErlangEmptyList]
  in let
    arg_42 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_43 (ErlangCons int_12 ErlangEmptyList)]
  in let
    head_40 =
      BIF.erlang__apply__2
        [named_36, ErlangCons arg_41 (ErlangCons arg_42 ErlangEmptyList)]
  in let arg_68 = toErl "value"
  in let tup_el_73 = toErl 0
  in let arg_70 = ErlangTuple [ErlangAtom "int", ann_0, tup_el_73]
  in let
    arg_69 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_70 (ErlangCons int_12 ErlangEmptyList)]
  in let
    head_67 =
      BIF.erlang__apply__2
        [named_36, ErlangCons arg_68 (ErlangCons arg_69 ErlangEmptyList)]
  in let arg_79 = toErl "protected"
  in let
    arg_81 =
      ErlangTuple [ErlangAtom "bool", ann_0, ErlangAtom "false"]
  in let arg_86 = toErl "bool"
  in let
    arg_85 =
      BIF.erlang__apply__2 [id_9, ErlangCons arg_86 ErlangEmptyList]
  in let
    arg_80 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_81 (ErlangCons arg_85 ErlangEmptyList)]
  in let
    head_78 =
      BIF.erlang__apply__2
        [named_36, ErlangCons arg_79 (ErlangCons arg_80 ErlangEmptyList)]
  in let arg_96 = toErl "protected"
  in let
    tup_el_95 =
      BIF.erlang__apply__2 [id_9, ErlangCons arg_96 ErlangEmptyList]
  in let tup_el_104 = toErl "option"
  in let
    tup_el_101 = ErlangTuple [ErlangAtom "id", ann_0, tup_el_104]
  in let
    tup_el_98 =
      ErlangTuple
        [ErlangAtom "app_t", ann_0, tup_el_101,
         ErlangCons ret_2 ErlangEmptyList]
  in let
    tup_el_92 =
      ErlangTuple
        [ErlangAtom "if_t", ann_0, tup_el_95, tup_el_98, ret_2]
  in
    ErlangTuple
      [ErlangAtom "fun_t", ann_0,
       ErlangCons head_40
         (ErlangCons head_67 (ErlangCons head_78 ErlangEmptyList)),
       args_1, tup_el_92]
erlps__contract_call_type__1 [arg_109] = EXC.function_clause unit
erlps__contract_call_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__contract_call_type__1) args

erlps__bind_contract__2 :: ErlangFun
erlps__bind_contract__2 [(ErlangTuple [contract_0, ann_1, id_2,
                                       contents_3]),
                         env_4]
  | ((==) contract_0 (ErlangAtom "contract_main")) ||
      (((==) contract_0 (ErlangAtom "contract_interface")) ||
         ((==) contract_0 (ErlangAtom "contract_child"))) =
  let    key_6 = erlps__name__1 [id_2]
  in let
    head_7 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    lop_12 =
      flmap
        (\ lc_17 ->
           case lc_17 of
             (ErlangTuple [(ErlangAtom "fun_decl"), annf_14, entrypoint_15,
                           type_16]) ->
               let    tup_el_22 = erlps__contract_call_type__1 [type_16]
               in let
                 lcRet_18 =
                   ErlangTuple
                     [ErlangAtom "field_t", annf_14, entrypoint_15, tup_el_22]
               in ErlangCons lcRet_18 ErlangEmptyList
             _ -> ErlangEmptyList)
        contents_3
  in let
    lop_25 =
      flmap
        (\ lc_33 ->
           case lc_33 of
             (ErlangTuple [(ErlangAtom "letfun"), annf_27,
                           entrypoint_29@(ErlangTuple [(ErlangAtom "id"), _,
                                                       name_28]),
                           args_30, _type_31,
                           (ErlangTuple [(ErlangAtom "typed"), _, _,
                                         rett_32])]) ->
               let    rop_36 = toErl "init"
               in let cond_34 = BIF.erlang__op_exactNeq [name_28, rop_36]
               in
                 case cond_34 of
                   (ErlangAtom "true") ->
                     let   
                       tup_el_46 =
                         flmap
                           (\ lc_49 ->
                              case lc_49 of
                                (ErlangTuple [(ErlangAtom "typed"), _, _,
                                              argt_48]) ->
                                  ErlangCons argt_48 ErlangEmptyList
                                _ -> ErlangEmptyList)
                           args_30
                     in let
                       arg_42 =
                         ErlangTuple
                           [ErlangAtom "fun_t", annf_27, ErlangEmptyList,
                            tup_el_46, rett_32]
                     in let tup_el_41 = erlps__contract_call_type__1 [arg_42]
                     in let
                       lcRet_37 =
                         ErlangTuple
                           [ErlangAtom "field_t", annf_27, entrypoint_29,
                            tup_el_41]
                     in ErlangCons lcRet_37 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        contents_3
  in let tup_el_60 = toErl "address"
  in let
    tup_el_57 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_7 ErlangEmptyList, tup_el_60]
  in let tup_el_64 = toErl "address"
  in let
    tup_el_61 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_7 ErlangEmptyList, tup_el_64]
  in let
    head_54 =
      ErlangTuple
        [ErlangAtom "field_t", ErlangCons head_7 ErlangEmptyList,
         tup_el_57, tup_el_61]
  in let tup_el_73 = toErl "#__constructor__#"
  in let
    tup_el_70 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_7 ErlangEmptyList, tup_el_73]
  in let
    lop_77 =
      flmap
        (\ lc_85 ->
           case lc_85 of
             (ErlangTuple [(ErlangAtom "letfun"), annf_79,
                           (ErlangTuple [(ErlangAtom "id"), _,
                                         (ErlangCons (ErlangInt num_80) (ErlangCons (ErlangInt num_81) (ErlangCons (ErlangInt num_82) (ErlangCons (ErlangInt num_83) (ErlangEmptyList)))))]),
                           args_84, _, _]) | (ErlangInt num_80) == (toErl 105)
                                           , (ErlangInt num_81) == (toErl 110)
                                           , (ErlangInt num_82) == (toErl 105)
                                           , (ErlangInt num_83) ==
                                               (toErl 116) ->
               let
                 cond_86 =
                   BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                     [ErlangAtom "entrypoint", annf_79, ErlangAtom "false"]
               in
                 case cond_86 of
                   (ErlangAtom "true") ->
                     let
                       lcRet_90 =
                         flmap
                           (\ lc_93 ->
                              case lc_93 of
                                (ErlangTuple [(ErlangAtom "typed"), _, _,
                                              argt_92]) ->
                                  ErlangCons argt_92 ErlangEmptyList
                                _ -> ErlangEmptyList)
                           args_84
                     in ErlangCons lcRet_90 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        contents_3
  in let
    lop_96 =
      flmap
        (\ lc_104 ->
           case lc_104 of
             (ErlangTuple [(ErlangAtom "fun_decl"), annf_98,
                           (ErlangTuple [(ErlangAtom "id"), _,
                                         (ErlangCons (ErlangInt num_99) (ErlangCons (ErlangInt num_100) (ErlangCons (ErlangInt num_101) (ErlangCons (ErlangInt num_102) (ErlangEmptyList)))))]),
                           (ErlangTuple [(ErlangAtom "fun_t"), _, _, args_103,
                                         _])]) | (ErlangInt num_99) ==
                                                   (toErl 105)
                                               , (ErlangInt num_100) ==
                                                   (toErl 110)
                                               , (ErlangInt num_101) ==
                                                   (toErl 105)
                                               , (ErlangInt num_102) ==
                                                   (toErl 116) ->
               let
                 cond_105 =
                   BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                     [ErlangAtom "entrypoint", annf_98, ErlangAtom "false"]
               in
                 case cond_105 of
                   (ErlangAtom "true") -> ErlangCons args_103 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        contents_3
  in let
    rop_110 =
      flmap
        (\ lc_118 ->
           case lc_118 of
             (ErlangTuple [(ErlangAtom "fun_decl"), annf_112,
                           (ErlangTuple [(ErlangAtom "id"), _,
                                         (ErlangCons (ErlangInt num_113) (ErlangCons (ErlangInt num_114) (ErlangCons (ErlangInt num_115) (ErlangCons (ErlangInt num_116) (ErlangEmptyList)))))]),
                           (ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                         args_117, _])]) | (ErlangInt
                                                              num_113) ==
                                                             (toErl 105)
                                                         , (ErlangInt
                                                              num_114) ==
                                                             (toErl 110)
                                                         , (ErlangInt
                                                              num_115) ==
                                                             (toErl 105)
                                                         , (ErlangInt
                                                              num_116) ==
                                                             (toErl 116) ->
               let
                 cond_119 =
                   BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                     [ErlangAtom "entrypoint", annf_112, ErlangAtom "false"]
               in
                 case cond_119 of
                   (ErlangAtom "true") -> ErlangCons args_117 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        contents_3
  in let rop_95 = BIF.erlang__op_append [lop_96, rop_110]
  in let case_76 = BIF.erlang__op_append [lop_77, rop_95]
  in let
    arg_75 =
      case case_76 of
        (ErlangEmptyList) ->
          let    tup_el_135 = toErl "void"
          in let
            tup_el_132 =
              ErlangTuple
                [ErlangAtom "id", ErlangCons head_7 ErlangEmptyList, tup_el_135]
          in
            ErlangTuple
              [ErlangAtom "fun_t",
               ErlangCons (ErlangAtom "stateful")
                 (ErlangCons (ErlangAtom "payable")
                    (ErlangCons head_7 ErlangEmptyList)),
               ErlangEmptyList, ErlangEmptyList, tup_el_132]
        (ErlangCons args_136 (ErlangEmptyList)) ->
          let    tup_el_148 = toErl "void"
          in let
            tup_el_145 =
              ErlangTuple
                [ErlangAtom "id", ErlangCons head_7 ErlangEmptyList, tup_el_148]
          in
            ErlangTuple
              [ErlangAtom "fun_t",
               ErlangCons (ErlangAtom "stateful")
                 (ErlangCons (ErlangAtom "payable")
                    (ErlangCons head_7 ErlangEmptyList)),
               ErlangEmptyList, args_136, tup_el_145]
        something_else -> EXC.case_clause something_else
  in let tup_el_74 = erlps__contract_call_type__1 [arg_75]
  in let
    head_67 =
      ErlangTuple
        [ErlangAtom "field_t", ErlangCons head_7 ErlangEmptyList,
         tup_el_70, tup_el_74]
  in let
    rop_52 =
      BIF.erlang__op_append
        [ErlangCons head_54 ErlangEmptyList,
         ErlangCons head_67 ErlangEmptyList]
  in let rop_24 = BIF.erlang__op_append [lop_25, rop_52]
  in let fields_150 = BIF.erlang__op_append [lop_12, rop_24]
  in let
    fieldinfo_164 =
      flmap
        (\ lc_155 ->
           case lc_155 of
             (ErlangTuple [(ErlangAtom "field_t"), _,
                           (ErlangTuple [(ErlangAtom "id"), fieldann_152,
                                         entrypoint_153]),
                           type_154]) ->
               let   
                 tup_el_158 =
                   ErlangTuple
                     [ErlangAtom "field_info", fieldann_152, type_154, id_2,
                      ErlangAtom "contract"]
               in let lcRet_156 = ErlangTuple [entrypoint_153, tup_el_158]
               in ErlangCons lcRet_156 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_150
  in let
    tup_el_169 = ErlangTuple [ErlangAtom "contract_t", fields_150]
  in let arg_167 = ErlangTuple [ErlangEmptyList, tup_el_169]
  in let arg_172 = erlps__bind_fields__2 [fieldinfo_164, env_4]
  in erlps__bind_type__4 [key_6, ann_1, arg_167, arg_172]
erlps__bind_contract__2 [arg_175, arg_176] =
  EXC.function_clause unit
erlps__bind_contract__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_contract__2) args

erlps__possible_scopes__2 :: ErlangFun
erlps__possible_scopes__2 [(ErlangTuple [(ErlangAtom "env"), _,
                                         _, _, _, current_0, _, _, _, _]),
                           name_1]
  =
  let   
    qual_3 =
      BIF.do_remote_fun_call "Lists" "erlps__droplast__1" [name_1]
  in let arg_5 = toErl 0
  in let arg_6 = BIF.erlang__length__1 [current_0]
  in let
    lcSrc_4 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_5, arg_6]
  in
    flmap
      (\ lc_9 ->
         let   
           lop_11 =
             BIF.do_remote_fun_call "Lists" "erlps__sublist__2"
               [current_0, lc_9]
         in let lcRet_10 = BIF.erlang__op_append [lop_11, qual_3]
         in ErlangCons lcRet_10 ErlangEmptyList)
      lcSrc_4
erlps__possible_scopes__2 [arg_15, arg_16] =
  EXC.function_clause unit
erlps__possible_scopes__2 args =
  EXC.badarity (ErlangFun 2 erlps__possible_scopes__2) args

erlps__lookup_type__2 :: ErlangFun
erlps__lookup_type__2 [env_0, id_1] =
  let   
    arg_4 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [id_1]
  in let arg_6 = erlps__qname__1 [id_1]
  in erlps__lookup_env__4 [env_0, ErlangAtom "type", arg_4, arg_6]
erlps__lookup_type__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__lookup_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_type__2) args

erlps__lookup_env__4 :: ErlangFun
erlps__lookup_env__4 [env_0, kind_1, ann_2, name_3] =
  let
    var_12 =
      case name_3 of
        (ErlangCons x_5 (ErlangEmptyList)) | weakEq kind_1
                                               (ErlangAtom "term") ->
          let
            arg_7 =
              case env_0 of
                (ErlangTuple arr_10) | (DM.Just field_9) <- (arr_10 DA.!! 2) ->
                  field_9
                _ -> EXC.badrecord (ErlangAtom "env")
          in
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [x_5, arg_7, ErlangAtom "false"]
        _ -> ErlangAtom "false"
  in
    case var_12 of
      (ErlangTuple [ann1_14, type_15]) ->
        let tup_el_17 = ErlangTuple [ann1_14, type_15]
        in ErlangTuple [name_3, tup_el_17]
      (ErlangAtom "false") ->
        let    lcSrc_20 = erlps__possible_scopes__2 [env_0, name_3]
        in let
          names_31 =
            flmap
              (\ lc_24 ->
                 let   
                   head_28 =
                     BIF.do_remote_fun_call "Lists" "erlps__last__1" [name_3]
                 in let
                   lcRet_25 =
                     BIF.erlang__op_append
                       [lc_24, ErlangCons head_28 ErlangEmptyList]
                 in ErlangCons lcRet_25 ErlangEmptyList)
              lcSrc_20
        in let
          case_32 =
            flmap
              (\ lc_35 ->
                 let
                   head_37 = erlps__lookup_env1__4 [env_0, kind_1, ann_2, lc_35]
                 in
                   flmap
                     (\ lc_44 ->
                        let
                          cond_45 =
                            BIF.erlang__op_neq [lc_44, ErlangAtom "false"]
                        in
                          case cond_45 of
                            (ErlangAtom "true") ->
                              ErlangCons lc_44 ErlangEmptyList
                            _ -> ErlangEmptyList)
                     (ErlangCons head_37 ErlangEmptyList))
              names_31
        in
          case case_32 of
            (ErlangEmptyList) -> ErlangAtom "false"
            (ErlangCons res_49 (ErlangEmptyList)) -> res_49
            many_50 ->
              let   
                tup_el_53 =
                  flmap
                    (\ lc_57 ->
                       case lc_57 of
                         (ErlangTuple [q_55, (ErlangTuple [a_56, _])]) ->
                           let
                             lcRet_58 =
                               ErlangTuple [ErlangAtom "qid", a_56, q_55]
                           in ErlangCons lcRet_58 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    many_50
              in let
                arg_51 = ErlangTuple [ErlangAtom "ambiguous_name", tup_el_53]
              in let _ = erlps__type_error__1 [arg_51]
              in ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__lookup_env__4 [arg_62, arg_63, arg_64, arg_65] =
  EXC.function_clause unit
erlps__lookup_env__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_env__4) args

erlps__lookup_env1__4 :: ErlangFun
erlps__lookup_env1__4 [(ErlangTuple [(ErlangAtom "env"),
                                     scopes_0, _, _, _, current_1, _, _, _, _]),
                       kind_2, ann_3, qname_4]
  =
  let   
    qual_6 =
      BIF.do_remote_fun_call "Lists" "erlps__droplast__1" [qname_4]
  in let
    name_8 =
      BIF.do_remote_fun_call "Lists" "erlps__last__1" [qname_4]
  in let
    allowprivate_11 =
      BIF.do_remote_fun_call "Lists" "erlps__prefix__2"
        [qual_6, current_1]
  in let
    case_12 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [qual_6, scopes_0, ErlangAtom "false"]
  in
    case case_12 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "scope"), funs_16, types_17, _, _,
                    _]) ->
        let   
          defs_19 =
            case kind_2 of
              (ErlangAtom "type") -> types_17
              (ErlangAtom "term") -> funs_16
              something_else -> EXC.case_clause something_else
        in let
          case_20 =
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [name_8, defs_19, ErlangAtom "false"]
        in
          case case_20 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangTuple [(ErlangAtom "reserved_init"), ann1_24, type_25]) ->
              let   
                arg_26 =
                  ErlangTuple [ErlangAtom "cannot_call_init_function", ann_3]
              in let _ = erlps__type_error__1 [arg_26]
              in let tup_el_30 = ErlangTuple [ann1_24, type_25]
              in ErlangTuple [qname_4, tup_el_30]
            (ErlangTuple [(ErlangAtom "contract_fun"), ann1_33, type_34]) ->
              let   
                arg_35 =
                  ErlangTuple
                    [ErlangAtom "contract_treated_as_namespace", ann_3, qname_4]
              in let _ = erlps__type_error__1 [arg_35]
              in let tup_el_40 = ErlangTuple [ann1_33, type_34]
              in ErlangTuple [qname_4, tup_el_40]
            e_44@(ErlangTuple [ann1_43, _]) ->
              let    op_arg_47 = erlps__is_private__1 [ann1_43]
              in let lop_46 = BIF.erlang__not__1 [op_arg_47]
              in let
                case_45 =
                  case lop_46 of
                    (ErlangAtom "true") -> ErlangAtom "true"
                    (ErlangAtom "false") -> allowprivate_11
                    _ -> EXC.badarg1 lop_46
              in
                case case_45 of
                  (ErlangAtom "true") -> ErlangTuple [qname_4, e_44]
                  (ErlangAtom "false") -> ErlangAtom "false"
                  something_else -> EXC.case_clause something_else
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__lookup_env1__4 [arg_51, arg_52, arg_53, arg_54] =
  EXC.function_clause unit
erlps__lookup_env1__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_env1__4) args

erlps__lookup_record_field__2 :: ErlangFun
erlps__lookup_record_field__2 [env_0, fieldname_1] =
  let
    arg_3 =
      case env_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 4) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "env")
  in
    BIF.do_remote_fun_call "Maps" "erlps__get__3"
      [fieldname_1, arg_3, ErlangEmptyList]
erlps__lookup_record_field__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__lookup_record_field__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_record_field__2) args

erlps__lookup_record_field__3 :: ErlangFun
erlps__lookup_record_field__3 [env_0, fieldname_1, kind_2] =
  let lcSrc_3 = erlps__lookup_record_field__2 [env_0, fieldname_1]
  in
    flmap
      (\ lc_8 ->
         case lc_8 of
           fld_7@(ErlangTuple [(ErlangAtom "field_info"), _, _, _, k_6]) ->
             let    lop_10 = BIF.erlang__op_eq [kind_2, ErlangAtom "project"]
             in let
               cond_9 =
                 case lop_10 of
                   (ErlangAtom "true") -> ErlangAtom "true"
                   (ErlangAtom "false") ->
                     BIF.erlang__op_neq [k_6, ErlangAtom "contract"]
                   _ -> EXC.badarg1 lop_10
             in
               case cond_9 of
                 (ErlangAtom "true") -> ErlangCons fld_7 ErlangEmptyList
                 _ -> ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_3
erlps__lookup_record_field__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__lookup_record_field__3 args =
  EXC.badarity (ErlangFun 3 erlps__lookup_record_field__3) args

erlps__qname__1 :: ErlangFun
erlps__qname__1 [(ErlangTuple [(ErlangAtom "id"), _, x_0])] =
  ErlangCons x_0 ErlangEmptyList
erlps__qname__1 [(ErlangTuple [(ErlangAtom "qid"), _, xs_0])] =
  xs_0
erlps__qname__1 [(ErlangTuple [(ErlangAtom "con"), _, x_0])] =
  ErlangCons x_0 ErlangEmptyList
erlps__qname__1 [(ErlangTuple [(ErlangAtom "qcon"), _, xs_0])] =
  xs_0
erlps__qname__1 [arg_1] = EXC.function_clause unit
erlps__qname__1 args =
  EXC.badarity (ErlangFun 1 erlps__qname__1) args

erlps__name__1 :: ErlangFun
erlps__name__1 [(ErlangTuple [_, _, x_0])] = x_0
erlps__name__1 [arg_1] = EXC.function_clause unit
erlps__name__1 args =
  EXC.badarity (ErlangFun 1 erlps__name__1) args

erlps__qid__2 :: ErlangFun
erlps__qid__2 [ann_0, (ErlangCons x_1 (ErlangEmptyList))] =
  ErlangTuple [ErlangAtom "id", ann_0, x_1]
erlps__qid__2 [ann_0, xs_1] =
  ErlangTuple [ErlangAtom "qid", ann_0, xs_1]
erlps__qid__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__qid__2 args =
  EXC.badarity (ErlangFun 2 erlps__qid__2) args

erlps__qcon__2 :: ErlangFun
erlps__qcon__2 [ann_0, (ErlangCons x_1 (ErlangEmptyList))] =
  ErlangTuple [ErlangAtom "con", ann_0, x_1]
erlps__qcon__2 [ann_0, xs_1] =
  ErlangTuple [ErlangAtom "qcon", ann_0, xs_1]
erlps__qcon__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__qcon__2 args =
  EXC.badarity (ErlangFun 2 erlps__qcon__2) args

erlps__set_qname__2 :: ErlangFun
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "id"), ann_1, _])]
  =
  erlps__qid__2 [ann_1, xs_0]
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "qid"), ann_1, _])]
  =
  erlps__qid__2 [ann_1, xs_0]
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "con"), ann_1, _])]
  =
  erlps__qcon__2 [ann_1, xs_0]
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "qcon"), ann_1, _])]
  =
  erlps__qcon__2 [ann_1, xs_0]
erlps__set_qname__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__set_qname__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_qname__2) args

erlps__is_private__1 :: ErlangFun
erlps__is_private__1 [ann_0] =
  BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
    [ErlangAtom "private", ann_0, ErlangAtom "false"]
erlps__is_private__1 [arg_4] = EXC.function_clause unit
erlps__is_private__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_private__1) args

erlps__global_env__0 :: ErlangFun
erlps__global_env__0 [] =
  let   
    head_0 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let tup_el_7 = toErl "int"
  in let
    int_8 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_7]
  in let tup_el_11 = toErl "char"
  in let
    char_12 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_11]
  in let tup_el_15 = toErl "bool"
  in let
    bool_16 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_15]
  in let tup_el_19 = toErl "string"
  in let
    string_20 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_19]
  in let tup_el_23 = toErl "address"
  in let
    address_24 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_23]
  in let tup_el_27 = toErl "hash"
  in let
    hash_28 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_27]
  in let tup_el_31 = toErl "bits"
  in let
    bits_32 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_31]
  in let
    bytes_39 =
      ErlangFun 1
        (let
           lambda_33 [len_35] =
             ErlangTuple
               [ErlangAtom "bytes_t", ErlangCons head_0 ErlangEmptyList, len_35]
           lambda_33 [arg_34] = EXC.function_clause unit
           lambda_33 args = EXC.badarity (ErlangFun 1 lambda_33) args
         in lambda_33)
  in let
    oracle_56 =
      ErlangFun 2
        (let
           lambda_40 [q_43, r_44] =
             let    tup_el_50 = toErl "oracle"
             in let
               tup_el_47 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_50]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_47, ErlangCons q_43 (ErlangCons r_44 ErlangEmptyList)]
           lambda_40 [arg_41, arg_42] = EXC.function_clause unit
           lambda_40 args = EXC.badarity (ErlangFun 2 lambda_40) args
         in lambda_40)
  in let
    query_73 =
      ErlangFun 2
        (let
           lambda_57 [q_60, r_61] =
             let    tup_el_67 = toErl "oracle_query"
             in let
               tup_el_64 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_67]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_64, ErlangCons q_60 (ErlangCons r_61 ErlangEmptyList)]
           lambda_57 [arg_58, arg_59] = EXC.function_clause unit
           lambda_57 args = EXC.badarity (ErlangFun 2 lambda_57) args
         in lambda_57)
  in let
    unit_77 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
         ErlangEmptyList]
  in let
    list_90 =
      ErlangFun 1
        (let
           lambda_78 [t_80] =
             let    tup_el_86 = toErl "list"
             in let
               tup_el_83 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_86]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_83, ErlangCons t_80 ErlangEmptyList]
           lambda_78 [arg_79] = EXC.function_clause unit
           lambda_78 args = EXC.badarity (ErlangFun 1 lambda_78) args
         in lambda_78)
  in let
    option_103 =
      ErlangFun 1
        (let
           lambda_91 [t_93] =
             let    tup_el_99 = toErl "option"
             in let
               tup_el_96 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_99]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_96, ErlangCons t_93 ErlangEmptyList]
           lambda_91 [arg_92] = EXC.function_clause unit
           lambda_91 args = EXC.badarity (ErlangFun 1 lambda_91) args
         in lambda_91)
  in let
    map_120 =
      ErlangFun 2
        (let
           lambda_104 [a_107, b_108] =
             let    tup_el_114 = toErl "map"
             in let
               tup_el_111 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_114]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_111,
                  ErlangCons a_107 (ErlangCons b_108 ErlangEmptyList)]
           lambda_104 [arg_105, arg_106] = EXC.function_clause unit
           lambda_104 args = EXC.badarity (ErlangFun 2 lambda_104) args
         in lambda_104)
  in let
    pair_133 =
      ErlangFun 2
        (let
           lambda_121 [a_124, b_125] =
             ErlangTuple
               [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
                ErlangCons a_124 (ErlangCons b_125 ErlangEmptyList)]
           lambda_121 [arg_122, arg_123] = EXC.function_clause unit
           lambda_121 args = EXC.badarity (ErlangFun 2 lambda_121) args
         in lambda_121)
  in let
    func_147 =
      ErlangFun 3
        (let
           lambda_134 [c_138, ts_139, t_140] =
             ErlangTuple
               [ErlangAtom "type_sig", ErlangCons head_0 ErlangEmptyList, c_138,
                ErlangEmptyList, ts_139, t_140]
           lambda_134 [arg_135, arg_136, arg_137] = EXC.function_clause unit
           lambda_134 args = EXC.badarity (ErlangFun 3 lambda_134) args
         in lambda_134)
  in let
    func1_163 =
      ErlangFun 3
        (let
           lambda_148 [c_152, s_153, t_154] =
             ErlangTuple
               [ErlangAtom "type_sig", ErlangCons head_0 ErlangEmptyList, c_152,
                ErlangEmptyList, ErlangCons s_153 ErlangEmptyList, t_154]
           lambda_148 [arg_149, arg_150, arg_151] = EXC.function_clause unit
           lambda_148 args = EXC.badarity (ErlangFun 3 lambda_148) args
         in lambda_148)
  in let
    fun_173 =
      ErlangFun 2
        (let
           lambda_164 [ts_167, t_168] =
             BIF.erlang__apply__2
               [func_147,
                ErlangCons (ErlangAtom "none")
                  (ErlangCons ts_167 (ErlangCons t_168 ErlangEmptyList))]
           lambda_164 [arg_165, arg_166] = EXC.function_clause unit
           lambda_164 args = EXC.badarity (ErlangFun 2 lambda_164) args
         in lambda_164)
  in let
    fun1_184 =
      ErlangFun 2
        (let
           lambda_174 [s_177, t_178] =
             BIF.erlang__apply__2
               [fun_173,
                ErlangCons (ErlangCons s_177 ErlangEmptyList)
                  (ErlangCons t_178 ErlangEmptyList)]
           lambda_174 [arg_175, arg_176] = EXC.function_clause unit
           lambda_174 args = EXC.badarity (ErlangFun 2 lambda_174) args
         in lambda_174)
  in let
    funcn_200 =
      ErlangFun 4
        (let
           lambda_185 [c_190, named_191, normal_192, ret_193] =
             ErlangTuple
               [ErlangAtom "type_sig", ErlangCons head_0 ErlangEmptyList, c_190,
                named_191, normal_192, ret_193]
           lambda_185 [arg_186, arg_187, arg_188, arg_189] =
             EXC.function_clause unit
           lambda_185 args = EXC.badarity (ErlangFun 4 lambda_185) args
         in lambda_185)
  in let
    funn_213 =
      ErlangFun 3
        (let
           lambda_201 [named_205, normal_206, ret_207] =
             BIF.erlang__apply__2
               [funcn_200,
                ErlangCons (ErlangAtom "none")
                  (ErlangCons named_205
                     (ErlangCons normal_206
                        (ErlangCons ret_207 ErlangEmptyList)))]
           lambda_201 [arg_202, arg_203, arg_204] = EXC.function_clause unit
           lambda_201 args = EXC.badarity (ErlangFun 3 lambda_201) args
         in lambda_201)
  in let
    statefun_227 =
      ErlangFun 2
        (let
           lambda_214 [ts_217, t_218] =
             ErlangTuple
               [ErlangAtom "type_sig",
                ErlangCons (ErlangAtom "stateful")
                  (ErlangCons head_0 ErlangEmptyList),
                ErlangAtom "none", ErlangEmptyList, ts_217, t_218]
           lambda_214 [arg_215, arg_216] = EXC.function_clause unit
           lambda_214 args = EXC.badarity (ErlangFun 2 lambda_214) args
         in lambda_214)
  in let
    tvar_236 =
      ErlangFun 1
        (let
           lambda_228 [x_230] =
             let    lop_234 = toErl "\'"
             in let tup_el_233 = BIF.erlang__op_append [lop_234, x_230]
             in
               ErlangTuple
                 [ErlangAtom "tvar", ErlangCons head_0 ErlangEmptyList,
                  tup_el_233]
           lambda_228 [arg_229] = EXC.function_clause unit
           lambda_228 args = EXC.badarity (ErlangFun 1 lambda_228) args
         in lambda_228)
  in let tup_el_239 = toErl "signature"
  in let
    signid_240 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_239]
  in let bin_el_244 = toErl 0
  in let
    tup_el_243 =
      ErlangBinary (BIN.fromInt bin_el_244 (toErl 64) 8 BIN.Big)
  in let
    signdef_245 =
      ErlangTuple
        [ErlangAtom "bytes", ErlangCons head_0 ErlangEmptyList,
         tup_el_243]
  in let
    tup_el_250 =
      ErlangTuple
        [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
         signdef_245, signid_240]
  in let
    signature_255 =
      ErlangTuple
        [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
         signid_240, signid_240, tup_el_250]
  in let
    signfun_271 =
      ErlangFun 2
        (let
           lambda_256 [ts_259, t_260] =
             ErlangTuple
               [ErlangAtom "type_sig",
                ErlangCons (ErlangAtom "stateful")
                  (ErlangCons head_0 ErlangEmptyList),
                ErlangAtom "none", ErlangCons signature_255 ErlangEmptyList,
                ts_259, t_260]
           lambda_256 [arg_257, arg_258] = EXC.function_clause unit
           lambda_256 args = EXC.badarity (ErlangFun 2 lambda_256) args
         in lambda_256)
  in let head_275 = toErl "Chain"
  in let head_277 = toErl "ttl"
  in let
    ttl_279 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_275 (ErlangCons head_277 ErlangEmptyList)]
  in let head_283 = toErl "AENS"
  in let head_285 = toErl "pointee"
  in let
    pointee_287 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_283 (ErlangCons head_285 ErlangEmptyList)]
  in let head_291 = toErl "AENS"
  in let head_293 = toErl "name"
  in let
    aensname_295 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_291 (ErlangCons head_293 ErlangEmptyList)]
  in let head_299 = toErl "MCL_BLS12_381"
  in let head_301 = toErl "fr"
  in let
    fr_303 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_299 (ErlangCons head_301 ErlangEmptyList)]
  in let head_307 = toErl "MCL_BLS12_381"
  in let head_309 = toErl "fp"
  in let
    fp_311 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_307 (ErlangCons head_309 ErlangEmptyList)]
  in let
    fp2_319 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
         ErlangCons fp_311 (ErlangCons fp_311 ErlangEmptyList)]
  in let
    g1_329 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
         ErlangCons fp_311
           (ErlangCons fp_311 (ErlangCons fp_311 ErlangEmptyList))]
  in let
    g2_339 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
         ErlangCons fp2_319
           (ErlangCons fp2_319 (ErlangCons fp2_319 ErlangEmptyList))]
  in let arg_343 = toErl 12
  in let
    tup_el_342 =
      BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
        [arg_343, fp_311]
  in let
    gt_345 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
         tup_el_342]
  in let head_349 = toErl "Chain"
  in let head_351 = toErl "tx"
  in let
    tx_353 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_349 (ErlangCons head_351 ErlangEmptyList)]
  in let head_357 = toErl "Chain"
  in let head_359 = toErl "ga_meta_tx"
  in let
    gametatx_361 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_357 (ErlangCons head_359 ErlangEmptyList)]
  in let head_365 = toErl "Chain"
  in let head_367 = toErl "base_tx"
  in let
    basetx_369 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_365 (ErlangCons head_367 ErlangEmptyList)]
  in let head_373 = toErl "Chain"
  in let head_375 = toErl "paying_for_tx"
  in let
    payfortx_377 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_373 (ErlangCons head_375 ErlangEmptyList)]
  in let
    fldt_390 =
      ErlangFun 2
        (let
           lambda_378 [id_381, t_382] =
             let
               tup_el_385 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, id_381]
             in
               ErlangTuple
                 [ErlangAtom "field_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_385, t_382]
           lambda_378 [arg_379, arg_380] = EXC.function_clause unit
           lambda_378 args = EXC.badarity (ErlangFun 2 lambda_378) args
         in lambda_378)
  in let tup_el_392 = toErl "paying_for"
  in let
    tup_el_393 =
      BIF.erlang__apply__2
        [option_103, ErlangCons payfortx_377 ErlangEmptyList]
  in let head_391 = ErlangTuple [tup_el_392, tup_el_393]
  in let tup_el_398 = toErl "ga_metas"
  in let
    tup_el_399 =
      BIF.erlang__apply__2
        [list_90, ErlangCons gametatx_361 ErlangEmptyList]
  in let head_397 = ErlangTuple [tup_el_398, tup_el_399]
  in let tup_el_404 = toErl "actor"
  in let head_403 = ErlangTuple [tup_el_404, address_24]
  in let tup_el_408 = toErl "fee"
  in let head_407 = ErlangTuple [tup_el_408, int_8]
  in let tup_el_412 = toErl "ttl"
  in let head_411 = ErlangTuple [tup_el_412, int_8]
  in let tup_el_416 = toErl "tx"
  in let head_415 = ErlangTuple [tup_el_416, basetx_369]
  in let
    tup_el_421 =
      flmap
        (\ lc_425 ->
           case lc_425 of
             (ErlangTuple [n_423, t_424]) ->
               let
                 lcRet_426 =
                   BIF.erlang__apply__2
                     [fldt_390,
                      ErlangCons n_423 (ErlangCons t_424 ErlangEmptyList)]
               in ErlangCons lcRet_426 ErlangEmptyList
             _ -> ErlangEmptyList)
        (ErlangCons head_391
           (ErlangCons head_397
              (ErlangCons head_403
                 (ErlangCons head_407
                    (ErlangCons head_411
                       (ErlangCons head_415 ErlangEmptyList))))))
  in let
    txtype_430 = ErlangTuple [ErlangAtom "record_t", tup_el_421]
  in let
    stateful_441 =
      ErlangFun 1
        (let
           lambda_431 [t_433] =
             let    arg_434 = toErl 2
             in let arg_439 = toErl 2
             in let tail_438 = BIF.erlang__element__2 [arg_439, t_433]
             in
               BIF.erlang__setelement__3
                 [arg_434, t_433, ErlangCons (ErlangAtom "stateful") tail_438]
           lambda_431 [arg_432] = EXC.function_clause unit
           lambda_431 args = EXC.badarity (ErlangFun 1 lambda_431) args
         in lambda_431)
  in let head_445 = toErl "a"
  in let head_447 = toErl "q"
  in let head_449 = toErl "r"
  in let head_451 = toErl "k"
  in let head_453 = toErl "v"
  in let
    matchExpr_460 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [tvar_236,
         ErlangCons head_445
           (ErlangCons head_447
              (ErlangCons head_449
                 (ErlangCons head_451 (ErlangCons head_453 ErlangEmptyList))))]
  in
    case matchExpr_460 of
      (ErlangCons a_455 (ErlangCons q_456 (ErlangCons r_457 (ErlangCons k_458 (ErlangCons v_459 (ErlangEmptyList)))))) ->
        let   
          mkdefs_475 =
            ErlangFun 1
              (let
                 lambda_461 [defs_463] =
                   flmap
                     (\ lc_467 ->
                        case lc_467 of
                          (ErlangTuple [x_465, t_466]) ->
                            let   
                              tup_el_472 =
                                case ErlangAtom "true" of
                                  _ | isEInt t_466 ->
                                    ErlangTuple [ErlangAtom "builtin", t_466]
                                  _ -> t_466
                            in let
                              tup_el_470 =
                                ErlangTuple
                                  [ErlangCons head_0 ErlangEmptyList,
                                   tup_el_472]
                            in let lcRet_468 = ErlangTuple [x_465, tup_el_470]
                            in ErlangCons lcRet_468 ErlangEmptyList
                          _ -> ErlangEmptyList)
                     defs_463
                 lambda_461 [arg_462] = EXC.function_clause unit
                 lambda_461 args = EXC.badarity (ErlangFun 1 lambda_461) args
               in lambda_461)
        in let tup_el_480 = toErl "None"
        in let
          tup_el_481 =
            BIF.erlang__apply__2
              [option_103, ErlangCons a_455 ErlangEmptyList]
        in let head_479 = ErlangTuple [tup_el_480, tup_el_481]
        in let tup_el_486 = toErl "Some"
        in let
          arg_489 =
            BIF.erlang__apply__2
              [option_103, ErlangCons a_455 ErlangEmptyList]
        in let
          tup_el_487 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons a_455 (ErlangCons arg_489 ErlangEmptyList)]
        in let head_485 = ErlangTuple [tup_el_486, tup_el_487]
        in let tup_el_495 = toErl "RelativeTTL"
        in let
          tup_el_496 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons int_8 (ErlangCons ttl_279 ErlangEmptyList)]
        in let head_494 = ErlangTuple [tup_el_495, tup_el_496]
        in let tup_el_502 = toErl "FixedTTL"
        in let
          tup_el_503 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons int_8 (ErlangCons ttl_279 ErlangEmptyList)]
        in let head_501 = ErlangTuple [tup_el_502, tup_el_503]
        in let tup_el_509 = toErl "abort"
        in let
          tup_el_510 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons a_455 ErlangEmptyList)]
        in let head_508 = ErlangTuple [tup_el_509, tup_el_510]
        in let tup_el_516 = toErl "require"
        in let
          tup_el_517 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bool_16 (ErlangCons string_20 ErlangEmptyList))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_515 = ErlangTuple [tup_el_516, tup_el_517]
        in let
          tup_el_477 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_479
                    (ErlangCons head_485
                       (ErlangCons head_494
                          (ErlangCons head_501
                             (ErlangCons head_508
                                (ErlangCons head_515 ErlangEmptyList))))))
                 ErlangEmptyList]
        in let tup_el_530 = toErl "int"
        in let tup_el_531 = toErl 0
        in let head_529 = ErlangTuple [tup_el_530, tup_el_531]
        in let tup_el_534 = toErl "bool"
        in let tup_el_535 = toErl 0
        in let head_533 = ErlangTuple [tup_el_534, tup_el_535]
        in let tup_el_538 = toErl "char"
        in let tup_el_539 = toErl 0
        in let head_537 = ErlangTuple [tup_el_538, tup_el_539]
        in let tup_el_542 = toErl "string"
        in let tup_el_543 = toErl 0
        in let head_541 = ErlangTuple [tup_el_542, tup_el_543]
        in let tup_el_546 = toErl "address"
        in let tup_el_547 = toErl 0
        in let head_545 = ErlangTuple [tup_el_546, tup_el_547]
        in let tup_el_550 = toErl "void"
        in let tup_el_551 = toErl 0
        in let head_549 = ErlangTuple [tup_el_550, tup_el_551]
        in let tup_el_554 = toErl "unit"
        in let tup_el_557 = ErlangTuple [ErlangAtom "alias_t", unit_77]
        in let tup_el_555 = ErlangTuple [ErlangEmptyList, tup_el_557]
        in let head_553 = ErlangTuple [tup_el_554, tup_el_555]
        in let tup_el_562 = toErl "hash"
        in let arg_568 = toErl 32
        in let
          tup_el_567 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_568 ErlangEmptyList]
        in let
          tup_el_565 = ErlangTuple [ErlangAtom "alias_t", tup_el_567]
        in let tup_el_563 = ErlangTuple [ErlangEmptyList, tup_el_565]
        in let head_561 = ErlangTuple [tup_el_562, tup_el_563]
        in let tup_el_572 = toErl "signature"
        in let arg_578 = toErl 64
        in let
          tup_el_577 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_578 ErlangEmptyList]
        in let
          tup_el_575 = ErlangTuple [ErlangAtom "alias_t", tup_el_577]
        in let tup_el_573 = ErlangTuple [ErlangEmptyList, tup_el_575]
        in let head_571 = ErlangTuple [tup_el_572, tup_el_573]
        in let tup_el_582 = toErl "bits"
        in let tup_el_583 = toErl 0
        in let head_581 = ErlangTuple [tup_el_582, tup_el_583]
        in let tup_el_586 = toErl "option"
        in let tup_el_587 = toErl 1
        in let head_585 = ErlangTuple [tup_el_586, tup_el_587]
        in let tup_el_590 = toErl "list"
        in let tup_el_591 = toErl 1
        in let head_589 = ErlangTuple [tup_el_590, tup_el_591]
        in let tup_el_594 = toErl "map"
        in let tup_el_595 = toErl 2
        in let head_593 = ErlangTuple [tup_el_594, tup_el_595]
        in let tup_el_598 = toErl "oracle"
        in let tup_el_599 = toErl 2
        in let head_597 = ErlangTuple [tup_el_598, tup_el_599]
        in let tup_el_602 = toErl "oracle_query"
        in let tup_el_603 = toErl 2
        in let head_601 = ErlangTuple [tup_el_602, tup_el_603]
        in let
          tup_el_527 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_529
                    (ErlangCons head_533
                       (ErlangCons head_537
                          (ErlangCons head_541
                             (ErlangCons head_545
                                (ErlangCons head_549
                                   (ErlangCons head_553
                                      (ErlangCons head_561
                                         (ErlangCons head_571
                                            (ErlangCons head_581
                                               (ErlangCons head_585
                                                  (ErlangCons head_589
                                                     (ErlangCons head_593
                                                        (ErlangCons head_597
                                                           (ErlangCons head_601
                                                              ErlangEmptyList)))))))))))))))
                 ErlangEmptyList]
        in let
          head_609 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          topscope_613 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_477, tup_el_527, ErlangAtom "public",
               ErlangAtom "namespace", ErlangCons head_609 ErlangEmptyList]
        in let tup_el_618 = toErl "spend"
        in let
          tup_el_619 =
            BIF.erlang__apply__2
              [statefun_227,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_617 = ErlangTuple [tup_el_618, tup_el_619]
        in let tup_el_629 = toErl "balance"
        in let
          tup_el_630 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList)]
        in let head_628 = ErlangTuple [tup_el_629, tup_el_630]
        in let tup_el_636 = toErl "block_hash"
        in let
          arg_639 =
            BIF.erlang__apply__2
              [option_103, ErlangCons hash_28 ErlangEmptyList]
        in let
          tup_el_637 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons int_8 (ErlangCons arg_639 ErlangEmptyList)]
        in let head_635 = ErlangTuple [tup_el_636, tup_el_637]
        in let tup_el_645 = toErl "coinbase"
        in let head_644 = ErlangTuple [tup_el_645, address_24]
        in let tup_el_649 = toErl "timestamp"
        in let head_648 = ErlangTuple [tup_el_649, int_8]
        in let tup_el_653 = toErl "block_height"
        in let head_652 = ErlangTuple [tup_el_653, int_8]
        in let tup_el_657 = toErl "difficulty"
        in let head_656 = ErlangTuple [tup_el_657, int_8]
        in let tup_el_661 = toErl "gas_limit"
        in let head_660 = ErlangTuple [tup_el_661, int_8]
        in let tup_el_665 = toErl "bytecode_hash"
        in let
          arg_669 =
            BIF.erlang__apply__2
              [option_103, ErlangCons hash_28 ErlangEmptyList]
        in let
          tup_el_666 =
            BIF.erlang__apply__2
              [func1_163,
               ErlangCons (ErlangAtom "bytecode_hash")
                 (ErlangCons a_455 (ErlangCons arg_669 ErlangEmptyList))]
        in let head_664 = ErlangTuple [tup_el_665, tup_el_666]
        in let tup_el_675 = toErl "create"
        in let tup_el_685 = toErl "value"
        in let
          tup_el_682 =
            ErlangTuple
              [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_685]
        in let tup_el_693 = toErl 0
        in let
          tup_el_690 =
            ErlangTuple
              [ErlangAtom "int", ErlangCons head_0 ErlangEmptyList, tup_el_693]
        in let
          tup_el_687 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
               tup_el_690, int_8]
        in let
          head_679 =
            ErlangTuple
              [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
               tup_el_682, int_8, tup_el_687]
        in let
          arg_677 =
            BIF.erlang__apply__2
              [funn_213,
               ErlangCons (ErlangCons head_679 ErlangEmptyList)
                 (ErlangCons (ErlangAtom "var_args")
                    (ErlangCons a_455 ErlangEmptyList))]
        in let
          tup_el_676 =
            BIF.erlang__apply__2
              [stateful_441, ErlangCons arg_677 ErlangEmptyList]
        in let head_674 = ErlangTuple [tup_el_675, tup_el_676]
        in let tup_el_702 = toErl "clone"
        in let tup_el_712 = toErl "gas"
        in let
          tup_el_709 =
            ErlangTuple
              [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_712]
        in let head_727 = toErl "Call"
        in let head_729 = toErl "gas_left"
        in let
          tup_el_723 =
            ErlangTuple
              [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
               ErlangCons head_727 (ErlangCons head_729 ErlangEmptyList)]
        in let
          arg_732 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons ErlangEmptyList (ErlangCons int_8 ErlangEmptyList)]
        in let tup_el_731 = erlps__typesig_to_fun_t__1 [arg_732]
        in let
          tup_el_720 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
               tup_el_723, tup_el_731]
        in let
          tup_el_717 =
            ErlangTuple
              [ErlangAtom "app", ErlangCons head_0 ErlangEmptyList, tup_el_720,
               ErlangEmptyList]
        in let
          tup_el_714 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
               tup_el_717, int_8]
        in let
          head_706 =
            ErlangTuple
              [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
               tup_el_709, int_8, tup_el_714]
        in let tup_el_745 = toErl "value"
        in let
          tup_el_742 =
            ErlangTuple
              [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_745]
        in let tup_el_753 = toErl 0
        in let
          tup_el_750 =
            ErlangTuple
              [ErlangAtom "int", ErlangCons head_0 ErlangEmptyList, tup_el_753]
        in let
          tup_el_747 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
               tup_el_750, int_8]
        in let
          head_739 =
            ErlangTuple
              [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
               tup_el_742, int_8, tup_el_747]
        in let tup_el_762 = toErl "protected"
        in let
          tup_el_759 =
            ErlangTuple
              [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_762]
        in let
          tup_el_767 =
            ErlangTuple
              [ErlangAtom "bool", ErlangCons head_0 ErlangEmptyList,
               ErlangAtom "false"]
        in let
          tup_el_764 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
               tup_el_767, bool_16]
        in let
          head_756 =
            ErlangTuple
              [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
               tup_el_759, bool_16, tup_el_764]
        in let tup_el_779 = toErl "ref"
        in let
          tup_el_776 =
            ErlangTuple
              [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_779]
        in let
          head_773 =
            ErlangTuple
              [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
               tup_el_776, a_455, ErlangAtom "undefined"]
        in let
          arg_704 =
            BIF.erlang__apply__2
              [funn_213,
               ErlangCons
                 (ErlangCons head_706
                    (ErlangCons head_739
                       (ErlangCons head_756
                          (ErlangCons head_773 ErlangEmptyList))))
                 (ErlangCons (ErlangAtom "var_args")
                    (ErlangCons a_455 ErlangEmptyList))]
        in let
          tup_el_703 =
            BIF.erlang__apply__2
              [stateful_441, ErlangCons arg_704 ErlangEmptyList]
        in let head_701 = ErlangTuple [tup_el_702, tup_el_703]
        in let tup_el_789 = toErl "GAMetaTx"
        in let
          tup_el_790 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons gametatx_361 ErlangEmptyList)]
        in let head_788 = ErlangTuple [tup_el_789, tup_el_790]
        in let tup_el_800 = toErl "PayingForTx"
        in let
          tup_el_801 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons payfortx_377 ErlangEmptyList)]
        in let head_799 = ErlangTuple [tup_el_800, tup_el_801]
        in let tup_el_811 = toErl "SpendTx"
        in let
          tup_el_812 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24
                    (ErlangCons int_8 (ErlangCons string_20 ErlangEmptyList)))
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_810 = ErlangTuple [tup_el_811, tup_el_812]
        in let tup_el_824 = toErl "OracleRegisterTx"
        in let head_823 = ErlangTuple [tup_el_824, basetx_369]
        in let tup_el_828 = toErl "OracleQueryTx"
        in let head_827 = ErlangTuple [tup_el_828, basetx_369]
        in let tup_el_832 = toErl "OracleResponseTx"
        in let head_831 = ErlangTuple [tup_el_832, basetx_369]
        in let tup_el_836 = toErl "OracleExtendTx"
        in let head_835 = ErlangTuple [tup_el_836, basetx_369]
        in let tup_el_840 = toErl "NamePreclaimTx"
        in let head_839 = ErlangTuple [tup_el_840, basetx_369]
        in let tup_el_844 = toErl "NameClaimTx"
        in let
          tup_el_845 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons string_20 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_843 = ErlangTuple [tup_el_844, tup_el_845]
        in let tup_el_853 = toErl "NameUpdateTx"
        in let
          tup_el_854 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons hash_28 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_852 = ErlangTuple [tup_el_853, tup_el_854]
        in let tup_el_862 = toErl "NameRevokeTx"
        in let
          tup_el_863 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons hash_28 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_861 = ErlangTuple [tup_el_862, tup_el_863]
        in let tup_el_871 = toErl "NameTransferTx"
        in let
          tup_el_872 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons hash_28 ErlangEmptyList))
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_870 = ErlangTuple [tup_el_871, tup_el_872]
        in let tup_el_882 = toErl "ChannelCreateTx"
        in let
          tup_el_883 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_881 = ErlangTuple [tup_el_882, tup_el_883]
        in let tup_el_891 = toErl "ChannelDepositTx"
        in let
          tup_el_892 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_890 = ErlangTuple [tup_el_891, tup_el_892]
        in let tup_el_902 = toErl "ChannelWithdrawTx"
        in let
          tup_el_903 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_901 = ErlangTuple [tup_el_902, tup_el_903]
        in let tup_el_913 = toErl "ChannelForceProgressTx"
        in let
          tup_el_914 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_912 = ErlangTuple [tup_el_913, tup_el_914]
        in let tup_el_922 = toErl "ChannelCloseMutualTx"
        in let
          tup_el_923 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_921 = ErlangTuple [tup_el_922, tup_el_923]
        in let tup_el_931 = toErl "ChannelCloseSoloTx"
        in let
          tup_el_932 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_930 = ErlangTuple [tup_el_931, tup_el_932]
        in let tup_el_940 = toErl "ChannelSlashTx"
        in let
          tup_el_941 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_939 = ErlangTuple [tup_el_940, tup_el_941]
        in let tup_el_949 = toErl "ChannelSettleTx"
        in let
          tup_el_950 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_948 = ErlangTuple [tup_el_949, tup_el_950]
        in let tup_el_958 = toErl "ChannelSnapshotSoloTx"
        in let
          tup_el_959 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons address_24 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_957 = ErlangTuple [tup_el_958, tup_el_959]
        in let tup_el_967 = toErl "ContractCreateTx"
        in let
          tup_el_968 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons int_8 ErlangEmptyList)
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_966 = ErlangTuple [tup_el_967, tup_el_968]
        in let tup_el_976 = toErl "ContractCallTx"
        in let
          tup_el_977 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons basetx_369 ErlangEmptyList)]
        in let head_975 = ErlangTuple [tup_el_976, tup_el_977]
        in let tup_el_987 = toErl "GAAttachTx"
        in let head_986 = ErlangTuple [tup_el_987, basetx_369]
        in let
          tup_el_615 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_617
                    (ErlangCons head_628
                       (ErlangCons head_635
                          (ErlangCons head_644
                             (ErlangCons head_648
                                (ErlangCons head_652
                                   (ErlangCons head_656
                                      (ErlangCons head_660
                                         (ErlangCons head_664
                                            (ErlangCons head_674
                                               (ErlangCons head_701
                                                  (ErlangCons head_788
                                                     (ErlangCons head_799
                                                        (ErlangCons head_810
                                                           (ErlangCons head_823
                                                              (ErlangCons
                                                                 head_827
                                                                 (ErlangCons
                                                                    head_831
                                                                    (ErlangCons
                                                                       head_835
                                                                       (ErlangCons
                                                                          head_839
                                                                          (ErlangCons
                                                                             head_843
                                                                             (ErlangCons
                                                                                head_852
                                                                                (ErlangCons
                                                                                   head_861
                                                                                   (ErlangCons
                                                                                      head_870
                                                                                      (ErlangCons
                                                                                         head_881
                                                                                         (ErlangCons
                                                                                            head_890
                                                                                            (ErlangCons
                                                                                               head_901
                                                                                               (ErlangCons
                                                                                                  head_912
                                                                                                  (ErlangCons
                                                                                                     head_921
                                                                                                     (ErlangCons
                                                                                                        head_930
                                                                                                        (ErlangCons
                                                                                                           head_939
                                                                                                           (ErlangCons
                                                                                                              head_948
                                                                                                              (ErlangCons
                                                                                                                 head_957
                                                                                                                 (ErlangCons
                                                                                                                    head_966
                                                                                                                    (ErlangCons
                                                                                                                       head_975
                                                                                                                       (ErlangCons
                                                                                                                          head_986
                                                                                                                          ErlangEmptyList)))))))))))))))))))))))))))))))))))
                 ErlangEmptyList]
        in let tup_el_994 = toErl "ttl"
        in let tup_el_995 = toErl 0
        in let head_993 = ErlangTuple [tup_el_994, tup_el_995]
        in let tup_el_998 = toErl "tx"
        in let tup_el_999 = ErlangTuple [ErlangEmptyList, txtype_430]
        in let head_997 = ErlangTuple [tup_el_998, tup_el_999]
        in let tup_el_1004 = toErl "base_tx"
        in let tup_el_1005 = toErl 0
        in let head_1003 = ErlangTuple [tup_el_1004, tup_el_1005]
        in let tup_el_1008 = toErl "paying_for_tx"
        in let tup_el_1009 = toErl 0
        in let head_1007 = ErlangTuple [tup_el_1008, tup_el_1009]
        in let tup_el_1012 = toErl "ga_meta_tx"
        in let tup_el_1013 = toErl 0
        in let head_1011 = ErlangTuple [tup_el_1012, tup_el_1013]
        in let
          tup_el_991 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_993
                    (ErlangCons head_997
                       (ErlangCons head_1003
                          (ErlangCons head_1007
                             (ErlangCons head_1011 ErlangEmptyList)))))
                 ErlangEmptyList]
        in let
          head_1019 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          chainscope_1023 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_615, tup_el_991, ErlangAtom "public",
               ErlangAtom "namespace", ErlangCons head_1019 ErlangEmptyList]
        in let tup_el_1028 = toErl "address"
        in let head_1027 = ErlangTuple [tup_el_1028, address_24]
        in let tup_el_1032 = toErl "creator"
        in let head_1031 = ErlangTuple [tup_el_1032, address_24]
        in let tup_el_1036 = toErl "balance"
        in let head_1035 = ErlangTuple [tup_el_1036, int_8]
        in let
          tup_el_1025 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1027
                    (ErlangCons head_1031
                       (ErlangCons head_1035 ErlangEmptyList)))
                 ErlangEmptyList]
        in let
          head_1044 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          contractscope_1048 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1025, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1044 ErlangEmptyList]
        in let tup_el_1053 = toErl "origin"
        in let head_1052 = ErlangTuple [tup_el_1053, address_24]
        in let tup_el_1057 = toErl "caller"
        in let head_1056 = ErlangTuple [tup_el_1057, address_24]
        in let tup_el_1061 = toErl "value"
        in let head_1060 = ErlangTuple [tup_el_1061, int_8]
        in let tup_el_1065 = toErl "gas_price"
        in let head_1064 = ErlangTuple [tup_el_1065, int_8]
        in let tup_el_1069 = toErl "fee"
        in let head_1068 = ErlangTuple [tup_el_1069, int_8]
        in let tup_el_1073 = toErl "gas_left"
        in let
          tup_el_1074 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons ErlangEmptyList (ErlangCons int_8 ErlangEmptyList)]
        in let head_1072 = ErlangTuple [tup_el_1073, tup_el_1074]
        in let
          tup_el_1050 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1052
                    (ErlangCons head_1056
                       (ErlangCons head_1060
                          (ErlangCons head_1064
                             (ErlangCons head_1068
                                (ErlangCons head_1072 ErlangEmptyList))))))
                 ErlangEmptyList]
        in let
          head_1084 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          callscope_1088 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1050, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1084 ErlangEmptyList]
        in let tup_el_1093 = toErl "register"
        in let
          arg_1102 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1094 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons address_24
                    (ErlangCons int_8 (ErlangCons ttl_279 ErlangEmptyList)))
                 (ErlangCons arg_1102 ErlangEmptyList)]
        in let head_1092 = ErlangTuple [tup_el_1093, tup_el_1094]
        in let tup_el_1109 = toErl "expiry"
        in let
          head_1112 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1110 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons head_1112 ErlangEmptyList)
                 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1108 = ErlangTuple [tup_el_1109, tup_el_1110]
        in let tup_el_1121 = toErl "query_fee"
        in let
          head_1124 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1122 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons head_1124 ErlangEmptyList)
                 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1120 = ErlangTuple [tup_el_1121, tup_el_1122]
        in let tup_el_1133 = toErl "query"
        in let
          head_1136 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          arg_1149 =
            BIF.erlang__apply__2
              [query_73, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1134 =
            BIF.erlang__apply__2
              [statefun_227,
               ErlangCons
                 (ErlangCons head_1136
                    (ErlangCons q_456
                       (ErlangCons int_8
                          (ErlangCons ttl_279
                             (ErlangCons ttl_279 ErlangEmptyList)))))
                 (ErlangCons arg_1149 ErlangEmptyList)]
        in let head_1132 = ErlangTuple [tup_el_1133, tup_el_1134]
        in let tup_el_1156 = toErl "get_question"
        in let
          head_1159 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          head_1164 =
            BIF.erlang__apply__2
              [query_73, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1157 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons head_1159 (ErlangCons head_1164 ErlangEmptyList))
                 (ErlangCons q_456 ErlangEmptyList)]
        in let head_1155 = ErlangTuple [tup_el_1156, tup_el_1157]
        in let tup_el_1173 = toErl "respond"
        in let
          head_1176 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          head_1181 =
            BIF.erlang__apply__2
              [query_73, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1174 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons head_1176
                    (ErlangCons head_1181 (ErlangCons r_457 ErlangEmptyList)))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1172 = ErlangTuple [tup_el_1173, tup_el_1174]
        in let tup_el_1192 = toErl "extend"
        in let
          head_1195 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1193 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons head_1195 (ErlangCons ttl_279 ErlangEmptyList))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1191 = ErlangTuple [tup_el_1192, tup_el_1193]
        in let tup_el_1206 = toErl "get_answer"
        in let
          head_1209 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          head_1214 =
            BIF.erlang__apply__2
              [query_73, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          arg_1219 =
            erlps__option_t__2 [ErlangCons head_0 ErlangEmptyList, r_457]
        in let
          tup_el_1207 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons head_1209 (ErlangCons head_1214 ErlangEmptyList))
                 (ErlangCons arg_1219 ErlangEmptyList)]
        in let head_1205 = ErlangTuple [tup_el_1206, tup_el_1207]
        in let tup_el_1225 = toErl "check"
        in let
          head_1228 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1226 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons head_1228 ErlangEmptyList)
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1224 = ErlangTuple [tup_el_1225, tup_el_1226]
        in let tup_el_1237 = toErl "check_query"
        in let
          head_1240 =
            BIF.erlang__apply__2
              [oracle_56, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          head_1245 =
            BIF.erlang__apply__2
              [query_73, ErlangCons q_456 (ErlangCons r_457 ErlangEmptyList)]
        in let
          tup_el_1238 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons head_1240 (ErlangCons head_1245 ErlangEmptyList))
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1236 = ErlangTuple [tup_el_1237, tup_el_1238]
        in let
          tup_el_1090 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1092
                    (ErlangCons head_1108
                       (ErlangCons head_1120
                          (ErlangCons head_1132
                             (ErlangCons head_1155
                                (ErlangCons head_1172
                                   (ErlangCons head_1191
                                      (ErlangCons head_1205
                                         (ErlangCons head_1224
                                            (ErlangCons head_1236
                                               ErlangEmptyList))))))))))
                 ErlangEmptyList]
        in let
          head_1258 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          oraclescope_1262 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1090, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1258 ErlangEmptyList]
        in let tup_el_1267 = toErl "resolve"
        in let
          arg_1274 =
            erlps__option_t__2 [ErlangCons head_0 ErlangEmptyList, a_455]
        in let
          tup_el_1268 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons string_20 (ErlangCons string_20 ErlangEmptyList))
                 (ErlangCons arg_1274 ErlangEmptyList)]
        in let head_1266 = ErlangTuple [tup_el_1267, tup_el_1268]
        in let tup_el_1280 = toErl "preclaim"
        in let
          tup_el_1281 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons hash_28 ErlangEmptyList))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1279 = ErlangTuple [tup_el_1280, tup_el_1281]
        in let tup_el_1291 = toErl "claim"
        in let
          tup_el_1292 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons address_24
                    (ErlangCons string_20
                       (ErlangCons int_8 (ErlangCons int_8 ErlangEmptyList))))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1290 = ErlangTuple [tup_el_1291, tup_el_1292]
        in let tup_el_1306 = toErl "transfer"
        in let
          tup_el_1307 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons address_24
                    (ErlangCons address_24
                       (ErlangCons string_20 ErlangEmptyList)))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1305 = ErlangTuple [tup_el_1306, tup_el_1307]
        in let tup_el_1319 = toErl "revoke"
        in let
          tup_el_1320 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons address_24 (ErlangCons string_20 ErlangEmptyList))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1318 = ErlangTuple [tup_el_1319, tup_el_1320]
        in let tup_el_1330 = toErl "update"
        in let
          head_1337 =
            BIF.erlang__apply__2
              [option_103, ErlangCons ttl_279 ErlangEmptyList]
        in let
          head_1341 =
            BIF.erlang__apply__2
              [option_103, ErlangCons int_8 ErlangEmptyList]
        in let
          arg_1346 =
            BIF.erlang__apply__2
              [map_120,
               ErlangCons string_20 (ErlangCons pointee_287 ErlangEmptyList)]
        in let
          head_1345 =
            BIF.erlang__apply__2
              [option_103, ErlangCons arg_1346 ErlangEmptyList]
        in let
          tup_el_1331 =
            BIF.erlang__apply__2
              [signfun_271,
               ErlangCons
                 (ErlangCons address_24
                    (ErlangCons string_20
                       (ErlangCons head_1337
                          (ErlangCons head_1341
                             (ErlangCons head_1345 ErlangEmptyList)))))
                 (ErlangCons unit_77 ErlangEmptyList)]
        in let head_1329 = ErlangTuple [tup_el_1330, tup_el_1331]
        in let tup_el_1356 = toErl "lookup"
        in let
          arg_1361 =
            erlps__option_t__2
              [ErlangCons head_0 ErlangEmptyList, aensname_295]
        in let
          tup_el_1357 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons (ErlangCons string_20 ErlangEmptyList)
                 (ErlangCons arg_1361 ErlangEmptyList)]
        in let head_1355 = ErlangTuple [tup_el_1356, tup_el_1357]
        in let tup_el_1367 = toErl "AccountPt"
        in let
          tup_el_1368 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons pointee_287 ErlangEmptyList)]
        in let head_1366 = ErlangTuple [tup_el_1367, tup_el_1368]
        in let tup_el_1374 = toErl "OraclePt"
        in let
          tup_el_1375 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons pointee_287 ErlangEmptyList)]
        in let head_1373 = ErlangTuple [tup_el_1374, tup_el_1375]
        in let tup_el_1381 = toErl "ContractPt"
        in let
          tup_el_1382 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons pointee_287 ErlangEmptyList)]
        in let head_1380 = ErlangTuple [tup_el_1381, tup_el_1382]
        in let tup_el_1388 = toErl "ChannelPt"
        in let
          tup_el_1389 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons pointee_287 ErlangEmptyList)]
        in let head_1387 = ErlangTuple [tup_el_1388, tup_el_1389]
        in let tup_el_1395 = toErl "Name"
        in let
          head_1402 =
            BIF.erlang__apply__2
              [map_120,
               ErlangCons string_20 (ErlangCons pointee_287 ErlangEmptyList)]
        in let
          tup_el_1396 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons address_24
                    (ErlangCons ttl_279 (ErlangCons head_1402 ErlangEmptyList)))
                 (ErlangCons aensname_295 ErlangEmptyList)]
        in let head_1394 = ErlangTuple [tup_el_1395, tup_el_1396]
        in let
          tup_el_1264 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1266
                    (ErlangCons head_1279
                       (ErlangCons head_1290
                          (ErlangCons head_1305
                             (ErlangCons head_1318
                                (ErlangCons head_1329
                                   (ErlangCons head_1355
                                      (ErlangCons head_1366
                                         (ErlangCons head_1373
                                            (ErlangCons head_1380
                                               (ErlangCons head_1387
                                                  (ErlangCons head_1394
                                                     ErlangEmptyList))))))))))))
                 ErlangEmptyList]
        in let tup_el_1414 = toErl "pointee"
        in let tup_el_1415 = toErl 0
        in let head_1413 = ErlangTuple [tup_el_1414, tup_el_1415]
        in let tup_el_1418 = toErl "name"
        in let tup_el_1419 = toErl 0
        in let head_1417 = ErlangTuple [tup_el_1418, tup_el_1419]
        in let
          tup_el_1411 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1413 (ErlangCons head_1417 ErlangEmptyList))
                 ErlangEmptyList]
        in let
          head_1425 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          aensscope_1429 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1264, tup_el_1411,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1425 ErlangEmptyList]
        in let tup_el_1434 = toErl "from_list"
        in let
          arg_1437 =
            BIF.erlang__apply__2
              [pair_133, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          arg_1436 =
            BIF.erlang__apply__2
              [list_90, ErlangCons arg_1437 ErlangEmptyList]
        in let
          arg_1442 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          tup_el_1435 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons arg_1436 (ErlangCons arg_1442 ErlangEmptyList)]
        in let head_1433 = ErlangTuple [tup_el_1434, tup_el_1435]
        in let tup_el_1449 = toErl "to_list"
        in let
          arg_1451 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          arg_1456 =
            BIF.erlang__apply__2
              [pair_133, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          arg_1455 =
            BIF.erlang__apply__2
              [list_90, ErlangCons arg_1456 ErlangEmptyList]
        in let
          tup_el_1450 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons arg_1451 (ErlangCons arg_1455 ErlangEmptyList)]
        in let head_1448 = ErlangTuple [tup_el_1449, tup_el_1450]
        in let tup_el_1464 = toErl "lookup"
        in let
          head_1469 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          arg_1474 =
            BIF.erlang__apply__2
              [option_103, ErlangCons v_459 ErlangEmptyList]
        in let
          tup_el_1465 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons k_458 (ErlangCons head_1469 ErlangEmptyList))
                 (ErlangCons arg_1474 ErlangEmptyList)]
        in let head_1463 = ErlangTuple [tup_el_1464, tup_el_1465]
        in let tup_el_1480 = toErl "lookup_default"
        in let
          head_1485 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          tup_el_1481 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons k_458
                    (ErlangCons head_1485 (ErlangCons v_459 ErlangEmptyList)))
                 (ErlangCons v_459 ErlangEmptyList)]
        in let head_1479 = ErlangTuple [tup_el_1480, tup_el_1481]
        in let tup_el_1496 = toErl "delete"
        in let
          head_1501 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          arg_1506 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          tup_el_1497 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons k_458 (ErlangCons head_1501 ErlangEmptyList))
                 (ErlangCons arg_1506 ErlangEmptyList)]
        in let head_1495 = ErlangTuple [tup_el_1496, tup_el_1497]
        in let tup_el_1513 = toErl "member"
        in let
          head_1518 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          tup_el_1514 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons k_458 (ErlangCons head_1518 ErlangEmptyList))
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1512 = ErlangTuple [tup_el_1513, tup_el_1514]
        in let tup_el_1527 = toErl "size"
        in let
          arg_1529 =
            BIF.erlang__apply__2
              [map_120, ErlangCons k_458 (ErlangCons v_459 ErlangEmptyList)]
        in let
          tup_el_1528 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons arg_1529 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1526 = ErlangTuple [tup_el_1527, tup_el_1528]
        in let
          tup_el_1431 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1433
                    (ErlangCons head_1448
                       (ErlangCons head_1463
                          (ErlangCons head_1479
                             (ErlangCons head_1495
                                (ErlangCons head_1512
                                   (ErlangCons head_1526 ErlangEmptyList)))))))
                 ErlangEmptyList]
        in let
          head_1541 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          mapscope_1545 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1431, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1541 ErlangEmptyList]
        in let tup_el_1550 = toErl "verify_sig"
        in let
          tup_el_1551 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons hash_28
                    (ErlangCons address_24
                       (ErlangCons signid_240 ErlangEmptyList)))
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1549 = ErlangTuple [tup_el_1550, tup_el_1551]
        in let tup_el_1563 = toErl "verify_sig_secp256k1"
        in let arg_1569 = toErl 64
        in let
          head_1568 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_1569 ErlangEmptyList]
        in let
          tup_el_1564 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons hash_28
                    (ErlangCons head_1568
                       (ErlangCons signid_240 ErlangEmptyList)))
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1562 = ErlangTuple [tup_el_1563, tup_el_1564]
        in let tup_el_1578 = toErl "ecverify_secp256k1"
        in let arg_1584 = toErl 20
        in let
          head_1583 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_1584 ErlangEmptyList]
        in let arg_1588 = toErl 65
        in let
          head_1587 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_1588 ErlangEmptyList]
        in let
          tup_el_1579 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons hash_28
                    (ErlangCons head_1583
                       (ErlangCons head_1587 ErlangEmptyList)))
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1577 = ErlangTuple [tup_el_1578, tup_el_1579]
        in let tup_el_1595 = toErl "ecrecover_secp256k1"
        in let arg_1601 = toErl 65
        in let
          head_1600 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_1601 ErlangEmptyList]
        in let arg_1606 = toErl 20
        in let
          arg_1605 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons arg_1606 ErlangEmptyList]
        in let
          arg_1604 =
            BIF.erlang__apply__2
              [option_103, ErlangCons arg_1605 ErlangEmptyList]
        in let
          tup_el_1596 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons hash_28 (ErlangCons head_1600 ErlangEmptyList))
                 (ErlangCons arg_1604 ErlangEmptyList)]
        in let head_1594 = ErlangTuple [tup_el_1595, tup_el_1596]
        in let tup_el_1612 = toErl "sha3"
        in let
          tup_el_1613 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons a_455 (ErlangCons hash_28 ErlangEmptyList)]
        in let head_1611 = ErlangTuple [tup_el_1612, tup_el_1613]
        in let tup_el_1619 = toErl "sha256"
        in let
          tup_el_1620 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons a_455 (ErlangCons hash_28 ErlangEmptyList)]
        in let head_1618 = ErlangTuple [tup_el_1619, tup_el_1620]
        in let tup_el_1626 = toErl "blake2b"
        in let
          tup_el_1627 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons a_455 (ErlangCons hash_28 ErlangEmptyList)]
        in let head_1625 = ErlangTuple [tup_el_1626, tup_el_1627]
        in let
          tup_el_1547 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1549
                    (ErlangCons head_1562
                       (ErlangCons head_1577
                          (ErlangCons head_1594
                             (ErlangCons head_1611
                                (ErlangCons head_1618
                                   (ErlangCons head_1625 ErlangEmptyList)))))))
                 ErlangEmptyList]
        in let
          head_1637 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          cryptoscope_1641 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1547, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1637 ErlangEmptyList]
        in let tup_el_1646 = toErl "g1_neg"
        in let
          tup_el_1647 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons g1_329 (ErlangCons g1_329 ErlangEmptyList)]
        in let head_1645 = ErlangTuple [tup_el_1646, tup_el_1647]
        in let tup_el_1653 = toErl "g1_norm"
        in let
          tup_el_1654 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons g1_329 (ErlangCons g1_329 ErlangEmptyList)]
        in let head_1652 = ErlangTuple [tup_el_1653, tup_el_1654]
        in let tup_el_1660 = toErl "g1_valid"
        in let
          tup_el_1661 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons g1_329 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1659 = ErlangTuple [tup_el_1660, tup_el_1661]
        in let tup_el_1667 = toErl "g1_is_zero"
        in let
          tup_el_1668 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons g1_329 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1666 = ErlangTuple [tup_el_1667, tup_el_1668]
        in let tup_el_1674 = toErl "g1_add"
        in let
          tup_el_1675 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons g1_329 (ErlangCons g1_329 ErlangEmptyList))
                 (ErlangCons g1_329 ErlangEmptyList)]
        in let head_1673 = ErlangTuple [tup_el_1674, tup_el_1675]
        in let tup_el_1685 = toErl "g1_mul"
        in let
          tup_el_1686 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons fr_303 (ErlangCons g1_329 ErlangEmptyList))
                 (ErlangCons g1_329 ErlangEmptyList)]
        in let head_1684 = ErlangTuple [tup_el_1685, tup_el_1686]
        in let tup_el_1696 = toErl "g2_neg"
        in let
          tup_el_1697 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons g2_339 (ErlangCons g2_339 ErlangEmptyList)]
        in let head_1695 = ErlangTuple [tup_el_1696, tup_el_1697]
        in let tup_el_1703 = toErl "g2_norm"
        in let
          tup_el_1704 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons g2_339 (ErlangCons g2_339 ErlangEmptyList)]
        in let head_1702 = ErlangTuple [tup_el_1703, tup_el_1704]
        in let tup_el_1710 = toErl "g2_valid"
        in let
          tup_el_1711 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons g2_339 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1709 = ErlangTuple [tup_el_1710, tup_el_1711]
        in let tup_el_1717 = toErl "g2_is_zero"
        in let
          tup_el_1718 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons g2_339 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1716 = ErlangTuple [tup_el_1717, tup_el_1718]
        in let tup_el_1724 = toErl "g2_add"
        in let
          tup_el_1725 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons g2_339 (ErlangCons g2_339 ErlangEmptyList))
                 (ErlangCons g2_339 ErlangEmptyList)]
        in let head_1723 = ErlangTuple [tup_el_1724, tup_el_1725]
        in let tup_el_1735 = toErl "g2_mul"
        in let
          tup_el_1736 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons fr_303 (ErlangCons g2_339 ErlangEmptyList))
                 (ErlangCons g2_339 ErlangEmptyList)]
        in let head_1734 = ErlangTuple [tup_el_1735, tup_el_1736]
        in let tup_el_1746 = toErl "gt_inv"
        in let
          tup_el_1747 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons gt_345 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1745 = ErlangTuple [tup_el_1746, tup_el_1747]
        in let tup_el_1753 = toErl "gt_add"
        in let
          tup_el_1754 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons gt_345 (ErlangCons gt_345 ErlangEmptyList))
                 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1752 = ErlangTuple [tup_el_1753, tup_el_1754]
        in let tup_el_1764 = toErl "gt_mul"
        in let
          tup_el_1765 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons gt_345 (ErlangCons gt_345 ErlangEmptyList))
                 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1763 = ErlangTuple [tup_el_1764, tup_el_1765]
        in let tup_el_1775 = toErl "gt_pow"
        in let
          tup_el_1776 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons gt_345 (ErlangCons fr_303 ErlangEmptyList))
                 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1774 = ErlangTuple [tup_el_1775, tup_el_1776]
        in let tup_el_1786 = toErl "gt_is_one"
        in let
          tup_el_1787 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons gt_345 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_1785 = ErlangTuple [tup_el_1786, tup_el_1787]
        in let tup_el_1793 = toErl "pairing"
        in let
          tup_el_1794 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons g1_329 (ErlangCons g2_339 ErlangEmptyList))
                 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1792 = ErlangTuple [tup_el_1793, tup_el_1794]
        in let tup_el_1804 = toErl "miller_loop"
        in let
          tup_el_1805 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons g1_329 (ErlangCons g2_339 ErlangEmptyList))
                 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1803 = ErlangTuple [tup_el_1804, tup_el_1805]
        in let tup_el_1815 = toErl "final_exp"
        in let
          tup_el_1816 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons gt_345 (ErlangCons gt_345 ErlangEmptyList)]
        in let head_1814 = ErlangTuple [tup_el_1815, tup_el_1816]
        in let tup_el_1822 = toErl "int_to_fr"
        in let
          tup_el_1823 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons int_8 (ErlangCons fr_303 ErlangEmptyList)]
        in let head_1821 = ErlangTuple [tup_el_1822, tup_el_1823]
        in let tup_el_1829 = toErl "int_to_fp"
        in let
          tup_el_1830 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons int_8 (ErlangCons fp_311 ErlangEmptyList)]
        in let head_1828 = ErlangTuple [tup_el_1829, tup_el_1830]
        in let tup_el_1836 = toErl "fr_to_int"
        in let
          tup_el_1837 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons fr_303 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1835 = ErlangTuple [tup_el_1836, tup_el_1837]
        in let tup_el_1843 = toErl "fp_to_int"
        in let
          tup_el_1844 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons fp_311 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1842 = ErlangTuple [tup_el_1843, tup_el_1844]
        in let
          tup_el_1643 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1645
                    (ErlangCons head_1652
                       (ErlangCons head_1659
                          (ErlangCons head_1666
                             (ErlangCons head_1673
                                (ErlangCons head_1684
                                   (ErlangCons head_1695
                                      (ErlangCons head_1702
                                         (ErlangCons head_1709
                                            (ErlangCons head_1716
                                               (ErlangCons head_1723
                                                  (ErlangCons head_1734
                                                     (ErlangCons head_1745
                                                        (ErlangCons head_1752
                                                           (ErlangCons head_1763
                                                              (ErlangCons
                                                                 head_1774
                                                                 (ErlangCons
                                                                    head_1785
                                                                    (ErlangCons
                                                                       head_1792
                                                                       (ErlangCons
                                                                          head_1803
                                                                          (ErlangCons
                                                                             head_1814
                                                                             (ErlangCons
                                                                                head_1821
                                                                                (ErlangCons
                                                                                   head_1828
                                                                                   (ErlangCons
                                                                                      head_1835
                                                                                      (ErlangCons
                                                                                         head_1842
                                                                                         ErlangEmptyList))))))))))))))))))))))))
                 ErlangEmptyList]
        in let tup_el_1853 = toErl "fr"
        in let tup_el_1854 = toErl 0
        in let head_1852 = ErlangTuple [tup_el_1853, tup_el_1854]
        in let tup_el_1857 = toErl "fp"
        in let tup_el_1858 = toErl 0
        in let head_1856 = ErlangTuple [tup_el_1857, tup_el_1858]
        in let
          tup_el_1850 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1852 (ErlangCons head_1856 ErlangEmptyList))
                 ErlangEmptyList]
        in let
          head_1864 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          mcl_bls12_381_scope_1868 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1643, tup_el_1850,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1864 ErlangEmptyList]
        in let tup_el_1873 = toErl "tx_hash"
        in let
          tup_el_1874 =
            BIF.erlang__apply__2
              [option_103, ErlangCons hash_28 ErlangEmptyList]
        in let head_1872 = ErlangTuple [tup_el_1873, tup_el_1874]
        in let tup_el_1879 = toErl "tx"
        in let
          tup_el_1880 =
            BIF.erlang__apply__2
              [option_103, ErlangCons tx_353 ErlangEmptyList]
        in let head_1878 = ErlangTuple [tup_el_1879, tup_el_1880]
        in let
          tup_el_1870 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1872 (ErlangCons head_1878 ErlangEmptyList))
                 ErlangEmptyList]
        in let
          head_1889 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          authscope_1893 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1870, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1889 ErlangEmptyList]
        in let tup_el_1898 = toErl "length"
        in let
          tup_el_1899 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1897 = ErlangTuple [tup_el_1898, tup_el_1899]
        in let tup_el_1905 = toErl "concat"
        in let
          tup_el_1906 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons string_20 (ErlangCons string_20 ErlangEmptyList))
                 (ErlangCons string_20 ErlangEmptyList)]
        in let head_1904 = ErlangTuple [tup_el_1905, tup_el_1906]
        in let tup_el_1916 = toErl "to_list"
        in let
          arg_1919 =
            BIF.erlang__apply__2
              [list_90, ErlangCons char_12 ErlangEmptyList]
        in let
          tup_el_1917 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons arg_1919 ErlangEmptyList)]
        in let head_1915 = ErlangTuple [tup_el_1916, tup_el_1917]
        in let tup_el_1925 = toErl "from_list"
        in let
          arg_1927 =
            BIF.erlang__apply__2
              [list_90, ErlangCons char_12 ErlangEmptyList]
        in let
          tup_el_1926 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons arg_1927 (ErlangCons string_20 ErlangEmptyList)]
        in let head_1924 = ErlangTuple [tup_el_1925, tup_el_1926]
        in let tup_el_1934 = toErl "to_upper"
        in let
          tup_el_1935 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons string_20 ErlangEmptyList)]
        in let head_1933 = ErlangTuple [tup_el_1934, tup_el_1935]
        in let tup_el_1941 = toErl "to_lower"
        in let
          tup_el_1942 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons string_20 ErlangEmptyList)]
        in let head_1940 = ErlangTuple [tup_el_1941, tup_el_1942]
        in let tup_el_1948 = toErl "sha3"
        in let
          tup_el_1949 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons hash_28 ErlangEmptyList)]
        in let head_1947 = ErlangTuple [tup_el_1948, tup_el_1949]
        in let tup_el_1955 = toErl "sha256"
        in let
          tup_el_1956 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons hash_28 ErlangEmptyList)]
        in let head_1954 = ErlangTuple [tup_el_1955, tup_el_1956]
        in let tup_el_1962 = toErl "blake2b"
        in let
          tup_el_1963 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons string_20 (ErlangCons hash_28 ErlangEmptyList)]
        in let head_1961 = ErlangTuple [tup_el_1962, tup_el_1963]
        in let
          tup_el_1895 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1897
                    (ErlangCons head_1904
                       (ErlangCons head_1915
                          (ErlangCons head_1924
                             (ErlangCons head_1933
                                (ErlangCons head_1940
                                   (ErlangCons head_1947
                                      (ErlangCons head_1954
                                         (ErlangCons head_1961
                                            ErlangEmptyList)))))))))
                 ErlangEmptyList]
        in let
          head_1973 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          stringscope_1977 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1895, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1973 ErlangEmptyList]
        in let tup_el_1982 = toErl "to_int"
        in let
          tup_el_1983 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons char_12 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1981 = ErlangTuple [tup_el_1982, tup_el_1983]
        in let tup_el_1989 = toErl "from_int"
        in let
          arg_1992 =
            BIF.erlang__apply__2
              [option_103, ErlangCons char_12 ErlangEmptyList]
        in let
          tup_el_1990 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons int_8 (ErlangCons arg_1992 ErlangEmptyList)]
        in let head_1988 = ErlangTuple [tup_el_1989, tup_el_1990]
        in let
          tup_el_1979 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_1981 (ErlangCons head_1988 ErlangEmptyList))
                 ErlangEmptyList]
        in let
          head_2002 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          charscope_2006 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1979, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_2002 ErlangEmptyList]
        in let tup_el_2011 = toErl "set"
        in let
          tup_el_2012 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bits_32 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons bits_32 ErlangEmptyList)]
        in let head_2010 = ErlangTuple [tup_el_2011, tup_el_2012]
        in let tup_el_2022 = toErl "clear"
        in let
          tup_el_2023 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bits_32 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons bits_32 ErlangEmptyList)]
        in let head_2021 = ErlangTuple [tup_el_2022, tup_el_2023]
        in let tup_el_2033 = toErl "test"
        in let
          tup_el_2034 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bits_32 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_2032 = ErlangTuple [tup_el_2033, tup_el_2034]
        in let tup_el_2044 = toErl "sum"
        in let
          tup_el_2045 =
            BIF.erlang__apply__2
              [fun1_184, ErlangCons bits_32 (ErlangCons int_8 ErlangEmptyList)]
        in let head_2043 = ErlangTuple [tup_el_2044, tup_el_2045]
        in let tup_el_2051 = toErl "intersection"
        in let
          tup_el_2052 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bits_32 (ErlangCons bits_32 ErlangEmptyList))
                 (ErlangCons bits_32 ErlangEmptyList)]
        in let head_2050 = ErlangTuple [tup_el_2051, tup_el_2052]
        in let tup_el_2062 = toErl "union"
        in let
          tup_el_2063 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bits_32 (ErlangCons bits_32 ErlangEmptyList))
                 (ErlangCons bits_32 ErlangEmptyList)]
        in let head_2061 = ErlangTuple [tup_el_2062, tup_el_2063]
        in let tup_el_2073 = toErl "difference"
        in let
          tup_el_2074 =
            BIF.erlang__apply__2
              [fun_173,
               ErlangCons
                 (ErlangCons bits_32 (ErlangCons bits_32 ErlangEmptyList))
                 (ErlangCons bits_32 ErlangEmptyList)]
        in let head_2072 = ErlangTuple [tup_el_2073, tup_el_2074]
        in let tup_el_2084 = toErl "none"
        in let head_2083 = ErlangTuple [tup_el_2084, bits_32]
        in let tup_el_2088 = toErl "all"
        in let head_2087 = ErlangTuple [tup_el_2088, bits_32]
        in let
          tup_el_2008 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_2010
                    (ErlangCons head_2021
                       (ErlangCons head_2032
                          (ErlangCons head_2043
                             (ErlangCons head_2050
                                (ErlangCons head_2061
                                   (ErlangCons head_2072
                                      (ErlangCons head_2083
                                         (ErlangCons head_2087
                                            ErlangEmptyList)))))))))
                 ErlangEmptyList]
        in let
          head_2096 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          bitsscope_2100 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_2008, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_2096 ErlangEmptyList]
        in let tup_el_2105 = toErl "to_int"
        in let
          arg_2107 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          tup_el_2106 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons arg_2107 (ErlangCons int_8 ErlangEmptyList)]
        in let head_2104 = ErlangTuple [tup_el_2105, tup_el_2106]
        in let tup_el_2114 = toErl "to_str"
        in let
          arg_2116 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          tup_el_2115 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons arg_2116 (ErlangCons string_20 ErlangEmptyList)]
        in let head_2113 = ErlangTuple [tup_el_2114, tup_el_2115]
        in let tup_el_2123 = toErl "concat"
        in let
          head_2127 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          head_2131 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_2135 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          tup_el_2124 =
            BIF.erlang__apply__2
              [func_147,
               ErlangCons (ErlangAtom "bytes_concat")
                 (ErlangCons
                    (ErlangCons head_2127
                       (ErlangCons head_2131 ErlangEmptyList))
                    (ErlangCons arg_2135 ErlangEmptyList))]
        in let head_2122 = ErlangTuple [tup_el_2123, tup_el_2124]
        in let tup_el_2141 = toErl "split"
        in let
          head_2145 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_2150 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_2153 =
            BIF.erlang__apply__2
              [bytes_39, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_2149 =
            BIF.erlang__apply__2
              [pair_133,
               ErlangCons arg_2150 (ErlangCons arg_2153 ErlangEmptyList)]
        in let
          tup_el_2142 =
            BIF.erlang__apply__2
              [func_147,
               ErlangCons (ErlangAtom "bytes_split")
                 (ErlangCons (ErlangCons head_2145 ErlangEmptyList)
                    (ErlangCons arg_2149 ErlangEmptyList))]
        in let head_2140 = ErlangTuple [tup_el_2141, tup_el_2142]
        in let
          tup_el_2102 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_2104
                    (ErlangCons head_2113
                       (ErlangCons head_2122
                          (ErlangCons head_2140 ErlangEmptyList))))
                 ErlangEmptyList]
        in let
          head_2164 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          bytesscope_2168 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_2102, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_2164 ErlangEmptyList]
        in let tup_el_2173 = toErl "to_str"
        in let
          tup_el_2174 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons int_8 (ErlangCons string_20 ErlangEmptyList)]
        in let head_2172 = ErlangTuple [tup_el_2173, tup_el_2174]
        in let
          tup_el_2170 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons (ErlangCons head_2172 ErlangEmptyList)
                 ErlangEmptyList]
        in let
          head_2184 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          intscope_2188 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_2170, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_2184 ErlangEmptyList]
        in let tup_el_2193 = toErl "to_str"
        in let
          tup_el_2194 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons string_20 ErlangEmptyList)]
        in let head_2192 = ErlangTuple [tup_el_2193, tup_el_2194]
        in let tup_el_2200 = toErl "to_contract"
        in let
          tup_el_2201 =
            BIF.erlang__apply__2
              [func_147,
               ErlangCons (ErlangAtom "address_to_contract")
                 (ErlangCons (ErlangCons address_24 ErlangEmptyList)
                    (ErlangCons a_455 ErlangEmptyList))]
        in let head_2199 = ErlangTuple [tup_el_2200, tup_el_2201]
        in let tup_el_2210 = toErl "is_oracle"
        in let
          tup_el_2211 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_2209 = ErlangTuple [tup_el_2210, tup_el_2211]
        in let tup_el_2217 = toErl "is_contract"
        in let
          tup_el_2218 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_2216 = ErlangTuple [tup_el_2217, tup_el_2218]
        in let tup_el_2224 = toErl "is_payable"
        in let
          tup_el_2225 =
            BIF.erlang__apply__2
              [fun1_184,
               ErlangCons address_24 (ErlangCons bool_16 ErlangEmptyList)]
        in let head_2223 = ErlangTuple [tup_el_2224, tup_el_2225]
        in let
          tup_el_2190 =
            BIF.erlang__apply__2
              [mkdefs_475,
               ErlangCons
                 (ErlangCons head_2192
                    (ErlangCons head_2199
                       (ErlangCons head_2209
                          (ErlangCons head_2216
                             (ErlangCons head_2223 ErlangEmptyList)))))
                 ErlangEmptyList]
        in let
          head_2235 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          addressscope_2239 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_2190, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_2235 ErlangEmptyList]
        in let head_2244 = toErl "Chain"
        in let head_2247 = toErl "Contract"
        in let head_2250 = toErl "Call"
        in let head_2253 = toErl "Oracle"
        in let head_2256 = toErl "AENS"
        in let head_2259 = toErl "Map"
        in let head_2262 = toErl "Auth"
        in let head_2265 = toErl "Crypto"
        in let head_2268 = toErl "MCL_BLS12_381"
        in let head_2271 = toErl "StringInternal"
        in let head_2274 = toErl "Char"
        in let head_2277 = toErl "Bits"
        in let head_2280 = toErl "Bytes"
        in let head_2283 = toErl "Int"
        in let head_2286 = toErl "Address"
        in let
          tup_el_2241 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple ErlangEmptyList topscope_613,
                  DT.Tuple (ErlangCons head_2244 ErlangEmptyList)
                    chainscope_1023,
                  DT.Tuple (ErlangCons head_2247 ErlangEmptyList)
                    contractscope_1048,
                  DT.Tuple (ErlangCons head_2250 ErlangEmptyList)
                    callscope_1088,
                  DT.Tuple (ErlangCons head_2253 ErlangEmptyList)
                    oraclescope_1262,
                  DT.Tuple (ErlangCons head_2256 ErlangEmptyList)
                    aensscope_1429,
                  DT.Tuple (ErlangCons head_2259 ErlangEmptyList) mapscope_1545,
                  DT.Tuple (ErlangCons head_2262 ErlangEmptyList)
                    authscope_1893,
                  DT.Tuple (ErlangCons head_2265 ErlangEmptyList)
                    cryptoscope_1641,
                  DT.Tuple (ErlangCons head_2268 ErlangEmptyList)
                    mcl_bls12_381_scope_1868,
                  DT.Tuple (ErlangCons head_2271 ErlangEmptyList)
                    stringscope_1977,
                  DT.Tuple (ErlangCons head_2274 ErlangEmptyList)
                    charscope_2006,
                  DT.Tuple (ErlangCons head_2277 ErlangEmptyList)
                    bitsscope_2100,
                  DT.Tuple (ErlangCons head_2280 ErlangEmptyList)
                    bytesscope_2168,
                  DT.Tuple (ErlangCons head_2283 ErlangEmptyList) intscope_2188,
                  DT.Tuple (ErlangCons head_2286 ErlangEmptyList)
                    addressscope_2239])
        in let
          arg_2307 =
            flmap
              (\ lc_2311 ->
                 case lc_2311 of
                   (ErlangTuple [n_2309, t_2310]) ->
                     let   
                       head_2315 =
                         ErlangTuple
                           [ErlangAtom "field_info", ErlangEmptyList, t_2310,
                            tx_353, ErlangAtom "record"]
                     in let
                       lcRet_2312 =
                         ErlangTuple
                           [n_2309, ErlangCons head_2315 ErlangEmptyList]
                     in ErlangCons lcRet_2312 ErlangEmptyList
                   _ -> ErlangEmptyList)
              (ErlangCons head_391
                 (ErlangCons head_397
                    (ErlangCons head_403
                       (ErlangCons head_407
                          (ErlangCons head_411
                             (ErlangCons head_415 ErlangEmptyList))))))
        in let tup_el_2306 = BIF.maps__from_list__1 [arg_2307]
        in
          ErlangTuple
            [ErlangAtom "env", tup_el_2241, ErlangEmptyList,
             ErlangAtom "unrestricted", tup_el_2306, ErlangEmptyList,
             ErlangAtom "false", ErlangAtom "false", ErlangAtom "none",
             ErlangAtom "top"]
      _ -> EXC.badmatch matchExpr_460
erlps__global_env__0 args =
  EXC.badarity (ErlangFun 0 erlps__global_env__0) args

erlps__option_t__2 :: ErlangFun
erlps__option_t__2 [as_0, t_1] =
  let    tup_el_7 = toErl "option"
  in let tup_el_4 = ErlangTuple [ErlangAtom "id", as_0, tup_el_7]
  in
    ErlangTuple
      [ErlangAtom "app_t", as_0, tup_el_4,
       ErlangCons t_1 ErlangEmptyList]
erlps__option_t__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__option_t__2 args =
  EXC.badarity (ErlangFun 2 erlps__option_t__2) args

erlps__map_t__3 :: ErlangFun
erlps__map_t__3 [as_0, k_1, v_2] =
  let    tup_el_8 = toErl "map"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", as_0, tup_el_8]
  in
    ErlangTuple
      [ErlangAtom "app_t", as_0, tup_el_5,
       ErlangCons k_1 (ErlangCons v_2 ErlangEmptyList)]
erlps__map_t__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__map_t__3 args =
  EXC.badarity (ErlangFun 3 erlps__map_t__3) args

erlps__infer__1 :: ErlangFun
erlps__infer__1 [contracts_0] =
  erlps__infer__2 [contracts_0, ErlangEmptyList]
erlps__infer__1 [arg_3] = EXC.function_clause unit
erlps__infer__1 args =
  EXC.badarity (ErlangFun 1 erlps__infer__1) args

erlps__init_env__1 :: ErlangFun
erlps__init_env__1 [_options_0] = erlps__global_env__0 []
erlps__init_env__1 [arg_1] = EXC.function_clause unit
erlps__init_env__1 args =
  EXC.badarity (ErlangFun 1 erlps__init_env__1) args

erlps__infer__2 :: ErlangFun
erlps__infer__2 [(ErlangEmptyList), options_0] =
  let    _ = erlps__create_type_errors__0 []
  in let
    tup_el_3 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "src_file", options_0, ErlangAtom "no_file"]
  in let arg_1 = ErlangTuple [ErlangAtom "no_decls", tup_el_3]
  in let _ = erlps__type_error__1 [arg_1]
  in let arg_7 = erlps__init_env__1 [options_0]
  in erlps__destroy_and_report_type_errors__1 [arg_7]
erlps__infer__2 [contracts_0, options_1] =
  let _ = erlps__ets_init__0 []
  in
    EXC.tryCatchFinally
      (\ _ ->
         let    env_3 = erlps__init_env__1 [options_1]
         in let _ = erlps__create_options__1 [options_1]
         in let
           _ =
             erlps__ets_new__2
               [ErlangAtom "defined_contracts",
                ErlangCons (ErlangAtom "bag") ErlangEmptyList]
         in let
           _ =
             erlps__ets_new__2
               [ErlangAtom "type_vars",
                ErlangCons (ErlangAtom "set") ErlangEmptyList]
         in let _ = erlps__check_modifiers__2 [env_3, contracts_0]
         in let _ = erlps__create_type_errors__0 []
         in let
           contracts1_17 =
             erlps__identify_main_contract__2 [contracts_0, options_1]
         in let _ = erlps__destroy_and_report_type_errors__1 [env_3]
         in let
           matchExpr_25 =
             erlps__infer1__4
               [env_3, contracts1_17, ErlangEmptyList, options_1]
         in
           case matchExpr_25 of
             (ErlangTuple [env1_23, decls_24]) ->
               let   
                 case_26 =
                   BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
                     [ErlangAtom "dont_unfold", options_1, ErlangAtom "false"]
               in let
                 matchExpr_49 =
                   case case_26 of
                     (ErlangAtom "true") ->
                       ErlangTuple [env1_23, decls_24, decls_24]
                     (ErlangAtom "false") ->
                       let   
                         arg_34 =
                           ErlangFun 1
                             (let
                                lambda_35 [scope_37] =
                                  erlps__unfold_record_types__2
                                    [env1_23, scope_37]
                                lambda_35 [arg_36] = EXC.function_clause unit
                                lambda_35 args =
                                  EXC.badarity (ErlangFun 1 lambda_35) args
                              in lambda_35)
                       in let e_40 = erlps__on_scopes__2 [env1_23, arg_34]
                       in let
                         tup_el_43 =
                           erlps__unfold_record_types__2 [e_40, decls_24]
                       in ErlangTuple [e_40, decls_24, tup_el_43]
                     something_else -> EXC.case_clause something_else
               in
                 case matchExpr_49 of
                   (ErlangTuple [env2_46, declsfolded_47, declsunfolded_48]) ->
                     let
                       case_50 =
                         BIF.do_remote_fun_call "Proplists"
                           "erlps__get_value__3"
                           [ErlangAtom "return_env", options_1,
                            ErlangAtom "false"]
                     in
                       case case_50 of
                         (ErlangAtom "false") ->
                           ErlangTuple [declsfolded_47, declsunfolded_48]
                         (ErlangAtom "true") ->
                           ErlangTuple
                             [env2_46, declsfolded_47, declsunfolded_48]
                         something_else -> EXC.case_clause something_else
                   _ -> EXC.badmatch matchExpr_49
             _ -> EXC.badmatch matchExpr_25)
      (\ ex_60 -> EXC.raise ex_60) (\ _ -> erlps__clean_up_ets__0 [])
erlps__infer__2 [arg_62, arg_63] = EXC.function_clause unit
erlps__infer__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer__2) args

erlps__infer1__4 :: ErlangFun
erlps__infer1__4 [env_0, (ErlangEmptyList), acc_1, _options_2] =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in ErlangTuple [env_0, tup_el_4]
erlps__infer1__4 [env_0,
                  (ErlangCons (ErlangTuple [contract_1, ann_2, conname_3,
                                            code_4]) rest_5),
                  acc_6, options_7]
  | ((==) contract_1 (ErlangAtom "contract_main")) ||
      (((==) contract_1 (ErlangAtom "contract_interface")) ||
         ((==) contract_1 (ErlangAtom "contract_child"))) =
  let   
    _ =
      erlps__check_scope_name_clash__3
        [env_0, ErlangAtom "contract", conname_3]
  in let
    what_12 =
      case contract_1 of
        (ErlangAtom "contract_main") -> ErlangAtom "contract"
        (ErlangAtom "contract_child") -> ErlangAtom "contract"
        (ErlangAtom "contract_interface") ->
          ErlangAtom "contract_interface"
        something_else -> EXC.case_clause something_else
  in let
    _ =
      case what_12 of
        (ErlangAtom "contract") ->
          let    tup_el_16 = erlps__qname__1 [conname_3]
          in let arg_15 = ErlangTuple [tup_el_16]
          in erlps__ets_insert__2 [ErlangAtom "defined_contracts", arg_15]
        (ErlangAtom "contract_interface") -> ErlangAtom "ok"
        something_else -> EXC.case_clause something_else
  in let
    arg_18 =
      erlps__push_scope__3 [ErlangAtom "contract", conname_3, env_0]
  in let
    matchExpr_27 =
      erlps__infer_contract_top__4 [arg_18, what_12, code_4, options_7]
  in
    case matchExpr_27 of
      (ErlangTuple [env1_25, code1_26]) ->
        let   
          contract1_32 =
            ErlangTuple [contract_1, ann_2, conname_3, code1_26]
        in let env2_34 = erlps__pop_scope__1 [env1_25]
        in let env3_37 = erlps__bind_contract__2 [contract1_32, env2_34]
        in
          erlps__infer1__4
            [env3_37, rest_5, ErlangCons contract1_32 acc_6, options_7]
      _ -> EXC.badmatch matchExpr_27
erlps__infer1__4 [env_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "namespace"), ann_1,
                                            name_2, code_3]) rest_4),
                  acc_5, options_6]
  =
  let   
    _ =
      erlps__check_scope_name_clash__3
        [env_0, ErlangAtom "namespace", name_2]
  in let
    arg_10 =
      erlps__push_scope__3 [ErlangAtom "namespace", name_2, env_0]
  in let
    matchExpr_19 =
      erlps__infer_contract_top__4
        [arg_10, ErlangAtom "namespace", code_3, options_6]
  in
    case matchExpr_19 of
      (ErlangTuple [env1_17, code1_18]) ->
        let   
          namespace1_24 =
            ErlangTuple [ErlangAtom "namespace", ann_1, name_2, code1_18]
        in let arg_25 = erlps__pop_scope__1 [env1_17]
        in
          erlps__infer1__4
            [arg_25, rest_4, ErlangCons namespace1_24 acc_5, options_6]
      _ -> EXC.badmatch matchExpr_19
erlps__infer1__4 [env_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "pragma"), _,
                                            _]) rest_1),
                  acc_2, options_3]
  =
  erlps__infer1__4 [env_0, rest_1, acc_2, options_3]
erlps__infer1__4 [arg_8, arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__infer1__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer1__4) args

erlps__identify_main_contract__2 :: ErlangFun
erlps__identify_main_contract__2 [contracts_0, options_1] =
  let   
    children_6 =
      flmap
        (\ lc_4 ->
           case lc_4 of
             c_3@(ErlangTuple [(ErlangAtom "contract_child"), _, _, _]) ->
               ErlangCons c_3 ErlangEmptyList
             _ -> ErlangEmptyList)
        contracts_0
  in let
    mains_11 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             c_8@(ErlangTuple [(ErlangAtom "contract_main"), _, _, _]) ->
               ErlangCons c_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        contracts_0
  in
    case mains_11 of
      (ErlangEmptyList) ->
        case children_6 of
          (ErlangEmptyList) ->
            let   
              tup_el_16 =
                flmap
                  (\ lc_19 ->
                     case lc_19 of
                       (ErlangTuple [(ErlangAtom "src_file"), file_18]) ->
                         let lcRet_20 = ErlangTuple [ErlangAtom "file", file_18]
                         in ErlangCons lcRet_20 ErlangEmptyList
                       _ -> ErlangEmptyList)
                  options_1
            in let
              arg_14 =
                ErlangTuple [ErlangAtom "main_contract_undefined", tup_el_16]
            in erlps__type_error__1 [arg_14]
          (ErlangCons (ErlangTuple [(ErlangAtom "contract_child"), ann_23,
                                    con_24, body_25]) (ErlangEmptyList)) ->
            let    lop_26 = BIF.erlang__op_unAppend [contracts_0, children_6]
            in let
              head_30 =
                ErlangTuple
                  [ErlangAtom "contract_main", ann_23, con_24, body_25]
            in
              BIF.erlang__op_append
                [lop_26, ErlangCons head_30 ErlangEmptyList]
          (ErlangCons h_36 _) ->
            let   
              tup_el_39 =
                BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [h_36]
            in let
              arg_37 =
                ErlangTuple [ErlangAtom "ambiguous_main_contract", tup_el_39]
            in erlps__type_error__1 [arg_37]
          something_else -> EXC.case_clause something_else
      (ErlangCons _ (ErlangEmptyList)) ->
        let lop_41 = BIF.erlang__op_unAppend [contracts_0, mains_11]
        in BIF.erlang__op_append [lop_41, mains_11]
      (ErlangCons h_45 _) ->
        let   
          tup_el_48 =
            BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [h_45]
        in let
          arg_46 =
            ErlangTuple [ErlangAtom "multiple_main_contracts", tup_el_48]
        in erlps__type_error__1 [arg_46]
      something_else -> EXC.case_clause something_else
erlps__identify_main_contract__2 [arg_50, arg_51] =
  EXC.function_clause unit
erlps__identify_main_contract__2 args =
  EXC.badarity (ErlangFun 2 erlps__identify_main_contract__2) args

erlps__check_scope_name_clash__3 :: ErlangFun
erlps__check_scope_name_clash__3 [env_0, kind_1, name_2] =
  let    arg_5 = erlps__qname__1 [name_2]
  in let case_3 = erlps__get_scope__2 [env_0, arg_5]
  in
    case case_3 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      (ErlangTuple [(ErlangAtom "scope"), _, _, _, k_7, ann_8]) ->
        let    _ = erlps__create_type_errors__0 []
        in let
          arg_9 =
            ErlangTuple
              [ErlangAtom "duplicate_scope", kind_1, name_2, k_7, ann_8]
        in let _ = erlps__type_error__1 [arg_9]
        in erlps__destroy_and_report_type_errors__1 [env_0]
      something_else -> EXC.case_clause something_else
erlps__check_scope_name_clash__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__check_scope_name_clash__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_scope_name_clash__3) args

erlps__infer_contract_top__4 :: ErlangFun
erlps__infer_contract_top__4 [env_0, kind_1, defs0_2, options_3]
  =
  let    _ = erlps__create_type_errors__0 []
  in let defs_5 = erlps__desugar__1 [defs0_2]
  in let _ = erlps__destroy_and_report_type_errors__1 [env_0]
  in erlps__infer_contract__4 [env_0, kind_1, defs_5, options_3]
erlps__infer_contract_top__4 [arg_11, arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__infer_contract_top__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_contract_top__4) args

erlps__infer_contract__4 :: ErlangFun
erlps__infer_contract__4 [env0_0, what_1, defs0_2, options_3] =
  let    _ = erlps__create_type_errors__0 []
  in let defs01_5 = erlps__process_blocks__1 [defs0_2]
  in let
    case_6 =
      BIF.lists__member__2 [ErlangAtom "debug_mode", options_3]
  in let
    defs_11 =
      case case_6 of
        (ErlangAtom "true") ->
          erlps__expose_internals__2 [defs01_5, what_1]
        (ErlangAtom "false") -> defs01_5
        something_else -> EXC.case_clause something_else
  in let _ = erlps__destroy_and_report_type_errors__1 [env0_0]
  in let
    env_24 =
      case env0_0 of
        (ErlangTuple [(ErlangAtom "env"), scopes_15, vars_16,
                      typevars_17, fields_18, namespace_19, in_pattern_20,
                      stateful_21, current_function_22, what_23]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_15, vars_16, typevars_17, fields_18,
             namespace_19, in_pattern_20, stateful_21, current_function_22,
             what_1]
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    kind_27 =
      ErlangFun 1
        (let
           lambda_25 [(ErlangTuple [(ErlangAtom "type_def"), _, _, _, _])] =
             ErlangAtom "type"
           lambda_25 [(ErlangTuple [(ErlangAtom "letfun"), _, _, _, _, _])]
             =
             ErlangAtom "function"
           lambda_25 [(ErlangTuple [(ErlangAtom "fun_clauses"), _, _, _,
                                    _])]
             =
             ErlangAtom "function"
           lambda_25 [(ErlangTuple [(ErlangAtom "fun_decl"), _, _, _])] =
             ErlangAtom "prototype"
           lambda_25 [_] = ErlangAtom "unexpected"
           lambda_25 [arg_26] = EXC.function_clause unit
           lambda_25 args = EXC.badarity (ErlangFun 1 lambda_25) args
         in lambda_25)
  in let
    get_42 =
      ErlangFun 2
        (let
           lambda_28 [k_31, in_32] =
             flmap
               (\ lc_35 ->
                  let   
                    lop_37 =
                      BIF.erlang__apply__2
                        [kind_27, ErlangCons lc_35 ErlangEmptyList]
                  in let cond_36 = BIF.erlang__op_eq [lop_37, k_31]
                  in
                    case cond_36 of
                      (ErlangAtom "true") -> ErlangCons lc_35 ErlangEmptyList
                      _ -> ErlangEmptyList)
               in_32
           lambda_28 [arg_29, arg_30] = EXC.function_clause unit
           lambda_28 args = EXC.badarity (ErlangFun 2 lambda_28) args
         in lambda_28)
  in let
    arg_44 =
      BIF.erlang__apply__2
        [get_42,
         ErlangCons (ErlangAtom "type")
           (ErlangCons defs_11 ErlangEmptyList)]
  in let matchExpr_50 = erlps__check_typedefs__2 [env_24, arg_44]
  in
    case matchExpr_50 of
      (ErlangTuple [env1_48, typedefs_49]) ->
        let    _ = erlps__create_type_errors__0 []
        in let
          arg_51 =
            BIF.erlang__apply__2
              [get_42,
               ErlangCons (ErlangAtom "unexpected")
                 (ErlangCons defs_11 ErlangEmptyList)]
        in let _ = erlps__check_unexpected__1 [arg_51]
        in let
          env2_57 =
            case what_1 of
              (ErlangAtom "namespace") -> env1_48
              (ErlangAtom "contract_interface") -> env1_48
              (ErlangAtom "contract") -> erlps__bind_state__1 [env1_48]
              something_else -> EXC.case_clause something_else
        in let
          lcSrc_59 =
            BIF.erlang__apply__2
              [get_42,
               ErlangCons (ErlangAtom "prototype")
                 (ErlangCons defs_11 ErlangEmptyList)]
        in let
          arg_58 =
            flmap
              (\ lc_64 ->
                 let lcRet_65 = erlps__check_fundecl__2 [env1_48, lc_64]
                 in ErlangCons lcRet_65 ErlangEmptyList)
              lcSrc_59
        in let
          matchExpr_70 =
            BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_58]
        in
          case matchExpr_70 of
            (ErlangTuple [protosigs_68, decls_69]) ->
              let    env3_73 = erlps__bind_funs__2 [protosigs_68, env2_57]
              in let
                functions_77 =
                  BIF.erlang__apply__2
                    [get_42,
                     ErlangCons (ErlangAtom "function")
                       (ErlangCons defs_11 ErlangEmptyList)]
              in let
                funbind_94 =
                  ErlangFun 1
                    (let
                       lambda_78 [(ErlangTuple [(ErlangAtom "letfun"), ann_80,
                                                (ErlangTuple [(ErlangAtom "id"),
                                                              _, fun_81]),
                                                _, _, _])]
                         =
                         let
                           tup_el_83 =
                             ErlangTuple
                               [ErlangAtom "tuple_t", ann_80, ErlangEmptyList]
                         in ErlangTuple [fun_81, tup_el_83]
                       lambda_78 [(ErlangTuple [(ErlangAtom "fun_clauses"),
                                                ann_87,
                                                (ErlangTuple [(ErlangAtom "id"),
                                                              _, fun_88]),
                                                _, _])]
                         =
                         let
                           tup_el_90 =
                             ErlangTuple
                               [ErlangAtom "tuple_t", ann_87, ErlangEmptyList]
                         in ErlangTuple [fun_88, tup_el_90]
                       lambda_78 [arg_79] = EXC.function_clause unit
                       lambda_78 args =
                         EXC.badarity (ErlangFun 1 lambda_78) args
                     in lambda_78)
              in let
                funname_102 =
                  ErlangFun 1
                    (let
                       lambda_95 [def_97] =
                         let
                           matchExpr_101 =
                             BIF.erlang__apply__2
                               [funbind_94, ErlangCons def_97 ErlangEmptyList]
                         in
                           case matchExpr_101 of
                             (ErlangTuple [name_100, _]) -> name_100
                             _ -> EXC.badmatch matchExpr_101
                       lambda_95 [arg_96] = EXC.function_clause unit
                       lambda_95 args =
                         EXC.badarity (ErlangFun 1 lambda_95) args
                     in lambda_95)
              in let
                arg_103 =
                  BIF.do_remote_fun_call "Lists" "erlps__map__2"
                    [funbind_94, functions_77]
              in let
                head_117 =
                  ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
              in let
                val_110 =
                  ErlangTuple
                    [ErlangAtom "scope", ErlangEmptyList, ErlangEmptyList,
                     ErlangAtom "public", ErlangAtom "namespace",
                     ErlangCons head_117 ErlangEmptyList]
              in let
                tup_el_108 = ErlangMap (Map.singleton ErlangEmptyList val_110)
              in let tup_el_123 = ErlangMap Map.empty
              in let
                arg_106 =
                  ErlangTuple
                    [ErlangAtom "env", tup_el_108, ErlangEmptyList,
                     ErlangAtom "unrestricted", tup_el_123, ErlangEmptyList,
                     ErlangAtom "false", ErlangAtom "false", ErlangAtom "none",
                     ErlangAtom "top"]
              in let matchExpr_129 = erlps__bind_funs__2 [arg_103, arg_106]
              in let
                arg_130 =
                  flmap
                    (\ lc_133 ->
                       let   
                         tup_el_135 =
                           BIF.erlang__apply__2
                             [funname_102, ErlangCons lc_133 ErlangEmptyList]
                       in let lcRet_134 = ErlangTuple [tup_el_135, lc_133]
                       in ErlangCons lcRet_134 ErlangEmptyList)
                    functions_77
              in let funmap_139 = BIF.maps__from_list__1 [arg_130]
              in let _ = erlps__check_reserved_entrypoints__1 [funmap_139]
              in let
                arg_141 =
                  ErlangFun 2
                    (let
                       lambda_142 [_, def_145] =
                         BIF.do_remote_fun_call "Aeso.Syntax.Utils"
                           "erlps__used_ids__1" [def_145]
                       lambda_142 [arg_143, arg_144] = EXC.function_clause unit
                       lambda_142 args =
                         EXC.badarity (ErlangFun 2 lambda_142) args
                     in lambda_142)
              in let
                depgraph_148 =
                  BIF.do_remote_fun_call "Maps" "erlps__map__2"
                    [arg_141, funmap_139]
              in let
                sccs_150 =
                  BIF.do_remote_fun_call "Aeso.Utils" "erlps__scc__1"
                    [depgraph_148]
              in let
                matchExpr_157 =
                  erlps__check_sccs__4
                    [env3_73, funmap_139, sccs_150, ErlangEmptyList]
              in
                case matchExpr_157 of
                  (ErlangTuple [env4_155, defs1_156]) ->
                    let   
                      _ =
                        erlps__check_state_dependencies__2 [env4_155, defs1_156]
                    in let
                      _ = erlps__destroy_and_report_type_errors__1 [env4_155]
                    in let rop_164 = BIF.erlang__op_append [decls_69, defs1_156]
                    in let
                      tup_el_162 = BIF.erlang__op_append [typedefs_49, rop_164]
                    in ErlangTuple [env4_155, tup_el_162]
                  _ -> EXC.badmatch matchExpr_157
            _ -> EXC.badmatch matchExpr_70
      _ -> EXC.badmatch matchExpr_50
erlps__infer_contract__4 [arg_167, arg_168, arg_169, arg_170] =
  EXC.function_clause unit
erlps__infer_contract__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_contract__4) args

erlps__process_blocks__1 :: ErlangFun
erlps__process_blocks__1 [decls_0] =
  let
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "block"), ann_4, ds_5])] =
             erlps__process_block__2 [ann_4, ds_5]
           lambda_2 [decl_8] = ErlangCons decl_8 ErlangEmptyList
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
      [arg_1, decls_0]
erlps__process_blocks__1 [arg_12] = EXC.function_clause unit
erlps__process_blocks__1 args =
  EXC.badarity (ErlangFun 1 erlps__process_blocks__1) args

erlps__process_block__2 :: ErlangFun
erlps__process_block__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__process_block__2 [_,
                         (ErlangCons decl_0 (ErlangEmptyList))]
  =
  ErlangCons decl_0 ErlangEmptyList
erlps__process_block__2 [_ann_0, (ErlangCons decl_1 decls_2)] =
  let
    isthis_11 =
      ErlangFun 1
        (let
           lambda_3 [name_5] =
             ErlangFun 1
               (let
                  lambda_6 [(ErlangTuple [(ErlangAtom "letfun"), _,
                                          (ErlangTuple [(ErlangAtom "id"), _,
                                                        name1_8]),
                                          _, _, _])]
                    =
                    BIF.erlang__op_eq [name_5, name1_8]
                  lambda_6 [_] = ErlangAtom "false"
                  lambda_6 [arg_7] = EXC.function_clause unit
                  lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
                in lambda_6)
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in
    case decl_1 of
      (ErlangTuple [(ErlangAtom "fun_decl"), ann1_13,
                    id_15@(ErlangTuple [(ErlangAtom "id"), _, name_14]),
                    type_16]) ->
        let   
          arg_17 =
            BIF.erlang__apply__2
              [isthis_11, ErlangCons name_14 ErlangEmptyList]
        in let
          matchExpr_23 =
            BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
              [arg_17, decls_2]
        in
          case matchExpr_23 of
            (ErlangTuple [clauses_21, rest_22]) ->
              let   
                _ =
                  flmap
                    (\ lc_26 ->
                       let   
                         arg_28 =
                           ErlangTuple
                             [ErlangAtom "mismatched_decl_in_funblock", name_14,
                              lc_26]
                       in let lcRet_27 = erlps__type_error__1 [arg_28]
                       in ErlangCons lcRet_27 ErlangEmptyList)
                    rest_22
              in let
                head_32 =
                  ErlangTuple
                    [ErlangAtom "fun_clauses", ann1_13, id_15, type_16,
                     clauses_21]
              in ErlangCons head_32 ErlangEmptyList
            _ -> EXC.badmatch matchExpr_23
      (ErlangTuple [(ErlangAtom "letfun"), ann1_39,
                    id_41@(ErlangTuple [(ErlangAtom "id"), _, name_40]), _, _,
                    _]) ->
        let   
          arg_42 =
            BIF.erlang__apply__2
              [isthis_11, ErlangCons name_40 ErlangEmptyList]
        in let
          matchExpr_50 =
            BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
              [arg_42, ErlangCons decl_1 decls_2]
        in
          case matchExpr_50 of
            (ErlangTuple [clauses_48, rest_49]) ->
              let   
                _ =
                  flmap
                    (\ lc_53 ->
                       let   
                         arg_55 =
                           ErlangTuple
                             [ErlangAtom "mismatched_decl_in_funblock", name_40,
                              lc_53]
                       in let lcRet_54 = erlps__type_error__1 [arg_55]
                       in ErlangCons lcRet_54 ErlangEmptyList)
                    rest_49
              in let
                head_66 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
              in let tup_el_70 = toErl "_"
              in let
                tup_el_63 =
                  ErlangTuple
                    [ErlangAtom "id", ErlangCons head_66 ann1_39, tup_el_70]
              in let
                head_59 =
                  ErlangTuple
                    [ErlangAtom "fun_clauses", ann1_39, id_41, tup_el_63,
                     clauses_48]
              in ErlangCons head_59 ErlangEmptyList
            _ -> EXC.badmatch matchExpr_50
      something_else -> EXC.case_clause something_else
erlps__process_block__2 [arg_73, arg_74] =
  EXC.function_clause unit
erlps__process_block__2 args =
  EXC.badarity (ErlangFun 2 erlps__process_block__2) args

erlps__expose_internals__2 :: ErlangFun
erlps__expose_internals__2 [defs_0, what_1] =
  flmap
    (\ lc_4 ->
       let    arg_6 = toErl 2
       in let ann_8 = BIF.erlang__element__2 [arg_6, lc_4]
       in let
         newann_26 =
           case what_1 of
             (ErlangAtom "namespace") ->
               flmap
                 (\ lc_12 ->
                    let   
                      rop_15 =
                        ErlangTuple [ErlangAtom "private", ErlangAtom "true"]
                    in let cond_13 = BIF.erlang__op_neq [lc_12, rop_15]
                    in
                      case cond_13 of
                        (ErlangAtom "true") ->
                          let
                            cond_18 =
                              BIF.erlang__op_neq [lc_12, ErlangAtom "private"]
                          in
                            case cond_18 of
                              (ErlangAtom "true") ->
                                ErlangCons lc_12 ErlangEmptyList
                              _ -> ErlangEmptyList
                        _ -> ErlangEmptyList)
                 ann_8
             (ErlangAtom "contract") ->
               let
                 head_22 =
                   ErlangTuple [ErlangAtom "entrypoint", ErlangAtom "true"]
               in ErlangCons head_22 ann_8
             (ErlangAtom "contract_interface") -> ann_8
             something_else -> EXC.case_clause something_else
       in let arg_27 = toErl 2
       in let
         def1_30 = BIF.erlang__setelement__3 [arg_27, lc_4, newann_26]
       in let
         lcRet_5 =
           case def1_30 of
             (ErlangTuple [(ErlangAtom "fun_clauses"), ans_32, id_33, t_34,
                           clauses_35]) ->
               let tup_el_40 = erlps__expose_internals__2 [clauses_35, what_1]
               in
                 ErlangTuple
                   [ErlangAtom "fun_clauses", ans_32, id_33, t_34, tup_el_40]
             _ -> def1_30
       in ErlangCons lcRet_5 ErlangEmptyList)
    defs_0
erlps__expose_internals__2 [arg_43, arg_44] =
  EXC.function_clause unit
erlps__expose_internals__2 args =
  EXC.badarity (ErlangFun 2 erlps__expose_internals__2) args

erlps__check_typedefs__2 :: ErlangFun
erlps__check_typedefs__2 [env_1@(ErlangTuple [(ErlangAtom "env"),
                                              _, _, _, _, ns_0, _, _, _, _]),
                          defs_2]
  =
  let    _ = erlps__create_type_errors__0 []
  in let
    getname_6 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "type_def"), _,
                                   (ErlangTuple [(ErlangAtom "id"), _, name_5]),
                                   _, _])]
             =
             name_5
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    arg_7 =
      flmap
        (\ lc_10 ->
           let   
             tup_el_12 =
               BIF.erlang__apply__2
                 [getname_6, ErlangCons lc_10 ErlangEmptyList]
           in let lcRet_11 = ErlangTuple [tup_el_12, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        defs_2
  in let typemap_16 = BIF.maps__from_list__1 [arg_7]
  in let
    arg_17 =
      ErlangFun 2
        (let
           lambda_18 [_, def_21] =
             BIF.do_remote_fun_call "Aeso.Syntax.Utils" "erlps__used_types__2"
               [ns_0, def_21]
           lambda_18 [arg_19, arg_20] = EXC.function_clause unit
           lambda_18 args = EXC.badarity (ErlangFun 2 lambda_18) args
         in lambda_18)
  in let
    depgraph_25 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2"
        [arg_17, typemap_16]
  in let
    sccs_27 =
      BIF.do_remote_fun_call "Aeso.Utils" "erlps__scc__1" [depgraph_25]
  in let
    matchExpr_34 =
      erlps__check_typedef_sccs__4
        [env_1, typemap_16, sccs_27, ErlangEmptyList]
  in
    case matchExpr_34 of
      (ErlangTuple [env1_32, defs1_33]) ->
        let _ = erlps__destroy_and_report_type_errors__1 [env_1]
        in ErlangTuple [env1_32, defs1_33]
      _ -> EXC.badmatch matchExpr_34
erlps__check_typedefs__2 [arg_38, arg_39] =
  EXC.function_clause unit
erlps__check_typedefs__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_typedefs__2) args

erlps__check_typedef_sccs__4 :: ErlangFun
erlps__check_typedef_sccs__4 [env_0, _typemap_1,
                              (ErlangEmptyList), acc_2]
  =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
  in ErlangTuple [env_0, tup_el_4]
erlps__check_typedef_sccs__4 [env_0, typemap_1,
                              (ErlangCons (ErlangTuple [(ErlangAtom "acyclic"),
                                                        name_2]) sccs_3),
                              acc_4]
  =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_2, typemap_1, ErlangAtom "undefined"]
  in
    case case_5 of
      (ErlangAtom "undefined") ->
        erlps__check_typedef_sccs__4 [env_0, typemap_1, sccs_3, acc_4]
      (ErlangTuple [(ErlangAtom "type_def"), ann_13, d_14, xs_15,
                    def0_16]) ->
        let    arg_21 = erlps__bind_tvars__2 [xs_15, env_0]
        in let arg_20 = erlps__check_typedef__2 [arg_21, def0_16]
        in let
          def_25 = erlps__check_event__4 [env_0, name_2, ann_13, arg_20]
        in let
          head_26 =
            ErlangTuple [ErlangAtom "type_def", ann_13, d_14, xs_15, def_25]
        in let arg_36 = ErlangTuple [xs_15, def_25]
        in let
          env1_40 = erlps__bind_type__4 [name_2, ann_13, arg_36, env_0]
        in
          case def_25 of
            (ErlangTuple [(ErlangAtom "alias_t"), _]) ->
              erlps__check_typedef_sccs__4
                [env1_40, typemap_1, sccs_3, ErlangCons head_26 acc_4]
            (ErlangTuple [(ErlangAtom "record_t"), fields_46]) ->
              let    arg_48 = erlps__app_t__3 [ann_13, d_14, xs_15]
              in let recty_52 = erlps__check_type__2 [env1_40, arg_48]
              in let
                env2_57 =
                  erlps__check_fields__4
                    [env1_40, typemap_1, recty_52, fields_46]
              in
                erlps__check_typedef_sccs__4
                  [env2_57, typemap_1, sccs_3, ErlangCons head_26 acc_4]
            (ErlangTuple [(ErlangAtom "variant_t"), cons_62]) ->
              let    arg_64 = erlps__app_t__3 [ann_13, d_14, xs_15]
              in let target_68 = erlps__check_type__2 [env1_40, arg_64]
              in let
                contype_78 =
                  ErlangFun 1
                    (let
                       lambda_69 [(ErlangEmptyList)] = target_68
                       lambda_69 [args_71] =
                         ErlangTuple
                           [ErlangAtom "type_sig", ann_13, ErlangAtom "none",
                            ErlangEmptyList, args_71, target_68]
                       lambda_69 [arg_70] = EXC.function_clause unit
                       lambda_69 args =
                         EXC.badarity (ErlangFun 1 lambda_69) args
                     in lambda_69)
              in let
                contypes_90 =
                  flmap
                    (\ lc_81 ->
                       case lc_81 of
                         (ErlangTuple [(ErlangAtom "constr_t"), _,
                                       (ErlangTuple [(ErlangAtom "con"), _,
                                                     con_83]),
                                       args_84]) ->
                           let
                             tup_el_87 =
                               BIF.erlang__apply__2
                                 [contype_78,
                                  ErlangCons args_84 ErlangEmptyList]
                             lcRet_82 = ErlangTuple [con_83, tup_el_87]
                           in ErlangCons lcRet_82 ErlangEmptyList
                         _ -> EXC.badmatch lc_81)
                    cons_62
              in let
                arg_91 =
                  flmap
                    (\ lc_95 ->
                       case lc_95 of
                         (ErlangTuple [(ErlangAtom "constr_t"), _, con_93,
                                       args_94]) ->
                           let   
                             tup_el_98 =
                               BIF.erlang__apply__2
                                 [contype_78,
                                  ErlangCons args_94 ErlangEmptyList]
                           in let lcRet_96 = ErlangTuple [con_93, tup_el_98]
                           in ErlangCons lcRet_96 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    cons_62
              in let _ = erlps__check_repeated_constructors__1 [arg_91]
              in let
                _ =
                  flmap
                    (\ lc_103 ->
                       case lc_103 of
                         (ErlangTuple [(ErlangAtom "constr_t"), _, con_102,
                                       _]) ->
                           let
                             lcRet_104 =
                               erlps__check_constructor_overlap__3
                                 [env1_40, con_102, target_68]
                           in ErlangCons lcRet_104 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    cons_62
              in let arg_108 = erlps__bind_funs__2 [contypes_90, env1_40]
              in
                erlps__check_typedef_sccs__4
                  [arg_108, typemap_1, sccs_3, ErlangCons head_26 acc_4]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__check_typedef_sccs__4 [env_0, typemap_1,
                              (ErlangCons (ErlangTuple [(ErlangAtom "cyclic"),
                                                        names_2]) sccs_3),
                              acc_4]
  =
  let   
    id_12 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let matchExpr_11 = BIF.maps__get__2 [x_7, typemap_1]
             in
               case matchExpr_11 of
                 (ErlangTuple [(ErlangAtom "type_def"), _, d_10, _, _]) -> d_10
                 _ -> EXC.badmatch matchExpr_11
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in let
    tup_el_15 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [id_12, names_2]
  in let
    arg_13 =
      ErlangTuple
        [ErlangAtom "recursive_types_not_implemented", tup_el_15]
  in let _ = erlps__type_error__1 [arg_13]
  in erlps__check_typedef_sccs__4 [env_0, typemap_1, sccs_3, acc_4]
erlps__check_typedef_sccs__4 [arg_22, arg_23, arg_24, arg_25] =
  EXC.function_clause unit
erlps__check_typedef_sccs__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_typedef_sccs__4) args

erlps__check_typedef__2 :: ErlangFun
erlps__check_typedef__2 [env_0,
                         (ErlangTuple [(ErlangAtom "alias_t"), type_1])]
  =
  let tup_el_3 = erlps__check_type__2 [env_0, type_1]
  in ErlangTuple [ErlangAtom "alias_t", tup_el_3]
erlps__check_typedef__2 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fields_1])]
  =
  let
    tup_el_3 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [(ErlangAtom "field_t"), ann_5, id_6, type_7]) ->
               let    tup_el_13 = erlps__check_type__2 [env_0, type_7]
               in let
                 lcRet_9 =
                   ErlangTuple [ErlangAtom "field_t", ann_5, id_6, tup_el_13]
               in ErlangCons lcRet_9 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_1
  in ErlangTuple [ErlangAtom "record_t", tup_el_3]
erlps__check_typedef__2 [env_0,
                         (ErlangTuple [(ErlangAtom "variant_t"), cons_1])]
  =
  let
    tup_el_3 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [(ErlangAtom "constr_t"), ann_5, con_6, args_7]) ->
               let   
                 tup_el_13 =
                   flmap
                     (\ lc_16 ->
                        let lcRet_17 = erlps__check_type__2 [env_0, lc_16]
                        in ErlangCons lcRet_17 ErlangEmptyList)
                     args_7
               in let
                 lcRet_9 =
                   ErlangTuple [ErlangAtom "constr_t", ann_5, con_6, tup_el_13]
               in ErlangCons lcRet_9 ErlangEmptyList
             _ -> ErlangEmptyList)
        cons_1
  in ErlangTuple [ErlangAtom "variant_t", tup_el_3]
erlps__check_typedef__2 [arg_20, arg_21] =
  EXC.function_clause unit
erlps__check_typedef__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_typedef__2) args

erlps__check_unexpected__1 :: ErlangFun
erlps__check_unexpected__1 [xs_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__type_error__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    xs_0
erlps__check_unexpected__1 [arg_6] = EXC.function_clause unit
erlps__check_unexpected__1 args =
  EXC.badarity (ErlangFun 1 erlps__check_unexpected__1) args

erlps__check_modifiers__2 :: ErlangFun
erlps__check_modifiers__2 [env_0, contracts_1] =
  let    _ = erlps__create_type_errors__0 []
  in let _ = erlps__check_modifiers___2 [env_0, contracts_1]
  in erlps__destroy_and_report_type_errors__1 [env_0]
erlps__check_modifiers__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__check_modifiers__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_modifiers__2) args

erlps__check_modifiers___2 :: ErlangFun
erlps__check_modifiers___2 [env_0,
                            (ErlangCons (ErlangTuple [contract_1, _, con_2,
                                                      decls_3]) rest_4)]
  | ((==) contract_1 (ErlangAtom "contract_main")) ||
      (((==) contract_1 (ErlangAtom "contract_interface")) ||
         ((==) contract_1 (ErlangAtom "contract_child"))) =
  let   
    isinterface_7 =
      BIF.erlang__op_exactEq
        [contract_1, ErlangAtom "contract_interface"]
  in let
    _ = erlps__check_modifiers1__2 [ErlangAtom "contract", decls_3]
  in let arg_13 = toErl 1
  in let
    tup_el_11 =
      BIF.lists__keymember__3 [ErlangAtom "letfun", arg_13, decls_3]
  in let
    tup_el_15 =
      flmap
        (\ lc_18 ->
           let
             cond_19 =
               BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                 [ErlangAtom "entrypoint", lc_18, ErlangAtom "false"]
           in
             case cond_19 of
               (ErlangAtom "true") -> ErlangCons lc_18 ErlangEmptyList
               _ -> ErlangEmptyList)
        decls_3
  in let case_10 = ErlangTuple [tup_el_11, tup_el_15]
  in let
    _ =
      case case_10 of
        (ErlangTuple [(ErlangAtom "true"), (ErlangEmptyList)]) ->
          let
            arg_24 =
              ErlangTuple [ErlangAtom "contract_has_no_entrypoints", con_2]
          in erlps__type_error__1 [arg_24]
        _ | (==) (ErlangAtom "true") isinterface_7 ->
          let
            case_27 =
              flmap
                (\ lc_31 ->
                   case lc_31 of
                     (ErlangTuple [(ErlangAtom "letfun"), annf_29, id_30, _, _,
                                   _]) ->
                       let lcRet_32 = ErlangTuple [annf_29, id_30]
                       in ErlangCons lcRet_32 ErlangEmptyList
                     _ -> ErlangEmptyList)
                decls_3
          in
            case case_27 of
              (ErlangCons (ErlangTuple [annf_35, id_36]) _) ->
                let
                  arg_37 =
                    ErlangTuple
                      [ErlangAtom "definition_in_contract_interface", annf_35,
                       id_36]
                in erlps__type_error__1 [arg_37]
              (ErlangEmptyList) -> ErlangAtom "ok"
              something_else -> EXC.case_clause something_else
        _ -> ErlangAtom "ok"
  in erlps__check_modifiers___2 [env_0, rest_4]
erlps__check_modifiers___2 [env_0,
                            (ErlangCons (ErlangTuple [(ErlangAtom "namespace"),
                                                      _, _, decls_1]) rest_2)]
  =
  let
    _ = erlps__check_modifiers1__2 [ErlangAtom "namespace", decls_1]
  in erlps__check_modifiers___2 [env_0, rest_2]
erlps__check_modifiers___2 [env_0,
                            (ErlangCons (ErlangTuple [(ErlangAtom "pragma"),
                                                      ann_1, pragma_2]) rest_3)]
  =
  let _ = erlps__check_pragma__3 [env_0, ann_1, pragma_2]
  in erlps__check_modifiers___2 [env_0, rest_3]
erlps__check_modifiers___2 [env_0, (ErlangCons decl_1 rest_2)] =
  let   
    arg_3 = ErlangTuple [ErlangAtom "bad_top_level_decl", decl_1]
  in let _ = erlps__type_error__1 [arg_3]
  in erlps__check_modifiers___2 [env_0, rest_2]
erlps__check_modifiers___2 [_env_0, (ErlangEmptyList)] =
  ErlangAtom "ok"
erlps__check_modifiers___2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__check_modifiers___2 args =
  EXC.badarity (ErlangFun 2 erlps__check_modifiers___2) args

erlps__check_pragma__3 :: ErlangFun
erlps__check_pragma__3 [_env_0, ann_1,
                        (ErlangTuple [(ErlangAtom "compiler"), op_2, ver_3])]
  =
  let
    case_4 =
      BIF.do_remote_fun_call "Aeso.Compiler"
        "erlps__numeric_version__0" []
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "error"), err_5]) ->
        let
          arg_6 =
            ErlangTuple [ErlangAtom "failed_to_get_compiler_version", err_5]
        in erlps__type_error__1 [arg_6]
      (ErlangTuple [(ErlangAtom "ok"), version_9]) ->
        let   
          strip_22 =
            ErlangFun 1
              (let
                 lambda_10 [v_12] =
                   let   
                     arg_14 =
                       ErlangFun 1
                         (let
                            lambda_15 [x_17] =
                              let rop_19 = toErl 0
                              in BIF.erlang__op_eq [x_17, rop_19]
                            lambda_15 [arg_16] = EXC.function_clause unit
                            lambda_15 args =
                              EXC.badarity (ErlangFun 1 lambda_15) args
                          in lambda_15)
                   in let
                     arg_20 =
                       BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [v_12]
                   in let
                     arg_13 =
                       BIF.do_remote_fun_call "Lists" "erlps__dropwhile__2"
                         [arg_14, arg_20]
                   in
                     BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_13]
                 lambda_10 [arg_11] = EXC.function_clause unit
                 lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
               in lambda_10)
        in let
          head_27 =
            BIF.erlang__apply__2
              [strip_22, ErlangCons version_9 ErlangEmptyList]
        in let
          head_31 =
            BIF.erlang__apply__2 [strip_22, ErlangCons ver_3 ErlangEmptyList]
        in let
          case_23 =
            BIF.erlang__apply__3
              [ErlangAtom "erlang", op_2,
               ErlangCons head_27 (ErlangCons head_31 ErlangEmptyList)]
        in
          case case_23 of
            (ErlangAtom "true") -> ErlangAtom "ok"
            (ErlangAtom "false") ->
              let
                arg_35 =
                  ErlangTuple
                    [ErlangAtom "compiler_version_mismatch", ann_1, version_9,
                     op_2, ver_3]
              in erlps__type_error__1 [arg_35]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__check_pragma__3 [arg_41, arg_42, arg_43] =
  EXC.function_clause unit
erlps__check_pragma__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_pragma__3) args

erlps__check_modifiers1__2 :: ErlangFun
erlps__check_modifiers1__2 [what_0, decls_1] | isEList decls_1 =
  let
    matchExpr_8 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__check_modifiers1__2 [what_0, lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        decls_1
  in ErlangAtom "ok"
erlps__check_modifiers1__2 [what_0, decl_1]
  | (onElement (toErl 1) decl_1 weakEq (ErlangAtom "letfun")) ||
      (onElement (toErl 1) decl_1 weakEq (ErlangAtom "fun_decl")) =
  let   
    public_5 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "public", decl_1, ErlangAtom "false"]
  in let
    private_9 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "private", decl_1, ErlangAtom "false"]
  in let
    payable_13 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "payable", decl_1, ErlangAtom "false"]
  in let
    entrypoint_17 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "entrypoint", decl_1, ErlangAtom "false"]
  in let arg_19 = toErl 1
  in let lop_18 = BIF.erlang__element__2 [arg_19, decl_1]
  in let
    fundecl_22 = BIF.erlang__op_eq [lop_18, ErlangAtom "fun_decl"]
  in let arg_23 = toErl 3
  in let matchExpr_26 = BIF.erlang__element__2 [arg_23, decl_1]
  in
    case matchExpr_26 of
      (ErlangTuple [(ErlangAtom "id"), _, name_25]) ->
        let    rop_29 = toErl "init"
        in let lop_27 = BIF.erlang__op_eq [name_25, rop_29]
        in let
          isinit_32 =
            case lop_27 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") ->
                BIF.erlang__op_eq [what_0, ErlangAtom "contract"]
              _ -> EXC.badarg1 lop_27
        in let
          matchExpr_44 =
            case fundecl_22 of
              (ErlangAtom "true") ->
                let
                  cond_34 =
                    case private_9 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") -> BIF.erlang__not__1 [entrypoint_17]
                      _ -> EXC.badarg1 private_9
                in
                  case cond_34 of
                    (ErlangAtom "true") ->
                      let
                        cond_37 =
                          BIF.erlang__op_eq [what_0, ErlangAtom "contract"]
                      in
                        case cond_37 of
                          (ErlangAtom "true") ->
                            let   
                              arg_41 =
                                ErlangTuple
                                  [ErlangAtom "proto_must_be_entrypoint",
                                   decl_1]
                            in let lcRet_40 = erlps__type_error__1 [arg_41]
                            in ErlangCons lcRet_40 ErlangEmptyList
                          _ -> ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_53 =
            case fundecl_22 of
              (ErlangAtom "true") ->
                let cond_46 = BIF.erlang__op_eq [what_0, ErlangAtom "namespace"]
                in
                  case cond_46 of
                    (ErlangAtom "true") ->
                      let   
                        arg_50 =
                          ErlangTuple [ErlangAtom "proto_in_namespace", decl_1]
                      in let lcRet_49 = erlps__type_error__1 [arg_50]
                      in ErlangCons lcRet_49 ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let cond_54 = BIF.erlang__not__1 [entrypoint_17]
        in let
          matchExpr_61 =
            case cond_54 of
              (ErlangAtom "true") ->
                case isinit_32 of
                  (ErlangAtom "true") ->
                    let   
                      arg_58 =
                        ErlangTuple
                          [ErlangAtom "init_must_be_an_entrypoint", decl_1]
                    in let lcRet_57 = erlps__type_error__1 [arg_58]
                    in ErlangCons lcRet_57 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_68 =
            case payable_13 of
              (ErlangAtom "true") ->
                case isinit_32 of
                  (ErlangAtom "true") ->
                    let   
                      arg_65 =
                        ErlangTuple
                          [ErlangAtom "init_must_not_be_payable", decl_1]
                    in let lcRet_64 = erlps__type_error__1 [arg_65]
                    in ErlangCons lcRet_64 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_81 =
            case public_5 of
              (ErlangAtom "true") ->
                let cond_70 = BIF.erlang__not__1 [private_9]
                in
                  case cond_70 of
                    (ErlangAtom "true") ->
                      let cond_72 = BIF.erlang__not__1 [entrypoint_17]
                      in
                        case cond_72 of
                          (ErlangAtom "true") ->
                            let
                              cond_74 =
                                BIF.erlang__op_eq
                                  [what_0, ErlangAtom "contract"]
                            in
                              case cond_74 of
                                (ErlangAtom "true") ->
                                  let   
                                    arg_78 =
                                      ErlangTuple
                                        [ErlangAtom
                                           "public_modifier_in_contract",
                                         decl_1]
                                  in let
                                    lcRet_77 = erlps__type_error__1 [arg_78]
                                  in ErlangCons lcRet_77 ErlangEmptyList
                                _ -> ErlangEmptyList
                          _ -> ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_90 =
            case entrypoint_17 of
              (ErlangAtom "true") ->
                let cond_83 = BIF.erlang__op_eq [what_0, ErlangAtom "namespace"]
                in
                  case cond_83 of
                    (ErlangAtom "true") ->
                      let   
                        arg_87 =
                          ErlangTuple
                            [ErlangAtom "entrypoint_in_namespace", decl_1]
                      in let lcRet_86 = erlps__type_error__1 [arg_87]
                      in ErlangCons lcRet_86 ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_97 =
            case private_9 of
              (ErlangAtom "true") ->
                case entrypoint_17 of
                  (ErlangAtom "true") ->
                    let   
                      arg_94 =
                        ErlangTuple [ErlangAtom "private_entrypoint", decl_1]
                    in let lcRet_93 = erlps__type_error__1 [arg_94]
                    in ErlangCons lcRet_93 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_104 =
            case private_9 of
              (ErlangAtom "true") ->
                case public_5 of
                  (ErlangAtom "true") ->
                    let   
                      arg_101 =
                        ErlangTuple [ErlangAtom "private_and_public", decl_1]
                    in let lcRet_100 = erlps__type_error__1 [arg_101]
                    in ErlangCons lcRet_100 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in ErlangAtom "ok"
      _ -> EXC.badmatch matchExpr_26
erlps__check_modifiers1__2 [_, _] = ErlangAtom "ok"
erlps__check_modifiers1__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__check_modifiers1__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_modifiers1__2) args

erlps__check_type__2 :: ErlangFun
erlps__check_type__2 [env_0, t_1] =
  let arg_4 = toErl 0
  in erlps__check_type__3 [env_0, t_1, arg_4]
erlps__check_type__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__check_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_type__2) args

erlps__check_type__3 :: ErlangFun
erlps__check_type__3 [env_0,
                      t_1@(ErlangTuple [(ErlangAtom "tvar"), _, _]), arity_2]
  =
  let    rop_5 = toErl 0
  in let cond_3 = BIF.erlang__op_neq [arity_2, rop_5]
  in let
    _ =
      case cond_3 of
        (ErlangAtom "true") ->
          let   
            arg_7 = ErlangTuple [ErlangAtom "higher_kinded_typevar", t_1]
          in let lcRet_6 = erlps__type_error__1 [arg_7]
          in ErlangCons lcRet_6 ErlangEmptyList
        _ -> ErlangEmptyList
  in erlps__check_tvar__2 [env_0, t_1]
erlps__check_type__3 [_env_0,
                      x_3@(ErlangTuple [(ErlangAtom "id"), ann_1,
                                        (ErlangCons (ErlangInt num_2) (ErlangEmptyList))]),
                      arity_4]
  | (ErlangInt num_2) == (toErl 95) =
  let _ = erlps__ensure_base_type__2 [x_3, arity_4]
  in erlps__fresh_uvar__1 [ann_1]
erlps__check_type__3 [env_0, x_2@(ErlangTuple [tag_1, _, _]),
                      arity_3]
  | (((weakEq tag_1 (ErlangAtom "con")) ||
        (weakEq tag_1 (ErlangAtom "qcon"))) ||
       (weakEq tag_1 (ErlangAtom "id"))) ||
      (weakEq tag_1 (ErlangAtom "qid")) =
  let case_4 = erlps__lookup_type__2 [env_0, x_2]
  in
    case case_4 of
      (ErlangTuple [q_7, (ErlangTuple [_, def_8])]) ->
        let   
          arity1_13 =
            case def_8 of
              (ErlangTuple [(ErlangAtom "builtin"), ar_10]) -> ar_10
              (ErlangTuple [args_11, _]) -> BIF.erlang__length__1 [args_11]
              something_else -> EXC.case_clause something_else
        in let cond_14 = BIF.erlang__op_neq [arity_3, arity1_13]
        in let
          _ =
            case cond_14 of
              (ErlangAtom "true") ->
                let   
                  arg_18 =
                    ErlangTuple
                      [ErlangAtom "wrong_type_arguments", x_2, arity_3,
                       arity1_13]
                in let lcRet_17 = erlps__type_error__1 [arg_18]
                in ErlangCons lcRet_17 ErlangEmptyList
              _ -> ErlangEmptyList
        in erlps__set_qname__2 [q_7, x_2]
      (ErlangAtom "false") ->
        let    arg_25 = ErlangTuple [ErlangAtom "unbound_type", x_2]
        in let _ = erlps__type_error__1 [arg_25]
        in x_2
      something_else -> EXC.case_clause something_else
erlps__check_type__3 [env_0,
                      type_3@(ErlangTuple [(ErlangAtom "tuple_t"), ann_1,
                                           types_2]),
                      arity_4]
  =
  let    _ = erlps__ensure_base_type__2 [type_3, arity_4]
  in let
    tup_el_9 =
      flmap
        (\ lc_12 ->
           let    arg_16 = toErl 0
           in let lcRet_13 = erlps__check_type__3 [env_0, lc_12, arg_16]
           in ErlangCons lcRet_13 ErlangEmptyList)
        types_2
  in ErlangTuple [ErlangAtom "tuple_t", ann_1, tup_el_9]
erlps__check_type__3 [_env_0,
                      type_3@(ErlangTuple [(ErlangAtom "bytes_t"), _ann_1,
                                           _len_2]),
                      arity_4]
  =
  let _ = erlps__ensure_base_type__2 [type_3, arity_4]
  in type_3
erlps__check_type__3 [env_0,
                      (ErlangTuple [(ErlangAtom "app_t"), ann_1, type_2,
                                    types_3]),
                      arity_4]
  =
  let   
    types1_12 =
      flmap
        (\ lc_7 ->
           let    arg_11 = toErl 0
           in let lcRet_8 = erlps__check_type__3 [env_0, lc_7, arg_11]
           in ErlangCons lcRet_8 ErlangEmptyList)
        types_3
  in let rop_17 = BIF.erlang__length__1 [types_3]
  in let arg_15 = BIF.erlang__op_plus [arity_4, rop_17]
  in let type1_19 = erlps__check_type__3 [env_0, type_2, arg_15]
  in ErlangTuple [ErlangAtom "app_t", ann_1, type1_19, types1_12]
erlps__check_type__3 [env_0,
                      type_5@(ErlangTuple [(ErlangAtom "fun_t"), ann_1,
                                           namedargs_2, args_3, ret_4]),
                      arity_6]
  =
  let    _ = erlps__ensure_base_type__2 [type_5, arity_6]
  in let
    namedargs1_15 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__check_named_arg__2 [env_0, lc_11]
           in ErlangCons lcRet_12 ErlangEmptyList)
        namedargs_2
  in let
    args1_23 =
      flmap
        (\ lc_18 ->
           let    arg_22 = toErl 0
           in let lcRet_19 = erlps__check_type__3 [env_0, lc_18, arg_22]
           in ErlangCons lcRet_19 ErlangEmptyList)
        args_3
  in let arg_26 = toErl 0
  in let ret1_27 = erlps__check_type__3 [env_0, ret_4, arg_26]
  in
    ErlangTuple
      [ErlangAtom "fun_t", ann_1, namedargs1_15, args1_23, ret1_27]
erlps__check_type__3 [_env_0,
                      type_1@(ErlangTuple [(ErlangAtom "uvar"), _, _]), arity_2]
  =
  let _ = erlps__ensure_base_type__2 [type_1, arity_2]
  in type_1
erlps__check_type__3 [_env_0,
                      (ErlangTuple [(ErlangAtom "args_t"), ann_1, ts_2]), _]
  =
  let   
    arg_3 = ErlangTuple [ErlangAtom "new_tuple_syntax", ann_1, ts_2]
  in let _ = erlps__type_error__1 [arg_3]
  in ErlangTuple [ErlangAtom "tuple_t", ann_1, ts_2]
erlps__check_type__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__check_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_type__3) args

erlps__ensure_base_type__2 :: ErlangFun
erlps__ensure_base_type__2 [type_0, arity_1] =
  let    rop_4 = toErl 0
  in let cond_2 = BIF.erlang__op_neq [arity_1, rop_4]
  in let
    _ =
      case cond_2 of
        (ErlangAtom "true") ->
          let    tup_el_10 = toErl 0
          in let
            arg_6 =
              ErlangTuple
                [ErlangAtom "wrong_type_arguments", type_0, arity_1, tup_el_10]
          in let lcRet_5 = erlps__type_error__1 [arg_6]
          in ErlangCons lcRet_5 ErlangEmptyList
        _ -> ErlangEmptyList
  in ErlangAtom "ok"
erlps__ensure_base_type__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__ensure_base_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__ensure_base_type__2) args

erlps__check_named_arg__2 :: ErlangFun
erlps__check_named_arg__2 [env_0,
                           (ErlangTuple [(ErlangAtom "named_arg_t"), ann_1,
                                         id_2, type_3, default_4])]
  =
  let    type1_7 = erlps__check_type__2 [env_0, type_3]
  in let
    matchExpr_12 = erlps__check_expr__3 [env_0, default_4, type1_7]
  in
    case matchExpr_12 of
      (ErlangTuple [(ErlangAtom "typed"), _, default1_11, _]) ->
        ErlangTuple
          [ErlangAtom "named_arg_t", ann_1, id_2, type1_7, default1_11]
      _ -> EXC.badmatch matchExpr_12
erlps__check_named_arg__2 [arg_18, arg_19] =
  EXC.function_clause unit
erlps__check_named_arg__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_named_arg__2) args

erlps__check_fields__4 :: ErlangFun
erlps__check_fields__4 [env_0, _typemap_1, _, (ErlangEmptyList)]
  =
  env_0
erlps__check_fields__4 [env_0, typemap_1, recty_2,
                        (ErlangCons (ErlangTuple [(ErlangAtom "field_t"), ann_3,
                                                  id_4, type_5]) fields_6)]
  =
  let    arg_7 = erlps__name__1 [id_4]
  in let
    arg_9 =
      ErlangTuple
        [ErlangAtom "field_info", ann_3, type_5, recty_2,
         ErlangAtom "record"]
  in let env1_16 = erlps__bind_field__3 [arg_7, arg_9, env_0]
  in erlps__check_fields__4 [env1_16, typemap_1, recty_2, fields_6]
erlps__check_fields__4 [arg_21, arg_22, arg_23, arg_24] =
  EXC.function_clause unit
erlps__check_fields__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_fields__4) args

erlps__check_event__4 :: ErlangFun
erlps__check_event__4 [env_0,
                       (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList)))))),
                       ann_6, def_7]
  | (ErlangInt num_1) == (toErl 101)
  , (ErlangInt num_2) == (toErl 118)
  , (ErlangInt num_3) == (toErl 101)
  , (ErlangInt num_4) == (toErl 110)
  , (ErlangInt num_5) == (toErl 116) =
  case def_7 of
    (ErlangTuple [(ErlangAtom "variant_t"), cons_9]) ->
      let
        tup_el_11 =
          flmap
            (\ lc_14 ->
               let lcRet_15 = erlps__check_event_con__2 [env_0, lc_14]
               in ErlangCons lcRet_15 ErlangEmptyList)
            cons_9
      in ErlangTuple [ErlangAtom "variant_t", tup_el_11]
    _ ->
      let   
        arg_18 =
          ErlangTuple [ErlangAtom "event_must_be_variant_type", ann_6]
      in let _ = erlps__type_error__1 [arg_18]
      in def_7
erlps__check_event__4 [_env_0, _name_1, _ann_2, def_3] = def_3
erlps__check_event__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__check_event__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_event__4) args

erlps__check_event_con__2 :: ErlangFun
erlps__check_event_con__2 [env_0,
                           (ErlangTuple [(ErlangAtom "constr_t"), ann_1, con_2,
                                         args_3])]
  =
  let   
    isindexed_27 =
      ErlangFun 1
        (let
           lambda_4 [t_6] =
             let    t1_9 = erlps__unfold_types_in_type__2 [env_0, t_6]
             in let tup_el_11 = erlps__is_word_type__1 [t1_9]
             in let tup_el_13 = erlps__is_string_type__1 [t1_9]
             in let
               tup_el_15 =
                 BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                   [ErlangAtom "indexed", t_6, ErlangAtom "false"]
             in let case_10 = ErlangTuple [tup_el_11, tup_el_13, tup_el_15]
             in
               case case_10 of
                 (ErlangTuple [(ErlangAtom "true"), _, _]) ->
                   ErlangAtom "indexed"
                 (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "true"),
                               (ErlangAtom "true")]) ->
                   let
                     arg_19 =
                       ErlangTuple
                         [ErlangAtom "indexed_type_must_be_word", t_6, t1_9]
                   in erlps__type_error__1 [arg_19]
                 (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "true"), _]) ->
                   ErlangAtom "notindexed"
                 (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "false"),
                               _]) ->
                   let   
                     arg_23 =
                       ErlangTuple
                         [ErlangAtom "event_arg_type_word_or_string", t_6, t1_9]
                   in let _ = erlps__type_error__1 [arg_23]
                   in ErlangAtom "error"
                 something_else -> EXC.case_clause something_else
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    indices_30 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [isindexed_27, args_3]
  in let
    indexed_40 =
      flmap
        (\ lc_33 ->
           let   
             lop_35 =
               BIF.erlang__apply__2
                 [isindexed_27, ErlangCons lc_33 ErlangEmptyList]
           in let cond_34 = BIF.erlang__op_eq [lop_35, ErlangAtom "indexed"]
           in
             case cond_34 of
               (ErlangAtom "true") -> ErlangCons lc_33 ErlangEmptyList
               _ -> ErlangEmptyList)
        args_3
  in let
    nonindexed_43 = BIF.erlang__op_unAppend [args_3, indexed_40]
  in let lop_45 = BIF.erlang__length__1 [indexed_40]
  in let rop_47 = toErl 3
  in let cond_44 = BIF.erlang__op_greater [lop_45, rop_47]
  in let
    _ =
      case cond_44 of
        (ErlangAtom "true") ->
          let   
            arg_49 =
              ErlangTuple [ErlangAtom "event_0_to_3_indexed_values", con_2]
          in let lcRet_48 = erlps__type_error__1 [arg_49]
          in ErlangCons lcRet_48 ErlangEmptyList
        _ -> ErlangEmptyList
  in let lop_53 = BIF.erlang__length__1 [nonindexed_43]
  in let rop_55 = toErl 1
  in let cond_52 = BIF.erlang__op_greater [lop_53, rop_55]
  in let
    _ =
      case cond_52 of
        (ErlangAtom "true") ->
          let   
            arg_57 =
              ErlangTuple [ErlangAtom "event_0_to_1_string_values", con_2]
          in let lcRet_56 = erlps__type_error__1 [arg_57]
          in ErlangCons lcRet_56 ErlangEmptyList
        _ -> ErlangEmptyList
  in let head_62 = ErlangTuple [ErlangAtom "indices", indices_30]
  in
    ErlangTuple
      [ErlangAtom "constr_t", ErlangCons head_62 ann_1, con_2, args_3]
erlps__check_event_con__2 [arg_68, arg_69] =
  EXC.function_clause unit
erlps__check_event_con__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_event_con__2) args

erlps__is_word_type__1 :: ErlangFun
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "id"), _,
                                      name_0])]
  =
  let    head_3 = toErl "int"
  in let head_5 = toErl "address"
  in let head_7 = toErl "hash"
  in let head_9 = toErl "bits"
  in let head_11 = toErl "bool"
  in
    BIF.lists__member__2
      [name_0,
       ErlangCons head_3
         (ErlangCons head_5
            (ErlangCons head_7
               (ErlangCons head_9 (ErlangCons head_11 ErlangEmptyList))))]
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "app_t"), _,
                                      (ErlangTuple [(ErlangAtom "id"), _,
                                                    name_0]),
                                      (ErlangCons _ (ErlangCons _ (ErlangEmptyList)))])]
  =
  let    head_3 = toErl "oracle"
  in let head_5 = toErl "oracle_query"
  in
    BIF.lists__member__2
      [name_0, ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)]
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _,
                                      n_0])]
  =
  let rop_2 = toErl 32
  in BIF.erlang__op_lesserEq [n_0, rop_2]
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "con"), _, _])]
  =
  ErlangAtom "true"
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "qcon"), _,
                                      _])]
  =
  ErlangAtom "true"
erlps__is_word_type__1 [_] = ErlangAtom "false"
erlps__is_word_type__1 [arg_0] = EXC.function_clause unit
erlps__is_word_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_word_type__1) args

erlps__is_string_type__1 :: ErlangFun
erlps__is_string_type__1 [(ErlangTuple [(ErlangAtom "id"), _,
                                        (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList)))))))])]
  | (ErlangInt num_0) == (toErl 115)
  , (ErlangInt num_1) == (toErl 116)
  , (ErlangInt num_2) == (toErl 114)
  , (ErlangInt num_3) == (toErl 105)
  , (ErlangInt num_4) == (toErl 110)
  , (ErlangInt num_5) == (toErl 103) =
  ErlangAtom "true"
erlps__is_string_type__1 [(ErlangTuple [(ErlangAtom "bytes_t"),
                                        _, n_0])]
  =
  let rop_2 = toErl 32
  in BIF.erlang__op_greater [n_0, rop_2]
erlps__is_string_type__1 [_] = ErlangAtom "false"
erlps__is_string_type__1 [arg_0] = EXC.function_clause unit
erlps__is_string_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_string_type__1) args

erlps__check_constructor_overlap__3 :: ErlangFun
erlps__check_constructor_overlap__3 [env_0,
                                     con_3@(ErlangTuple [(ErlangAtom "con"),
                                                         ann_1, name_2]),
                                     newtype_4]
  =
  let
    case_5 =
      erlps__lookup_env__4 [env_0, ErlangAtom "term", ann_1, name_2]
  in
    case case_5 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      (ErlangTuple [_, (ErlangTuple [ann_10, type_11])]) | ann_10 ==
                                                             ann_1 ->
        let   
          oldtype_14 =
            case type_11 of
              (ErlangTuple [(ErlangAtom "type_sig"), _, _, _, _, t_13]) -> t_13
              _ -> type_11
        in let oldcon_18 = ErlangTuple [ErlangAtom "con", ann_1, name_2]
        in let head_22 = ErlangTuple [oldcon_18, oldtype_14]
        in let head_26 = ErlangTuple [con_3, newtype_4]
        in let
          arg_19 =
            ErlangTuple
              [ErlangAtom "repeated_constructor",
               ErlangCons head_22 (ErlangCons head_26 ErlangEmptyList)]
        in erlps__type_error__1 [arg_19]
      something_else -> EXC.case_clause something_else
erlps__check_constructor_overlap__3 [arg_30, arg_31, arg_32] =
  EXC.function_clause unit
erlps__check_constructor_overlap__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_constructor_overlap__3)
    args

erlps__check_repeated_constructors__1 :: ErlangFun
erlps__check_repeated_constructors__1 [cons_0] =
  let   
    names_5 =
      flmap
        (\ lc_3 ->
           case lc_3 of
             (ErlangTuple [(ErlangTuple [(ErlangAtom "con"), _, name_2]),
                           _]) ->
               ErlangCons name_2 ErlangEmptyList
             _ -> ErlangEmptyList)
        cons_0
  in let
    rop_8 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [names_5]
  in let arg_6 = BIF.erlang__op_unAppend [names_5, rop_8]
  in let
    duplicated_10 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_6]
  in let
    fail_25 =
      ErlangFun 1
        (let
           lambda_11 [name_13] =
             let   
               tup_el_16 =
                 flmap
                   (\ lc_20 ->
                      case lc_20 of
                        ct_19@(ErlangTuple [(ErlangTuple [(ErlangAtom "con"), _,
                                                          c_18]),
                                            _]) ->
                          let cond_21 = BIF.erlang__op_eq [c_18, name_13]
                          in
                            case cond_21 of
                              (ErlangAtom "true") ->
                                ErlangCons ct_19 ErlangEmptyList
                              _ -> ErlangEmptyList
                        _ -> ErlangEmptyList)
                   cons_0
             in let
               arg_14 =
                 ErlangTuple [ErlangAtom "repeated_constructor", tup_el_16]
             in erlps__type_error__1 [arg_14]
           lambda_11 [arg_12] = EXC.function_clause unit
           lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
         in lambda_11)
  in let
    _ =
      flmap
        (\ lc_28 ->
           let
             lcRet_29 =
               BIF.erlang__apply__2 [fail_25, ErlangCons lc_28 ErlangEmptyList]
           in ErlangCons lcRet_29 ErlangEmptyList)
        duplicated_10
  in ErlangAtom "ok"
erlps__check_repeated_constructors__1 [arg_32] =
  EXC.function_clause unit
erlps__check_repeated_constructors__1 args =
  EXC.badarity (ErlangFun 1 erlps__check_repeated_constructors__1)
    args

erlps__check_sccs__4 :: ErlangFun
erlps__check_sccs__4 [env_0, _, (ErlangEmptyList), acc_1] =
  let
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in ErlangTuple [env_0, tup_el_3]
erlps__check_sccs__4 [env_0@(ErlangTuple [(ErlangAtom "env"), _,
                                          _, _, _, _, _, _, _, _]),
                      funs_1,
                      (ErlangCons (ErlangTuple [(ErlangAtom "acyclic"),
                                                x_2]) sccs_3),
                      acc_4]
  =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [x_2, funs_1, ErlangAtom "undefined"]
  in
    case case_5 of
      (ErlangAtom "undefined") ->
        erlps__check_sccs__4 [env_0, funs_1, sccs_3, acc_4]
      def_13 ->
        let matchExpr_18 = erlps__infer_nonrec__2 [env_0, def_13]
        in
          case matchExpr_18 of
            (ErlangTuple [(ErlangTuple [_, typesig_16]), def1_17]) ->
              let env1_22 = erlps__bind_fun__3 [x_2, typesig_16, env_0]
              in
                erlps__check_sccs__4
                  [env1_22, funs_1, sccs_3, ErlangCons def1_17 acc_4]
            _ -> EXC.badmatch matchExpr_18
erlps__check_sccs__4 [env_0@(ErlangTuple [(ErlangAtom "env"), _,
                                          _, _, _, _, _, _, _, _]),
                      funs_1,
                      (ErlangCons (ErlangTuple [(ErlangAtom "cyclic"),
                                                xs_2]) sccs_3),
                      acc_4]
  =
  let   
    defs_11 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = BIF.maps__get__2 [lc_7, funs_1]
           in ErlangCons lcRet_8 ErlangEmptyList)
        xs_2
  in let matchExpr_16 = erlps__infer_letrec__2 [env_0, defs_11]
  in
    case matchExpr_16 of
      (ErlangTuple [typesigs_14, defs1_15]) ->
        let    env1_19 = erlps__bind_funs__2 [typesigs_14, env_0]
        in let arg_23 = BIF.erlang__op_append [defs1_15, acc_4]
        in erlps__check_sccs__4 [env1_19, funs_1, sccs_3, arg_23]
      _ -> EXC.badmatch matchExpr_16
erlps__check_sccs__4 [arg_26, arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__check_sccs__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_sccs__4) args

erlps__check_reserved_entrypoints__1 :: ErlangFun
erlps__check_reserved_entrypoints__1 [funs_0] =
  let    head_1 = toErl "address"
  in let lcSrc_4 = BIF.maps__to_list__1 [funs_0]
  in let
    matchExpr_17 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [name_6, def_7]) ->
               let
                 cond_9 =
                   BIF.lists__member__2
                     [name_6, ErlangCons head_1 ErlangEmptyList]
               in
                 case cond_9 of
                   (ErlangAtom "true") ->
                     let   
                       arg_13 =
                         ErlangTuple
                           [ErlangAtom "reserved_entrypoint", name_6, def_7]
                     in let lcRet_12 = erlps__type_error__1 [arg_13]
                     in ErlangCons lcRet_12 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_4
  in ErlangAtom "ok"
erlps__check_reserved_entrypoints__1 [arg_18] =
  EXC.function_clause unit
erlps__check_reserved_entrypoints__1 args =
  EXC.badarity (ErlangFun 1 erlps__check_reserved_entrypoints__1)
    args

erlps__check_fundecl__2 :: ErlangFun
erlps__check_fundecl__2 [env_0,
                         (ErlangTuple [(ErlangAtom "fun_decl"), ann_1,
                                       id_3@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_2]),
                                       type_4@(ErlangTuple [(ErlangAtom "fun_t"),
                                                            _, _, _, _])])]
  =
  let matchExpr_10 = erlps__check_type__2 [env_0, type_4]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangAtom "fun_t"), _, named_7, args_8,
                    ret_9]) ->
        let   
          tup_el_14 =
            ErlangTuple
              [ErlangAtom "type_sig", ann_1, ErlangAtom "none", named_7,
               args_8, ret_9]
        in let tup_el_12 = ErlangTuple [name_2, tup_el_14]
        in let
          tup_el_21 =
            ErlangTuple [ErlangAtom "fun_decl", ann_1, id_3, matchExpr_10]
        in ErlangTuple [tup_el_12, tup_el_21]
      _ -> EXC.badmatch matchExpr_10
erlps__check_fundecl__2 [env_0,
                         (ErlangTuple [(ErlangAtom "fun_decl"), ann_1,
                                       id_3@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_2]),
                                       type_4])]
  =
  let   
    arg_5 =
      ErlangTuple
        [ErlangAtom "fundecl_must_have_funtype", ann_1, id_3, type_4]
  in let _ = erlps__type_error__1 [arg_5]
  in let
    tup_el_12 =
      ErlangTuple
        [ErlangAtom "type_sig", ann_1, ErlangAtom "none",
         ErlangEmptyList, ErlangEmptyList, type_4]
  in let tup_el_10 = ErlangTuple [name_2, tup_el_12]
  in let tup_el_19 = erlps__check_type__2 [env_0, type_4]
  in ErlangTuple [tup_el_10, tup_el_19]
erlps__check_fundecl__2 [arg_22, arg_23] =
  EXC.function_clause unit
erlps__check_fundecl__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_fundecl__2) args

erlps__infer_nonrec__2 :: ErlangFun
erlps__infer_nonrec__2 [env_0, letfun_1] =
  let    _ = erlps__create_constraints__0 []
  in let newletfun_4 = erlps__infer_letfun__2 [env_0, letfun_1]
  in let _ = erlps__check_special_funs__2 [env_0, newletfun_4]
  in let
    _ = erlps__destroy_and_report_unsolved_constraints__1 [env_0]
  in let matchExpr_10 = erlps__instantiate__1 [newletfun_4]
  in
    case matchExpr_10 of
      (ErlangTuple [typesig_9, _]) ->
        let _ = erlps__print_typesig__1 [typesig_9]
        in matchExpr_10
      _ -> EXC.badmatch matchExpr_10
erlps__infer_nonrec__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__infer_nonrec__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_nonrec__2) args

erlps__check_special_funs__2 :: ErlangFun
erlps__check_special_funs__2 [env_0,
                              (ErlangTuple [(ErlangTuple [(ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangEmptyList))))),
                                                          type_5]),
                                            _])]
  | (ErlangInt num_1) == (toErl 105)
  , (ErlangInt num_2) == (toErl 110)
  , (ErlangInt num_3) == (toErl 105)
  , (ErlangInt num_4) == (toErl 116) =
  case type_5 of
    (ErlangTuple [(ErlangAtom "type_sig"), ann_6, _constr_7,
                  _named_8, _args_9, res_10]) ->
      let    tup_el_17 = toErl "state"
      in let
        arg_14 =
          ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_17]
      in let case_12 = erlps__lookup_type__2 [env_0, arg_14]
      in let
        state_29 =
          case case_12 of
            (ErlangAtom "false") ->
              let
                head_20 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
              in
                ErlangTuple
                  [ErlangAtom "tuple_t", ErlangCons head_20 ErlangEmptyList,
                   ErlangEmptyList]
            (ErlangTuple [s_25, _]) ->
              ErlangTuple [ErlangAtom "qid", ErlangEmptyList, s_25]
            something_else -> EXC.case_clause something_else
      in let
        arg_33 = ErlangTuple [ErlangAtom "checking_init_type", ann_6]
      in erlps__unify__4 [env_0, res_10, state_29, arg_33]
    _ -> EXC.badmatch type_5
erlps__check_special_funs__2 [_, _] = ErlangAtom "ok"
erlps__check_special_funs__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__check_special_funs__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_special_funs__2) args

erlps__typesig_to_fun_t__1 :: ErlangFun
erlps__typesig_to_fun_t__1 [(ErlangTuple [(ErlangAtom "type_sig"),
                                          ann_0, _constr_1, named_2, args_3,
                                          res_4])]
  =
  ErlangTuple [ErlangAtom "fun_t", ann_0, named_2, args_3, res_4]
erlps__typesig_to_fun_t__1 [arg_10] = EXC.function_clause unit
erlps__typesig_to_fun_t__1 args =
  EXC.badarity (ErlangFun 1 erlps__typesig_to_fun_t__1) args

erlps__infer_letrec__2 :: ErlangFun
erlps__infer_letrec__2 [env_0, defs_1] =
  let    _ = erlps__create_constraints__0 []
  in let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "letfun"), _,
                                   (ErlangTuple [(ErlangAtom "id"), ann_5,
                                                 name_6]),
                                   _, _, _])]
             =
             let tup_el_8 = erlps__fresh_uvar__1 [ann_5]
             in ErlangTuple [name_6, tup_el_8]
           lambda_3 [(ErlangTuple [(ErlangAtom "fun_clauses"), _,
                                   (ErlangTuple [(ErlangAtom "id"), ann_10,
                                                 name_11]),
                                   _, _])]
             =
             let tup_el_13 = erlps__fresh_uvar__1 [ann_10]
             in ErlangTuple [name_11, tup_el_13]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    funs_16 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_2, defs_1]
  in let extendenv_19 = erlps__bind_funs__2 [funs_16, env_0]
  in let
    inferred_55 =
      flmap
        (\ lc_22 ->
           let matchExpr_28 = erlps__infer_letfun__2 [extendenv_19, lc_22]
           in
             case matchExpr_28 of
               (ErlangTuple [(ErlangTuple [name_26, typesig_27]), _]) ->
                 let   
                   got_32 =
                     BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
                       [name_26, funs_16]
                 in let expect_34 = erlps__typesig_to_fun_t__1 [typesig_27]
                 in let
                   arg_38 =
                     ErlangTuple
                       [ErlangAtom "check_typesig", name_26, got_32, expect_34]
                 in let _ = erlps__unify__4 [env_0, got_32, expect_34, arg_38]
                 in let _ = erlps__solve_field_constraints__1 [env_0]
                 in let
                   arg_45 =
                     ErlangFun 0
                       (let
                          lambda_46 [] =
                            let    arg_47 = toErl "Checked ~s : ~s\n"
                            in let arg_52 = erlps__dereference_deep__1 [got_32]
                            in let head_51 = erlps__pp__1 [arg_52]
                            in
                              BIF.do_remote_fun_call "Erlang.Io"
                                "erlps__format__2"
                                [arg_47,
                                 ErlangCons name_26
                                   (ErlangCons head_51 ErlangEmptyList)]
                          lambda_46 [] = EXC.function_clause unit
                          lambda_46 args =
                            EXC.badarity (ErlangFun 0 lambda_46) args
                        in lambda_46)
                 in let
                   _ = erlps__when_option__2 [ErlangAtom "pp_types", arg_45]
                 in ErlangCons matchExpr_28 ErlangEmptyList
               _ -> EXC.badmatch matchExpr_28)
        defs_1
  in let
    _ = erlps__destroy_and_report_unsolved_constraints__1 [env_0]
  in let
    arg_57 =
      flmap
        (\ lc_60 ->
           case lc_60 of
             (ErlangTuple [sig_59, _]) -> ErlangCons sig_59 ErlangEmptyList
             _ -> ErlangEmptyList)
        inferred_55
  in let typesigs_62 = erlps__instantiate__1 [arg_57]
  in let
    arg_63 =
      flmap
        (\ lc_66 ->
           case lc_66 of
             (ErlangTuple [_, d_65]) -> ErlangCons d_65 ErlangEmptyList
             _ -> ErlangEmptyList)
        inferred_55
  in let newdefs_68 = erlps__instantiate__1 [arg_63]
  in let
    _ =
      flmap
        (\ lc_71 ->
           let lcRet_72 = erlps__print_typesig__1 [lc_71]
           in ErlangCons lcRet_72 ErlangEmptyList)
        typesigs_62
  in ErlangTuple [typesigs_62, newdefs_68]
erlps__infer_letrec__2 [arg_76, arg_77] =
  EXC.function_clause unit
erlps__infer_letrec__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_letrec__2) args

erlps__infer_letfun__2 :: ErlangFun
erlps__infer_letfun__2 [env_0,
                        (ErlangTuple [(ErlangAtom "fun_clauses"), ann_1,
                                      fun_3@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_2]),
                                      type_4, clauses_5])]
  =
  let    type1_8 = erlps__check_type__2 [env_0, type_4]
  in let
    arg_9 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__infer_letfun1__2 [env_0, lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        clauses_5
  in let
    matchExpr_18 =
      BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_9]
  in
    case matchExpr_18 of
      (ErlangTuple [namesigs_16, clauses1_17]) ->
        let
          matchExpr_22 =
            BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [namesigs_16]
        in
          case matchExpr_22 of
            (ErlangTuple [_, sigs_21@(ErlangCons sig_20 _)]) ->
              let   
                matchExpr_37 =
                  flmap
                    (\ lc_25 ->
                       let    clauset_28 = erlps__typesig_to_fun_t__1 [lc_25]
                       in let
                         arg_32 =
                           ErlangTuple
                             [ErlangAtom "check_typesig", name_2, clauset_28,
                              type1_8]
                         lcRet_26 =
                           erlps__unify__4 [env_0, clauset_28, type1_8, arg_32]
                       in ErlangCons lcRet_26 ErlangEmptyList)
                    sigs_21
              in let tup_el_38 = ErlangTuple [name_2, sig_20]
              in let
                tup_el_41 =
                  erlps__desugar_clauses__4 [ann_1, fun_3, sig_20, clauses1_17]
              in ErlangTuple [tup_el_38, tup_el_41]
            _ -> EXC.badmatch matchExpr_22
      _ -> EXC.badmatch matchExpr_18
erlps__infer_letfun__2 [env_0,
                        letfun_3@(ErlangTuple [(ErlangAtom "letfun"), ann_1,
                                               fun_2, _, _, _])]
  =
  let matchExpr_9 = erlps__infer_letfun1__2 [env_0, letfun_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangTuple [name_6, sig_7]), clause_8]) ->
        let    tup_el_10 = ErlangTuple [name_6, sig_7]
        in let
          tup_el_13 =
            erlps__desugar_clauses__4
              [ann_1, fun_2, sig_7, ErlangCons clause_8 ErlangEmptyList]
        in ErlangTuple [tup_el_10, tup_el_13]
      _ -> EXC.badmatch matchExpr_9
erlps__infer_letfun__2 [arg_20, arg_21] =
  EXC.function_clause unit
erlps__infer_letfun__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_letfun__2) args

erlps__infer_letfun1__2 :: ErlangFun
erlps__infer_letfun1__2 [env0_0,
                         (ErlangTuple [(ErlangAtom "letfun"), attrib_1,
                                       fun_4@(ErlangTuple [(ErlangAtom "id"),
                                                           nameattrib_2,
                                                           name_3]),
                                       args_5, what_6, body_7])]
  =
  let   
    record_updt_9 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "stateful", attrib_1, ErlangAtom "false"]
  in let
    env_23 =
      case env0_0 of
        (ErlangTuple [(ErlangAtom "env"), scopes_14, vars_15,
                      typevars_16, fields_17, namespace_18, in_pattern_19,
                      stateful_20, current_function_21, what_22]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_14, vars_15, typevars_16, fields_17,
             namespace_18, in_pattern_19, record_updt_9, fun_4, what_22]
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    head_28 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    arg_25 =
      ErlangTuple
        [ErlangAtom "tuple", ErlangCons head_28 nameattrib_2, args_5]
  in let matchExpr_36 = erlps__infer_pattern__2 [env_23, arg_25]
  in
    case matchExpr_36 of
      (ErlangTuple [newenv_33,
                    (ErlangTuple [(ErlangAtom "typed"), _,
                                  (ErlangTuple [(ErlangAtom "tuple"), _,
                                                typedargs_34]),
                                  (ErlangTuple [(ErlangAtom "tuple_t"), _,
                                                argtypes_35])])]) ->
        let    arg_38 = erlps__arg_type__2 [nameattrib_2, what_6]
        in let expectedtype_41 = erlps__check_type__2 [env_23, arg_38]
        in let
          matchExpr_46 =
            erlps__check_expr__3 [newenv_33, body_7, expectedtype_41]
        in
          case matchExpr_46 of
            (ErlangTuple [(ErlangAtom "typed"), _, _, resulttype_45]) ->
              let   
                typesig_55 =
                  ErlangTuple
                    [ErlangAtom "type_sig", attrib_1, ErlangAtom "none",
                     ErlangEmptyList, argtypes_35, resulttype_45]
              in let tup_el_56 = ErlangTuple [name_3, typesig_55]
              in let
                tup_el_62 = ErlangTuple [ErlangAtom "id", nameattrib_2, name_3]
              in let
                tup_el_59 =
                  ErlangTuple
                    [ErlangAtom "letfun", attrib_1, tup_el_62, typedargs_34,
                     resulttype_45, matchExpr_46]
              in ErlangTuple [tup_el_56, tup_el_59]
            _ -> EXC.badmatch matchExpr_46
      _ -> EXC.badmatch matchExpr_36
erlps__infer_letfun1__2 [arg_69, arg_70] =
  EXC.function_clause unit
erlps__infer_letfun1__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_letfun1__2) args

erlps__desugar_clauses__4 :: ErlangFun
erlps__desugar_clauses__4 [ann_0, fun_1,
                           (ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                         argtypes_2, rettype_3]),
                           clauses_4]
  =
  let
    needdesugar_11 =
      case clauses_4 of
        (ErlangCons (ErlangTuple [(ErlangAtom "letfun"), _, _, as_6, _,
                                  _]) (ErlangEmptyList)) ->
          let
            arg_7 =
              ErlangFun 1
                (let
                   lambda_8 [(ErlangTuple [(ErlangAtom "typed"), _,
                                           (ErlangTuple [(ErlangAtom "id"), _,
                                                         _]),
                                           _])]
                     =
                     ErlangAtom "false"
                   lambda_8 [_] = ErlangAtom "true"
                   lambda_8 [arg_9] = EXC.function_clause unit
                   lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
                 in lambda_8)
          in BIF.do_remote_fun_call "Lists" "erlps__any__2" [arg_7, as_6]
        _ -> ErlangAtom "true"
  in
    case needdesugar_11 of
      (ErlangAtom "false") ->
        case clauses_4 of
          (ErlangCons clause_13 (ErlangEmptyList)) -> clause_13
          _ -> EXC.badmatch clauses_4
      (ErlangAtom "true") ->
        let   
          head_15 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let arg_21 = toErl 1
        in let lcSrc_20 = erlps__indexed__2 [arg_21, argtypes_2]
        in let
          args_37 =
            flmap
              (\ lc_25 ->
                 case lc_25 of
                   (ErlangTuple [i_23, type_24]) ->
                     let    lop_33 = toErl "x#"
                     in let rop_34 = BIF.erlang__integer_to_list__1 [i_23]
                     in let tup_el_32 = BIF.erlang__op_append [lop_33, rop_34]
                     in let
                       tup_el_29 =
                         ErlangTuple
                           [ErlangAtom "id", ErlangCons head_15 ErlangEmptyList,
                            tup_el_32]
                     in let
                       lcRet_26 =
                         ErlangTuple
                           [ErlangAtom "typed",
                            ErlangCons head_15 ErlangEmptyList, tup_el_29,
                            type_24]
                     in ErlangCons lcRet_26 ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_20
        in let
          tuple_52 =
            ErlangFun 1
              (let
                 lambda_38 [(ErlangCons x_40 (ErlangEmptyList))] = x_40
                 lambda_38 [as_41] =
                   let   
                     tup_el_44 =
                       ErlangTuple
                         [ErlangAtom "tuple",
                          ErlangCons head_15 ErlangEmptyList, as_41]
                   in let
                     tup_el_48 =
                       ErlangTuple
                         [ErlangAtom "tuple_t",
                          ErlangCons head_15 ErlangEmptyList, argtypes_2]
                   in
                     ErlangTuple
                       [ErlangAtom "typed", ErlangCons head_15 ErlangEmptyList,
                        tup_el_44, tup_el_48]
                 lambda_38 [arg_39] = EXC.function_clause unit
                 lambda_38 args = EXC.badarity (ErlangFun 1 lambda_38) args
               in lambda_38)
        in let
          tup_el_64 =
            BIF.erlang__apply__2
              [tuple_52, ErlangCons args_37 ErlangEmptyList]
        in let
          tup_el_67 =
            flmap
              (\ lc_72 ->
                 case lc_72 of
                   (ErlangTuple [(ErlangAtom "letfun"), annc_69, _, argsc_70, _,
                                 body_71]) ->
                     let   
                       tup_el_76 =
                         BIF.erlang__apply__2
                           [tuple_52, ErlangCons argsc_70 ErlangEmptyList]
                     in let
                       lcRet_73 =
                         ErlangTuple
                           [ErlangAtom "case", annc_69, tup_el_76, body_71]
                     in ErlangCons lcRet_73 ErlangEmptyList
                   _ -> ErlangEmptyList)
              clauses_4
        in let
          tup_el_61 =
            ErlangTuple
              [ErlangAtom "switch", ErlangCons head_15 ErlangEmptyList,
               tup_el_64, tup_el_67]
        in let
          tup_el_58 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_15 ErlangEmptyList,
               tup_el_61, rettype_3]
        in
          ErlangTuple
            [ErlangAtom "letfun", ann_0, fun_1, args_37, rettype_3,
             tup_el_58]
      something_else -> EXC.case_clause something_else
erlps__desugar_clauses__4 [arg_81, arg_82, arg_83, arg_84] =
  EXC.function_clause unit
erlps__desugar_clauses__4 args =
  EXC.badarity (ErlangFun 4 erlps__desugar_clauses__4) args

erlps__print_typesig__1 :: ErlangFun
erlps__print_typesig__1 [(ErlangTuple [name_0, typesig_1])] =
  let
    arg_3 =
      ErlangFun 0
        (let
           lambda_4 [] =
             let    arg_5 = toErl "Inferred ~s : ~s\n"
             in let head_9 = erlps__pp__1 [typesig_1]
             in
               BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                 [arg_5, ErlangCons name_0 (ErlangCons head_9 ErlangEmptyList)]
           lambda_4 [] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 0 lambda_4) args
         in lambda_4)
  in erlps__when_option__2 [ErlangAtom "pp_types", arg_3]
erlps__print_typesig__1 [arg_12] = EXC.function_clause unit
erlps__print_typesig__1 args =
  EXC.badarity (ErlangFun 1 erlps__print_typesig__1) args

erlps__arg_type__2 :: ErlangFun
erlps__arg_type__2 [argann_0,
                    (ErlangTuple [(ErlangAtom "id"), ann_1,
                                  (ErlangCons (ErlangInt num_2) (ErlangEmptyList))])]
  | (ErlangInt num_2) == (toErl 95) =
  let
    case_3 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "origin", ann_1, ErlangAtom "user"]
  in
    case case_3 of
      (ErlangAtom "system") -> erlps__fresh_uvar__1 [argann_0]
      (ErlangAtom "user") -> erlps__fresh_uvar__1 [ann_1]
      something_else -> EXC.case_clause something_else
erlps__arg_type__2 [argann_0,
                    (ErlangTuple [(ErlangAtom "app_t"), attrs_1, name_2,
                                  args_3])]
  =
  let
    tup_el_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__arg_type__2 [argann_0, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        args_3
  in ErlangTuple [ErlangAtom "app_t", attrs_1, name_2, tup_el_7]
erlps__arg_type__2 [_, t_0] = t_0
erlps__arg_type__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__arg_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__arg_type__2) args

erlps__app_t__3 :: ErlangFun
erlps__app_t__3 [_ann_0, name_1, (ErlangEmptyList)] = name_1
erlps__app_t__3 [ann_0, name_1, args_2] =
  ErlangTuple [ErlangAtom "app_t", ann_0, name_1, args_2]
erlps__app_t__3 [arg_7, arg_8, arg_9] = EXC.function_clause unit
erlps__app_t__3 args =
  EXC.badarity (ErlangFun 3 erlps__app_t__3) args

erlps__lookup_name__3 :: ErlangFun
erlps__lookup_name__3 [env_0, as_1, name_2] =
  erlps__lookup_name__4 [env_0, as_1, name_2, ErlangEmptyList]
erlps__lookup_name__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__lookup_name__3 args =
  EXC.badarity (ErlangFun 3 erlps__lookup_name__3) args

erlps__lookup_name__4 :: ErlangFun
erlps__lookup_name__4 [env_0, as_1, id_2, options_3] =
  let    arg_8 = erlps__qname__1 [id_2]
  in let
    case_4 =
      erlps__lookup_env__4 [env_0, ErlangAtom "term", as_1, arg_8]
  in
    case case_4 of
      (ErlangAtom "false") ->
        let    arg_10 = ErlangTuple [ErlangAtom "unbound_variable", id_2]
        in let _ = erlps__type_error__1 [arg_10]
        in let tup_el_14 = erlps__fresh_uvar__1 [as_1]
        in ErlangTuple [id_2, tup_el_14]
      (ErlangTuple [qid_16, (ErlangTuple [_, ty_17])]) ->
        let   
          freshen_21 =
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [ErlangAtom "freshen", options_3, ErlangAtom "false"]
        in let _ = erlps__check_stateful__3 [env_0, id_2, ty_17]
        in let
          ty1_30 =
            case ty_17 of
              (ErlangTuple [(ErlangAtom "type_sig"), _, _, _, _, _]) ->
                erlps__freshen_type_sig__2 [as_1, ty_17]
              _ | (==) (ErlangAtom "true") freshen_21 ->
                erlps__freshen_type__2 [as_1, ty_17]
              _ -> ty_17
        in let tup_el_31 = erlps__set_qname__2 [qid_16, id_2]
        in ErlangTuple [tup_el_31, ty1_30]
      something_else -> EXC.case_clause something_else
erlps__lookup_name__4 [arg_35, arg_36, arg_37, arg_38] =
  EXC.function_clause unit
erlps__lookup_name__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_name__4) args

erlps__check_stateful__3 :: ErlangFun
erlps__check_stateful__3 [(ErlangTuple [(ErlangAtom "env"), _, _,
                                        _, _, _, _, (ErlangAtom "false"), fun_0,
                                        _]),
                          id_1,
                          type_2@(ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                               _, _])]
  =
  let
    case_3 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "stateful", type_2, ErlangAtom "false"]
  in
    case case_3 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      (ErlangAtom "true") ->
        let
          arg_7 =
            ErlangTuple [ErlangAtom "stateful_not_allowed", id_1, fun_0]
        in erlps__type_error__1 [arg_7]
      something_else -> EXC.case_clause something_else
erlps__check_stateful__3 [_env_0, _id_1, _type_2] =
  ErlangAtom "ok"
erlps__check_stateful__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__check_stateful__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_stateful__3) args

erlps__check_stateful_named_arg__3 :: ErlangFun
erlps__check_stateful_named_arg__3 [(ErlangTuple [(ErlangAtom "env"),
                                                  _, _, _, _, _, _,
                                                  (ErlangAtom "false"), fun_0,
                                                  _]),
                                    (ErlangTuple [(ErlangAtom "id"), _,
                                                  (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList))))))]),
                                    default_6]
  | (ErlangInt num_1) == (toErl 118)
  , (ErlangInt num_2) == (toErl 97)
  , (ErlangInt num_3) == (toErl 108)
  , (ErlangInt num_4) == (toErl 117)
  , (ErlangInt num_5) == (toErl 101) =
  case default_6 of
    (ErlangTuple [(ErlangAtom "int"), _,
                  (ErlangInt num_8)]) | (ErlangInt num_8) == (toErl 0) ->
      ErlangAtom "ok"
    _ ->
      let
        arg_9 =
          ErlangTuple
            [ErlangAtom "value_arg_not_allowed", default_6, fun_0]
      in erlps__type_error__1 [arg_9]
erlps__check_stateful_named_arg__3 [_, _, _] = ErlangAtom "ok"
erlps__check_stateful_named_arg__3 [arg_0, arg_1, arg_2] =
  EXC.function_clause unit
erlps__check_stateful_named_arg__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_stateful_named_arg__3)
    args

erlps__check_state_dependencies__2 :: ErlangFun
erlps__check_state_dependencies__2 [env_0, defs_1] =
  let   
    top_5 =
      case env_0 of
        (ErlangTuple arr_4) | (DM.Just field_3) <- (arr_4 DA.!! 5) ->
          field_3
        _ -> EXC.badrecord (ErlangAtom "env")
  in let head_8 = toErl "state"
  in let
    getstate_10 =
      BIF.erlang__op_append [top_5, ErlangCons head_8 ErlangEmptyList]
  in let head_13 = toErl "put"
  in let
    setstate_15 =
      BIF.erlang__op_append [top_5, ErlangCons head_13 ErlangEmptyList]
  in let head_18 = toErl "init"
  in let
    init_20 =
      BIF.erlang__op_append [top_5, ErlangCons head_18 ErlangEmptyList]
  in let
    usednames_32 =
      ErlangFun 1
        (let
           lambda_21 [x_23] =
             let
               lcSrc_24 =
                 BIF.do_remote_fun_call "Aeso.Syntax.Utils" "erlps__used__1"
                   [x_23]
             in
               flmap
                 (\ lc_28 ->
                    case lc_28 of
                      (ErlangTuple [(ErlangTuple [(ErlangAtom "term"), xs_26]),
                                    ann_27]) ->
                        let lcRet_29 = ErlangTuple [xs_26, ann_27]
                        in ErlangCons lcRet_29 ErlangEmptyList
                      _ -> ErlangEmptyList)
                 lcSrc_24
           lambda_21 [arg_22] = EXC.function_clause unit
           lambda_21 args = EXC.badarity (ErlangFun 1 lambda_21) args
         in lambda_21)
  in let
    funs_47 =
      flmap
        (\ lc_39 ->
           case lc_39 of
             fun_38@(ErlangTuple [(ErlangAtom "letfun"), _,
                                  (ErlangTuple [(ErlangAtom "id"), _, name_34]),
                                  _args_35, _type_36, _body_37]) ->
               let   
                 tup_el_41 =
                   BIF.erlang__op_append
                     [top_5, ErlangCons name_34 ErlangEmptyList]
               in let lcRet_40 = ErlangTuple [tup_el_41, fun_38]
               in ErlangCons lcRet_40 ErlangEmptyList
             _ -> ErlangEmptyList)
        defs_1
  in let
    arg_48 =
      flmap
        (\ lc_52 ->
           case lc_52 of
             (ErlangTuple [name_50, def_51]) ->
               let   
                 tup_el_55 =
                   BIF.erlang__apply__2
                     [usednames_32, ErlangCons def_51 ErlangEmptyList]
               in let lcRet_53 = ErlangTuple [name_50, tup_el_55]
               in ErlangCons lcRet_53 ErlangEmptyList
             _ -> ErlangEmptyList)
        funs_47
  in let deps_58 = BIF.maps__from_list__1 [arg_48]
  in let
    case_59 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [init_20, deps_58, ErlangAtom "false"]
  in
    case case_59 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      _ ->
        let   
          lcSrc_63 =
            erlps__get_call_chains__3 [deps_58, init_20, getstate_10]
        in let
          _ =
            flmap
              (\ lc_68 ->
                 let   
                   arg_70 =
                     ErlangTuple
                       [ErlangAtom "init_depends_on_state", ErlangAtom "state",
                        lc_68]
                 in let lcRet_69 = erlps__type_error__1 [arg_70]
                 in ErlangCons lcRet_69 ErlangEmptyList)
              lcSrc_63
        in let
          lcSrc_74 =
            erlps__get_call_chains__3 [deps_58, init_20, setstate_15]
        in let
          _ =
            flmap
              (\ lc_79 ->
                 let   
                   arg_81 =
                     ErlangTuple
                       [ErlangAtom "init_depends_on_state", ErlangAtom "put",
                        lc_79]
                 in let lcRet_80 = erlps__type_error__1 [arg_81]
                 in ErlangCons lcRet_80 ErlangEmptyList)
              lcSrc_74
        in ErlangAtom "ok"
erlps__check_state_dependencies__2 [arg_85, arg_86] =
  EXC.function_clause unit
erlps__check_state_dependencies__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_state_dependencies__2)
    args

erlps__get_call_chains__3 :: ErlangFun
erlps__get_call_chains__3 [graph_0, start_1, stop_2] =
  let    arg_4 = ErlangMap Map.empty
  in let
    head_7 = ErlangTuple [start_1, ErlangEmptyList, ErlangEmptyList]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Queue" "erlps__from_list__1"
        [ErlangCons head_7 ErlangEmptyList]
  in
    erlps__get_call_chains__5
      [graph_0, arg_4, arg_5, stop_2, ErlangEmptyList]
erlps__get_call_chains__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__get_call_chains__3 args =
  EXC.badarity (ErlangFun 3 erlps__get_call_chains__3) args

erlps__get_call_chains__5 :: ErlangFun
erlps__get_call_chains__5 [graph_0, visited_1, queue_2, stop_3,
                           acc_4]
  =
  let
    case_5 = BIF.do_remote_fun_call "Queue" "erlps__out__1" [queue_2]
  in
    case case_5 of
      (ErlangTuple [(ErlangAtom "empty"), _]) ->
        BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_4]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "value"),
                                  (ErlangTuple [stop_8, ann_9, path_10])]),
                    queue1_11]) | stop_8 == stop_3 ->
        let    head_19 = ErlangTuple [stop_3, ann_9]
        in let
          head_17 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
              [ErlangCons head_19 path_10]
        in
          erlps__get_call_chains__5
            [graph_0, visited_1, queue1_11, stop_3, ErlangCons head_17 acc_4]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "value"),
                                  (ErlangTuple [node_24, ann_25, path_26])]),
                    queue1_27]) ->
        let case_28 = BIF.maps__is_key__2 [node_24, visited_1]
        in
          case case_28 of
            (ErlangAtom "true") ->
              erlps__get_call_chains__5
                [graph_0, visited_1, queue1_27, stop_3, acc_4]
            (ErlangAtom "false") ->
              let   
                calls_39 =
                  BIF.do_remote_fun_call "Maps" "erlps__get__3"
                    [node_24, graph_0, ErlangEmptyList]
              in let
                arg_40 =
                  flmap
                    (\ lc_44 ->
                       case lc_44 of
                         (ErlangTuple [new_42, ann1_43]) ->
                           let    head_49 = ErlangTuple [node_24, ann_25]
                           in let
                             lcRet_45 =
                               ErlangTuple
                                 [new_42, ann1_43, ErlangCons head_49 path_26]
                           in ErlangCons lcRet_45 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    calls_39
              in let
                newq_53 =
                  BIF.do_remote_fun_call "Queue" "erlps__from_list__1" [arg_40]
              in let
                mapExt_59 =
                  ErlangMap (Map.singleton node_24 (ErlangAtom "true"))
              in let arg_55 = BIF.maps__merge__2 [visited_1, mapExt_59]
              in let
                arg_61 =
                  BIF.do_remote_fun_call "Queue" "erlps__join__2"
                    [queue1_27, newq_53]
              in
                erlps__get_call_chains__5
                  [graph_0, arg_55, arg_61, stop_3, acc_4]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__get_call_chains__5 [arg_66, arg_67, arg_68, arg_69,
                           arg_70]
  =
  EXC.function_clause unit
erlps__get_call_chains__5 args =
  EXC.badarity (ErlangFun 5 erlps__get_call_chains__5) args

erlps__check_expr__3 :: ErlangFun
erlps__check_expr__3 [env_0, expr_1, type_2] =
  let matchExpr_8 = erlps__infer_expr__2 [env_0, expr_1]
  in
    case matchExpr_8 of
      (ErlangTuple [(ErlangAtom "typed"), ann_5, expr1_6, type1_7]) ->
        let   
          arg_12 =
            ErlangTuple [ErlangAtom "check_expr", expr_1, type1_7, type_2]
        in let _ = erlps__unify__4 [env_0, type1_7, type_2, arg_12]
        in ErlangTuple [ErlangAtom "typed", ann_5, expr1_6, type_2]
      _ -> EXC.badmatch matchExpr_8
erlps__check_expr__3 [arg_21, arg_22, arg_23] =
  EXC.function_clause unit
erlps__check_expr__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_expr__3) args

erlps__infer_expr__2 :: ErlangFun
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "bool"), as_1, _])]
  =
  let    tup_el_9 = toErl "bool"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "int"), as_1, _])]
  =
  let    tup_el_9 = toErl "int"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "char"), as_1, _])]
  =
  let    tup_el_9 = toErl "char"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "string"), as_1, _])]
  =
  let    tup_el_9 = toErl "string"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_3@(ErlangTuple [(ErlangAtom "bytes"), as_1, bin_2])]
  =
  let    tup_el_10 = BIF.erlang__byte_size__1 [bin_2]
  in let
    tup_el_7 = ErlangTuple [ErlangAtom "bytes_t", as_1, tup_el_10]
  in ErlangTuple [ErlangAtom "typed", as_1, body_3, tup_el_7]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "account_pubkey"), as_1,
                                           _])]
  =
  let    tup_el_9 = toErl "address"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "oracle_pubkey"), as_1,
                                           _])]
  =
  let    q_4 = erlps__fresh_uvar__1 [as_1]
  in let r_6 = erlps__fresh_uvar__1 [as_1]
  in let tup_el_16 = toErl "oracle"
  in let tup_el_13 = ErlangTuple [ErlangAtom "id", as_1, tup_el_16]
  in let
    tup_el_10 =
      ErlangTuple
        [ErlangAtom "app_t", as_1, tup_el_13,
         ErlangCons q_4 (ErlangCons r_6 ErlangEmptyList)]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_10]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "oracle_query_id"), as_1,
                                           _])]
  =
  let    q_4 = erlps__fresh_uvar__1 [as_1]
  in let r_6 = erlps__fresh_uvar__1 [as_1]
  in let tup_el_16 = toErl "oracle_query"
  in let tup_el_13 = ErlangTuple [ErlangAtom "id", as_1, tup_el_16]
  in let
    tup_el_10 =
      ErlangTuple
        [ErlangAtom "app_t", as_1, tup_el_13,
         ErlangCons q_4 (ErlangCons r_6 ErlangEmptyList)]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_10]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "contract_pubkey"), as_1,
                                           _])]
  =
  let    con_4 = erlps__fresh_uvar__1 [as_1]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "contract_literal", body_2]
  in let
    head_6 =
      ErlangTuple
        [ErlangAtom "is_contract_constraint", con_4, tup_el_9,
         ErlangAtom "false"]
  in let
    _ = erlps__constrain__1 [ErlangCons head_6 ErlangEmptyList]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, con_4]
erlps__infer_expr__2 [_env_0,
                      body_3@(ErlangTuple [(ErlangAtom "id"), as_1,
                                           (ErlangCons (ErlangInt num_2) (ErlangEmptyList))])]
  | (ErlangInt num_2) == (toErl 95) =
  let tup_el_7 = erlps__fresh_uvar__1 [as_1]
  in ErlangTuple [ErlangAtom "typed", as_1, body_3, tup_el_7]
erlps__infer_expr__2 [env_0, id_3@(ErlangTuple [tag_1, as_2, _])]
  | (weakEq tag_1 (ErlangAtom "id")) ||
      (weakEq tag_1 (ErlangAtom "qid")) =
  let matchExpr_9 = erlps__lookup_name__3 [env_0, as_2, id_3]
  in
    case matchExpr_9 of
      (ErlangTuple [qname_7, type_8]) ->
        ErlangTuple [ErlangAtom "typed", as_2, qname_7, type_8]
      _ -> EXC.badmatch matchExpr_9
erlps__infer_expr__2 [env_0, id_3@(ErlangTuple [tag_1, as_2, _])]
  | (weakEq tag_1 (ErlangAtom "con")) ||
      (weakEq tag_1 (ErlangAtom "qcon")) =
  let
    matchExpr_12 =
      erlps__lookup_name__4
        [env_0, as_2, id_3,
         ErlangCons (ErlangAtom "freshen") ErlangEmptyList]
  in
    case matchExpr_12 of
      (ErlangTuple [qname_10, type_11]) ->
        ErlangTuple [ErlangAtom "typed", as_2, qname_10, type_11]
      _ -> EXC.badmatch matchExpr_12
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "tuple"), as_1, cpts_2])]
  =
  let   
    newcpts_9 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = erlps__infer_expr__2 [env_0, lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        cpts_2
  in let
    cpttypes_14 =
      flmap
        (\ lc_12 ->
           case lc_12 of
             (ErlangTuple [(ErlangAtom "typed"), _, _, t_11]) ->
               ErlangCons t_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        newcpts_9
  in let
    tup_el_17 = ErlangTuple [ErlangAtom "tuple", as_1, newcpts_9]
  in let
    tup_el_21 = ErlangTuple [ErlangAtom "tuple_t", as_1, cpttypes_14]
  in ErlangTuple [ErlangAtom "typed", as_1, tup_el_17, tup_el_21]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list"), as_1, elems_2])]
  =
  let    elemtype_4 = erlps__fresh_uvar__1 [as_1]
  in let
    newelems_12 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__check_expr__3 [env_0, lc_7, elemtype_4]
           in ErlangCons lcRet_8 ErlangEmptyList)
        elems_2
  in let
    tup_el_15 = ErlangTuple [ErlangAtom "list", as_1, newelems_12]
  in let tup_el_25 = toErl "list"
  in let tup_el_22 = ErlangTuple [ErlangAtom "id", as_1, tup_el_25]
  in let
    tup_el_19 =
      ErlangTuple
        [ErlangAtom "app_t", as_1, tup_el_22,
         ErlangCons elemtype_4 ErlangEmptyList]
  in ErlangTuple [ErlangAtom "typed", as_1, tup_el_15, tup_el_19]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), as_1, yield_2,
                                    (ErlangEmptyList)])]
  =
  let typedyield_5 = erlps__infer_expr__2 [env_0, yield_2]
  in
    case typedyield_5 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, type_6]) ->
        let   
          tup_el_10 =
            ErlangTuple
              [ErlangAtom "list_comp", as_1, typedyield_5, ErlangEmptyList]
        in let tup_el_21 = toErl "list"
        in let tup_el_18 = ErlangTuple [ErlangAtom "id", as_1, tup_el_21]
        in let
          tup_el_15 =
            ErlangTuple
              [ErlangAtom "app_t", as_1, tup_el_18,
               ErlangCons type_6 ErlangEmptyList]
        in ErlangTuple [ErlangAtom "typed", as_1, tup_el_10, tup_el_15]
      _ -> EXC.badmatch typedyield_5
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), as_1, yield_2,
                                    (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_bind"),
                                                              pat_3,
                                                              bexpr_4]) rest_5)])]
  =
  let matchExpr_10 = erlps__infer_expr__2 [env_0, bexpr_4]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangAtom "typed"), as2_8, _, typebexpr_9]) ->
        let matchExpr_17 = erlps__infer_pattern__2 [env_0, pat_3]
        in
          case matchExpr_17 of
            (ErlangTuple [newe_14,
                          typedpat_16@(ErlangTuple [(ErlangAtom "typed"), _, _,
                                                    pattype_15])]) ->
              let    tup_el_26 = toErl "list"
              in let tup_el_23 = ErlangTuple [ErlangAtom "id", as_1, tup_el_26]
              in let
                arg_20 =
                  ErlangTuple
                    [ErlangAtom "app_t", as_1, tup_el_23,
                     ErlangCons pattype_15 ErlangEmptyList]
              in let tup_el_40 = toErl "list"
              in let tup_el_37 = ErlangTuple [ErlangAtom "id", as_1, tup_el_40]
              in let
                tup_el_34 =
                  ErlangTuple
                    [ErlangAtom "app_t", as2_8, tup_el_37,
                     ErlangCons pattype_15 ErlangEmptyList]
              in let
                arg_30 =
                  ErlangTuple
                    [ErlangAtom "list_comp", matchExpr_10, typebexpr_9,
                     tup_el_34]
              in let _ = erlps__unify__4 [env_0, typebexpr_9, arg_20, arg_30]
              in let
                arg_45 =
                  ErlangTuple [ErlangAtom "list_comp", as_1, yield_2, rest_5]
              in let matchExpr_53 = erlps__infer_expr__2 [newe_14, arg_45]
              in
                case matchExpr_53 of
                  (ErlangTuple [(ErlangAtom "typed"), _,
                                (ErlangTuple [(ErlangAtom "list_comp"), _,
                                              typedyield_50, typedrest_51]),
                                restype_52]) ->
                    let   
                      head_61 =
                        ErlangTuple
                          [ErlangAtom "comprehension_bind", typedpat_16,
                           matchExpr_10]
                    in let
                      tup_el_56 =
                        ErlangTuple
                          [ErlangAtom "list_comp", as_1, typedyield_50,
                           ErlangCons head_61 typedrest_51]
                    in
                      ErlangTuple
                        [ErlangAtom "typed", as_1, tup_el_56, restype_52]
                  _ -> EXC.badmatch matchExpr_53
            _ -> EXC.badmatch matchExpr_17
      _ -> EXC.badmatch matchExpr_10
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), attrsl_1, yield_2,
                                    (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_if"),
                                                              attrsif_3,
                                                              cond_4]) rest_5)])]
  =
  let    tup_el_11 = toErl "bool"
  in let
    arg_8 = ErlangTuple [ErlangAtom "id", attrsif_3, tup_el_11]
  in let newcond_12 = erlps__check_expr__3 [env_0, cond_4, arg_8]
  in let
    arg_14 =
      ErlangTuple [ErlangAtom "list_comp", attrsl_1, yield_2, rest_5]
  in let matchExpr_22 = erlps__infer_expr__2 [env_0, arg_14]
  in
    case matchExpr_22 of
      (ErlangTuple [(ErlangAtom "typed"), _,
                    (ErlangTuple [(ErlangAtom "list_comp"), _, typedyield_19,
                                  typedrest_20]),
                    restype_21]) ->
        let   
          head_30 =
            ErlangTuple
              [ErlangAtom "comprehension_if", attrsif_3, newcond_12]
        in let
          tup_el_25 =
            ErlangTuple
              [ErlangAtom "list_comp", attrsl_1, typedyield_19,
               ErlangCons head_30 typedrest_20]
        in
          ErlangTuple [ErlangAtom "typed", attrsl_1, tup_el_25, restype_21]
      _ -> EXC.badmatch matchExpr_22
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), aslc_1, yield_2,
                                    (ErlangCons (ErlangTuple [(ErlangAtom "letval"),
                                                              aslv_3, pattern_4,
                                                              e_5]) rest_6)])]
  =
  let matchExpr_10 = erlps__infer_expr__2 [env_0, e_5]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, pattype_9]) ->
        let    blocktype_13 = erlps__fresh_uvar__1 [aslv_3]
        in let
          arg_18 =
            ErlangTuple [ErlangAtom "list_comp", aslc_1, yield_2, rest_6]
        in let
          matchExpr_26 =
            erlps__infer_case__6
              [env_0, aslc_1, pattern_4, pattype_9, arg_18, blocktype_13]
        in
          case matchExpr_26 of
            (ErlangTuple [(ErlangAtom "case"), _, newpattern_24,
                          newrest_25]) ->
              case newrest_25 of
                (ErlangTuple [(ErlangAtom "typed"), _,
                              (ErlangTuple [(ErlangAtom "list_comp"), _,
                                            typedyield_27, typedrest_28]),
                              restype_29]) ->
                  let   
                    head_38 =
                      ErlangTuple
                        [ErlangAtom "letval", aslv_3, newpattern_24,
                         matchExpr_10]
                  in let
                    tup_el_33 =
                      ErlangTuple
                        [ErlangAtom "list_comp", aslc_1, typedyield_27,
                         ErlangCons head_38 typedrest_28]
                  in
                    ErlangTuple
                      [ErlangAtom "typed", aslc_1, tup_el_33, restype_29]
                _ -> EXC.badmatch newrest_25
            _ -> EXC.badmatch matchExpr_26
      _ -> EXC.badmatch matchExpr_10
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), aslc_1, yield_2,
                                    (ErlangCons def_4@(ErlangTuple [(ErlangAtom "letfun"),
                                                                    aslf_3, _,
                                                                    _, _,
                                                                    _]) rest_5)])]
  =
  let matchExpr_11 = erlps__infer_letfun__2 [env_0, def_4]
  in
    case matchExpr_11 of
      (ErlangTuple [(ErlangTuple [name_8, typesig_9]), letfun_10]) ->
        let    funt_13 = erlps__typesig_to_fun_t__1 [typesig_9]
        in let arg_14 = ErlangTuple [ErlangAtom "id", aslf_3, name_8]
        in let newe_20 = erlps__bind_var__3 [arg_14, funt_13, env_0]
        in let
          arg_22 =
            ErlangTuple [ErlangAtom "list_comp", aslc_1, yield_2, rest_5]
        in let matchExpr_30 = erlps__infer_expr__2 [newe_20, arg_22]
        in
          case matchExpr_30 of
            (ErlangTuple [(ErlangAtom "typed"), _,
                          (ErlangTuple [(ErlangAtom "list_comp"), _,
                                        typedyield_27, typedrest_28]),
                          restype_29]) ->
              let
                tup_el_33 =
                  ErlangTuple
                    [ErlangAtom "list_comp", aslc_1, typedyield_27,
                     ErlangCons letfun_10 typedrest_28]
              in
                ErlangTuple [ErlangAtom "typed", aslc_1, tup_el_33, restype_29]
            _ -> EXC.badmatch matchExpr_30
      _ -> EXC.badmatch matchExpr_11
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "typed"), as_1, body_2,
                                    type_3])]
  =
  let    type1_6 = erlps__check_type__2 [env_0, type_3]
  in let
    matchExpr_12 = erlps__check_expr__3 [env_0, body_2, type1_6]
  in
    case matchExpr_12 of
      (ErlangTuple [(ErlangAtom "typed"), _, newbody_10,
                    newtype_11]) ->
        ErlangTuple [ErlangAtom "typed", as_1, newbody_10, newtype_11]
      _ -> EXC.badmatch matchExpr_12
erlps__infer_expr__2 [env_0,
                      app_4@(ErlangTuple [(ErlangAtom "app"), ann_1, fun_2,
                                          args0_3])]
  =
  let matchExpr_8 = erlps__split_args__1 [args0_3]
  in
    case matchExpr_8 of
      (ErlangTuple [namedargs_6, args_7]) ->
        let
          case_9 =
            BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__2"
              [ErlangAtom "format", ann_1]
        in
          case case_9 of
            (ErlangAtom "infix") ->
              let arg_16 = ErlangFun 1 erlps__infer_infix__1
              in erlps__infer_op__5 [env_0, ann_1, fun_2, args_7, arg_16]
            (ErlangAtom "prefix") ->
              let arg_21 = ErlangFun 1 erlps__infer_prefix__1
              in erlps__infer_op__5 [env_0, ann_1, fun_2, args_7, arg_21]
            _ ->
              let    namedargsvar_23 = erlps__fresh_uvar__1 [ann_1]
              in let
                namedargs1_31 =
                  flmap
                    (\ lc_26 ->
                       let
                         lcRet_27 =
                           erlps__infer_named_arg__3
                             [env_0, namedargsvar_23, lc_26]
                       in ErlangCons lcRet_27 ErlangEmptyList)
                    namedargs_6
              in let newfun0_34 = erlps__infer_expr__2 [env_0, fun_2]
              in let
                newargs_41 =
                  flmap
                    (\ lc_37 ->
                       let lcRet_38 = erlps__infer_expr__2 [env_0, lc_37]
                       in ErlangCons lcRet_38 ErlangEmptyList)
                    args_7
              in let
                argtypes_46 =
                  flmap
                    (\ lc_44 ->
                       case lc_44 of
                         (ErlangTuple [(ErlangAtom "typed"), _, _, t_43]) ->
                           ErlangCons t_43 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    newargs_41
              in let
                matchExpr_52 =
                  erlps__infer_var_args_fun__4
                    [env_0, newfun0_34, namedargs1_31, argtypes_46]
              in
                case matchExpr_52 of
                  (ErlangTuple [(ErlangAtom "typed"), _, _, funtype_51]) ->
                    let   
                      when_60 =
                        ErlangTuple
                          [ErlangAtom "infer_app", fun_2, namedargs1_31, args_7,
                           funtype_51, argtypes_46]
                    in let generalresulttype_62 = erlps__fresh_uvar__1 [ann_1]
                    in let resulttype_64 = erlps__fresh_uvar__1 [ann_1]
                    in let
                      arg_67 =
                        ErlangTuple
                          [ErlangAtom "fun_t", ErlangEmptyList, namedargsvar_23,
                           argtypes_46, generalresulttype_62]
                    in let
                      _ = erlps__unify__4 [env_0, funtype_51, arg_67, when_60]
                    in let
                      tup_el_80 = ErlangTuple [ErlangAtom "check_return", app_4]
                    in let
                      arg_74 =
                        ErlangTuple
                          [ErlangAtom "dependent_type_constraint",
                           namedargsvar_23, namedargs1_31, generalresulttype_62,
                           resulttype_64, tup_el_80]
                    in let _ = erlps__add_named_argument_constraint__1 [arg_74]
                    in let
                      tup_el_89 =
                        BIF.erlang__op_append [namedargs1_31, newargs_41]
                    in let
                      tup_el_85 =
                        ErlangTuple
                          [ErlangAtom "app", ann_1, matchExpr_52, tup_el_89]
                    in let tup_el_92 = erlps__dereference__1 [resulttype_64]
                    in
                      ErlangTuple
                        [ErlangAtom "typed", ann_1, tup_el_85, tup_el_92]
                  _ -> EXC.badmatch matchExpr_52
      _ -> EXC.badmatch matchExpr_8
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "if"), attrs_1, cond_2, then_3,
                                    else_4])]
  =
  let    tup_el_10 = toErl "bool"
  in let arg_7 = ErlangTuple [ErlangAtom "id", attrs_1, tup_el_10]
  in let newcond_11 = erlps__check_expr__3 [env_0, cond_2, arg_7]
  in let matchExpr_15 = erlps__infer_expr__2 [env_0, then_3]
  in
    case matchExpr_15 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, thentype_14]) ->
        let matchExpr_20 = erlps__infer_expr__2 [env_0, else_4]
        in
          case matchExpr_20 of
            (ErlangTuple [(ErlangAtom "typed"), _, _, elsetype_19]) ->
              let   
                arg_25 =
                  ErlangTuple
                    [ErlangAtom "if_branches", then_3, thentype_14, else_4,
                     elsetype_19]
              in let
                _ = erlps__unify__4 [env_0, thentype_14, elsetype_19, arg_25]
              in let
                tup_el_33 =
                  ErlangTuple
                    [ErlangAtom "if", attrs_1, newcond_11, matchExpr_15,
                     matchExpr_20]
              in
                ErlangTuple
                  [ErlangAtom "typed", attrs_1, tup_el_33, thentype_14]
            _ -> EXC.badmatch matchExpr_20
      _ -> EXC.badmatch matchExpr_15
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "switch"), attrs_1, expr_2,
                                    cases_3])]
  =
  let matchExpr_7 = erlps__infer_expr__2 [env_0, expr_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, exprtype_6]) ->
        let    switchtype_10 = erlps__fresh_uvar__1 [attrs_1]
        in let
          newcases_23 =
            flmap
              (\ lc_15 ->
                 case lc_15 of
                   (ErlangTuple [(ErlangAtom "case"), as_12, pattern_13,
                                 branch_14]) ->
                     let
                       lcRet_16 =
                         erlps__infer_case__6
                           [env_0, as_12, pattern_13, exprtype_6, branch_14,
                            switchtype_10]
                     in ErlangCons lcRet_16 ErlangEmptyList
                   _ -> ErlangEmptyList)
              cases_3
        in let
          tup_el_26 =
            ErlangTuple
              [ErlangAtom "switch", attrs_1, matchExpr_7, newcases_23]
        in
          ErlangTuple
            [ErlangAtom "typed", attrs_1, tup_el_26, switchtype_10]
      _ -> EXC.badmatch matchExpr_7
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record"), attrs_1, fields_2])]
  =
  let    recordtype_4 = erlps__fresh_uvar__1 [attrs_1]
  in let
    newfields_17 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [(ErlangAtom "field"), a_6, fieldname_7, expr_8]) ->
               let    tup_el_14 = erlps__infer_expr__2 [env_0, expr_8]
               in let
                 lcRet_10 =
                   ErlangTuple [ErlangAtom "field", a_6, fieldname_7, tup_el_14]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_2
  in let
    recordtype1_20 =
      erlps__unfold_types_in_type__2 [env_0, recordtype_4]
  in let
    op_arg_24 =
      case env_0 of
        (ErlangTuple arr_27) | (DM.Just field_26) <- (arr_27 DA.!! 6) ->
          field_26
        _ -> EXC.badrecord (ErlangAtom "env")
  in let cond_23 = BIF.erlang__not__1 [op_arg_24]
  in let
    lop_22 =
      case cond_23 of
        (ErlangAtom "true") ->
          let   
            tup_el_31 =
              flmap
                (\ lc_34 ->
                   case lc_34 of
                     (ErlangTuple [(ErlangAtom "field"), _,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                             _,
                                                             fieldname_33]) (ErlangEmptyList)),
                                   _]) ->
                       ErlangCons fieldname_33 ErlangEmptyList
                     _ -> ErlangEmptyList)
                fields_2
          in let
            lcRet_28 =
              ErlangTuple
                [ErlangAtom "record_create_constraint", recordtype1_20,
                 tup_el_31, attrs_1]
          in ErlangCons lcRet_28 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    lcSrc_38 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [fields_2, newfields_17]
  in let
    rop_37 =
      flmap
        (\ lc_44 ->
           case lc_44 of
             (ErlangTuple [fld_41,
                           (ErlangTuple [(ErlangAtom "field"), _, lv_42,
                                         (ErlangTuple [(ErlangAtom "typed"), _,
                                                       _, t_43])])]) ->
               case lv_42 of
                 (ErlangCons (ErlangTuple [(ErlangAtom "proj"), _,
                                           fieldname_46]) (ErlangEmptyList)) ->
                   let
                     lcRet_45 =
                       ErlangTuple
                         [ErlangAtom "field_constraint", recordtype1_20,
                          fieldname_46, t_43, ErlangAtom "create", fld_41]
                   in ErlangCons lcRet_45 ErlangEmptyList
                 _ -> EXC.badmatch lv_42
             _ -> ErlangEmptyList)
        lcSrc_38
  in let arg_21 = BIF.erlang__op_append [lop_22, rop_37]
  in let _ = erlps__constrain__1 [arg_21]
  in let
    tup_el_56 =
      ErlangTuple [ErlangAtom "record", attrs_1, newfields_17]
  in
    ErlangTuple
      [ErlangAtom "typed", attrs_1, tup_el_56, recordtype_4]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record"), attrs_1, record_2,
                                    update_3])]
  =
  let matchExpr_7 = erlps__infer_expr__2 [env_0, record_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, recordtype_6]) ->
        let   
          newupdate_16 =
            flmap
              (\ lc_11 ->
                 let
                   lcRet_12 =
                     erlps__check_record_update__3 [env_0, recordtype_6, lc_11]
                 in ErlangCons lcRet_12 ErlangEmptyList)
              update_3
        in let
          tup_el_19 =
            ErlangTuple
              [ErlangAtom "record", attrs_1, matchExpr_7, newupdate_16]
        in
          ErlangTuple
            [ErlangAtom "typed", attrs_1, tup_el_19, recordtype_6]
      _ -> EXC.badmatch matchExpr_7
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "proj"), attrs_1, record_2,
                                    fieldname_3])]
  =
  let matchExpr_7 = erlps__infer_expr__2 [env_0, record_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, recordtype_6]) ->
        let    fieldtype_10 = erlps__fresh_uvar__1 [attrs_1]
        in let
          tup_el_14 = erlps__unfold_types_in_type__2 [env_0, recordtype_6]
        in let
          tup_el_20 =
            ErlangTuple [ErlangAtom "proj", attrs_1, record_2, fieldname_3]
        in let
          head_12 =
            ErlangTuple
              [ErlangAtom "field_constraint", tup_el_14, fieldname_3,
               fieldtype_10, ErlangAtom "project", tup_el_20]
        in let
          _ = erlps__constrain__1 [ErlangCons head_12 ErlangEmptyList]
        in let
          tup_el_28 =
            ErlangTuple
              [ErlangAtom "proj", attrs_1, matchExpr_7, fieldname_3]
        in
          ErlangTuple
            [ErlangAtom "typed", attrs_1, tup_el_28, fieldtype_10]
      _ -> EXC.badmatch matchExpr_7
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map_get"), attrs_1, map_2,
                                    key_3])]
  =
  let    keytype_5 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_7 = erlps__fresh_uvar__1 [attrs_1]
  in let
    maptype_11 = erlps__map_t__3 [attrs_1, keytype_5, valtype_7]
  in let map1_15 = erlps__check_expr__3 [env_0, map_2, maptype_11]
  in let key1_19 = erlps__check_expr__3 [env_0, key_3, keytype_5]
  in let
    tup_el_22 =
      ErlangTuple [ErlangAtom "map_get", attrs_1, map1_15, key1_19]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_22, valtype_7]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map_get"), attrs_1, map_2,
                                    key_3, val_4])]
  =
  let    keytype_6 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_8 = erlps__fresh_uvar__1 [attrs_1]
  in let
    maptype_12 = erlps__map_t__3 [attrs_1, keytype_6, valtype_8]
  in let map1_16 = erlps__check_expr__3 [env_0, map_2, maptype_12]
  in let key1_20 = erlps__check_expr__3 [env_0, key_3, keytype_6]
  in let val1_24 = erlps__check_expr__3 [env_0, val_4, valtype_8]
  in let
    tup_el_27 =
      ErlangTuple
        [ErlangAtom "map_get", attrs_1, map1_16, key1_20, val1_24]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_27, valtype_8]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map"), attrs_1, kvs_2])]
  =
  let    keytype_4 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_6 = erlps__fresh_uvar__1 [attrs_1]
  in let
    kvs1_20 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [k_8, v_9]) ->
               let    tup_el_12 = erlps__check_expr__3 [env_0, k_8, keytype_4]
               in let tup_el_16 = erlps__check_expr__3 [env_0, v_9, valtype_6]
               in let lcRet_11 = ErlangTuple [tup_el_12, tup_el_16]
               in ErlangCons lcRet_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        kvs_2
  in let
    tup_el_23 = ErlangTuple [ErlangAtom "map", attrs_1, kvs1_20]
  in let
    tup_el_27 = erlps__map_t__3 [attrs_1, keytype_4, valtype_6]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_23, tup_el_27]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map"), attrs_1, map_2,
                                    updates_3])]
  =
  let    keytype_5 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_7 = erlps__fresh_uvar__1 [attrs_1]
  in let
    maptype_11 = erlps__map_t__3 [attrs_1, keytype_5, valtype_7]
  in let map1_15 = erlps__check_expr__3 [env_0, map_2, maptype_11]
  in let
    updates1_24 =
      flmap
        (\ lc_18 ->
           let
             lcRet_19 =
               erlps__check_map_update__4 [env_0, lc_18, keytype_5, valtype_7]
           in ErlangCons lcRet_19 ErlangEmptyList)
        updates_3
  in let
    tup_el_27 =
      ErlangTuple [ErlangAtom "map", attrs_1, map1_15, updates1_24]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_27, maptype_11]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "block"), attrs_1, stmts_2])]
  =
  let    blocktype_4 = erlps__fresh_uvar__1 [attrs_1]
  in let
    newstmts_9 =
      erlps__infer_block__4 [env_0, attrs_1, stmts_2, blocktype_4]
  in let
    tup_el_12 = ErlangTuple [ErlangAtom "block", attrs_1, newstmts_9]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_12, blocktype_4]
erlps__infer_expr__2 [_env_0,
                      (ErlangTuple [(ErlangAtom "record_or_map_error"), attrs_1,
                                    fields_2])]
  =
  let   
    tup_el_5 = ErlangTuple [ErlangAtom "record", attrs_1, fields_2]
  in let
    arg_3 = ErlangTuple [ErlangAtom "mixed_record_and_map", tup_el_5]
  in let _ = erlps__type_error__1 [arg_3]
  in let type_10 = erlps__fresh_uvar__1 [attrs_1]
  in let
    tup_el_13 =
      ErlangTuple [ErlangAtom "record", attrs_1, ErlangEmptyList]
  in ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_13, type_10]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record_or_map_error"), attrs_1,
                                    expr_2, (ErlangEmptyList)])]
  =
  let   
    tup_el_5 =
      ErlangTuple
        [ErlangAtom "record", attrs_1, expr_2, ErlangEmptyList]
  in let
    arg_3 =
      ErlangTuple [ErlangAtom "empty_record_or_map_update", tup_el_5]
  in let _ = erlps__type_error__1 [arg_3]
  in erlps__infer_expr__2 [env_0, expr_2]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record_or_map_error"), attrs_1,
                                    expr_2, fields_3])]
  =
  let   
    tup_el_6 =
      ErlangTuple [ErlangAtom "record", attrs_1, expr_2, fields_3]
  in let
    arg_4 = ErlangTuple [ErlangAtom "mixed_record_and_map", tup_el_6]
  in let _ = erlps__type_error__1 [arg_4]
  in erlps__infer_expr__2 [env_0, expr_2]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "lam"), attrs_1, args_2,
                                    body_3])]
  =
  let   
    argtypes_9 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "arg"), as_5, _, _]) ->
               let lcRet_7 = erlps__fresh_uvar__1 [as_5]
               in ErlangCons lcRet_7 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_2
  in let
    argpatterns_22 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangAtom "arg"), as_11, pat_12, t_13]) ->
               let    tup_el_19 = erlps__check_type__2 [env_0, t_13]
               in let
                 lcRet_15 =
                   ErlangTuple [ErlangAtom "typed", as_11, pat_12, tup_el_19]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_2
  in let resulttype_24 = erlps__fresh_uvar__1 [attrs_1]
  in let
    arg_27 =
      ErlangTuple [ErlangAtom "tuple", attrs_1, argpatterns_22]
  in let
    arg_31 = ErlangTuple [ErlangAtom "tuple_t", attrs_1, argtypes_9]
  in let
    matchExpr_39 =
      erlps__infer_case__6
        [env_0, attrs_1, arg_27, arg_31, body_3, resulttype_24]
  in
    case matchExpr_39 of
      (ErlangTuple [(ErlangAtom "case"), _,
                    (ErlangTuple [(ErlangAtom "typed"), _,
                                  (ErlangTuple [(ErlangAtom "tuple"), _,
                                                newargpatterns_37]),
                                  _]),
                    newbody_38]) ->
        let   
          newargs_50 =
            flmap
              (\ lc_44 ->
                 case lc_44 of
                   (ErlangTuple [(ErlangAtom "typed"), as_41, newpat_42,
                                 newt_43]) ->
                     let
                       lcRet_45 =
                         ErlangTuple
                           [ErlangAtom "arg", as_41, newpat_42, newt_43]
                     in ErlangCons lcRet_45 ErlangEmptyList
                   _ -> ErlangEmptyList)
              newargpatterns_37
        in let
          tup_el_53 =
            ErlangTuple [ErlangAtom "lam", attrs_1, newargs_50, newbody_38]
        in let
          tup_el_58 =
            ErlangTuple
              [ErlangAtom "fun_t", attrs_1, ErlangEmptyList, argtypes_9,
               resulttype_24]
        in
          ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_53, tup_el_58]
      _ -> EXC.badmatch matchExpr_39
erlps__infer_expr__2 [env_0,
                      let_2@(ErlangTuple [(ErlangAtom "letval"), attrs_1, _,
                                          _])]
  =
  let   
    arg_3 = ErlangTuple [ErlangAtom "missing_body_for_let", attrs_1]
  in let _ = erlps__type_error__1 [arg_3]
  in let arg_15 = toErl "missing body"
  in let head_13 = erlps__abort_expr__2 [attrs_1, arg_15]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "block", attrs_1,
         ErlangCons let_2 (ErlangCons head_13 ErlangEmptyList)]
  in erlps__infer_expr__2 [env_0, arg_7]
erlps__infer_expr__2 [env_0,
                      let_2@(ErlangTuple [(ErlangAtom "letfun"), attrs_1, _, _,
                                          _, _])]
  =
  let   
    arg_3 = ErlangTuple [ErlangAtom "missing_body_for_let", attrs_1]
  in let _ = erlps__type_error__1 [arg_3]
  in let arg_15 = toErl "missing body"
  in let head_13 = erlps__abort_expr__2 [attrs_1, arg_15]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "block", attrs_1,
         ErlangCons let_2 (ErlangCons head_13 ErlangEmptyList)]
  in erlps__infer_expr__2 [env_0, arg_7]
erlps__infer_expr__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__infer_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_expr__2) args

erlps__infer_var_args_fun__4 :: ErlangFun
erlps__infer_var_args_fun__4 [env_0,
                              (ErlangTuple [(ErlangAtom "typed"), ann_1, fun_2,
                                            funtype0_3]),
                              namedargs_4, argtypes_5]
  =
  let
    funtype_141 =
      case fun_2 of
        (ErlangTuple [(ErlangAtom "qid"), _,
                      (ErlangCons (ErlangCons (ErlangInt num_7) (ErlangCons (ErlangInt num_8) (ErlangCons (ErlangInt num_9) (ErlangCons (ErlangInt num_10) (ErlangCons (ErlangInt num_11) (ErlangEmptyList)))))) (ErlangCons (ErlangCons (ErlangInt num_12) (ErlangCons (ErlangInt num_13) (ErlangCons (ErlangInt num_14) (ErlangCons (ErlangInt num_15) (ErlangCons (ErlangInt num_16) (ErlangCons (ErlangInt num_17) (ErlangEmptyList))))))) (ErlangEmptyList)))]) | (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_7) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            67)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_8) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            104)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_9) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            97)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_10) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            105)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_11) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            110)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_12) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            99)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_13) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            114)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_14) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            101)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_15) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            97)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_16) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            116)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          num_17) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            101) ->
          case funtype0_3 of
            (ErlangTuple [(ErlangAtom "fun_t"), _, namedargst_18,
                          (ErlangAtom "var_args"), rett_19]) ->
              let    tup_el_26 = toErl "gas"
              in let
                tup_el_23 = ErlangTuple [ErlangAtom "id", ann_1, tup_el_26]
              in let tup_el_30 = toErl "int"
              in let
                tup_el_27 = ErlangTuple [ErlangAtom "id", ann_1, tup_el_30]
              in let tup_el_34 = toErl 0
              in let
                tup_el_31 = ErlangTuple [ErlangAtom "int", ann_1, tup_el_34]
              in let
                gascapmock_35 =
                  ErlangTuple
                    [ErlangAtom "named_arg_t", ann_1, tup_el_23, tup_el_27,
                     tup_el_31]
              in let tup_el_41 = toErl "protected"
              in let
                tup_el_38 = ErlangTuple [ErlangAtom "id", ann_1, tup_el_41]
              in let tup_el_45 = toErl "bool"
              in let
                tup_el_42 = ErlangTuple [ErlangAtom "id", ann_1, tup_el_45]
              in let
                tup_el_46 =
                  ErlangTuple [ErlangAtom "bool", ann_1, ErlangAtom "false"]
              in let
                protectedmock_50 =
                  ErlangTuple
                    [ErlangAtom "named_arg_t", ann_1, tup_el_38, tup_el_42,
                     tup_el_46]
              in let
                namedargst1_64 =
                  case namedargst_18 of
                    (ErlangCons value_52 rest_53) ->
                      ErlangCons gascapmock_35
                        (ErlangCons value_52
                           (ErlangCons protectedmock_50 rest_53))
                    _ ->
                      ErlangCons gascapmock_35
                        (ErlangCons protectedmock_50 namedargst_18)
              in let
                _ =
                  erlps__check_contract_construction__7
                    [env_0, ErlangAtom "true", rett_19, fun_2, namedargst1_64,
                     argtypes_5, rett_19]
              in
                ErlangTuple
                  [ErlangAtom "fun_t", ann_1, namedargst_18, argtypes_5,
                   rett_19]
            _ -> EXC.badmatch funtype0_3
        (ErlangTuple [(ErlangAtom "qid"), _,
                      (ErlangCons (ErlangCons (ErlangInt num_77) (ErlangCons (ErlangInt num_78) (ErlangCons (ErlangInt num_79) (ErlangCons (ErlangInt num_80) (ErlangCons (ErlangInt num_81) (ErlangEmptyList)))))) (ErlangCons (ErlangCons (ErlangInt num_82) (ErlangCons (ErlangInt num_83) (ErlangCons (ErlangInt num_84) (ErlangCons (ErlangInt num_85) (ErlangCons (ErlangInt num_86) (ErlangEmptyList)))))) (ErlangEmptyList)))]) | (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_77) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               67)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_78) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               104)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_79) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               97)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_80) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               105)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_81) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               110)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_82) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               99)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_83) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               108)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_84) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               111)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_85) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               110)
                                                                                                                                                                                                                                                                                                                                                                                                                                        , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                             num_86) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                            (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                               101) ->
          case funtype0_3 of
            (ErlangTuple [(ErlangAtom "fun_t"), _, namedargst_87,
                          (ErlangAtom "var_args"), rett_88]) ->
              let   
                case_90 =
                  flmap
                    (\ lc_96 ->
                       case lc_96 of
                         (ErlangTuple [(ErlangAtom "named_arg"), _,
                                       (ErlangTuple [(ErlangAtom "id"), _,
                                                     (ErlangCons (ErlangInt num_92) (ErlangCons (ErlangInt num_93) (ErlangCons (ErlangInt num_94) (ErlangEmptyList))))]),
                                       (ErlangTuple [(ErlangAtom "typed"), _, _,
                                                     contractt_95])]) | (ErlangInt
                                                                           num_92) ==
                                                                          (toErl
                                                                             114)
                                                                      , (ErlangInt
                                                                           num_93) ==
                                                                          (toErl
                                                                             101)
                                                                      , (ErlangInt
                                                                           num_94) ==
                                                                          (toErl
                                                                             102) ->
                           ErlangCons contractt_95 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    namedargs_4
              in let
                contractt_103 =
                  case case_90 of
                    (ErlangCons c_98 (ErlangEmptyList)) -> c_98
                    _ ->
                      let   
                        arg_99 =
                          ErlangTuple [ErlangAtom "clone_no_contract", ann_1]
                      in let _ = erlps__type_error__1 [arg_99]
                      in erlps__fresh_uvar__1 [ann_1]
              in let
                arg_104 =
                  ErlangFun 1
                    (let
                       lambda_105 [(ErlangTuple [(ErlangAtom "named_arg_t"), _,
                                                 (ErlangTuple [(ErlangAtom "id"),
                                                               _,
                                                               (ErlangCons (ErlangInt num_107) (ErlangCons (ErlangInt num_108) (ErlangCons (ErlangInt num_109) (ErlangEmptyList))))]),
                                                 _, _])]
                         | (ErlangInt num_107) == (toErl 114)
                         , (ErlangInt num_108) == (toErl 101)
                         , (ErlangInt num_109) == (toErl 102) =
                         ErlangAtom "false"
                       lambda_105 [_] = ErlangAtom "true"
                       lambda_105 [arg_106] = EXC.function_clause unit
                       lambda_105 args =
                         EXC.badarity (ErlangFun 1 lambda_105) args
                     in lambda_105)
              in let
                namedargstnoref_111 =
                  BIF.do_remote_fun_call "Lists" "erlps__filter__2"
                    [arg_104, namedargst_87]
              in let
                _ =
                  erlps__check_contract_construction__7
                    [env_0, ErlangAtom "false", contractt_103, fun_2,
                     namedargstnoref_111, argtypes_5, rett_88]
              in let tup_el_129 = toErl "protected"
              in let
                tup_el_126 = ErlangTuple [ErlangAtom "id", ann_1, tup_el_129]
              in let tup_el_136 = toErl "option"
              in let
                tup_el_133 = ErlangTuple [ErlangAtom "id", ann_1, tup_el_136]
              in let
                tup_el_130 =
                  ErlangTuple
                    [ErlangAtom "app_t", ann_1, tup_el_133,
                     ErlangCons rett_88 ErlangEmptyList]
              in let
                tup_el_123 =
                  ErlangTuple
                    [ErlangAtom "if_t", ann_1, tup_el_126, tup_el_130, rett_88]
              in
                ErlangTuple
                  [ErlangAtom "fun_t", ann_1, namedargst_87, argtypes_5,
                   tup_el_123]
            _ -> EXC.badmatch funtype0_3
        _ -> funtype0_3
  in ErlangTuple [ErlangAtom "typed", ann_1, fun_2, funtype_141]
erlps__infer_var_args_fun__4 [arg_146, arg_147, arg_148, arg_149]
  =
  EXC.function_clause unit
erlps__infer_var_args_fun__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_var_args_fun__4) args

erlps__check_contract_construction__7 :: ErlangFun
erlps__check_contract_construction__7 [env_0, forcedef_1,
                                       contractt_2, fun_3, namedargst_4,
                                       argtypes_5, rett_6]
  =
  let   
    ann_8 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [fun_3]
  in let initt_10 = erlps__fresh_uvar__1 [ann_8]
  in let tup_el_18 = erlps__fresh_uvar__1 [ann_8]
  in let
    arg_13 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_8, namedargst_4, argtypes_5, tup_el_18]
  in let
    arg_20 =
      ErlangTuple
        [ErlangAtom "checking_init_args", ann_8, contractt_2, argtypes_5]
  in let _ = erlps__unify__4 [env_0, initt_10, arg_13, arg_20]
  in let
    arg_28 =
      ErlangTuple [ErlangAtom "return_contract", fun_3, contractt_2]
  in let _ = erlps__unify__4 [env_0, rett_6, contractt_2, arg_28]
  in let
    tup_el_35 = erlps__unfold_types_in_type__2 [env_0, contractt_2]
  in let tup_el_41 = toErl "#__constructor__#"
  in let
    tup_el_38 = ErlangTuple [ErlangAtom "id", ann_8, tup_el_41]
  in let
    tup_el_44 = ErlangTuple [ErlangAtom "var_args", ann_8, fun_3]
  in let
    head_33 =
      ErlangTuple
        [ErlangAtom "field_constraint", tup_el_35, tup_el_38, initt_10,
         ErlangAtom "project", tup_el_44]
  in let
    tup_el_52 = ErlangTuple [ErlangAtom "var_args", ann_8, fun_3]
  in let
    head_49 =
      ErlangTuple
        [ErlangAtom "is_contract_constraint", contractt_2, tup_el_52,
         forcedef_1]
  in let
    _ =
      erlps__constrain__1
        [ErlangCons head_33 (ErlangCons head_49 ErlangEmptyList)]
  in ErlangAtom "ok"
erlps__check_contract_construction__7 [arg_58, arg_59, arg_60,
                                       arg_61, arg_62, arg_63, arg_64]
  =
  EXC.function_clause unit
erlps__check_contract_construction__7 args =
  EXC.badarity (ErlangFun 7 erlps__check_contract_construction__7)
    args

erlps__split_args__1 :: ErlangFun
erlps__split_args__1 [args0_0] =
  let   
    namedargs_5 =
      flmap
        (\ lc_3 ->
           case lc_3 of
             arg_2@(ErlangTuple [(ErlangAtom "named_arg"), _, _, _]) ->
               ErlangCons arg_2 ErlangEmptyList
             _ -> ErlangEmptyList)
        args0_0
  in let args_8 = BIF.erlang__op_unAppend [args0_0, namedargs_5]
  in ErlangTuple [namedargs_5, args_8]
erlps__split_args__1 [arg_11] = EXC.function_clause unit
erlps__split_args__1 args =
  EXC.badarity (ErlangFun 1 erlps__split_args__1) args

erlps__infer_named_arg__3 :: ErlangFun
erlps__infer_named_arg__3 [env_0, namedargs_1,
                           (ErlangTuple [(ErlangAtom "named_arg"), ann_2, id_3,
                                         e_4])]
  =
  let matchExpr_8 = erlps__infer_expr__2 [env_0, e_4]
  in
    case matchExpr_8 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, argtype_7]) ->
        let    _ = erlps__check_stateful_named_arg__3 [env_0, id_3, e_4]
        in let
          arg_13 =
            ErlangTuple
              [ErlangAtom "named_argument_constraint", namedargs_1, id_3,
               argtype_7]
        in let _ = erlps__add_named_argument_constraint__1 [arg_13]
        in ErlangTuple [ErlangAtom "named_arg", ann_2, id_3, matchExpr_8]
      _ -> EXC.badmatch matchExpr_8
erlps__infer_named_arg__3 [arg_22, arg_23, arg_24] =
  EXC.function_clause unit
erlps__infer_named_arg__3 args =
  EXC.badarity (ErlangFun 3 erlps__infer_named_arg__3) args

erlps__check_map_update__4 :: ErlangFun
erlps__check_map_update__4 [env_0,
                            (ErlangTuple [(ErlangAtom "field"), ann_1,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    ann1_2,
                                                                    key_3]) (ErlangEmptyList)),
                                          val_4]),
                            keytype_5, valtype_6]
  =
  let    key1_10 = erlps__check_expr__3 [env_0, key_3, keytype_5]
  in let val1_14 = erlps__check_expr__3 [env_0, val_4, valtype_6]
  in let
    head_18 = ErlangTuple [ErlangAtom "map_get", ann1_2, key1_10]
  in
    ErlangTuple
      [ErlangAtom "field", ann_1, ErlangCons head_18 ErlangEmptyList,
       val1_14]
erlps__check_map_update__4 [_env_0,
                            upd_6@(ErlangTuple [(ErlangAtom "field"), _ann_1,
                                                (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                          _ann1_2,
                                                                          _key_3,
                                                                          _def_4]) (ErlangEmptyList)),
                                                _val_5]),
                            _keytype_7, _valtype_8]
  =
  let
    arg_9 =
      ErlangTuple [ErlangAtom "unnamed_map_update_with_default", upd_6]
  in erlps__type_error__1 [arg_9]
erlps__check_map_update__4 [env_0,
                            (ErlangTuple [(ErlangAtom "field"), ann_1,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    ann1_2,
                                                                    key_3]) (ErlangEmptyList)),
                                          id_4, val_5]),
                            keytype_6, valtype_7]
  =
  let   
    funtype_15 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_1, ErlangEmptyList,
         ErlangCons valtype_7 ErlangEmptyList, valtype_7]
  in let key1_19 = erlps__check_expr__3 [env_0, key_3, keytype_6]
  in let
    head_25 = ErlangTuple [ErlangAtom "arg", ann1_2, id_4, valtype_7]
  in let
    arg_21 =
      ErlangTuple
        [ErlangAtom "lam", ann1_2, ErlangCons head_25 ErlangEmptyList,
         val_5]
  in let fun_33 = erlps__check_expr__3 [env_0, arg_21, funtype_15]
  in let
    head_37 = ErlangTuple [ErlangAtom "map_get", ann1_2, key1_19]
  in
    ErlangTuple
      [ErlangAtom "field_upd", ann_1,
       ErlangCons head_37 ErlangEmptyList, fun_33]
erlps__check_map_update__4 [env_0,
                            (ErlangTuple [(ErlangAtom "field"), ann_1,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    ann1_2,
                                                                    key_3,
                                                                    def_4]) (ErlangEmptyList)),
                                          id_5, val_6]),
                            keytype_7, valtype_8]
  =
  let   
    funtype_16 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_1, ErlangEmptyList,
         ErlangCons valtype_8 ErlangEmptyList, valtype_8]
  in let key1_20 = erlps__check_expr__3 [env_0, key_3, keytype_7]
  in let def1_24 = erlps__check_expr__3 [env_0, def_4, valtype_8]
  in let
    head_30 = ErlangTuple [ErlangAtom "arg", ann1_2, id_5, valtype_8]
  in let
    arg_26 =
      ErlangTuple
        [ErlangAtom "lam", ann1_2, ErlangCons head_30 ErlangEmptyList,
         val_6]
  in let fun_38 = erlps__check_expr__3 [env_0, arg_26, funtype_16]
  in let
    head_42 =
      ErlangTuple [ErlangAtom "map_get", ann1_2, key1_20, def1_24]
  in
    ErlangTuple
      [ErlangAtom "field_upd", ann_1,
       ErlangCons head_42 ErlangEmptyList, fun_38]
erlps__check_map_update__4 [_,
                            (ErlangTuple [(ErlangAtom "field"), ann_0, flds_1,
                                          _]),
                            _, _]
  =
  let
    arg_2 =
      ErlangTuple
        [ErlangAtom "nested_map_updates_not_implemented", ann_0, flds_1]
  in BIF.erlang__error__1 [arg_2]
erlps__check_map_update__4 [arg_6, arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__check_map_update__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_map_update__4) args

erlps__check_record_update__3 :: ErlangFun
erlps__check_record_update__3 [env_0, recordtype_1, fld_2] =
  let matchExpr_9 = BIF.erlang__tuple_to_list__1 [fld_2]
  in
    case matchExpr_9 of
      (ErlangCons (ErlangAtom "field") (ErlangCons ann_4 (ErlangCons lv_7@(ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                                                                    ann1_5,
                                                                                                    fieldname_6]) (ErlangEmptyList)) val_8))) ->
        let    fldtype_11 = erlps__fresh_uvar__1 [ann_4]
        in let
          fld1_49 =
            case val_8 of
              (ErlangCons expr_13 (ErlangEmptyList)) ->
                let
                  tup_el_17 = erlps__check_expr__3 [env_0, expr_13, fldtype_11]
                in ErlangTuple [ErlangAtom "field", ann_4, lv_7, tup_el_17]
              (ErlangCons id_21 (ErlangCons expr_22 (ErlangEmptyList))) ->
                let   
                  head_26 =
                    ErlangTuple [ErlangAtom "arg", ann1_5, id_21, fldtype_11]
                in let
                  fun_33 =
                    ErlangTuple
                      [ErlangAtom "lam", ann1_5,
                       ErlangCons head_26 ErlangEmptyList, expr_22]
                in let
                  funtype_41 =
                    ErlangTuple
                      [ErlangAtom "fun_t", ann1_5, ErlangEmptyList,
                       ErlangCons fldtype_11 ErlangEmptyList, fldtype_11]
                in let
                  tup_el_45 = erlps__check_expr__3 [env_0, fun_33, funtype_41]
                in ErlangTuple [ErlangAtom "field_upd", ann_4, lv_7, tup_el_45]
              something_else -> EXC.case_clause something_else
        in let
          tup_el_53 = erlps__unfold_types_in_type__2 [env_0, recordtype_1]
        in let
          head_51 =
            ErlangTuple
              [ErlangAtom "field_constraint", tup_el_53, fieldname_6,
               fldtype_11, ErlangAtom "update", fld_2]
        in let
          _ = erlps__constrain__1 [ErlangCons head_51 ErlangEmptyList]
        in fld1_49
      _ -> EXC.badmatch matchExpr_9
erlps__check_record_update__3 [arg_61, arg_62, arg_63] =
  EXC.function_clause unit
erlps__check_record_update__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_record_update__3) args

erlps__infer_op__5 :: ErlangFun
erlps__infer_op__5 [env_0, as_1, op_2, args_3, inferop_4] =
  let   
    typedargs_11 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__infer_expr__2 [env_0, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        args_3
  in let
    argtypes_16 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangAtom "typed"), _, _, t_13]) ->
               ErlangCons t_13 ErlangEmptyList
             _ -> ErlangEmptyList)
        typedargs_11
  in let
    matchExpr_21 =
      BIF.erlang__apply__2 [inferop_4, ErlangCons op_2 ErlangEmptyList]
  in
    case matchExpr_21 of
      (ErlangTuple [(ErlangAtom "fun_t"), _, _, operandtypes_19,
                    resulttype_20]) ->
        let   
          arg_26 =
            ErlangTuple
              [ErlangAtom "infer_app", op_2, ErlangEmptyList, args_3,
               matchExpr_21, argtypes_16]
        in let
          _ = erlps__unify__4 [env_0, argtypes_16, operandtypes_19, arg_26]
        in let
          tup_el_35 =
            ErlangTuple [ErlangAtom "app", as_1, op_2, typedargs_11]
        in
          ErlangTuple [ErlangAtom "typed", as_1, tup_el_35, resulttype_20]
      _ -> EXC.badmatch matchExpr_21
erlps__infer_op__5 [arg_41, arg_42, arg_43, arg_44, arg_45] =
  EXC.function_clause unit
erlps__infer_op__5 args =
  EXC.badarity (ErlangFun 5 erlps__infer_op__5) args

erlps__infer_pattern__2 :: ErlangFun
erlps__infer_pattern__2 [env_0, pattern_1] =
  let    vars_3 = erlps__free_vars__1 [pattern_1]
  in let
    names_11 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "id"), _, n_5]) ->
               let    rop_9 = toErl "_"
               in let cond_7 = BIF.erlang__op_neq [n_5, rop_9]
               in
                 case cond_7 of
                   (ErlangAtom "true") -> ErlangCons n_5 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        vars_3
  in let
    rop_14 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [names_11]
  in let case_12 = BIF.erlang__op_unAppend [names_11, rop_14]
  in let
    _ =
      case case_12 of
        (ErlangEmptyList) -> ErlangAtom "ok"
        nonlinear_16 ->
          let   
            tup_el_20 =
              BIF.do_remote_fun_call "Lists" "erlps__usort__1" [nonlinear_16]
          in let
            arg_17 =
              ErlangTuple
                [ErlangAtom "non_linear_pattern", pattern_1, tup_el_20]
          in erlps__type_error__1 [arg_17]
  in let
    arg_22 =
      flmap
        (\ lc_26 ->
           case lc_26 of
             var_25@(ErlangTuple [(ErlangAtom "id"), ann1_24, _]) ->
               let    tup_el_29 = erlps__fresh_uvar__1 [ann1_24]
               in let lcRet_27 = ErlangTuple [var_25, tup_el_29]
               in ErlangCons lcRet_27 ErlangEmptyList
             _ -> ErlangEmptyList)
        vars_3
  in let
    arg_31 =
      case env_0 of
        (ErlangTuple [(ErlangAtom "env"), scopes_34, vars_35,
                      typevars_36, fields_37, namespace_38, in_pattern_39,
                      stateful_40, current_function_41, what_42]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_34, vars_35, typevars_36, fields_37,
             namespace_38, ErlangAtom "true", stateful_40,
             current_function_41, what_42]
        _ -> EXC.badrecord (ErlangAtom "env")
  in let newenv_43 = erlps__bind_vars__2 [arg_22, arg_31]
  in let
    newpattern_46 = erlps__infer_expr__2 [newenv_43, pattern_1]
  in let
    record_updt_49 =
      case env_0 of
        (ErlangTuple arr_52) | (DM.Just field_51) <- (arr_52 DA.!! 6) ->
          field_51
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    tup_el_47 =
      case newenv_43 of
        (ErlangTuple [(ErlangAtom "env"), scopes_53, vars_54,
                      typevars_55, fields_56, namespace_57, in_pattern_58,
                      stateful_59, current_function_60, what_61]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_53, vars_54, typevars_55, fields_56,
             namespace_57, record_updt_49, stateful_59, current_function_60,
             what_61]
        _ -> EXC.badrecord (ErlangAtom "env")
  in ErlangTuple [tup_el_47, newpattern_46]
erlps__infer_pattern__2 [arg_63, arg_64] =
  EXC.function_clause unit
erlps__infer_pattern__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_pattern__2) args

erlps__infer_case__6 :: ErlangFun
erlps__infer_case__6 [env_0, attrs_1, pattern_2, exprtype_3,
                      branch_4, switchtype_5]
  =
  let matchExpr_11 = erlps__infer_pattern__2 [env_0, pattern_2]
  in
    case matchExpr_11 of
      (ErlangTuple [newenv_8,
                    newpattern_10@(ErlangTuple [(ErlangAtom "typed"), _, _,
                                                pattype_9])]) ->
        let   
          arg_12 =
            case newenv_8 of
              (ErlangTuple [(ErlangAtom "env"), scopes_15, vars_16,
                            typevars_17, fields_18, namespace_19, in_pattern_20,
                            stateful_21, current_function_22, what_23]) ->
                ErlangTuple
                  [ErlangAtom "env", scopes_15, vars_16, typevars_17, fields_18,
                   namespace_19, ErlangAtom "false", stateful_21,
                   current_function_22, what_23]
              _ -> EXC.badrecord (ErlangAtom "env")
        in let
          newbranch_26 =
            erlps__check_expr__3 [arg_12, branch_4, switchtype_5]
        in let
          arg_30 =
            ErlangTuple
              [ErlangAtom "case_pat", pattern_2, pattype_9, exprtype_3]
        in let _ = erlps__unify__4 [env_0, pattype_9, exprtype_3, arg_30]
        in
          ErlangTuple
            [ErlangAtom "case", attrs_1, newpattern_10, newbranch_26]
      _ -> EXC.badmatch matchExpr_11
erlps__infer_case__6 [arg_39, arg_40, arg_41, arg_42, arg_43,
                      arg_44]
  =
  EXC.function_clause unit
erlps__infer_case__6 args =
  EXC.badarity (ErlangFun 6 erlps__infer_case__6) args

erlps__infer_block__4 :: ErlangFun
erlps__infer_block__4 [_env_0, attrs_1, (ErlangEmptyList),
                       blocktype_2]
  =
  let
    arg_3 =
      ErlangTuple
        [ErlangAtom "impossible", ErlangAtom "empty_block", attrs_1,
         blocktype_2]
  in BIF.erlang__error__1 [arg_3]
erlps__infer_block__4 [env_0, _,
                       (ErlangCons e_1 (ErlangEmptyList)), blocktype_2]
  =
  let head_3 = erlps__check_expr__3 [env_0, e_1, blocktype_2]
  in ErlangCons head_3 ErlangEmptyList
erlps__infer_block__4 [env_0, attrs_1,
                       (ErlangCons def_3@(ErlangTuple [(ErlangAtom "letfun"),
                                                       ann_2, _, _, _,
                                                       _]) rest_4),
                       blocktype_5]
  =
  let matchExpr_11 = erlps__infer_letfun__2 [env_0, def_3]
  in
    case matchExpr_11 of
      (ErlangTuple [(ErlangTuple [name_8, typesig_9]), letfun_10]) ->
        let    funt_13 = erlps__typesig_to_fun_t__1 [typesig_9]
        in let arg_14 = ErlangTuple [ErlangAtom "id", ann_2, name_8]
        in let newe_20 = erlps__bind_var__3 [arg_14, funt_13, env_0]
        in let
          tail_22 =
            erlps__infer_block__4 [newe_20, attrs_1, rest_4, blocktype_5]
        in ErlangCons letfun_10 tail_22
      _ -> EXC.badmatch matchExpr_11
erlps__infer_block__4 [env_0, _,
                       (ErlangCons (ErlangTuple [(ErlangAtom "letval"), attrs_1,
                                                 pattern_2, e_3]) rest_4),
                       blocktype_5]
  =
  let matchExpr_9 = erlps__infer_expr__2 [env_0, e_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, pattype_8]) ->
        let    arg_15 = ErlangTuple [ErlangAtom "block", attrs_1, rest_4]
        in let
          matchExpr_22 =
            erlps__infer_case__6
              [env_0, attrs_1, pattern_2, pattype_8, arg_15, blocktype_5]
        in
          case matchExpr_22 of
            (ErlangTuple [(ErlangAtom "case"), _, newpattern_20,
                          (ErlangTuple [(ErlangAtom "typed"), _,
                                        (ErlangTuple [(ErlangAtom "block"), _,
                                                      newrest_21]),
                                        _])]) ->
              let
                head_23 =
                  ErlangTuple
                    [ErlangAtom "letval", attrs_1, newpattern_20, matchExpr_9]
              in ErlangCons head_23 newrest_21
            _ -> EXC.badmatch matchExpr_22
      _ -> EXC.badmatch matchExpr_9
erlps__infer_block__4 [env_0, attrs_1, (ErlangCons e_2 rest_3),
                       blocktype_4]
  =
  let    head_5 = erlps__infer_expr__2 [env_0, e_2]
  in let
    tail_8 =
      erlps__infer_block__4 [env_0, attrs_1, rest_3, blocktype_4]
  in ErlangCons head_5 tail_8
erlps__infer_block__4 [arg_13, arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__infer_block__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_block__4) args

erlps__infer_infix__1 :: ErlangFun
erlps__infer_infix__1 [(ErlangTuple [boolop_0, as_1])]
  | ((==) boolop_0 (ErlangAtom "&&")) ||
      ((==) boolop_0 (ErlangAtom "||")) =
  let    tup_el_4 = toErl "bool"
  in let bool_5 = ErlangTuple [ErlangAtom "id", as_1, tup_el_4]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons bool_5 (ErlangCons bool_5 ErlangEmptyList), bool_5]
erlps__infer_infix__1 [(ErlangTuple [intop_0, as_1])]
  | (((((weakEq intop_0 (ErlangAtom "+")) ||
          (weakEq intop_0 (ErlangAtom "-"))) ||
         (weakEq intop_0 (ErlangAtom "*"))) ||
        (weakEq intop_0 (ErlangAtom "/"))) ||
       (weakEq intop_0 (ErlangAtom "^"))) ||
      (weakEq intop_0 (ErlangAtom "mod")) =
  let    tup_el_4 = toErl "int"
  in let int_5 = ErlangTuple [ErlangAtom "id", as_1, tup_el_4]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons int_5 (ErlangCons int_5 ErlangEmptyList), int_5]
erlps__infer_infix__1 [(ErlangTuple [relop_0, as_1])]
  | ((((((weakEq relop_0 (ErlangAtom "==")) ||
           (weakEq relop_0 (ErlangAtom "!="))) ||
          (weakEq relop_0 (ErlangAtom "<"))) ||
         (weakEq relop_0 (ErlangAtom ">"))) ||
        (weakEq relop_0 (ErlangAtom "<="))) ||
       (weakEq relop_0 (ErlangAtom "=<"))) ||
      (weakEq relop_0 (ErlangAtom ">=")) =
  let    t_3 = erlps__fresh_uvar__1 [as_1]
  in let tup_el_6 = toErl "bool"
  in let bool_7 = ErlangTuple [ErlangAtom "id", as_1, tup_el_6]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons t_3 (ErlangCons t_3 ErlangEmptyList), bool_7]
erlps__infer_infix__1 [(ErlangTuple [(ErlangAtom ".."), as_0])] =
  let    tup_el_3 = toErl "int"
  in let int_4 = ErlangTuple [ErlangAtom "id", as_0, tup_el_3]
  in let tup_el_19 = toErl "list"
  in let tup_el_16 = ErlangTuple [ErlangAtom "id", as_0, tup_el_19]
  in let
    tup_el_13 =
      ErlangTuple
        [ErlangAtom "app_t", as_0, tup_el_16,
         ErlangCons int_4 ErlangEmptyList]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons int_4 (ErlangCons int_4 ErlangEmptyList), tup_el_13]
erlps__infer_infix__1 [(ErlangTuple [(ErlangAtom "::"), as_0])] =
  let    elemtype_2 = erlps__fresh_uvar__1 [as_0]
  in let tup_el_8 = toErl "list"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", as_0, tup_el_8]
  in let
    listtype_12 =
      ErlangTuple
        [ErlangAtom "app_t", as_0, tup_el_5,
         ErlangCons elemtype_2 ErlangEmptyList]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons elemtype_2 (ErlangCons listtype_12 ErlangEmptyList),
       listtype_12]
erlps__infer_infix__1 [(ErlangTuple [(ErlangAtom "++"), as_0])] =
  let    elemtype_2 = erlps__fresh_uvar__1 [as_0]
  in let tup_el_8 = toErl "list"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", as_0, tup_el_8]
  in let
    listtype_12 =
      ErlangTuple
        [ErlangAtom "app_t", as_0, tup_el_5,
         ErlangCons elemtype_2 ErlangEmptyList]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons listtype_12 (ErlangCons listtype_12 ErlangEmptyList),
       listtype_12]
erlps__infer_infix__1 [arg_22] = EXC.function_clause unit
erlps__infer_infix__1 args =
  EXC.badarity (ErlangFun 1 erlps__infer_infix__1) args

erlps__infer_prefix__1 :: ErlangFun
erlps__infer_prefix__1 [(ErlangTuple [(ErlangAtom "!"), as_0])] =
  let    tup_el_3 = toErl "bool"
  in let bool_4 = ErlangTuple [ErlangAtom "id", as_0, tup_el_3]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons bool_4 ErlangEmptyList, bool_4]
erlps__infer_prefix__1 [(ErlangTuple [intop_0, as_1])]
  | (==) intop_0 (ErlangAtom "-") =
  let    tup_el_4 = toErl "int"
  in let int_5 = ErlangTuple [ErlangAtom "id", as_1, tup_el_4]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons int_5 ErlangEmptyList, int_5]
erlps__infer_prefix__1 [arg_13] = EXC.function_clause unit
erlps__infer_prefix__1 args =
  EXC.badarity (ErlangFun 1 erlps__infer_prefix__1) args

erlps__abort_expr__2 :: ErlangFun
erlps__abort_expr__2 [ann_0, str_1] =
  let    tup_el_7 = toErl "abort"
  in let tup_el_4 = ErlangTuple [ErlangAtom "id", ann_0, tup_el_7]
  in let head_9 = ErlangTuple [ErlangAtom "string", ann_0, str_1]
  in
    ErlangTuple
      [ErlangAtom "app", ann_0, tup_el_4,
       ErlangCons head_9 ErlangEmptyList]
erlps__abort_expr__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__abort_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__abort_expr__2) args

erlps__free_vars__1 :: ErlangFun
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "int"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "char"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "string"), _, _])]
  =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "bool"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [id_0@(ErlangTuple [(ErlangAtom "id"), _,
                                        _])]
  =
  ErlangCons id_0 ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "con"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "qcon"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "tuple"), _,
                                   cpts_0])]
  =
  erlps__free_vars__1 [cpts_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "list"), _,
                                   elems_0])]
  =
  erlps__free_vars__1 [elems_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                   (ErlangTuple [(ErlangAtom "::"), _]),
                                   args_0])]
  =
  erlps__free_vars__1 [args_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                   (ErlangTuple [(ErlangAtom "con"), _, _]),
                                   args_0])]
  =
  erlps__free_vars__1 [args_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                   (ErlangTuple [(ErlangAtom "qcon"), _, _]),
                                   args_0])]
  =
  erlps__free_vars__1 [args_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "record"), _,
                                   fields_0])]
  =
  let
    arg_1 =
      flmap
        (\ lc_4 ->
           case lc_4 of
             (ErlangTuple [(ErlangAtom "field"), _, _, e_3]) ->
               ErlangCons e_3 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_0
  in erlps__free_vars__1 [arg_1]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "typed"), _, a_0,
                                   _])]
  =
  erlps__free_vars__1 [a_0]
erlps__free_vars__1 [l_0] | isEList l_0 =
  flmap
    (\ lc_3 ->
       let lcSrc_4 = erlps__free_vars__1 [lc_3]
       in flmap (\ lc_7 -> ErlangCons lc_7 ErlangEmptyList) lcSrc_4)
    l_0
erlps__free_vars__1 [arg_9] = EXC.function_clause unit
erlps__free_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__free_vars__1) args

erlps__next_count__0 :: ErlangFun
erlps__next_count__0 [] =
  let    case_0 = BIF.erlang__get__1 [ErlangAtom "counter"]
  in let
    v_3 =
      case case_0 of
        (ErlangAtom "undefined") -> toErl 0
        x_2 -> x_2
  in let rop_7 = toErl 1
  in let arg_5 = BIF.erlang__op_plus [v_3, rop_7]
  in let _ = BIF.erlang__put__2 [ErlangAtom "counter", arg_5]
  in v_3
erlps__next_count__0 args =
  EXC.badarity (ErlangFun 0 erlps__next_count__0) args

erlps__ets_tables__0 :: ErlangFun
erlps__ets_tables__0 [] =
  ErlangCons (ErlangAtom "options")
    (ErlangCons (ErlangAtom "type_vars")
       (ErlangCons (ErlangAtom "type_defs")
          (ErlangCons (ErlangAtom "record_fields")
             (ErlangCons (ErlangAtom "named_argument_constraints")
                (ErlangCons (ErlangAtom "field_constraints")
                   (ErlangCons (ErlangAtom "freshen_tvars")
                      (ErlangCons (ErlangAtom "type_errors")
                         (ErlangCons (ErlangAtom "defined_contracts")
                            ErlangEmptyList))))))))
erlps__ets_tables__0 args =
  EXC.badarity (ErlangFun 0 erlps__ets_tables__0) args

erlps__clean_up_ets__0 :: ErlangFun
erlps__clean_up_ets__0 [] =
  let    lcSrc_0 = erlps__ets_tables__0 []
  in let
    _ =
      flmap
        (\ lc_2 ->
           let
             lcRet_3 =
               EXC.tryCatch (\ _ -> erlps__ets_delete__1 [lc_2])
                 (\ ex_6 ->
                    case ex_6 of
                      (ErlangTuple [(ErlangAtom "throw"), payload_8, _]) ->
                        payload_8
                      (ErlangTuple [(ErlangAtom "error"), payload_9,
                                    stack_10]) ->
                        let tup_el_12 = ErlangTuple [payload_9, stack_10]
                        in ErlangTuple [ErlangAtom "EXIT", tup_el_12]
                      (ErlangTuple [(ErlangAtom "exit"), payload_15, _]) ->
                        ErlangTuple [ErlangAtom "EXIT", payload_15]
                      ex_7 -> EXC.raise ex_7)
           in ErlangCons lcRet_3 ErlangEmptyList)
        lcSrc_0
  in ErlangAtom "ok"
erlps__clean_up_ets__0 args =
  EXC.badarity (ErlangFun 0 erlps__clean_up_ets__0) args

erlps__ets_init__0 :: ErlangFun
erlps__ets_init__0 [] =
  let arg_1 = ErlangMap Map.empty
  in BIF.erlang__put__2 [ErlangAtom "aeso_ast_infer_types", arg_1]
erlps__ets_init__0 args =
  EXC.badarity (ErlangFun 0 erlps__ets_init__0) args

erlps__ets_tabid__1 :: ErlangFun
erlps__ets_tabid__1 [name_0] =
  let
    matchExpr_4 =
      BIF.erlang__get__1 [ErlangAtom "aeso_ast_infer_types"]
  in
    case matchExpr_4 of
      (ErlangMap map_2) | (DM.Just tabid_3) <-
                            (Map.lookup name_0 map_2) ->
        tabid_3
      _ -> EXC.badmatch matchExpr_4
erlps__ets_tabid__1 [arg_5] = EXC.function_clause unit
erlps__ets_tabid__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_tabid__1) args

erlps__ets_new__2 :: ErlangFun
erlps__ets_new__2 [name_0, opts_1] =
  let   
    arg_3 =
      BIF.erlang__op_unAppend
        [opts_1, ErlangCons (ErlangAtom "named_table") ErlangEmptyList]
  in let
    tabid_8 =
      BIF.do_remote_fun_call "Ets" "erlps__new__2" [name_0, arg_3]
  in let
    tabs_10 = BIF.erlang__get__1 [ErlangAtom "aeso_ast_infer_types"]
  in let mapExt_16 = ErlangMap (Map.singleton name_0 tabid_8)
  in let arg_12 = BIF.maps__merge__2 [tabs_10, mapExt_16]
  in let
    _ =
      BIF.erlang__put__2 [ErlangAtom "aeso_ast_infer_types", arg_12]
  in name_0
erlps__ets_new__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__ets_new__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_new__2) args

erlps__ets_delete__1 :: ErlangFun
erlps__ets_delete__1 [name_0] =
  let
    tabs_2 = BIF.erlang__get__1 [ErlangAtom "aeso_ast_infer_types"]
  in
    case tabs_2 of
      (ErlangMap map_3) | (DM.Just tabid_4) <-
                            (Map.lookup name_0 map_3) ->
        let    arg_7 = BIF.maps__remove__2 [name_0, tabs_2]
        in let
          _ = BIF.erlang__put__2 [ErlangAtom "aeso_ast_infer_types", arg_7]
        in BIF.do_remote_fun_call "Ets" "erlps__delete__1" [tabid_4]
      _ -> EXC.badmatch tabs_2
erlps__ets_delete__1 [arg_11] = EXC.function_clause unit
erlps__ets_delete__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_delete__1) args

erlps__ets_insert__2 :: ErlangFun
erlps__ets_insert__2 [name_0, object_1] =
  let tabid_3 = erlps__ets_tabid__1 [name_0]
  in
    BIF.do_remote_fun_call "Ets" "erlps__insert__2"
      [tabid_3, object_1]
erlps__ets_insert__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__ets_insert__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_insert__2) args

erlps__ets_lookup__2 :: ErlangFun
erlps__ets_lookup__2 [name_0, key_1] =
  let tabid_3 = erlps__ets_tabid__1 [name_0]
  in
    BIF.do_remote_fun_call "Ets" "erlps__lookup__2" [tabid_3, key_1]
erlps__ets_lookup__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__ets_lookup__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_lookup__2) args

erlps__ets_tab2list__1 :: ErlangFun
erlps__ets_tab2list__1 [name_0] =
  let tabid_2 = erlps__ets_tabid__1 [name_0]
  in BIF.do_remote_fun_call "Ets" "erlps__tab2list__1" [tabid_2]
erlps__ets_tab2list__1 [arg_4] = EXC.function_clause unit
erlps__ets_tab2list__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_tab2list__1) args

erlps__ets_insert_ordered__2 :: ErlangFun
erlps__ets_insert_ordered__2 [_, (ErlangEmptyList)] =
  ErlangAtom "true"
erlps__ets_insert_ordered__2 [name_0, (ErlangCons h_1 t_2)] =
  let _ = erlps__ets_insert_ordered__2 [name_0, h_1]
  in erlps__ets_insert_ordered__2 [name_0, t_2]
erlps__ets_insert_ordered__2 [name_0, object_1] =
  let    count_2 = erlps__next_count__0 []
  in let tabid_4 = erlps__ets_tabid__1 [name_0]
  in let arg_6 = ErlangTuple [count_2, object_1]
  in
    BIF.do_remote_fun_call "Ets" "erlps__insert__2" [tabid_4, arg_6]
erlps__ets_insert_ordered__2 [arg_9, arg_10] =
  EXC.function_clause unit
erlps__ets_insert_ordered__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_insert_ordered__2) args

erlps__ets_tab2list_ordered__1 :: ErlangFun
erlps__ets_tab2list_ordered__1 [name_0] =
  let lcSrc_1 = erlps__ets_tab2list__1 [name_0]
  in
    flmap
      (\ lc_4 ->
         case lc_4 of
           (ErlangTuple [_, e_3]) -> ErlangCons e_3 ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_1
erlps__ets_tab2list_ordered__1 [arg_6] = EXC.function_clause unit
erlps__ets_tab2list_ordered__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_tab2list_ordered__1) args

erlps__create_options__1 :: ErlangFun
erlps__create_options__1 [options_0] =
  let   
    _ =
      erlps__ets_new__2
        [ErlangAtom "options",
         ErlangCons (ErlangAtom "set") ErlangEmptyList]
  in let
    tup_11 =
      ErlangFun 1
        (let
           lambda_5 [opt_7] | isEAtom opt_7 =
             ErlangTuple [opt_7, ErlangAtom "true"]
           lambda_5 [opt_10] | isETuple opt_10 = opt_10
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in let
    arg_13 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [tup_11, options_0]
  in erlps__ets_insert__2 [ErlangAtom "options", arg_13]
erlps__create_options__1 [arg_16] = EXC.function_clause unit
erlps__create_options__1 args =
  EXC.badarity (ErlangFun 1 erlps__create_options__1) args

erlps__get_option__2 :: ErlangFun
erlps__get_option__2 [key_0, default_1] =
  let case_2 = erlps__ets_lookup__2 [ErlangAtom "options", key_0]
  in
    case case_2 of
      (ErlangCons (ErlangTuple [key_5,
                                val_6]) (ErlangEmptyList)) | key_5 == key_0 ->
        val_6
      _ -> default_1
erlps__get_option__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__get_option__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_option__2) args

erlps__when_option__2 :: ErlangFun
erlps__when_option__2 [opt_0, do_1] =
  let lop_2 = erlps__get_option__2 [opt_0, ErlangAtom "false"]
  in
    case lop_2 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") ->
        BIF.erlang__apply__2 [do_1, ErlangEmptyList]
      _ -> EXC.badarg1 lop_2
erlps__when_option__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__when_option__2 args =
  EXC.badarity (ErlangFun 2 erlps__when_option__2) args

erlps__create_constraints__0 :: ErlangFun
erlps__create_constraints__0 [] =
  let    _ = erlps__create_named_argument_constraints__0 []
  in let _ = erlps__create_bytes_constraints__0 []
  in erlps__create_field_constraints__0 []
erlps__create_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_constraints__0) args

erlps__destroy_and_report_unsolved_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_constraints__1 [env_0] =
  let    _ = erlps__solve_field_constraints__1 [env_0]
  in let _ = erlps__solve_named_argument_constraints__1 [env_0]
  in let _ = erlps__solve_bytes_constraints__1 [env_0]
  in let
    _ =
      erlps__destroy_and_report_unsolved_bytes_constraints__1 [env_0]
  in let
    _ =
      erlps__destroy_and_report_unsolved_named_argument_constraints__1
        [env_0]
  in
    erlps__destroy_and_report_unsolved_field_constraints__1 [env_0]
erlps__destroy_and_report_unsolved_constraints__1 [arg_7] =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_constraints__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__destroy_and_report_unsolved_constraints__1)
    args

erlps__create_named_argument_constraints__0 :: ErlangFun
erlps__create_named_argument_constraints__0 [] =
  erlps__ets_new__2
    [ErlangAtom "named_argument_constraints",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_named_argument_constraints__0 args =
  EXC.badarity
    (ErlangFun 0 erlps__create_named_argument_constraints__0) args

erlps__destroy_named_argument_constraints__0 :: ErlangFun
erlps__destroy_named_argument_constraints__0 [] =
  erlps__ets_delete__1 [ErlangAtom "named_argument_constraints"]
erlps__destroy_named_argument_constraints__0 args =
  EXC.badarity
    (ErlangFun 0 erlps__destroy_named_argument_constraints__0) args

erlps__get_named_argument_constraints__0 :: ErlangFun
erlps__get_named_argument_constraints__0 [] =
  erlps__ets_tab2list_ordered__1
    [ErlangAtom "named_argument_constraints"]
erlps__get_named_argument_constraints__0 args =
  EXC.badarity
    (ErlangFun 0 erlps__get_named_argument_constraints__0) args

erlps__add_named_argument_constraint__1 :: ErlangFun
erlps__add_named_argument_constraint__1 [constraint_0] =
  let
    _ =
      erlps__ets_insert_ordered__2
        [ErlangAtom "named_argument_constraints", constraint_0]
  in ErlangAtom "ok"
erlps__add_named_argument_constraint__1 [arg_3] =
  EXC.function_clause unit
erlps__add_named_argument_constraint__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__add_named_argument_constraint__1) args

erlps__solve_named_argument_constraints__1 :: ErlangFun
erlps__solve_named_argument_constraints__1 [env_0] =
  let    arg_2 = erlps__get_named_argument_constraints__0 []
  in let
    unsolved_3 =
      erlps__solve_named_argument_constraints__2 [env_0, arg_2]
  in BIF.erlang__op_eq [unsolved_3, ErlangEmptyList]
erlps__solve_named_argument_constraints__1 [arg_6] =
  EXC.function_clause unit
erlps__solve_named_argument_constraints__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__solve_named_argument_constraints__1) args

erlps__solve_named_argument_constraints__2 :: ErlangFun
erlps__solve_named_argument_constraints__2 [env_0,
                                            constraints0_1]
  =
  let lcSrc_2 = erlps__dereference_deep__1 [constraints0_1]
  in
    flmap
      (\ lc_5 ->
         let   
           rop_8 = erlps__check_named_argument_constraint__2 [env_0, lc_5]
         in let cond_6 = BIF.erlang__op_eq [ErlangAtom "unsolved", rop_8]
         in
           case cond_6 of
             (ErlangAtom "true") -> ErlangCons lc_5 ErlangEmptyList
             _ -> ErlangEmptyList)
      lcSrc_2
erlps__solve_named_argument_constraints__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__solve_named_argument_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__solve_named_argument_constraints__2) args

erlps__check_named_argument_constraint__2 :: ErlangFun
erlps__check_named_argument_constraint__2 [_env_0,
                                           (ErlangTuple [(ErlangAtom "named_argument_constraint"),
                                                         (ErlangTuple [(ErlangAtom "uvar"),
                                                                       _, _]),
                                                         _, _])]
  =
  ErlangAtom "unsolved"
erlps__check_named_argument_constraint__2 [env_0,
                                           c_5@(ErlangTuple [(ErlangAtom "named_argument_constraint"),
                                                             args_1,
                                                             id_3@(ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                name_2]),
                                                             type_4])]
  =
  let
    case_6 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [(ErlangAtom "named_arg_t"), _,
                           (ErlangTuple [(ErlangAtom "id"), _, name1_8]), t_9,
                           _]) ->
               let cond_11 = BIF.erlang__op_eq [name1_8, name_2]
               in
                 case cond_11 of
                   (ErlangAtom "true") -> ErlangCons t_9 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        args_1
  in
    case case_6 of
      (ErlangEmptyList) ->
        let   
          arg_15 =
            ErlangTuple [ErlangAtom "bad_named_argument", args_1, id_3]
        in let _ = erlps__type_error__1 [arg_15]
        in ErlangAtom "false"
      (ErlangCons t_19 (ErlangEmptyList)) ->
        let   
          arg_23 =
            ErlangTuple [ErlangAtom "check_named_arg_constraint", c_5]
        in let _ = erlps__unify__4 [env_0, t_19, type_4, arg_23]
        in ErlangAtom "true"
      something_else -> EXC.case_clause something_else
erlps__check_named_argument_constraint__2 [env_0,
                                           (ErlangTuple [(ErlangAtom "dependent_type_constraint"),
                                                         namedargst0_1,
                                                         namedargs_2, gentype_3,
                                                         spectype_4,
                                                         (ErlangTuple [(ErlangAtom "check_return"),
                                                                       app_5])])]
  =
  let    namedargst_7 = erlps__dereference__1 [namedargst0_1]
  in let case_8 = erlps__dereference__1 [namedargst0_1]
  in
    case case_8 of
      namedargst_10@(ErlangCons _ _) | namedargst_10 == namedargst_7 ->
        let   
          getval_29 =
            ErlangFun 2
              (let
                 lambda_11 [name_14, default_15] =
                   let   
                     lop_17 =
                       flmap
                         (\ lc_21 ->
                            case lc_21 of
                              (ErlangTuple [(ErlangAtom "named_arg"), _,
                                            (ErlangTuple [(ErlangAtom "id"), _,
                                                          n_19]),
                                            val_20]) ->
                                let cond_22 = BIF.erlang__op_eq [n_19, name_14]
                                in
                                  case cond_22 of
                                    (ErlangAtom "true") ->
                                      ErlangCons val_20 ErlangEmptyList
                                    _ -> ErlangEmptyList
                              _ -> ErlangEmptyList)
                         namedargs_2
                   in let
                     arg_16 =
                       BIF.erlang__op_append
                         [lop_17, ErlangCons default_15 ErlangEmptyList]
                   in BIF.erlang__hd__1 [arg_16]
                 lambda_11 [arg_12, arg_13] = EXC.function_clause unit
                 lambda_11 args = EXC.badarity (ErlangFun 2 lambda_11) args
               in lambda_11)
        in let
          arg_30 =
            flmap
              (\ lc_34 ->
                 case lc_34 of
                   (ErlangTuple [(ErlangAtom "named_arg_t"), _,
                                 (ErlangTuple [(ErlangAtom "id"), _, name_32]),
                                 _, default_33]) ->
                     let   
                       tup_el_37 =
                         BIF.erlang__apply__2
                           [getval_29,
                            ErlangCons name_32
                              (ErlangCons default_33 ErlangEmptyList)]
                     in let lcRet_35 = ErlangTuple [name_32, tup_el_37]
                     in ErlangCons lcRet_35 ErlangEmptyList
                   _ -> ErlangEmptyList)
              namedargst_7
        in let argenv_41 = BIF.maps__from_list__1 [arg_30]
        in let
          gentype1_44 =
            erlps__specialize_dependent_type__2 [argenv_41, gentype_3]
        in let
          arg_48 =
            ErlangTuple
              [ErlangAtom "check_expr", app_5, gentype1_44, spectype_4]
        in let
          _ = erlps__unify__4 [env_0, gentype1_44, spectype_4, arg_48]
        in ErlangAtom "true"
      _ ->
        let   
          arg_56 =
            ErlangTuple
              [ErlangAtom "check_expr", app_5, gentype_3, spectype_4]
        in let _ = erlps__unify__4 [env_0, gentype_3, spectype_4, arg_56]
        in ErlangAtom "true"
erlps__check_named_argument_constraint__2 [arg_61, arg_62] =
  EXC.function_clause unit
erlps__check_named_argument_constraint__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__check_named_argument_constraint__2) args

erlps__specialize_dependent_type__2 :: ErlangFun
erlps__specialize_dependent_type__2 [env_0, type_1] =
  let case_2 = erlps__dereference__1 [type_1]
  in
    case case_2 of
      (ErlangTuple [(ErlangAtom "if_t"), _,
                    (ErlangTuple [(ErlangAtom "id"), _, arg_4]), then_5,
                    else_6]) ->
        let val_9 = BIF.maps__get__2 [arg_4, env_0]
        in
          case val_9 of
            (ErlangTuple [(ErlangAtom "typed"), _,
                          (ErlangTuple [(ErlangAtom "bool"), _,
                                        (ErlangAtom "true")]),
                          _]) ->
              then_5
            (ErlangTuple [(ErlangAtom "typed"), _,
                          (ErlangTuple [(ErlangAtom "bool"), _,
                                        (ErlangAtom "false")]),
                          _]) ->
              else_6
            _ ->
              let   
                arg_11 =
                  ErlangTuple
                    [ErlangAtom "named_argument_must_be_literal_bool", arg_4,
                     val_9]
              in let _ = erlps__type_error__1 [arg_11]
              in let
                arg_15 =
                  BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1"
                    [val_9]
              in erlps__fresh_uvar__1 [arg_15]
      _ -> type_1
erlps__specialize_dependent_type__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__specialize_dependent_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__specialize_dependent_type__2)
    args

erlps__destroy_and_report_unsolved_named_argument_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_named_argument_constraints__1 [env_0]
  =
  let    arg_2 = erlps__get_named_argument_constraints__0 []
  in let
    unsolved_3 =
      erlps__solve_named_argument_constraints__2 [env_0, arg_2]
  in let
    _ =
      flmap
        (\ lc_6 ->
           let   
             arg_8 =
               ErlangTuple
                 [ErlangAtom "unsolved_named_argument_constraint", lc_6]
           in let lcRet_7 = erlps__type_error__1 [arg_8]
           in ErlangCons lcRet_7 ErlangEmptyList)
        unsolved_3
  in let _ = erlps__destroy_named_argument_constraints__0 []
  in ErlangAtom "ok"
erlps__destroy_and_report_unsolved_named_argument_constraints__1 [arg_11]
  =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_named_argument_constraints__1 args
  =
  EXC.badarity
    (ErlangFun 1
       erlps__destroy_and_report_unsolved_named_argument_constraints__1)
    args

erlps__create_bytes_constraints__0 :: ErlangFun
erlps__create_bytes_constraints__0 [] =
  erlps__ets_new__2
    [ErlangAtom "bytes_constraints",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_bytes_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_bytes_constraints__0)
    args

erlps__get_bytes_constraints__0 :: ErlangFun
erlps__get_bytes_constraints__0 [] =
  erlps__ets_tab2list_ordered__1 [ErlangAtom "bytes_constraints"]
erlps__get_bytes_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__get_bytes_constraints__0) args

erlps__add_bytes_constraint__1 :: ErlangFun
erlps__add_bytes_constraint__1 [constraint_0] =
  erlps__ets_insert_ordered__2
    [ErlangAtom "bytes_constraints", constraint_0]
erlps__add_bytes_constraint__1 [arg_3] = EXC.function_clause unit
erlps__add_bytes_constraint__1 args =
  EXC.badarity (ErlangFun 1 erlps__add_bytes_constraint__1) args

erlps__solve_bytes_constraints__1 :: ErlangFun
erlps__solve_bytes_constraints__1 [env_0] =
  let    lcSrc_1 = erlps__get_bytes_constraints__0 []
  in let
    _ =
      flmap
        (\ lc_3 ->
           let lcRet_4 = erlps__solve_bytes_constraint__2 [env_0, lc_3]
           in ErlangCons lcRet_4 ErlangEmptyList)
        lcSrc_1
  in ErlangAtom "ok"
erlps__solve_bytes_constraints__1 [arg_7] =
  EXC.function_clause unit
erlps__solve_bytes_constraints__1 args =
  EXC.badarity (ErlangFun 1 erlps__solve_bytes_constraints__1)
    args

erlps__solve_bytes_constraint__2 :: ErlangFun
erlps__solve_bytes_constraint__2 [_env_0,
                                  (ErlangTuple [(ErlangAtom "is_bytes"), _])]
  =
  ErlangAtom "ok"
erlps__solve_bytes_constraint__2 [env_0,
                                  (ErlangTuple [(ErlangAtom "add_bytes"), ann_1,
                                                _, a0_2, b0_3, c0_4])]
  =
  let    arg_6 = erlps__dereference__1 [a0_2]
  in let a_8 = erlps__unfold_types_in_type__2 [env_0, arg_6]
  in let arg_10 = erlps__dereference__1 [b0_3]
  in let b_12 = erlps__unfold_types_in_type__2 [env_0, arg_10]
  in let arg_14 = erlps__dereference__1 [c0_4]
  in let c_16 = erlps__unfold_types_in_type__2 [env_0, arg_14]
  in let case_17 = ErlangTuple [a_8, b_12, c_16]
  in
    case case_17 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "bytes_t"), _, m_21]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, n_22]), _]) ->
        let    tup_el_27 = BIF.erlang__op_plus [m_21, n_22]
        in let
          arg_24 = ErlangTuple [ErlangAtom "bytes_t", ann_1, tup_el_27]
        in let arg_31 = ErlangTuple [ErlangAtom "at", ann_1]
        in erlps__unify__4 [env_0, arg_24, c_16, arg_31]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "bytes_t"), _, m_34]), _,
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, r_35])]) | weakGeq
                                                                          r_35
                                                                          m_34 ->
        let    tup_el_40 = BIF.erlang__op_minus [r_35, m_34]
        in let
          arg_37 = ErlangTuple [ErlangAtom "bytes_t", ann_1, tup_el_40]
        in let arg_44 = ErlangTuple [ErlangAtom "at", ann_1]
        in erlps__unify__4 [env_0, arg_37, b_12, arg_44]
      (ErlangTuple [_, (ErlangTuple [(ErlangAtom "bytes_t"), _, n_47]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, r_48])]) | weakGeq
                                                                          r_48
                                                                          n_47 ->
        let    tup_el_53 = BIF.erlang__op_minus [r_48, n_47]
        in let
          arg_50 = ErlangTuple [ErlangAtom "bytes_t", ann_1, tup_el_53]
        in let arg_57 = ErlangTuple [ErlangAtom "at", ann_1]
        in erlps__unify__4 [env_0, arg_50, a_8, arg_57]
      _ -> ErlangAtom "ok"
erlps__solve_bytes_constraint__2 [arg_60, arg_61] =
  EXC.function_clause unit
erlps__solve_bytes_constraint__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_bytes_constraint__2) args

erlps__destroy_bytes_constraints__0 :: ErlangFun
erlps__destroy_bytes_constraints__0 [] =
  erlps__ets_delete__1 [ErlangAtom "bytes_constraints"]
erlps__destroy_bytes_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__destroy_bytes_constraints__0)
    args

erlps__destroy_and_report_unsolved_bytes_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_bytes_constraints__1 [env_0] =
  let    constraints_1 = erlps__get_bytes_constraints__0 []
  in let
    inaddconstraint_22 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "add_bytes"), _, _, a_3, b_4, c_5]) ->
               flmap
                 (\ lc_15 ->
                    let    arg_18 = toErl 1
                    in let lop_17 = BIF.erlang__element__2 [arg_18, lc_15]
                    in let
                      cond_16 =
                        BIF.erlang__op_neq [lop_17, ErlangAtom "bytes_t"]
                    in
                      case cond_16 of
                        (ErlangAtom "true") -> ErlangCons lc_15 ErlangEmptyList
                        _ -> ErlangEmptyList)
                 (ErlangCons a_3
                    (ErlangCons b_4 (ErlangCons c_5 ErlangEmptyList)))
             _ -> ErlangEmptyList)
        constraints_1
  in let
    skip_28 =
      ErlangFun 1
        (let
           lambda_23 [(ErlangTuple [(ErlangAtom "is_bytes"), t_25])] =
             BIF.lists__member__2 [t_25, inaddconstraint_22]
           lambda_23 [_] = ErlangAtom "false"
           lambda_23 [arg_24] = EXC.function_clause unit
           lambda_23 args = EXC.badarity (ErlangFun 1 lambda_23) args
         in lambda_23)
  in let
    _ =
      flmap
        (\ lc_31 ->
           let   
             op_arg_33 =
               BIF.erlang__apply__2 [skip_28, ErlangCons lc_31 ErlangEmptyList]
           in let cond_32 = BIF.erlang__not__1 [op_arg_33]
           in
             case cond_32 of
               (ErlangAtom "true") ->
                 let lcRet_36 = erlps__check_bytes_constraint__2 [env_0, lc_31]
                 in ErlangCons lcRet_36 ErlangEmptyList
               _ -> ErlangEmptyList)
        constraints_1
  in erlps__destroy_bytes_constraints__0 []
erlps__destroy_and_report_unsolved_bytes_constraints__1 [arg_39]
  =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_bytes_constraints__1 args =
  EXC.badarity
    (ErlangFun 1
       erlps__destroy_and_report_unsolved_bytes_constraints__1)
    args

erlps__check_bytes_constraint__2 :: ErlangFun
erlps__check_bytes_constraint__2 [env_0,
                                  (ErlangTuple [(ErlangAtom "is_bytes"),
                                                type_1])]
  =
  let    arg_3 = erlps__instantiate__1 [type_1]
  in let type1_5 = erlps__unfold_types_in_type__2 [env_0, arg_3]
  in
    case type1_5 of
      (ErlangTuple [(ErlangAtom "bytes_t"), _, _]) -> ErlangAtom "ok"
      _ ->
        let
          arg_7 = ErlangTuple [ErlangAtom "unknown_byte_length", type_1]
        in erlps__type_error__1 [arg_7]
erlps__check_bytes_constraint__2 [env_0,
                                  (ErlangTuple [(ErlangAtom "add_bytes"), ann_1,
                                                fun_2, a0_3, b0_4, c0_5])]
  =
  let    arg_7 = erlps__instantiate__1 [a0_3]
  in let a_9 = erlps__unfold_types_in_type__2 [env_0, arg_7]
  in let arg_11 = erlps__instantiate__1 [b0_4]
  in let b_13 = erlps__unfold_types_in_type__2 [env_0, arg_11]
  in let arg_15 = erlps__instantiate__1 [c0_5]
  in let c_17 = erlps__unfold_types_in_type__2 [env_0, arg_15]
  in let case_18 = ErlangTuple [a_9, b_13, c_17]
  in
    case case_18 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "bytes_t"), _, _m_22]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, _n_23]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, _r_24])]) ->
        ErlangAtom "ok"
      _ ->
        let
          arg_25 =
            ErlangTuple
              [ErlangAtom "unsolved_bytes_constraint", ann_1, fun_2, a_9, b_13,
               c_17]
        in erlps__type_error__1 [arg_25]
erlps__check_bytes_constraint__2 [arg_32, arg_33] =
  EXC.function_clause unit
erlps__check_bytes_constraint__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_bytes_constraint__2) args

erlps__create_field_constraints__0 :: ErlangFun
erlps__create_field_constraints__0 [] =
  erlps__ets_new__2
    [ErlangAtom "field_constraints",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_field_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_field_constraints__0)
    args

erlps__destroy_field_constraints__0 :: ErlangFun
erlps__destroy_field_constraints__0 [] =
  erlps__ets_delete__1 [ErlangAtom "field_constraints"]
erlps__destroy_field_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__destroy_field_constraints__0)
    args

erlps__constrain__1 :: ErlangFun
erlps__constrain__1 [fieldconstraints_0] =
  erlps__ets_insert_ordered__2
    [ErlangAtom "field_constraints", fieldconstraints_0]
erlps__constrain__1 [arg_3] = EXC.function_clause unit
erlps__constrain__1 args =
  EXC.badarity (ErlangFun 1 erlps__constrain__1) args

erlps__get_field_constraints__0 :: ErlangFun
erlps__get_field_constraints__0 [] =
  erlps__ets_tab2list_ordered__1 [ErlangAtom "field_constraints"]
erlps__get_field_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__get_field_constraints__0) args

erlps__solve_field_constraints__1 :: ErlangFun
erlps__solve_field_constraints__1 [env_0] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_constraint"), _, _, _,
                                   _, _])]
             =
             ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_4 = erlps__get_field_constraints__0 []
  in let
    fieldcs_5 =
      BIF.do_remote_fun_call "Lists" "erlps__filter__2" [arg_1, arg_4]
  in erlps__solve_field_constraints__2 [env_0, fieldcs_5]
erlps__solve_field_constraints__1 [arg_8] =
  EXC.function_clause unit
erlps__solve_field_constraints__1 args =
  EXC.badarity (ErlangFun 1 erlps__solve_field_constraints__1)
    args

erlps__check_record_create_constraints__2 :: ErlangFun
erlps__check_record_create_constraints__2 [_, (ErlangEmptyList)]
  =
  ErlangAtom "ok"
erlps__check_record_create_constraints__2 [env_0,
                                           (ErlangCons c_1 cs_2)]
  =
  case c_1 of
    (ErlangTuple [(ErlangAtom "record_create_constraint"), type_3,
                  fields_4, when_5]) ->
      let    arg_8 = erlps__instantiate__1 [type_3]
      in let type1_10 = erlps__unfold_types_in_type__2 [env_0, arg_8]
      in let
        _ =
          EXC.tryOfCatch
            (\ _ ->
               let arg_12 = erlps__record_type_name__1 [type1_10]
               in erlps__lookup_type__2 [env_0, arg_12])
            (\ of_14 ->
               case of_14 of
                 (ErlangTuple [_qid_17,
                               (ErlangTuple [_ann_18,
                                             (ErlangTuple [_args_19,
                                                           (ErlangTuple [(ErlangAtom "record_t"),
                                                                         recfields_20])])])]) ->
                   let   
                     actualnames_25 =
                       flmap
                         (\ lc_23 ->
                            case lc_23 of
                              (ErlangTuple [(ErlangAtom "field_t"), _,
                                            (ErlangTuple [(ErlangAtom "id"), _,
                                                          fld_22]),
                                            _]) ->
                                ErlangCons fld_22 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         recfields_20
                   in let
                     givennames_30 =
                       flmap
                         (\ lc_28 ->
                            case lc_28 of
                              (ErlangTuple [(ErlangAtom "id"), _, fld_27]) ->
                                ErlangCons fld_27 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         fields_4
                   in let
                     case_31 =
                       BIF.erlang__op_unAppend [actualnames_25, givennames_30]
                   in
                     case case_31 of
                       (ErlangEmptyList) -> ErlangAtom "ok"
                       missing_34 ->
                         let
                           arg_35 =
                             ErlangTuple
                               [ErlangAtom "missing_fields", when_5, type1_10,
                                missing_34]
                         in erlps__type_error__1 [arg_35]
                 _ -> ErlangAtom "ok")
            (\ ex_15 ->
               case ex_15 of
                 (ErlangTuple [_, _, _]) -> ErlangAtom "ok"
                 ex_16 -> EXC.raise ex_16)
      in erlps__check_record_create_constraints__2 [env_0, cs_2]
    _ -> EXC.badmatch c_1
erlps__check_record_create_constraints__2 [arg_42, arg_43] =
  EXC.function_clause unit
erlps__check_record_create_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__check_record_create_constraints__2) args

erlps__is_contract_defined__1 :: ErlangFun
erlps__is_contract_defined__1 [c_0] =
  let    arg_3 = erlps__qname__1 [c_0]
  in let
    lop_1 =
      erlps__ets_lookup__2 [ErlangAtom "defined_contracts", arg_3]
  in BIF.erlang__op_exactNeq [lop_1, ErlangEmptyList]
erlps__is_contract_defined__1 [arg_6] = EXC.function_clause unit
erlps__is_contract_defined__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_contract_defined__1) args

erlps__check_is_contract_constraints__2 :: ErlangFun
erlps__check_is_contract_constraints__2 [_env_0,
                                         (ErlangEmptyList)]
  =
  ErlangAtom "ok"
erlps__check_is_contract_constraints__2 [env_0,
                                         (ErlangCons c_1 cs_2)]
  =
  case c_1 of
    (ErlangTuple [(ErlangAtom "is_contract_constraint"), type_3,
                  cxt_4, forcedef_5]) ->
      let    arg_8 = erlps__instantiate__1 [type_3]
      in let type1_10 = erlps__unfold_types_in_type__2 [env_0, arg_8]
      in let typename_12 = erlps__record_type_name__1 [type1_10]
      in let case_13 = erlps__lookup_type__2 [env_0, typename_12]
      in let
        _ =
          case case_13 of
            (ErlangTuple [_,
                          (ErlangTuple [_ann_16,
                                        (ErlangTuple [(ErlangEmptyList),
                                                      (ErlangTuple [(ErlangAtom "contract_t"),
                                                                    _])])])]) ->
              let    lop_18 = BIF.erlang__not__1 [forcedef_5]
              in let
                case_17 =
                  case lop_18 of
                    (ErlangAtom "true") -> ErlangAtom "true"
                    (ErlangAtom "false") ->
                      erlps__is_contract_defined__1 [typename_12]
                    _ -> EXC.badarg1 lop_18
              in
                case case_17 of
                  (ErlangAtom "true") -> ErlangAtom "ok"
                  (ErlangAtom "false") ->
                    let
                      arg_21 =
                        ErlangTuple
                          [ErlangAtom "contract_lacks_definition", type1_10,
                           cxt_4]
                    in erlps__type_error__1 [arg_21]
                  something_else -> EXC.case_clause something_else
            _ ->
              let
                arg_25 =
                  ErlangTuple
                    [ErlangAtom "not_a_contract_type", type1_10, cxt_4]
              in erlps__type_error__1 [arg_25]
      in erlps__check_is_contract_constraints__2 [env_0, cs_2]
    _ -> EXC.badmatch c_1
erlps__check_is_contract_constraints__2 [arg_31, arg_32] =
  EXC.function_clause unit
erlps__check_is_contract_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__check_is_contract_constraints__2) args

erlps__solve_field_constraints__2 :: ErlangFun
erlps__solve_field_constraints__2 [env_0, constraints_1] =
  let   
    isambiguous_40 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_constraint"),
                                   recordtype_4,
                                   field_7@(ErlangTuple [(ErlangAtom "id"),
                                                         _attrs_5,
                                                         fieldname_6]),
                                   fieldtype_8, kind_9, when_10])]
             =
             let
               case_11 =
                 erlps__lookup_record_field__3 [env_0, fieldname_6, kind_9]
             in
               case case_11 of
                 (ErlangEmptyList) ->
                   let   
                     arg_15 =
                       ErlangTuple [ErlangAtom "undefined_field", field_7]
                   in let _ = erlps__type_error__1 [arg_15]
                   in ErlangAtom "false"
                 (ErlangCons (ErlangTuple [(ErlangAtom "field_info"), _,
                                           fldtype_18, rectype_19,
                                           _]) (ErlangEmptyList)) ->
                   let    _ = erlps__create_freshen_tvars__0 []
                   in let freshfldtype_21 = erlps__freshen__1 [fldtype_18]
                   in let freshrectype_23 = erlps__freshen__1 [rectype_19]
                   in let _ = erlps__destroy_freshen_tvars__0 []
                   in let
                     arg_27 =
                       ErlangTuple
                         [ErlangAtom "field_constraint", freshfldtype_21,
                          fieldtype_8, when_10]
                   in let
                     _ =
                       erlps__unify__4
                         [env_0, freshfldtype_21, fieldtype_8, arg_27]
                   in let
                     arg_35 =
                       ErlangTuple
                         [ErlangAtom "record_constraint", freshrectype_23,
                          recordtype_4, when_10]
                   in let
                     _ =
                       erlps__unify__4
                         [env_0, freshrectype_23, recordtype_4, arg_35]
                   in ErlangAtom "false"
                 _ -> ErlangAtom "true"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    ambiguousconstraints_43 =
      BIF.do_remote_fun_call "Lists" "erlps__filter__2"
        [isambiguous_40, constraints_1]
  in
    erlps__solve_ambiguous_field_constraints__2
      [env_0, ambiguousconstraints_43]
erlps__solve_field_constraints__2 [arg_46, arg_47] =
  EXC.function_clause unit
erlps__solve_field_constraints__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_field_constraints__2)
    args

erlps__solve_ambiguous_field_constraints__2 :: ErlangFun
erlps__solve_ambiguous_field_constraints__2 [env_0,
                                             constraints_1]
  =
  let
    unknown_4 =
      erlps__solve_known_record_types__2 [env_0, constraints_1]
  in
    case ErlangAtom "true" of
      _ | weakEq unknown_4 ErlangEmptyList -> ErlangAtom "ok"
      _ | (ErlangAtom "true") ==
            (falsifyErrors
               (\ _ ->
                  let    lop_5 = BIF.erlang__length__1 [unknown_4]
                  in let rop_7 = BIF.erlang__length__1 [constraints_1]
                  in BIF.erlang__op_lesser [lop_5, rop_7])) ->
        erlps__solve_ambiguous_field_constraints__2 [env_0, unknown_4]
      _ ->
        let
          case_11 = erlps__solve_unknown_record_types__2 [env_0, unknown_4]
        in
          case case_11 of
            (ErlangAtom "true") ->
              erlps__solve_ambiguous_field_constraints__2 [env_0, unknown_4]
            _ -> ErlangAtom "ok"
erlps__solve_ambiguous_field_constraints__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__solve_ambiguous_field_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__solve_ambiguous_field_constraints__2) args

erlps__solve_unknown_record_types__2 :: ErlangFun
erlps__solve_unknown_record_types__2 [env_0, unknown_1] =
  let   
    arg_2 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             (ErlangTuple [(ErlangAtom "field_constraint"),
                           uvar_4@(ErlangTuple [(ErlangAtom "uvar"), _, _]), _,
                           _, _, _]) ->
               ErlangCons uvar_4 ErlangEmptyList
             _ -> ErlangEmptyList)
        unknown_1
  in let
    uvars_7 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_2]
  in let
    solutions_28 =
      flmap
        (\ lc_10 ->
           let   
             arg_14 =
               flmap
                 (\ lc_20 ->
                    case lc_20 of
                      (ErlangTuple [(ErlangAtom "field_constraint"), u_16,
                                    field_17, _, kind_18, when_19]) ->
                        let cond_21 = BIF.erlang__op_eq [u_16, lc_10]
                        in
                          case cond_21 of
                            (ErlangAtom "true") ->
                              let
                                lcRet_24 =
                                  ErlangTuple [kind_18, when_19, field_17]
                              in ErlangCons lcRet_24 ErlangEmptyList
                            _ -> ErlangEmptyList
                      _ -> ErlangEmptyList)
                 unknown_1
           in let lcRet_11 = erlps__solve_for_uvar__3 [env_0, lc_10, arg_14]
           in ErlangCons lcRet_11 ErlangEmptyList)
        uvars_7
  in let
    case_29 = BIF.lists__member__2 [ErlangAtom "true", solutions_28]
  in
    case case_29 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> solutions_28
      something_else -> EXC.case_clause something_else
erlps__solve_unknown_record_types__2 [arg_32, arg_33] =
  EXC.function_clause unit
erlps__solve_unknown_record_types__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_unknown_record_types__2)
    args

erlps__solve_known_record_types__2 :: ErlangFun
erlps__solve_known_record_types__2 [env_0, constraints_1] =
  let   
    derefconstraints_15 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             c_4@(ErlangTuple [(ErlangAtom "field_constraint"), recordtype_3,
                               _, _, _, _]) ->
               let    record_updt_8 = erlps__dereference__1 [recordtype_3]
               in let
                 lcRet_6 =
                   case c_4 of
                     (ErlangTuple [(ErlangAtom "field_constraint"), record_t_10,
                                   field_11, field_t_12, kind_13,
                                   context_14]) ->
                       ErlangTuple
                         [ErlangAtom "field_constraint", record_updt_8,
                          field_11, field_t_12, kind_13, context_14]
                     _ -> EXC.badrecord (ErlangAtom "field_constraint")
               in ErlangCons lcRet_6 ErlangEmptyList
             _ -> ErlangEmptyList)
        constraints_1
  in let
    solvedconstraints_87 =
      flmap
        (\ lc_18 ->
           let   
             case_20 =
               case lc_18 of
                 (ErlangTuple arr_23) | (DM.Just field_22) <-
                                          (arr_23 DA.!! 1) ->
                   field_22
                 _ -> EXC.badrecord (ErlangAtom "field_constraint")
           in let
             cond_19 =
               case case_20 of
                 (ErlangTuple [(ErlangAtom "uvar"), _, _]) -> ErlangAtom "false"
                 _ -> ErlangAtom "true"
           in
             case cond_19 of
               (ErlangAtom "true") ->
                 case lc_18 of
                   (ErlangTuple [(ErlangAtom "field_constraint"), rectype_25,
                                 fieldname_26, fieldtype_27, _, when_28]) ->
                     let    recid_31 = erlps__record_type_name__1 [rectype_25]
                     in let
                       attrs_33 =
                         BIF.do_remote_fun_call "Aeso.Syntax"
                           "erlps__get_ann__1" [recid_31]
                     in let
                       case_34 = erlps__lookup_type__2 [env_0, recid_31]
                       lcRet_24 =
                         case case_34 of
                           (ErlangTuple [_,
                                         (ErlangTuple [_ann_37,
                                                       (ErlangTuple [formals_38,
                                                                     (ErlangTuple [what_39,
                                                                                   fields_40])])])]) | ((==)
                                                                                                          what_39
                                                                                                          (ErlangAtom
                                                                                                             "record_t")) ||
                                                                                                         ((==)
                                                                                                            what_39
                                                                                                            (ErlangAtom
                                                                                                               "contract_t")) ->
                             let
                               fieldtypes_48 =
                                 flmap
                                   (\ lc_44 ->
                                      case lc_44 of
                                        (ErlangTuple [(ErlangAtom "field_t"), _,
                                                      (ErlangTuple [(ErlangAtom "id"),
                                                                    _,
                                                                    name_42]),
                                                      type_43]) ->
                                          let
                                            lcRet_45 =
                                              ErlangTuple [name_42, type_43]
                                          in ErlangCons lcRet_45 ErlangEmptyList
                                        _ -> ErlangEmptyList)
                                   fields_40
                             in
                               case fieldname_26 of
                                 (ErlangTuple [(ErlangAtom "id"), _,
                                               fieldstring_49]) ->
                                   let
                                     case_51 =
                                       BIF.do_remote_fun_call "Proplists"
                                         "erlps__get_value__2"
                                         [fieldstring_49, fieldtypes_48]
                                   in
                                     case case_51 of
                                       (ErlangAtom "undefined") ->
                                         let   
                                           arg_54 =
                                             ErlangTuple
                                               [ErlangAtom "missing_field",
                                                fieldname_26, recid_31]
                                         in let
                                           _ = erlps__type_error__1 [arg_54]
                                         in ErlangAtom "not_solved"
                                       fldtype_58 ->
                                         let   
                                           _ = erlps__create_freshen_tvars__0 []
                                         in let
                                           freshfldtype_60 =
                                             erlps__freshen__1 [fldtype_58]
                                         in let
                                           arg_61 =
                                             erlps__app_t__3
                                               [attrs_33, recid_31, formals_38]
                                         in let
                                           freshrectype_65 =
                                             erlps__freshen__1 [arg_61]
                                         in let
                                           _ =
                                             erlps__destroy_freshen_tvars__0 []
                                         in let
                                           arg_69 =
                                             ErlangTuple
                                               [ErlangAtom "field_constraint",
                                                freshfldtype_60, fieldtype_27,
                                                when_28]
                                         in let
                                           _ =
                                             erlps__unify__4
                                               [env_0, freshfldtype_60,
                                                fieldtype_27, arg_69]
                                         in let
                                           arg_77 =
                                             ErlangTuple
                                               [ErlangAtom "record_constraint",
                                                freshrectype_65, rectype_25,
                                                when_28]
                                         in let
                                           _ =
                                             erlps__unify__4
                                               [env_0, freshrectype_65,
                                                rectype_25, arg_77]
                                         in lc_18
                                 _ -> EXC.badmatch fieldname_26
                           _ ->
                             let   
                               tup_el_84 = erlps__instantiate__1 [rectype_25]
                             in let
                               arg_82 =
                                 ErlangTuple
                                   [ErlangAtom "not_a_record_type", tup_el_84,
                                    when_28]
                             in let _ = erlps__type_error__1 [arg_82]
                             in ErlangAtom "not_solved"
                     in ErlangCons lcRet_24 ErlangEmptyList
                   _ -> EXC.badmatch lc_18
               _ -> ErlangEmptyList)
        derefconstraints_15
  in
    BIF.erlang__op_unAppend
      [derefconstraints_15, solvedconstraints_87]
erlps__solve_known_record_types__2 [arg_90, arg_91] =
  EXC.function_clause unit
erlps__solve_known_record_types__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_known_record_types__2)
    args

erlps__destroy_and_report_unsolved_field_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_field_constraints__1 [env_0] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_constraint"), _, _, _,
                                   _, _])]
             =
             ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_4 = erlps__get_field_constraints__0 []
  in let
    matchExpr_7 =
      BIF.do_remote_fun_call "Lists" "erlps__partition__2"
        [arg_1, arg_4]
  in
    case matchExpr_7 of
      (ErlangTuple [fieldcs_5, othercs_6]) ->
        let   
          arg_8 =
            ErlangFun 1
              (let
                 lambda_9 [(ErlangTuple [(ErlangAtom "record_create_constraint"),
                                         _, _, _])]
                   =
                   ErlangAtom "true"
                 lambda_9 [_] = ErlangAtom "false"
                 lambda_9 [arg_10] = EXC.function_clause unit
                 lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
               in lambda_9)
        in let
          matchExpr_14 =
            BIF.do_remote_fun_call "Lists" "erlps__partition__2"
              [arg_8, othercs_6]
        in
          case matchExpr_14 of
            (ErlangTuple [createcs_12, othercs1_13]) ->
              let   
                arg_15 =
                  ErlangFun 1
                    (let
                       lambda_16 [(ErlangTuple [(ErlangAtom "is_contract_constraint"),
                                                _, _, _])]
                         =
                         ErlangAtom "true"
                       lambda_16 [_] = ErlangAtom "false"
                       lambda_16 [arg_17] = EXC.function_clause unit
                       lambda_16 args =
                         EXC.badarity (ErlangFun 1 lambda_16) args
                     in lambda_16)
              in let
                matchExpr_20 =
                  BIF.do_remote_fun_call "Lists" "erlps__partition__2"
                    [arg_15, othercs1_13]
              in
                case matchExpr_20 of
                  (ErlangTuple [contractcs_19, (ErlangEmptyList)]) ->
                    let   
                      unknown_23 =
                        erlps__solve_known_record_types__2 [env_0, fieldcs_5]
                    in let
                      _ =
                        case ErlangAtom "true" of
                          _ | weakEq unknown_23 ErlangEmptyList ->
                            ErlangAtom "ok"
                          _ ->
                            let
                              case_24 =
                                erlps__solve_unknown_record_types__2
                                  [env_0, unknown_23]
                            in
                              case case_24 of
                                (ErlangAtom "true") -> ErlangAtom "ok"
                                errors_27 ->
                                  flmap
                                    (\ lc_30 ->
                                       let
                                         lcRet_31 = erlps__type_error__1 [lc_30]
                                       in ErlangCons lcRet_31 ErlangEmptyList)
                                    errors_27
                    in let
                      _ =
                        erlps__check_record_create_constraints__2
                          [env_0, createcs_12]
                    in let
                      _ =
                        erlps__check_is_contract_constraints__2
                          [env_0, contractcs_19]
                    in let _ = erlps__destroy_field_constraints__0 []
                    in ErlangAtom "ok"
                  _ -> EXC.badmatch matchExpr_20
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_7
erlps__destroy_and_report_unsolved_field_constraints__1 [arg_37]
  =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_field_constraints__1 args =
  EXC.badarity
    (ErlangFun 1
       erlps__destroy_and_report_unsolved_field_constraints__1)
    args

erlps__record_type_name__1 :: ErlangFun
erlps__record_type_name__1 [(ErlangTuple [(ErlangAtom "app_t"),
                                          _attrs_0, recid_1, _args_2])]
  | onElement (toErl 1) recid_1
      (\ x _ ->
         case x of
           _ | (==) x (ErlangAtom "id") -> true
           _ | (==) x (ErlangAtom "qid") -> true
           _ | (==) x (ErlangAtom "con") -> true
           _ | (==) x (ErlangAtom "qcon") -> true
           _ -> false)
      ErlangEmptyList =
  recid_1
erlps__record_type_name__1 [recid_0]
  | onElement (toErl 1) recid_0
      (\ x _ ->
         case x of
           _ | (==) x (ErlangAtom "id") -> true
           _ | (==) x (ErlangAtom "qid") -> true
           _ | (==) x (ErlangAtom "con") -> true
           _ | (==) x (ErlangAtom "qcon") -> true
           _ -> false)
      ErlangEmptyList =
  recid_0
erlps__record_type_name__1 [_other_0] =
  let   
    head_3 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let tup_el_7 = toErl "not_a_record_type"
  in
    ErlangTuple
      [ErlangAtom "id", ErlangCons head_3 ErlangEmptyList, tup_el_7]
erlps__record_type_name__1 [arg_8] = EXC.function_clause unit
erlps__record_type_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__record_type_name__1) args

erlps__solve_for_uvar__3 :: ErlangFun
erlps__solve_for_uvar__3 [env_0,
                          uvar_2@(ErlangTuple [(ErlangAtom "uvar"), attrs_1,
                                               _]),
                          fields0_3]
  =
  let
    fields_11 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [kind_5, _, fld_6]) ->
               let lcRet_8 = ErlangTuple [kind_5, fld_6]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields0_3
  in
    case fields0_3 of
      (ErlangCons (ErlangTuple [_, when_12, _]) _) ->
        let   
          arg_14 =
            flmap
              (\ lc_17 ->
                 case lc_17 of
                   (ErlangTuple [(ErlangAtom "create"),
                                 (ErlangTuple [(ErlangAtom "id"), _,
                                               name_16])]) ->
                     ErlangCons name_16 ErlangEmptyList
                   _ -> ErlangEmptyList)
              fields_11
        in let
          covering_19 =
            BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_14]
        in let
          fieldnames_25 =
            flmap
              (\ lc_23 ->
                 case lc_23 of
                   (ErlangTuple [_kind_21,
                                 (ErlangTuple [(ErlangAtom "id"), _,
                                               name_22])]) ->
                     ErlangCons name_22 ErlangEmptyList
                   _ -> ErlangEmptyList)
              fields_11
        in let
          uniquefields_27 =
            BIF.do_remote_fun_call "Lists" "erlps__usort__1" [fieldnames_25]
        in let arg_30 = BIF.erlang__hd__1 [fieldnames_25]
        in let lcSrc_28 = erlps__lookup_record_field__2 [env_0, arg_30]
        in let
          candidates_35 =
            flmap
              (\ lc_33 ->
                 case lc_33 of
                   (ErlangTuple [(ErlangAtom "field_info"), _, _, rectype_32,
                                 _]) ->
                     ErlangCons rectype_32 ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_28
        in let
          typesandfields_64 =
            flmap
              (\ lc_38 ->
                 let    arg_42 = erlps__record_type_name__1 [lc_38]
                 in let case_40 = erlps__lookup_type__2 [env_0, arg_42]
                 in let
                   lcRet_39 =
                     case case_40 of
                       (ErlangTuple [_,
                                     (ErlangTuple [_,
                                                   (ErlangTuple [_,
                                                                 (ErlangTuple [(ErlangAtom "record_t"),
                                                                               recfields_44])])])]) ->
                         let
                           tup_el_46 =
                             flmap
                               (\ lc_49 ->
                                  case lc_49 of
                                    (ErlangTuple [(ErlangAtom "field_t"), _,
                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                _, field_48]),
                                                  _]) ->
                                      ErlangCons field_48 ErlangEmptyList
                                    _ -> ErlangEmptyList)
                               recfields_44
                         in ErlangTuple [lc_38, tup_el_46]
                       (ErlangTuple [_,
                                     (ErlangTuple [_,
                                                   (ErlangTuple [_,
                                                                 (ErlangTuple [(ErlangAtom "contract_t"),
                                                                               confields_51])])])]) ->
                         let
                           tup_el_53 =
                             flmap
                               (\ lc_56 ->
                                  case lc_56 of
                                    (ErlangTuple [(ErlangAtom "field_t"), _,
                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                _, field_55]),
                                                  _]) ->
                                      ErlangCons field_55 ErlangEmptyList
                                    _ -> ErlangEmptyList)
                               confields_51
                         in ErlangTuple [lc_38, tup_el_53]
                       (ErlangAtom "false") ->
                         let    tup_el_60 = erlps__record_type_name__1 [lc_38]
                         in let
                           arg_58 =
                             ErlangTuple
                               [ErlangAtom "no_definition_for", tup_el_60,
                                ErlangAtom "in", env_0]
                         in BIF.erlang__error__1 [arg_58]
                       something_else -> EXC.case_clause something_else
                 in ErlangCons lcRet_39 ErlangEmptyList)
              candidates_35
        in let
          arg_65 =
            flmap
              (\ lc_69 ->
                 case lc_69 of
                   (ErlangTuple [rectype_67, recfields_68]) ->
                     let   
                       lop_71 =
                         BIF.erlang__op_unAppend [uniquefields_27, recfields_68]
                     in let
                       cond_70 = BIF.erlang__op_eq [lop_71, ErlangEmptyList]
                     in
                       case cond_70 of
                         (ErlangAtom "true") ->
                           let   
                             tup_el_77 =
                               case ErlangAtom "true" of
                                 _ | weakEq covering_19 ErlangEmptyList ->
                                   ErlangEmptyList
                                 _ ->
                                   BIF.erlang__op_unAppend
                                     [recfields_68, covering_19]
                           in let lcRet_75 = ErlangTuple [rectype_67, tup_el_77]
                           in ErlangCons lcRet_75 ErlangEmptyList
                         _ -> ErlangEmptyList
                   _ -> ErlangEmptyList)
              typesandfields_64
        in let
          partialsolutions_80 =
            BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_65]
        in let
          solutions_85 =
            flmap
              (\ lc_83 ->
                 case lc_83 of
                   (ErlangTuple [recname_82, (ErlangEmptyList)]) ->
                     ErlangCons recname_82 ErlangEmptyList
                   _ -> ErlangEmptyList)
              partialsolutions_80
        in let case_86 = ErlangTuple [solutions_85, partialsolutions_80]
        in
          case case_86 of
            (ErlangTuple [(ErlangEmptyList), (ErlangEmptyList)]) ->
              ErlangTuple [ErlangAtom "no_records_with_all_fields", fields_11]
            (ErlangTuple [(ErlangEmptyList), _]) ->
              case partialsolutions_80 of
                (ErlangCons (ErlangTuple [rectype_92, missing_93]) _) ->
                  ErlangTuple
                    [ErlangAtom "missing_fields", when_12, rectype_92,
                     missing_93]
                something_else -> EXC.case_clause something_else
            (ErlangTuple [(ErlangCons rectype_98 (ErlangEmptyList)), _]) ->
              let    recname_100 = erlps__record_type_name__1 [rectype_98]
              in let matchExpr_105 = erlps__lookup_type__2 [env_0, recname_100]
              in
                case matchExpr_105 of
                  (ErlangTuple [_,
                                (ErlangTuple [_,
                                              (ErlangTuple [formals_103,
                                                            (ErlangTuple [_recorcon_104,
                                                                          _])])])]) ->
                    let    _ = erlps__create_freshen_tvars__0 []
                    in let
                      arg_106 =
                        erlps__app_t__3 [attrs_1, recname_100, formals_103]
                    in let freshrectype_110 = erlps__freshen__1 [arg_106]
                    in let _ = erlps__destroy_freshen_tvars__0 []
                    in let
                      arg_114 =
                        ErlangTuple
                          [ErlangAtom "solve_rec_type", uvar_2, fields_11]
                    in let
                      _ =
                        erlps__unify__4
                          [env_0, uvar_2, freshrectype_110, arg_114]
                    in ErlangAtom "true"
                  _ -> EXC.badmatch matchExpr_105
            (ErlangTuple [stillpossible_118, _]) ->
              ErlangTuple
                [ErlangAtom "ambiguous_record", fields_11, stillpossible_118]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch fields0_3
erlps__solve_for_uvar__3 [arg_122, arg_123, arg_124] =
  EXC.function_clause unit
erlps__solve_for_uvar__3 args =
  EXC.badarity (ErlangFun 3 erlps__solve_for_uvar__3) args

erlps__unfold_record_types__2 :: ErlangFun
erlps__unfold_record_types__2 [env_0, t_1] =
  erlps__unfold_types__3
    [env_0, t_1,
     ErlangCons (ErlangAtom "unfold_record_types") ErlangEmptyList]
erlps__unfold_record_types__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__unfold_record_types__2 args =
  EXC.badarity (ErlangFun 2 erlps__unfold_record_types__2) args

erlps__unfold_types__3 :: ErlangFun
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "typed"), attr_1, e_2,
                                      type_3]),
                        options_4]
  =
  let    head_5 = ErlangTuple [ErlangAtom "ann", attr_1]
  in let arg_10 = toErl 1
  in let
    tail_8 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [ErlangAtom "ann", arg_10, options_4]
  in let tup_el_15 = erlps__unfold_types__3 [env_0, e_2, options_4]
  in let
    tup_el_19 =
      erlps__unfold_types_in_type__3
        [env_0, type_3, ErlangCons head_5 tail_8]
  in ErlangTuple [ErlangAtom "typed", attr_1, tup_el_15, tup_el_19]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "arg"), attr_1, id_2,
                                      type_3]),
                        options_4]
  =
  let
    tup_el_8 =
      erlps__unfold_types_in_type__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "arg", attr_1, id_2, tup_el_8]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "type_sig"), ann_1, constr_2,
                                      namedargs_3, args_4, ret_5]),
                        options_6]
  =
  let   
    tup_el_10 =
      erlps__unfold_types_in_type__3 [env_0, namedargs_3, options_6]
  in let
    tup_el_14 =
      erlps__unfold_types_in_type__3 [env_0, args_4, options_6]
  in let
    tup_el_18 =
      erlps__unfold_types_in_type__3 [env_0, ret_5, options_6]
  in
    ErlangTuple
      [ErlangAtom "type_sig", ann_1, constr_2, tup_el_10, tup_el_14,
       tup_el_18]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "type_def"), ann_1, name_2,
                                      args_3, def_4]),
                        options_5]
  =
  let
    tup_el_10 =
      erlps__unfold_types_in_type__3 [env_0, def_4, options_5]
  in
    ErlangTuple
      [ErlangAtom "type_def", ann_1, name_2, args_3, tup_el_10]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "fun_decl"), ann_1, name_2,
                                      type_3]),
                        options_4]
  =
  let tup_el_8 = erlps__unfold_types__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "fun_decl", ann_1, name_2, tup_el_8]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "letfun"), ann_1, name_2,
                                      args_3, type_4, body_5]),
                        options_6]
  =
  let   
    tup_el_10 = erlps__unfold_types__3 [env_0, args_3, options_6]
  in let
    tup_el_14 =
      erlps__unfold_types_in_type__3 [env_0, type_4, options_6]
  in let
    tup_el_18 = erlps__unfold_types__3 [env_0, body_5, options_6]
  in
    ErlangTuple
      [ErlangAtom "letfun", ann_1, name_2, tup_el_10, tup_el_14,
       tup_el_18]
erlps__unfold_types__3 [env_0, t_1, options_2] | isETuple t_1 =
  let    arg_5 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_3 = erlps__unfold_types__3 [env_0, arg_5, options_2]
  in BIF.erlang__list_to_tuple__1 [arg_3]
erlps__unfold_types__3 [env_0, (ErlangCons h_1 t_2), options_3] =
  let    head_4 = erlps__unfold_types__3 [env_0, h_1, options_3]
  in let tail_8 = erlps__unfold_types__3 [env_0, t_2, options_3]
  in ErlangCons head_4 tail_8
erlps__unfold_types__3 [_env_0, x_1, _options_2] = x_1
erlps__unfold_types__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__unfold_types__3 args =
  EXC.badarity (ErlangFun 3 erlps__unfold_types__3) args

erlps__unfold_types_in_type__2 :: ErlangFun
erlps__unfold_types_in_type__2 [env_0, t_1] =
  erlps__unfold_types_in_type__3 [env_0, t_1, ErlangEmptyList]
erlps__unfold_types_in_type__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__unfold_types_in_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__unfold_types_in_type__2) args

erlps__unfold_types_in_type__3 :: ErlangFun
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "app_t"), ann_1,
                                              id_5@(ErlangTuple [(ErlangAtom "id"),
                                                                 _,
                                                                 (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangEmptyList))))]),
                                              args_7@(ErlangCons keytype0_6 (ErlangCons _ (ErlangEmptyList)))]),
                                options_8]
  | (ErlangInt num_2) == (toErl 109)
  , (ErlangInt num_3) == (toErl 97)
  , (ErlangInt num_4) == (toErl 112) =
  let
    matchExpr_13 =
      erlps__unfold_types_in_type__3 [env_0, args_7, options_8]
  in
    case matchExpr_13 of
      (ErlangCons keytype_12 (ErlangCons _ (ErlangEmptyList))) ->
        let   
          arg_17 =
            BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1"
              [keytype0_6]
        in let
          ann1_19 =
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [ErlangAtom "ann", options_8, arg_17]
        in let cond_20 = erlps__has_maps__1 [keytype_12]
        in let
          _ =
            case cond_20 of
              (ErlangAtom "true") ->
                let   
                  arg_23 =
                    ErlangTuple
                      [ErlangAtom "map_in_map_key", ann1_19, keytype0_6]
                in let lcRet_22 = erlps__type_error__1 [arg_23]
                in ErlangCons lcRet_22 ErlangEmptyList
              _ -> ErlangEmptyList
        in ErlangTuple [ErlangAtom "app_t", ann_1, id_5, matchExpr_13]
      _ -> EXC.badmatch matchExpr_13
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "app_t"), ann_1, id_2,
                                              args_3]),
                                options_4]
  | onElement (toErl 1) id_2
      (\ x _ ->
         case x of
           _ | (==) x (ErlangAtom "id") -> true
           _ | (==) x (ErlangAtom "qid") -> true
           _ | (==) x (ErlangAtom "con") -> true
           _ | (==) x (ErlangAtom "qcon") -> true
           _ -> false)
      ErlangEmptyList =
  let   
    unfoldrecords_8 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_record_types", options_4, ErlangAtom "false"]
  in let
    unfoldvariants_12 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_variant_types", options_4,
         ErlangAtom "false"]
  in let case_13 = erlps__lookup_type__2 [env_0, id_2]
  in
    case case_13 of
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [formals_16,
                                                (ErlangTuple [(ErlangAtom "record_t"),
                                                              fields_17])])])]) | (ErlangAtom
                                                                                     "true") ==
                                                                                    (falsifyErrors
                                                                                       (\ _ ->
                                                                                          case unfoldrecords_8 of
                                                                                            (ErlangAtom "false") ->
                                                                                              ErlangAtom
                                                                                                "false"
                                                                                            (ErlangAtom "true") ->
                                                                                              let   
                                                                                                lop_19 =
                                                                                                  BIF.erlang__length__1
                                                                                                    [formals_16]
                                                                                              in let
                                                                                                rop_21 =
                                                                                                  BIF.erlang__length__1
                                                                                                    [args_3]
                                                                                              in
                                                                                                BIF.erlang__op_eq
                                                                                                  [lop_19,
                                                                                                   rop_21]
                                                                                            _ ->
                                                                                              EXC.badarg1
                                                                                                unfoldrecords_8)) ->
        let   
          arg_27 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2"
              [formals_16, args_3]
        in let arg_26 = erlps__subst_tvars__2 [arg_27, fields_17]
        in let
          tup_el_24 =
            erlps__unfold_types_in_type__3 [env_0, arg_26, options_4]
        in ErlangTuple [ErlangAtom "record_t", tup_el_24]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [formals_32,
                                                (ErlangTuple [(ErlangAtom "alias_t"),
                                                              type_33])])])]) | (ErlangAtom
                                                                                   "true") ==
                                                                                  (falsifyErrors
                                                                                     (\ _ ->
                                                                                        let   
                                                                                          lop_34 =
                                                                                            BIF.erlang__length__1
                                                                                              [formals_32]
                                                                                        in let
                                                                                          rop_36 =
                                                                                            BIF.erlang__length__1
                                                                                              [args_3]
                                                                                        in
                                                                                          BIF.erlang__op_eq
                                                                                            [lop_34,
                                                                                             rop_36])) ->
        let   
          arg_40 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2"
              [formals_32, args_3]
        in let arg_39 = erlps__subst_tvars__2 [arg_40, type_33]
        in erlps__unfold_types_in_type__3 [env_0, arg_39, options_4]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [formals_45,
                                                (ErlangTuple [(ErlangAtom "variant_t"),
                                                              constrs_46])])])]) | (ErlangAtom
                                                                                      "true") ==
                                                                                     (falsifyErrors
                                                                                        (\ _ ->
                                                                                           case unfoldvariants_12 of
                                                                                             (ErlangAtom "false") ->
                                                                                               ErlangAtom
                                                                                                 "false"
                                                                                             (ErlangAtom "true") ->
                                                                                               let   
                                                                                                 lop_48 =
                                                                                                   BIF.erlang__length__1
                                                                                                     [formals_45]
                                                                                               in let
                                                                                                 rop_50 =
                                                                                                   BIF.erlang__length__1
                                                                                                     [args_3]
                                                                                               in
                                                                                                 BIF.erlang__op_eq
                                                                                                   [lop_48,
                                                                                                    rop_50]
                                                                                             _ ->
                                                                                               EXC.badarg1
                                                                                                 unfoldvariants_12)) ->
        let   
          arg_56 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2"
              [formals_45, args_3]
        in let arg_55 = erlps__subst_tvars__2 [arg_56, constrs_46]
        in let
          tup_el_53 =
            erlps__unfold_types_in_type__3 [env_0, arg_55, options_4]
        in ErlangTuple [ErlangAtom "variant_t", tup_el_53]
      _ ->
        let
          tup_el_64 =
            erlps__unfold_types_in_type__3 [env_0, args_3, options_4]
        in ErlangTuple [ErlangAtom "app_t", ann_1, id_2, tup_el_64]
erlps__unfold_types_in_type__3 [env_0, id_1, options_2]
  | onElement (toErl 1) id_1
      (\ x _ ->
         case x of
           _ | (==) x (ErlangAtom "id") -> true
           _ | (==) x (ErlangAtom "qid") -> true
           _ | (==) x (ErlangAtom "con") -> true
           _ | (==) x (ErlangAtom "qcon") -> true
           _ -> false)
      ErlangEmptyList =
  let   
    unfoldrecords_6 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_record_types", options_2, ErlangAtom "false"]
  in let
    unfoldvariants_10 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_variant_types", options_2,
         ErlangAtom "false"]
  in let case_11 = erlps__lookup_type__2 [env_0, id_1]
  in
    case case_11 of
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [(ErlangEmptyList),
                                                (ErlangTuple [(ErlangAtom "record_t"),
                                                              fields_14])])])]) | (==)
                                                                                    (ErlangAtom
                                                                                       "true")
                                                                                    unfoldrecords_6 ->
        let
          tup_el_16 =
            erlps__unfold_types_in_type__3 [env_0, fields_14, options_2]
        in ErlangTuple [ErlangAtom "record_t", tup_el_16]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [(ErlangEmptyList),
                                                (ErlangTuple [(ErlangAtom "variant_t"),
                                                              constrs_20])])])]) | (==)
                                                                                     (ErlangAtom
                                                                                        "true")
                                                                                     unfoldvariants_10 ->
        let
          tup_el_22 =
            erlps__unfold_types_in_type__3 [env_0, constrs_20, options_2]
        in ErlangTuple [ErlangAtom "variant_t", tup_el_22]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [(ErlangEmptyList),
                                                (ErlangTuple [(ErlangAtom "alias_t"),
                                                              type1_26])])])]) ->
        erlps__unfold_types_in_type__3 [env_0, type1_26, options_2]
      _ -> id_1
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "field_t"), attr_1,
                                              name_2, type_3]),
                                options_4]
  =
  let
    tup_el_8 =
      erlps__unfold_types_in_type__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "field_t", attr_1, name_2, tup_el_8]
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "constr_t"), ann_1,
                                              con_2, types_3]),
                                options_4]
  =
  let
    tup_el_8 =
      erlps__unfold_types_in_type__3 [env_0, types_3, options_4]
  in ErlangTuple [ErlangAtom "constr_t", ann_1, con_2, tup_el_8]
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "named_arg_t"), ann_1,
                                              con_2, types_3, default_4]),
                                options_5]
  =
  let
    tup_el_9 =
      erlps__unfold_types_in_type__3 [env_0, types_3, options_5]
  in
    ErlangTuple
      [ErlangAtom "named_arg_t", ann_1, con_2, tup_el_9, default_4]
erlps__unfold_types_in_type__3 [env_0, t_1, options_2]
  | isETuple t_1 =
  let    arg_5 = BIF.erlang__tuple_to_list__1 [t_1]
  in let
    arg_3 = erlps__unfold_types_in_type__3 [env_0, arg_5, options_2]
  in BIF.erlang__list_to_tuple__1 [arg_3]
erlps__unfold_types_in_type__3 [env_0, (ErlangCons h_1 t_2),
                                options_3]
  =
  let   
    head_4 = erlps__unfold_types_in_type__3 [env_0, h_1, options_3]
  in let
    tail_8 = erlps__unfold_types_in_type__3 [env_0, t_2, options_3]
  in ErlangCons head_4 tail_8
erlps__unfold_types_in_type__3 [_env_0, x_1, _options_2] = x_1
erlps__unfold_types_in_type__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__unfold_types_in_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__unfold_types_in_type__3) args

erlps__has_maps__1 :: ErlangFun
erlps__has_maps__1 [(ErlangTuple [(ErlangAtom "app_t"), _,
                                  (ErlangTuple [(ErlangAtom "id"), _,
                                                (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangEmptyList))))]),
                                  _])]
  | (ErlangInt num_0) == (toErl 109)
  , (ErlangInt num_1) == (toErl 97)
  , (ErlangInt num_2) == (toErl 112) =
  ErlangAtom "true"
erlps__has_maps__1 [l_0] | isEList l_0 =
  let arg_1 = ErlangFun 1 erlps__has_maps__1
  in BIF.do_remote_fun_call "Lists" "erlps__any__2" [arg_1, l_0]
erlps__has_maps__1 [t_0] | isETuple t_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [t_0]
  in erlps__has_maps__1 [arg_1]
erlps__has_maps__1 [_] = ErlangAtom "false"
erlps__has_maps__1 [arg_0] = EXC.function_clause unit
erlps__has_maps__1 args =
  EXC.badarity (ErlangFun 1 erlps__has_maps__1) args

erlps__subst_tvars__2 :: ErlangFun
erlps__subst_tvars__2 [env_0, type_1] =
  let
    arg_2 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangTuple [(ErlangAtom "tvar"), _, v_4]),
                           t_5]) ->
               let lcRet_7 = ErlangTuple [v_4, t_5]
               in ErlangCons lcRet_7 ErlangEmptyList
             _ -> ErlangEmptyList)
        env_0
  in erlps__subst_tvars1__2 [arg_2, type_1]
erlps__subst_tvars__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__subst_tvars__2 args =
  EXC.badarity (ErlangFun 2 erlps__subst_tvars__2) args

erlps__subst_tvars1__2 :: ErlangFun
erlps__subst_tvars1__2 [env_0,
                        t_2@(ErlangTuple [(ErlangAtom "tvar"), _, name_1])]
  =
  BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
    [name_1, env_0, t_2]
erlps__subst_tvars1__2 [env_0, (ErlangCons h_1 t_2)] =
  let    head_3 = erlps__subst_tvars1__2 [env_0, h_1]
  in let tail_6 = erlps__subst_tvars1__2 [env_0, t_2]
  in ErlangCons head_3 tail_6
erlps__subst_tvars1__2 [env_0, type_1] | isETuple type_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [type_1]
  in let arg_2 = erlps__subst_tvars1__2 [env_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__subst_tvars1__2 [_env_0, x_1] = x_1
erlps__subst_tvars1__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__subst_tvars1__2 args =
  EXC.badarity (ErlangFun 2 erlps__subst_tvars1__2) args

erlps__unify__4 :: ErlangFun
erlps__unify__4 [_,
                 (ErlangTuple [(ErlangAtom "id"), _,
                               (ErlangCons (ErlangInt num_0) (ErlangEmptyList))]),
                 _, _when_1]
  | (ErlangInt num_0) == (toErl 95) =
  ErlangAtom "true"
erlps__unify__4 [_, _,
                 (ErlangTuple [(ErlangAtom "id"), _,
                               (ErlangCons (ErlangInt num_0) (ErlangEmptyList))]),
                 _when_1]
  | (ErlangInt num_0) == (toErl 95) =
  ErlangAtom "true"
erlps__unify__4 [env_0, a_1, b_2, when_3] =
  let   
    options_11 =
      case when_3 of
        (ErlangTuple [(ErlangAtom "check_expr"), e_5, _, _]) ->
          let   
            tup_el_8 =
              BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [e_5]
          in let head_6 = ErlangTuple [ErlangAtom "ann", tup_el_8]
          in ErlangCons head_6 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    arg_12 = erlps__unfold_types_in_type__3 [env_0, a_1, options_11]
  in let a1_16 = erlps__dereference__1 [arg_12]
  in let
    arg_17 = erlps__unfold_types_in_type__3 [env_0, b_2, options_11]
  in let b1_21 = erlps__dereference__1 [arg_17]
  in erlps__unify1__4 [env_0, a1_16, b1_21, when_3]
erlps__unify__4 [arg_26, arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__unify__4 args =
  EXC.badarity (ErlangFun 4 erlps__unify__4) args

erlps__unify1__4 :: ErlangFun
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "uvar"), _, r_1]),
                  (ErlangTuple [(ErlangAtom "uvar"), _, r_2]), _when_3]
  | r_2 == r_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "uvar"), a_1, r_2]), t_3, when_4]
  =
  let case_5 = erlps__occurs_check__2 [r_2, t_3]
  in
    case case_5 of
      (ErlangAtom "true") ->
        let    arg_8 = ErlangTuple [ErlangAtom "uvar", a_1, r_2]
        in let _ = erlps__cannot_unify__3 [arg_8, t_3, when_4]
        in ErlangAtom "false"
      (ErlangAtom "false") ->
        let    arg_15 = ErlangTuple [r_2, t_3]
        in let _ = erlps__ets_insert__2 [ErlangAtom "type_vars", arg_15]
        in ErlangAtom "true"
      something_else -> EXC.case_clause something_else
erlps__unify1__4 [env_0, t_1,
                  (ErlangTuple [(ErlangAtom "uvar"), a_2, r_3]), when_4]
  =
  let arg_6 = ErlangTuple [ErlangAtom "uvar", a_2, r_3]
  in erlps__unify1__4 [env_0, arg_6, t_1, when_4]
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "tvar"), _, x_1]),
                  (ErlangTuple [(ErlangAtom "tvar"), _, x_2]), _when_3]
  | x_2 == x_1 =
  ErlangAtom "true"
erlps__unify1__4 [env_0, (ErlangCons a_1 b_2),
                  (ErlangCons c_3 d_4), when_5]
  =
  let lop_6 = erlps__unify__4 [env_0, a_1, c_3, when_5]
  in
    case lop_6 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") -> erlps__unify__4 [env_0, b_2, d_4, when_5]
      _ -> EXC.badarg1 lop_6
erlps__unify1__4 [_env_0, x_1, x_2, _when_3] | x_2 == x_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "id"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "id"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "con"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "con"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "qid"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "qid"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "qcon"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "qcon"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "bytes_t"), _, len_1]),
                  (ErlangTuple [(ErlangAtom "bytes_t"), _, len_2]), _when_3]
  | len_2 == len_1 =
  ErlangAtom "true"
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "if_t"), _,
                                (ErlangTuple [(ErlangAtom "id"), _, id_1]),
                                then1_2, else1_3]),
                  (ErlangTuple [(ErlangAtom "if_t"), _,
                                (ErlangTuple [(ErlangAtom "id"), _, id_4]),
                                then2_5, else2_6]),
                  when_7]
  | id_4 == id_1 =
  let lop_8 = erlps__unify__4 [env_0, then1_2, then2_5, when_7]
  in
    case lop_8 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") ->
        erlps__unify__4 [env_0, else1_3, else2_6, when_7]
      _ -> EXC.badarg1 lop_8
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "fun_t"), _, _, _, _]),
                  (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                (ErlangAtom "var_args"), _]),
                  when_1]
  =
  let arg_2 = ErlangTuple [ErlangAtom "unify_varargs", when_1]
  in erlps__type_error__1 [arg_2]
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                (ErlangAtom "var_args"), _]),
                  (ErlangTuple [(ErlangAtom "fun_t"), _, _, _, _]), when_1]
  =
  let arg_2 = ErlangTuple [ErlangAtom "unify_varargs", when_1]
  in erlps__type_error__1 [arg_2]
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "fun_t"), _, named1_1, args1_2,
                                result1_3]),
                  (ErlangTuple [(ErlangAtom "fun_t"), _, named2_4, args2_5,
                                result2_6]),
                  when_7]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_22 = BIF.erlang__length__1 [args1_2]
            in let rop_24 = BIF.erlang__length__1 [args2_5]
            in BIF.erlang__op_eq [lop_22, rop_24])) =
  let lop_8 = erlps__unify__4 [env_0, named1_1, named2_4, when_7]
  in
    case lop_8 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") ->
        let lop_13 = erlps__unify__4 [env_0, args1_2, args2_5, when_7]
        in
          case lop_13 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              erlps__unify__4 [env_0, result1_3, result2_6, when_7]
            _ -> EXC.badarg1 lop_13
      _ -> EXC.badarg1 lop_8
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "app_t"), _,
                                (ErlangTuple [tag_1, _, f_2]), args1_3]),
                  (ErlangTuple [(ErlangAtom "app_t"), _,
                                (ErlangTuple [tag_4, _, f_5]), args2_6]),
                  when_7]
  | tag_4 == tag_1
  , f_5 == f_2
  , (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_13 = BIF.erlang__length__1 [args1_3]
            in let rop_15 = BIF.erlang__length__1 [args2_6]
            in let lop_12 = BIF.erlang__op_eq [lop_13, rop_15]
            in
              case lop_12 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let lop_17 = BIF.erlang__op_eq [tag_1, ErlangAtom "id"]
                  in
                    case lop_17 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") ->
                        BIF.erlang__op_eq [tag_1, ErlangAtom "qid"]
                      _ -> EXC.badarg1 lop_17
                _ -> EXC.badarg1 lop_12)) =
  erlps__unify__4 [env_0, args1_3, args2_6, when_7]
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "tuple_t"), _, as_1]),
                  (ErlangTuple [(ErlangAtom "tuple_t"), _, bs_2]), when_3]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_8 = BIF.erlang__length__1 [as_1]
            in let rop_10 = BIF.erlang__length__1 [bs_2]
            in BIF.erlang__op_eq [lop_8, rop_10])) =
  erlps__unify__4 [env_0, as_1, bs_2, when_3]
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "named_arg_t"), _, id1_1, type1_2,
                                _]),
                  (ErlangTuple [(ErlangAtom "named_arg_t"), _, id2_3, type2_4,
                                _]),
                  when_5]
  =
  let   
    arg_9 = ErlangTuple [ErlangAtom "arg_name", id1_1, id2_3, when_5]
  in let _ = erlps__unify1__4 [env_0, id1_1, id2_3, arg_9]
  in erlps__unify1__4 [env_0, type1_2, type2_4, when_5]
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "app_t"), _, t_1,
                                (ErlangEmptyList)]),
                  b_2, when_3]
  =
  erlps__unify__4 [env_0, t_1, b_2, when_3]
erlps__unify1__4 [env_0, a_1,
                  (ErlangTuple [(ErlangAtom "app_t"), _, t_2,
                                (ErlangEmptyList)]),
                  when_3]
  =
  erlps__unify__4 [env_0, a_1, t_2, when_3]
erlps__unify1__4 [_env_0, a_1, b_2, when_3] =
  let _ = erlps__cannot_unify__3 [a_1, b_2, when_3]
  in ErlangAtom "false"
erlps__unify1__4 [arg_7, arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__unify1__4 args =
  EXC.badarity (ErlangFun 4 erlps__unify1__4) args

erlps__dereference__1 :: ErlangFun
erlps__dereference__1 [t_1@(ErlangTuple [(ErlangAtom "uvar"), _,
                                         r_0])]
  =
  let case_2 = erlps__ets_lookup__2 [ErlangAtom "type_vars", r_0]
  in
    case case_2 of
      (ErlangEmptyList) -> t_1
      (ErlangCons (ErlangTuple [r_5,
                                type_6]) (ErlangEmptyList)) | r_5 == r_0 ->
        erlps__dereference__1 [type_6]
      something_else -> EXC.case_clause something_else
erlps__dereference__1 [t_0] = t_0
erlps__dereference__1 [arg_1] = EXC.function_clause unit
erlps__dereference__1 args =
  EXC.badarity (ErlangFun 1 erlps__dereference__1) args

erlps__dereference_deep__1 :: ErlangFun
erlps__dereference_deep__1 [type_0] =
  let case_1 = erlps__dereference__1 [type_0]
  in
    case case_1 of
      tup_3 | isETuple tup_3 ->
        let    arg_5 = BIF.erlang__tuple_to_list__1 [tup_3]
        in let arg_4 = erlps__dereference_deep__1 [arg_5]
        in BIF.erlang__list_to_tuple__1 [arg_4]
      (ErlangCons h_7 t_8) ->
        let    head_9 = erlps__dereference_deep__1 [h_7]
        in let tail_11 = erlps__dereference_deep__1 [t_8]
        in ErlangCons head_9 tail_11
      t_13 -> t_13
erlps__dereference_deep__1 [arg_14] = EXC.function_clause unit
erlps__dereference_deep__1 args =
  EXC.badarity (ErlangFun 1 erlps__dereference_deep__1) args

erlps__occurs_check__2 :: ErlangFun
erlps__occurs_check__2 [r_0, t_1] =
  let arg_3 = erlps__dereference__1 [t_1]
  in erlps__occurs_check1__2 [r_0, arg_3]
erlps__occurs_check__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__occurs_check__2 args =
  EXC.badarity (ErlangFun 2 erlps__occurs_check__2) args

erlps__occurs_check1__2 :: ErlangFun
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "uvar"), _, r1_1])]
  =
  BIF.erlang__op_eq [r_0, r1_1]
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "id"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "con"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "qid"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "qcon"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "tvar"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "bytes_t"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "fun_t"), _, named_1, args_2,
                                       res_3])]
  =
  erlps__occurs_check__2
    [r_0, ErlangCons res_3 (ErlangCons named_1 args_2)]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "app_t"), _, t_1, ts_2])]
  =
  erlps__occurs_check__2 [r_0, ErlangCons t_1 ts_2]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "tuple_t"), _, ts_1])]
  =
  erlps__occurs_check__2 [r_0, ts_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "named_arg_t"), _, _, t_1,
                                       _])]
  =
  erlps__occurs_check__2 [r_0, t_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fields_1])]
  =
  erlps__occurs_check__2 [r_0, fields_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "field_t"), _, _, t_1])]
  =
  erlps__occurs_check__2 [r_0, t_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "if_t"), _, _, then_1,
                                       else_2])]
  =
  erlps__occurs_check__2
    [r_0, ErlangCons then_1 (ErlangCons else_2 ErlangEmptyList)]
erlps__occurs_check1__2 [r_0, (ErlangCons h_1 t_2)] =
  let lop_3 = erlps__occurs_check__2 [r_0, h_1]
  in
    case lop_3 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> erlps__occurs_check__2 [r_0, t_2]
      _ -> EXC.badarg1 lop_3
erlps__occurs_check1__2 [_, (ErlangEmptyList)] =
  ErlangAtom "false"
erlps__occurs_check1__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__occurs_check1__2 args =
  EXC.badarity (ErlangFun 2 erlps__occurs_check1__2) args

erlps__fresh_uvar__1 :: ErlangFun
erlps__fresh_uvar__1 [attrs_0] =
  let tup_el_3 = BIF.erlang__make_ref__0 []
  in ErlangTuple [ErlangAtom "uvar", attrs_0, tup_el_3]
erlps__fresh_uvar__1 [arg_4] = EXC.function_clause unit
erlps__fresh_uvar__1 args =
  EXC.badarity (ErlangFun 1 erlps__fresh_uvar__1) args

erlps__create_freshen_tvars__0 :: ErlangFun
erlps__create_freshen_tvars__0 [] =
  erlps__ets_new__2
    [ErlangAtom "freshen_tvars",
     ErlangCons (ErlangAtom "set") ErlangEmptyList]
erlps__create_freshen_tvars__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_freshen_tvars__0) args

erlps__destroy_freshen_tvars__0 :: ErlangFun
erlps__destroy_freshen_tvars__0 [] =
  erlps__ets_delete__1 [ErlangAtom "freshen_tvars"]
erlps__destroy_freshen_tvars__0 args =
  EXC.badarity (ErlangFun 0 erlps__destroy_freshen_tvars__0) args

erlps__freshen_type__2 :: ErlangFun
erlps__freshen_type__2 [ann_0, type_1] =
  let    _ = erlps__create_freshen_tvars__0 []
  in let type1_4 = erlps__freshen__2 [ann_0, type_1]
  in let _ = erlps__destroy_freshen_tvars__0 []
  in type1_4
erlps__freshen_type__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__freshen_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__freshen_type__2) args

erlps__freshen__1 :: ErlangFun
erlps__freshen__1 [type_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [type_0]
  in erlps__freshen__2 [arg_1, type_0]
erlps__freshen__1 [arg_4] = EXC.function_clause unit
erlps__freshen__1 args =
  EXC.badarity (ErlangFun 1 erlps__freshen__1) args

erlps__freshen__2 :: ErlangFun
erlps__freshen__2 [ann_0,
                   (ErlangTuple [(ErlangAtom "tvar"), _, name_1])]
  =
  let   
    case_2 =
      erlps__ets_lookup__2 [ErlangAtom "freshen_tvars", name_1]
  in let
    newt_8 =
      case case_2 of
        (ErlangEmptyList) -> erlps__fresh_uvar__1 [ann_0]
        (ErlangCons (ErlangTuple [name_6,
                                  t_7]) (ErlangEmptyList)) | name_6 == name_1 ->
          t_7
        something_else -> EXC.case_clause something_else
  in let arg_10 = ErlangTuple [name_1, newt_8]
  in let
    _ = erlps__ets_insert__2 [ErlangAtom "freshen_tvars", arg_10]
  in newt_8
erlps__freshen__2 [ann_0,
                   (ErlangTuple [(ErlangAtom "bytes_t"), _,
                                 (ErlangAtom "any")])]
  =
  let    x_2 = erlps__fresh_uvar__1 [ann_0]
  in let arg_3 = ErlangTuple [ErlangAtom "is_bytes", x_2]
  in let _ = erlps__add_bytes_constraint__1 [arg_3]
  in x_2
erlps__freshen__2 [ann_0, t_1] | isETuple t_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_2 = erlps__freshen__2 [ann_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__freshen__2 [ann_0, (ErlangCons a_1 b_2)] =
  let    head_3 = erlps__freshen__2 [ann_0, a_1]
  in let tail_6 = erlps__freshen__2 [ann_0, b_2]
  in ErlangCons head_3 tail_6
erlps__freshen__2 [_, x_0] = x_0
erlps__freshen__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__freshen__2 args =
  EXC.badarity (ErlangFun 2 erlps__freshen__2) args

erlps__freshen_type_sig__2 :: ErlangFun
erlps__freshen_type_sig__2 [ann_0,
                            typesig_2@(ErlangTuple [(ErlangAtom "type_sig"), _,
                                                    constr_1, _, _, _])]
  =
  let    arg_4 = erlps__typesig_to_fun_t__1 [typesig_2]
  in let funt_6 = erlps__freshen_type__2 [ann_0, arg_4]
  in let
    _ = erlps__apply_typesig_constraint__3 [ann_0, constr_1, funt_6]
  in funt_6
erlps__freshen_type_sig__2 [arg_10, arg_11] =
  EXC.function_clause unit
erlps__freshen_type_sig__2 args =
  EXC.badarity (ErlangFun 2 erlps__freshen_type_sig__2) args

erlps__apply_typesig_constraint__3 :: ErlangFun
erlps__apply_typesig_constraint__3 [_ann_0, (ErlangAtom "none"),
                                    _funt_1]
  =
  ErlangAtom "ok"
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "address_to_contract"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _,
                                                  (ErlangEmptyList),
                                                  (ErlangCons _ (ErlangEmptyList)),
                                                  type_1])]
  =
  let   
    tup_el_6 = ErlangTuple [ErlangAtom "address_to_contract", ann_0]
  in let
    head_3 =
      ErlangTuple
        [ErlangAtom "is_contract_constraint", type_1, tup_el_6,
         ErlangAtom "false"]
  in erlps__constrain__1 [ErlangCons head_3 ErlangEmptyList]
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "bytes_concat"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _,
                                                  (ErlangEmptyList),
                                                  (ErlangCons a_1 (ErlangCons b_2 (ErlangEmptyList))),
                                                  c_3])]
  =
  let
    arg_4 =
      ErlangTuple
        [ErlangAtom "add_bytes", ann_0, ErlangAtom "concat", a_1, b_2,
         c_3]
  in erlps__add_bytes_constraint__1 [arg_4]
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "bytes_split"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _,
                                                  (ErlangEmptyList),
                                                  (ErlangCons c_1 (ErlangEmptyList)),
                                                  (ErlangTuple [(ErlangAtom "tuple_t"),
                                                                _,
                                                                (ErlangCons a_2 (ErlangCons b_3 (ErlangEmptyList)))])])]
  =
  let
    arg_4 =
      ErlangTuple
        [ErlangAtom "add_bytes", ann_0, ErlangAtom "split", a_2, b_3,
         c_1]
  in erlps__add_bytes_constraint__1 [arg_4]
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "bytecode_hash"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                                  (ErlangCons con_1 (ErlangEmptyList)),
                                                  _])]
  =
  let    tup_el_6 = ErlangTuple [ErlangAtom "bytecode_hash", ann_0]
  in let
    head_3 =
      ErlangTuple
        [ErlangAtom "is_contract_constraint", con_1, tup_el_6,
         ErlangAtom "false"]
  in erlps__constrain__1 [ErlangCons head_3 ErlangEmptyList]
erlps__apply_typesig_constraint__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__apply_typesig_constraint__3 args =
  EXC.badarity (ErlangFun 3 erlps__apply_typesig_constraint__3)
    args

erlps__instantiate__1 :: ErlangFun
erlps__instantiate__1 [e_0] =
  let arg_1 = erlps__dereference__1 [e_0]
  in erlps__instantiate1__1 [arg_1]
erlps__instantiate__1 [arg_3] = EXC.function_clause unit
erlps__instantiate__1 args =
  EXC.badarity (ErlangFun 1 erlps__instantiate__1) args

erlps__instantiate1__1 :: ErlangFun
erlps__instantiate1__1 [(ErlangTuple [(ErlangAtom "uvar"),
                                      attr_0, r_1])]
  =
  let   
    arg_3 =
      erlps__ets_lookup__2 [ErlangAtom "type_vars", ErlangAtom "next"]
  in let arg_6 = toErl 0
  in let
    next_7 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "next", arg_3, arg_6]
  in let lop_11 = toErl "\'"
  in let rop_12 = erlps__integer_to_tvar__1 [next_7]
  in let tup_el_10 = BIF.erlang__op_append [lop_11, rop_12]
  in let
    tvar_14 = ErlangTuple [ErlangAtom "tvar", attr_0, tup_el_10]
  in let rop_21 = toErl 1
  in let tup_el_19 = BIF.erlang__op_plus [next_7, rop_21]
  in let head_17 = ErlangTuple [ErlangAtom "next", tup_el_19]
  in let head_23 = ErlangTuple [r_1, tvar_14]
  in let
    _ =
      erlps__ets_insert__2
        [ErlangAtom "type_vars",
         ErlangCons head_17 (ErlangCons head_23 ErlangEmptyList)]
  in tvar_14
erlps__instantiate1__1 [(ErlangTuple [(ErlangAtom "fun_t"),
                                      ann_0, named_1, args_2, ret_3])]
  =
  let case_4 = erlps__dereference__1 [named_1]
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "uvar"), _, r_6]) ->
        let    head_10 = ErlangTuple [r_6, ErlangEmptyList]
        in let
          _ =
            erlps__ets_insert__2
              [ErlangAtom "type_vars", ErlangCons head_10 ErlangEmptyList]
        in let tup_el_17 = erlps__instantiate__1 [args_2]
        in let tup_el_19 = erlps__instantiate__1 [ret_3]
        in
          ErlangTuple
            [ErlangAtom "fun_t", ann_0, ErlangEmptyList, tup_el_17,
             tup_el_19]
      named1_21 ->
        let    tup_el_24 = erlps__instantiate1__1 [named1_21]
        in let tup_el_26 = erlps__instantiate__1 [args_2]
        in let tup_el_28 = erlps__instantiate__1 [ret_3]
        in
          ErlangTuple
            [ErlangAtom "fun_t", ann_0, tup_el_24, tup_el_26, tup_el_28]
erlps__instantiate1__1 [t_0] | isETuple t_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [t_0]
  in let arg_1 = erlps__instantiate1__1 [arg_2]
  in BIF.erlang__list_to_tuple__1 [arg_1]
erlps__instantiate1__1 [(ErlangCons a_0 b_1)] =
  let    head_2 = erlps__instantiate__1 [a_0]
  in let tail_4 = erlps__instantiate__1 [b_1]
  in ErlangCons head_2 tail_4
erlps__instantiate1__1 [x_0] = x_0
erlps__instantiate1__1 [arg_1] = EXC.function_clause unit
erlps__instantiate1__1 args =
  EXC.badarity (ErlangFun 1 erlps__instantiate1__1) args

erlps__integer_to_tvar__1 :: ErlangFun
erlps__integer_to_tvar__1 [x_0] | weakLt x_0 (toErl 26) =
  let    lop_2 = toErl 97
  in let head_1 = BIF.erlang__op_plus [lop_2, x_0]
  in ErlangCons head_1 ErlangEmptyList
erlps__integer_to_tvar__1 [x_0] =
  let    rop_5 = toErl 26
  in let arg_3 = BIF.erlang__op_div_strict [x_0, rop_5]
  in let head_2 = erlps__integer_to_tvar__1 [arg_3]
  in let lop_9 = toErl 97
  in let rop_12 = toErl 26
  in let rop_10 = BIF.erlang__op_rem_strict [x_0, rop_12]
  in let head_8 = BIF.erlang__op_plus [lop_9, rop_10]
  in
    BIF.erlang__op_append
      [ErlangCons head_2 ErlangEmptyList,
       ErlangCons head_8 ErlangEmptyList]
erlps__integer_to_tvar__1 [arg_14] = EXC.function_clause unit
erlps__integer_to_tvar__1 args =
  EXC.badarity (ErlangFun 1 erlps__integer_to_tvar__1) args

erlps__cannot_unify__3 :: ErlangFun
erlps__cannot_unify__3 [a_0, b_1, when_2] =
  let
    arg_3 = ErlangTuple [ErlangAtom "cannot_unify", a_0, b_1, when_2]
  in erlps__type_error__1 [arg_3]
erlps__cannot_unify__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__cannot_unify__3 args =
  EXC.badarity (ErlangFun 3 erlps__cannot_unify__3) args

erlps__type_error__1 :: ErlangFun
erlps__type_error__1 [err_0] =
  erlps__ets_insert__2 [ErlangAtom "type_errors", err_0]
erlps__type_error__1 [arg_3] = EXC.function_clause unit
erlps__type_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__type_error__1) args

erlps__create_type_errors__0 :: ErlangFun
erlps__create_type_errors__0 [] =
  erlps__ets_new__2
    [ErlangAtom "type_errors",
     ErlangCons (ErlangAtom "bag") ErlangEmptyList]
erlps__create_type_errors__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_type_errors__0) args

erlps__destroy_and_report_type_errors__1 :: ErlangFun
erlps__destroy_and_report_type_errors__1 [env_0] =
  let    arg_1 = erlps__ets_tab2list__1 [ErlangAtom "type_errors"]
  in let
    errors0_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_1]
  in let _ = erlps__ets_delete__1 [ErlangAtom "type_errors"]
  in let
    errors_12 =
      flmap
        (\ lc_7 ->
           let    arg_9 = erlps__unqualify__2 [env_0, lc_7]
           in let lcRet_8 = erlps__mk_error__1 [arg_9]
           in ErlangCons lcRet_8 ErlangEmptyList)
        errors0_3
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1"
      [errors_12]
erlps__destroy_and_report_type_errors__1 [arg_14] =
  EXC.function_clause unit
erlps__destroy_and_report_type_errors__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__destroy_and_report_type_errors__1) args

erlps__unqualify__2 :: ErlangFun
erlps__unqualify__2 [(ErlangTuple [(ErlangAtom "env"), _, _, _,
                                   _, ns_0, _, _, _, _]),
                     (ErlangTuple [(ErlangAtom "qid"), ann_1, xs_2])]
  =
  let arg_4 = erlps__unqualify1__2 [ns_0, xs_2]
  in erlps__qid__2 [ann_1, arg_4]
erlps__unqualify__2 [(ErlangTuple [(ErlangAtom "env"), _, _, _,
                                   _, ns_0, _, _, _, _]),
                     (ErlangTuple [(ErlangAtom "qcon"), ann_1, xs_2])]
  =
  let arg_4 = erlps__unqualify1__2 [ns_0, xs_2]
  in erlps__qcon__2 [ann_1, arg_4]
erlps__unqualify__2 [env_0, t_1] | isETuple t_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_2 = erlps__unqualify__2 [env_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__unqualify__2 [env_0, (ErlangCons h_1 t_2)] =
  let    head_3 = erlps__unqualify__2 [env_0, h_1]
  in let tail_6 = erlps__unqualify__2 [env_0, t_2]
  in ErlangCons head_3 tail_6
erlps__unqualify__2 [_env_0, x_1] = x_1
erlps__unqualify__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__unqualify__2 args =
  EXC.badarity (ErlangFun 2 erlps__unqualify__2) args

erlps__unqualify1__2 :: ErlangFun
erlps__unqualify1__2 [ns_0, xs_1] =
  EXC.tryOfCatch
    (\ _ ->
       let arg_2 = BIF.erlang__length__1 [ns_0]
       in
         BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_2, xs_1])
    (\ of_5 ->
       case of_5 of
         (ErlangTuple [ns_8, ys_9]) | ns_8 == ns_0 -> ys_9
         _ -> xs_1)
    (\ ex_6 ->
       case ex_6 of
         (ErlangTuple [_, _, _]) -> xs_1
         ex_7 -> EXC.raise ex_7)
erlps__unqualify1__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__unqualify1__2 args =
  EXC.badarity (ErlangFun 2 erlps__unqualify1__2) args

erlps__mk_t_err__2 :: ErlangFun
erlps__mk_t_err__2 [pos_0, msg_1] =
  let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [msg_1]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__3"
      [ErlangAtom "type_error", pos_0, arg_4]
erlps__mk_t_err__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__mk_t_err__2 args =
  EXC.badarity (ErlangFun 2 erlps__mk_t_err__2) args

erlps__mk_t_err__3 :: ErlangFun
erlps__mk_t_err__3 [pos_0, msg_1, ctxt_2] =
  let   
    arg_5 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [msg_1]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [ctxt_2]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__4"
      [ErlangAtom "type_error", pos_0, arg_5, arg_7]
erlps__mk_t_err__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__mk_t_err__3 args =
  EXC.badarity (ErlangFun 3 erlps__mk_t_err__3) args

erlps__mk_error__1 :: ErlangFun
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "no_decls"),
                                  file_0])]
  =
  let    arg_2 = toErl 0
  in let arg_3 = toErl 0
  in let
    pos_4 =
      BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__3"
        [file_0, arg_2, arg_3]
  in let arg_6 = toErl "Empty contract\n"
  in erlps__mk_t_err__2 [pos_4, arg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "mismatched_decl_in_funblock"),
                                  name_0, decl_1])]
  =
  let   
    arg_2 =
      toErl
        "Mismatch in the function block. Expected implementation/type declaration of ~s function\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_1]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "higher_kinded_typevar"),
                                  t_0])]
  =
  let   
    arg_1 =
      toErl
        "Type ~s is a higher kinded type variable\n(takes another type as an argument)\n"
  in let arg_4 = erlps__instantiate__1 [t_0]
  in let head_3 = erlps__pp__1 [arg_4]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [t_0]
  in erlps__mk_t_err__2 [arg_8, msg_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "wrong_type_arguments"),
                                  x_0, aritygiven_1, arityreal_2])]
  =
  let   
    arg_3 =
      toErl "Arity for ~s doesn\'t match. Expected ~p, got ~p\n"
  in let arg_6 = erlps__instantiate__1 [x_0]
  in let head_5 = erlps__pp__1 [arg_6]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons arityreal_2
              (ErlangCons aritygiven_1 ErlangEmptyList))]
  in let arg_14 = erlps__pos__1 [x_0]
  in erlps__mk_t_err__2 [arg_14, msg_13]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unnamed_map_update_with_default"),
                                  upd_0])]
  =
  let    msg_1 = toErl "Invalid map update with default\n"
  in let arg_2 = erlps__pos__1 [upd_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "fundecl_must_have_funtype"),
                                  _ann_0, id_1, type_2])]
  =
  let   
    arg_3 =
      toErl
        "~s at ~s was declared with an invalid type ~s.\nEntrypoints and functions must have functional types"
  in let head_5 = erlps__pp__1 [id_1]
  in let head_8 = erlps__pp_loc__1 [id_1]
  in let arg_12 = erlps__instantiate__1 [type_2]
  in let head_11 = erlps__pp__1 [arg_12]
  in let
    msg_15 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
  in let arg_16 = erlps__pos__1 [id_1]
  in erlps__mk_t_err__2 [arg_16, msg_15]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "cannot_unify"),
                                  a_0, b_1, when_2])]
  =
  let    arg_3 = toErl "Cannot unify ~s\n         and ~s\n"
  in let arg_6 = erlps__instantiate__1 [a_0]
  in let head_5 = erlps__pp__1 [arg_6]
  in let arg_10 = erlps__instantiate__1 [b_1]
  in let head_9 = erlps__pp__1 [arg_10]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons head_5 (ErlangCons head_9 ErlangEmptyList)]
  in let matchExpr_17 = erlps__pp_when__1 [when_2]
  in
    case matchExpr_17 of
      (ErlangTuple [pos_15, ctxt_16]) ->
        erlps__mk_t_err__3 [pos_15, msg_13, ctxt_16]
      _ -> EXC.badmatch matchExpr_17
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unbound_variable"),
                                  id_0])]
  =
  let    arg_1 = toErl "Unbound variable ~s at ~s\n"
  in let head_3 = erlps__pp__1 [id_0]
  in let head_6 = erlps__pp_loc__1 [id_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in
    case id_0 of
      (ErlangTuple [(ErlangAtom "qid"), _,
                    (ErlangCons (ErlangCons (ErlangInt num_11) (ErlangCons (ErlangInt num_12) (ErlangCons (ErlangInt num_13) (ErlangCons (ErlangInt num_14) (ErlangCons (ErlangInt num_15) (ErlangEmptyList)))))) (ErlangCons (ErlangCons (ErlangInt num_16) (ErlangCons (ErlangInt num_17) (ErlangCons (ErlangInt num_18) (ErlangCons (ErlangInt num_19) (ErlangCons (ErlangInt num_20) (ErlangEmptyList)))))) (ErlangEmptyList)))]) | (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_11) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             67)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_12) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             104)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_13) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             97)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_14) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             105)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_15) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             110)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_16) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             101)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_17) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             118)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_18) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             101)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_19) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             110)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_20) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             116) ->
        let    cxt_21 = toErl "Did you forget to define the event type?"
        in let arg_22 = erlps__pos__1 [id_0]
        in erlps__mk_t_err__3 [arg_22, msg_9, cxt_21]
      _ ->
        let arg_26 = erlps__pos__1 [id_0]
        in erlps__mk_t_err__2 [arg_26, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "undefined_field"),
                                  id_0])]
  =
  let    arg_1 = toErl "Unbound field ~s at ~s\n"
  in let head_3 = erlps__pp__1 [id_0]
  in let head_6 = erlps__pp_loc__1 [id_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [id_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "not_a_record_type"),
                                  type_0, why_1])]
  =
  let    arg_2 = toErl "~s\n"
  in let arg_5 = toErl "Not a record type: "
  in let head_4 = erlps__pp_type__2 [arg_5, type_0]
  in let
    msg_8 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 ErlangEmptyList]
  in let matchExpr_12 = erlps__pp_why_record__1 [why_1]
  in
    case matchExpr_12 of
      (ErlangTuple [pos_10, ctxt_11]) ->
        erlps__mk_t_err__3 [pos_10, msg_8, ctxt_11]
      _ -> EXC.badmatch matchExpr_12
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "not_a_contract_type"),
                                  type_0, cxt_1])]
  =
  let   
    msg_9 =
      case type_0 of
        (ErlangTuple [(ErlangAtom "tvar"), _, _]) ->
          toErl "Unresolved contract type\n"
        _ ->
          let    arg_3 = toErl "The type ~s is not a contract type\n"
          in let arg_6 = toErl ""
          in let head_5 = erlps__pp_type__2 [arg_6, type_0]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_3, ErlangCons head_5 ErlangEmptyList]
  in let
    matchExpr_48 =
      case cxt_1 of
        (ErlangTuple [(ErlangAtom "var_args"), ann_11, fun_12]) ->
          let    tup_el_13 = erlps__pos__1 [ann_11]
          in let arg_16 = toErl "when calling variadic function\n~s\n"
          in let arg_19 = toErl "  "
          in let head_18 = erlps__pp_expr__2 [arg_19, fun_12]
          in let
            tup_el_15 =
              BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                [arg_16, ErlangCons head_18 ErlangEmptyList]
          in ErlangTuple [tup_el_13, tup_el_15]
        (ErlangTuple [(ErlangAtom "contract_literal"), lit_22]) ->
          let    tup_el_23 = erlps__pos__1 [lit_22]
          in let
            arg_26 =
              toErl
                "when checking that the contract literal\n~s\nhas the type\n~s\n"
          in let arg_29 = toErl "  "
          in let head_28 = erlps__pp_expr__2 [arg_29, lit_22]
          in let arg_33 = toErl "  "
          in let head_32 = erlps__pp_type__2 [arg_33, type_0]
          in let
            tup_el_25 =
              BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                [arg_26,
                 ErlangCons head_28 (ErlangCons head_32 ErlangEmptyList)]
          in ErlangTuple [tup_el_23, tup_el_25]
        (ErlangTuple [(ErlangAtom "address_to_contract"), ann_36]) ->
          let    tup_el_37 = erlps__pos__1 [ann_36]
          in let
            arg_40 =
              toErl
                "when checking that the call to\n  Address.to_contract\nhas the type\n~s\n"
          in let arg_43 = toErl "  "
          in let head_42 = erlps__pp_type__2 [arg_43, type_0]
          in let
            tup_el_39 =
              BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                [arg_40, ErlangCons head_42 ErlangEmptyList]
          in ErlangTuple [tup_el_37, tup_el_39]
        something_else -> EXC.case_clause something_else
  in
    case matchExpr_48 of
      (ErlangTuple [pos_46, cxt1_47]) ->
        erlps__mk_t_err__3 [pos_46, msg_9, cxt1_47]
      _ -> EXC.badmatch matchExpr_48
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "non_linear_pattern"),
                                  pattern_0, nonlinear_1])]
  =
  let   
    arg_2 = toErl "Repeated name~s ~s in pattern\n~s (at ~s)\n"
  in let arg_5 = toErl ""
  in let arg_6 = toErl "s"
  in let head_4 = erlps__plural__3 [arg_5, arg_6, nonlinear_1]
  in let arg_11 = toErl ", "
  in let
    head_9 =
      BIF.do_remote_fun_call "String" "erlps__join__2"
        [nonlinear_1, arg_11]
  in let arg_14 = toErl "  "
  in let head_13 = erlps__pp_expr__2 [arg_14, pattern_0]
  in let head_17 = erlps__pp_loc__1 [pattern_0]
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_9
              (ErlangCons head_13 (ErlangCons head_17 ErlangEmptyList)))]
  in let arg_21 = erlps__pos__1 [pattern_0]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "ambiguous_record"),
                                  fields_1@(ErlangCons (ErlangTuple [_,
                                                                     first_0]) _),
                                  candidates_2])]
  =
  let   
    arg_3 =
      toErl
        "Ambiguous record type with field~s ~s (at ~s) could be one of\n~s"
  in let arg_6 = toErl ""
  in let arg_7 = toErl "s"
  in let head_5 = erlps__plural__3 [arg_6, arg_7, fields_1]
  in let
    arg_11 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [_, f_13]) ->
               let lcRet_15 = erlps__pp__1 [f_13]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_1
  in let arg_17 = toErl ", "
  in let
    head_10 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_11, arg_17]
  in let head_19 = erlps__pp_loc__1 [first_0]
  in let
    head_22 =
      flmap
        (\ lc_25 ->
           let    head_27 = toErl "  - "
           in let head_29 = erlps__pp__1 [lc_25]
           in let head_32 = toErl " (at "
           in let head_34 = erlps__pp_loc__1 [lc_25]
           in let head_37 = toErl ")\n"
           in
             ErlangCons
               (ErlangCons head_27
                  (ErlangCons head_29
                     (ErlangCons head_32
                        (ErlangCons head_34
                           (ErlangCons head_37 ErlangEmptyList)))))
               ErlangEmptyList)
        candidates_2
  in let
    msg_40 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_10
              (ErlangCons head_19 (ErlangCons head_22 ErlangEmptyList)))]
  in let arg_41 = erlps__pos__1 [first_0]
  in erlps__mk_t_err__2 [arg_41, msg_40]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "missing_field"),
                                  field_0, rec_1])]
  =
  let   
    arg_2 = toErl "Record type ~s does not have field ~s (at ~s)\n"
  in let head_4 = erlps__pp__1 [rec_1]
  in let head_7 = erlps__pp__1 [field_0]
  in let head_10 = erlps__pp_loc__1 [field_0]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList))]
  in let arg_14 = erlps__pos__1 [field_0]
  in erlps__mk_t_err__2 [arg_14, msg_13]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "missing_fields"),
                                  ann_0, rectype_1, fields_2])]
  =
  let   
    arg_3 =
      toErl
        "The field~s ~s ~s missing when constructing an element of type ~s (at ~s)\n"
  in let arg_6 = toErl ""
  in let arg_7 = toErl "s"
  in let head_5 = erlps__plural__3 [arg_6, arg_7, fields_2]
  in let arg_12 = toErl ", "
  in let
    head_10 =
      BIF.do_remote_fun_call "String" "erlps__join__2"
        [fields_2, arg_12]
  in let arg_15 = toErl "is"
  in let arg_16 = toErl "are"
  in let head_14 = erlps__plural__3 [arg_15, arg_16, fields_2]
  in let head_19 = erlps__pp__1 [rectype_1]
  in let head_22 = erlps__pp_loc__1 [ann_0]
  in let
    msg_25 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_10
              (ErlangCons head_14
                 (ErlangCons head_19 (ErlangCons head_22 ErlangEmptyList))))]
  in let arg_26 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_26, msg_25]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "no_records_with_all_fields"),
                                  fields_1@(ErlangCons (ErlangTuple [_,
                                                                     first_0]) _)])]
  =
  let    arg_2 = toErl "No record type with field~s ~s (at ~s)\n"
  in let arg_5 = toErl ""
  in let arg_6 = toErl "s"
  in let head_4 = erlps__plural__3 [arg_5, arg_6, fields_1]
  in let
    arg_10 =
      flmap
        (\ lc_13 ->
           case lc_13 of
             (ErlangTuple [_, f_12]) ->
               let lcRet_14 = erlps__pp__1 [f_12]
               in ErlangCons lcRet_14 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_1
  in let arg_16 = toErl ", "
  in let
    head_9 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_10, arg_16]
  in let head_18 = erlps__pp_loc__1 [first_0]
  in let
    msg_21 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_9 (ErlangCons head_18 ErlangEmptyList))]
  in let arg_22 = erlps__pos__1 [first_0]
  in erlps__mk_t_err__2 [arg_22, msg_21]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "recursive_types_not_implemented"),
                                  types_0])]
  =
  let    arg_1 = toErl " is"
  in let arg_2 = toErl "s are mutually"
  in let s_4 = erlps__plural__3 [arg_1, arg_2, types_0]
  in let
    arg_5 =
      toErl
        "The following type~s recursive, which is not yet supported:\n~s"
  in let
    head_9 =
      flmap
        (\ lc_12 ->
           let    arg_14 = toErl "  - ~s (at ~s)\n"
           in let head_16 = erlps__pp__1 [lc_12]
           in let head_19 = erlps__pp_loc__1 [lc_12]
           in let
             lcRet_13 =
               BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                 [arg_14,
                  ErlangCons head_16 (ErlangCons head_19 ErlangEmptyList)]
           in ErlangCons lcRet_13 ErlangEmptyList)
        types_0
  in let
    msg_23 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons s_4 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_25 = BIF.erlang__hd__1 [types_0]
  in let arg_24 = erlps__pos__1 [arg_25]
  in erlps__mk_t_err__2 [arg_24, msg_23]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "event_must_be_variant_type"),
                                  where_0])]
  =
  let   
    arg_1 = toErl "The event type must be a variant type (at ~s)\n"
  in let head_3 = erlps__pp_loc__1 [where_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [where_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "indexed_type_must_be_word"),
                                  type_0, type_1])]
  | type_1 == type_0 =
  let   
    arg_2 = toErl "The indexed type ~s (at ~s) is not a word type\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_type__2 [arg_5, type_0]
  in let head_8 = erlps__pp_loc__1 [type_0]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "indexed_type_must_be_word"),
                                  type_0, type1_1])]
  =
  let   
    arg_2 =
      toErl
        "The indexed type ~s (at ~s) equals ~s which is not a word type\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_type__2 [arg_5, type_0]
  in let head_8 = erlps__pp_loc__1 [type_0]
  in let arg_12 = toErl ""
  in let head_11 = erlps__pp_type__2 [arg_12, type1_1]
  in let
    msg_15 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
  in let arg_16 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_16, msg_15]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "event_0_to_3_indexed_values"),
                                  constr_0])]
  =
  let   
    arg_1 =
      toErl
        "The event constructor ~s (at ~s) has too many indexed values (max 3)\n"
  in let head_3 = erlps__name__1 [constr_0]
  in let head_6 = erlps__pp_loc__1 [constr_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [constr_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "event_0_to_1_string_values"),
                                  constr_0])]
  =
  let   
    arg_1 =
      toErl
        "The event constructor ~s (at ~s) has too many non-indexed values (max 1)\n"
  in let head_3 = erlps__name__1 [constr_0]
  in let head_6 = erlps__pp_loc__1 [constr_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [constr_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "repeated_constructor"),
                                  cs_0])]
  =
  let   
    arg_1 =
      toErl "Variant types must have distinct constructor names\n~s"
  in let
    head_3 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [c_5, t_6]) ->
               let    arg_9 = toErl "~s  (at ~s)\n"
               in let arg_12 = toErl "  - "
               in let head_11 = erlps__pp_typed__3 [arg_12, c_5, t_6]
               in let head_16 = erlps__pp_loc__1 [c_5]
               in let
                 lcRet_8 =
                   BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                     [arg_9,
                      ErlangCons head_11 (ErlangCons head_16 ErlangEmptyList)]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        cs_0
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_23 = toErl 1
  in let arg_24 = BIF.erlang__hd__1 [cs_0]
  in let arg_22 = BIF.erlang__element__2 [arg_23, arg_24]
  in let arg_21 = erlps__pos__1 [arg_22]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "bad_named_argument"),
                                  (ErlangEmptyList), name_0])]
  =
  let   
    arg_1 =
      toErl
        "Named argument ~s (at ~s) supplied to function expecting no named arguments.\n"
  in let head_3 = erlps__pp__1 [name_0]
  in let head_6 = erlps__pp_loc__1 [name_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [name_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "bad_named_argument"),
                                  args_0, name_1])]
  =
  let   
    arg_2 =
      toErl
        "Named argument ~s (at ~s) is not one of the expected named arguments\n~s"
  in let head_4 = erlps__pp__1 [name_1]
  in let head_7 = erlps__pp_loc__1 [name_1]
  in let
    head_10 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangAtom "named_arg_t"), _, arg_12, type_13,
                           _]) ->
               let    arg_16 = toErl "~s\n"
               in let arg_19 = toErl "  - "
               in let head_18 = erlps__pp_typed__3 [arg_19, arg_12, type_13]
               in let
                 lcRet_15 =
                   BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                     [arg_16, ErlangCons head_18 ErlangEmptyList]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_0
  in let
    msg_24 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList))]
  in let arg_25 = erlps__pos__1 [name_1]
  in erlps__mk_t_err__2 [arg_25, msg_24]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unsolved_named_argument_constraint"),
                                  (ErlangTuple [(ErlangAtom "named_argument_constraint"),
                                                _, name_0, type_1])])]
  =
  let   
    arg_2 =
      toErl
        "Named argument ~s (at ~s) supplied to function with unknown named arguments.\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_typed__3 [arg_5, name_0, type_1]
  in let head_9 = erlps__pp_loc__1 [name_0]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [name_0]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "reserved_entrypoint"),
                                  name_0, def_1])]
  =
  let   
    arg_2 =
      toErl
        "The name \'~s\' is reserved and cannot be used for a\ntop-level contract function (at ~s).\n"
  in let head_6 = erlps__pp_loc__1 [def_1]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [def_1]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "duplicate_definition"),
                                  name_0, locs_1])]
  =
  let    arg_2 = toErl "Duplicate definitions of ~s at\n~s"
  in let
    head_6 =
      flmap
        (\ lc_9 ->
           let    head_11 = toErl "  - "
           in let head_13 = erlps__pp_loc__1 [lc_9]
           in let head_16 = toErl "\n"
           in
             ErlangCons
               (ErlangCons head_11
                  (ErlangCons head_13 (ErlangCons head_16 ErlangEmptyList)))
               ErlangEmptyList)
        locs_1
  in let
    msg_19 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 (ErlangCons head_6 ErlangEmptyList)]
  in let
    arg_21 = BIF.do_remote_fun_call "Lists" "erlps__last__1" [locs_1]
  in let arg_20 = erlps__pos__1 [arg_21]
  in erlps__mk_t_err__2 [arg_20, msg_19]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "duplicate_scope"),
                                  kind_0, name_1, otherkind_2, l_3])]
  =
  let   
    arg_4 =
      toErl "The ~p ~s (at ~s) has the same name as a ~p at ~s\n"
  in let head_8 = erlps__pp__1 [name_1]
  in let head_11 = erlps__pp_loc__1 [name_1]
  in let head_16 = erlps__pp_loc__1 [l_3]
  in let
    msg_19 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4,
         ErlangCons kind_0
           (ErlangCons head_8
              (ErlangCons head_11
                 (ErlangCons otherkind_2
                    (ErlangCons head_16 ErlangEmptyList))))]
  in let arg_20 = erlps__pos__1 [name_1]
  in erlps__mk_t_err__2 [arg_20, msg_19]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "include"), _,
                                  (ErlangTuple [(ErlangAtom "string"), pos_0,
                                                name_1])])]
  =
  let   
    arg_2 =
      toErl
        "Include of \'~s\' at ~s\nnot allowed, include only allowed at top level.\n"
  in let head_4 = BIF.erlang__binary_to_list__1 [name_1]
  in let head_7 = erlps__pp_loc__1 [pos_0]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 (ErlangCons head_7 ErlangEmptyList)]
  in let arg_11 = erlps__pos__1 [pos_0]
  in erlps__mk_t_err__2 [arg_11, msg_10]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "namespace"),
                                  _pos_0,
                                  (ErlangTuple [(ErlangAtom "con"), pos_1,
                                                name_2]),
                                  _def_3])]
  =
  let   
    arg_4 =
      toErl
        "Nested namespaces are not allowed\nNamespace \'~s\' at ~s not defined at top level.\n"
  in let head_8 = erlps__pp_loc__1 [pos_1]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons name_2 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [pos_1]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [contract_0, _pos_1,
                                  (ErlangTuple [(ErlangAtom "con"), pos_2,
                                                name_3]),
                                  _def_4])]
  | ((==) contract_0 (ErlangAtom "contract_main")) ||
      (((==) contract_0 (ErlangAtom "contract_interface")) ||
         ((==) contract_0 (ErlangAtom "contract_child"))) =
  let   
    arg_5 =
      toErl
        "Nested contracts are not allowed\nContract \'~s\' at ~s not defined at top level.\n"
  in let head_9 = erlps__pp_loc__1 [pos_2]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons name_3 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [pos_2]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "type_decl"), _,
                                  (ErlangTuple [(ErlangAtom "id"), pos_0,
                                                name_1]),
                                  _])]
  =
  let   
    arg_2 =
      toErl
        "Empty type declarations are not supported\nType ~s at ~s lacks a definition\n"
  in let head_6 = erlps__pp_loc__1 [pos_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_1 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [pos_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "letval"), _pos_0,
                                  (ErlangTuple [(ErlangAtom "id"), pos_1,
                                                name_2]),
                                  _def_3])]
  =
  let   
    arg_4 =
      toErl
        "Toplevel \"let\" definitions are not supported\nValue ~s at ~s could be replaced by 0-argument function\n"
  in let head_8 = erlps__pp_loc__1 [pos_1]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons name_2 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [pos_1]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "stateful_not_allowed"),
                                  id_0, fun_1])]
  =
  let   
    arg_2 =
      toErl
        "Cannot reference stateful function ~s (at ~s)\nin the definition of non-stateful function ~s.\n"
  in let head_4 = erlps__pp__1 [id_0]
  in let head_7 = erlps__pp_loc__1 [id_0]
  in let head_10 = erlps__pp__1 [fun_1]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList))]
  in let arg_14 = erlps__pos__1 [id_0]
  in erlps__mk_t_err__2 [arg_14, msg_13]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "value_arg_not_allowed"),
                                  value_0, fun_1])]
  =
  let   
    arg_2 =
      toErl
        "Cannot pass non-zero value argument ~s (at ~s)\nin the definition of non-stateful function ~s.\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_expr__2 [arg_5, value_0]
  in let head_8 = erlps__pp_loc__1 [value_0]
  in let head_11 = erlps__pp__1 [fun_1]
  in let
    msg_14 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
  in let arg_15 = erlps__pos__1 [value_0]
  in erlps__mk_t_err__2 [arg_15, msg_14]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "init_depends_on_state"),
                                  which_0, (ErlangCons _init_1 chain_2)])]
  =
  let   
    whichcalls_13 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangCons (ErlangInt num_7) (ErlangEmptyList))))]
             | (ErlangInt num_5) == (toErl 112)
             , (ErlangInt num_6) == (toErl 117)
             , (ErlangInt num_7) == (toErl 116) =
             toErl ""
           lambda_3 [(ErlangCons (ErlangInt num_8) (ErlangCons (ErlangInt num_9) (ErlangCons (ErlangInt num_10) (ErlangCons (ErlangInt num_11) (ErlangCons (ErlangInt num_12) (ErlangEmptyList))))))]
             | (ErlangInt num_8) == (toErl 115)
             , (ErlangInt num_9) == (toErl 116)
             , (ErlangInt num_10) == (toErl 97)
             , (ErlangInt num_11) == (toErl 116)
             , (ErlangInt num_12) == (toErl 101) =
             toErl ""
           lambda_3 [_] = toErl ", which calls"
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    arg_14 =
      toErl
        "The init function should return the initial state as its result and cannot ~s the state,\nbut it calls\n~s"
  in let
    head_16 =
      case ErlangAtom "true" of
        _ | weakEq which_0 (ErlangAtom "put") -> toErl "write"
        _ -> toErl "read"
  in let
    head_18 =
      flmap
        (\ lc_22 ->
           case lc_22 of
             (ErlangTuple [(ErlangCons _ (ErlangCons fun_20 (ErlangEmptyList))),
                           ann_21]) ->
               let    arg_24 = toErl "  - ~s (at ~s)~s\n"
               in let head_28 = erlps__pp_loc__1 [ann_21]
               in let
                 head_31 =
                   BIF.erlang__apply__2
                     [whichcalls_13, ErlangCons fun_20 ErlangEmptyList]
               in let
                 lcRet_23 =
                   BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                     [arg_24,
                      ErlangCons fun_20
                        (ErlangCons head_28
                           (ErlangCons head_31 ErlangEmptyList))]
               in ErlangCons lcRet_23 ErlangEmptyList
             _ -> ErlangEmptyList)
        chain_2
  in let
    msg_36 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_14, ErlangCons head_16 (ErlangCons head_18 ErlangEmptyList)]
  in let arg_39 = toErl 2
  in let arg_40 = BIF.erlang__hd__1 [chain_2]
  in let arg_38 = BIF.erlang__element__2 [arg_39, arg_40]
  in let arg_37 = erlps__pos__1 [arg_38]
  in erlps__mk_t_err__2 [arg_37, msg_36]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "missing_body_for_let"),
                                  ann_0])]
  =
  let   
    arg_1 =
      toErl "Let binding at ~s must be followed by an expression\n"
  in let head_3 = erlps__pp_loc__1 [ann_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "public_modifier_in_contract"),
                                  decl_0])]
  =
  let    decl1_2 = erlps__mk_entrypoint__1 [decl_0]
  in let
    arg_3 =
      toErl
        "Use \'entrypoint\' instead of \'function\' for public function ~s (at ~s):\n~s\n"
  in let arg_6 = toErl ""
  in let arg_8 = toErl 3
  in let arg_7 = BIF.erlang__element__2 [arg_8, decl_0]
  in let head_5 = erlps__pp_expr__2 [arg_6, arg_7]
  in let head_11 = erlps__pp_loc__1 [decl_0]
  in let arg_16 = toErl 2
  in let
    arg_17 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__decl__1" [decl1_2]
  in let
    arg_15 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_16, arg_17]
  in let
    head_14 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_15]
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_21 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "init_must_be_an_entrypoint"),
                                  decl_0])]
  =
  let    decl1_2 = erlps__mk_entrypoint__1 [decl_0]
  in let
    arg_3 =
      toErl "The init function (at ~s) must be an entrypoint:\n~s\n"
  in let head_5 = erlps__pp_loc__1 [decl_0]
  in let arg_10 = toErl 2
  in let
    arg_11 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__decl__1" [decl1_2]
  in let
    arg_9 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_10, arg_11]
  in let
    head_8 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_9]
  in let
    msg_14 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons head_5 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_15 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_15, msg_14]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "init_must_not_be_payable"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "The init function (at ~s) cannot be payable.\nYou don\'t need the \'payable\' annotation to be able to attach\nfunds to the create contract transaction."
  in let head_3 = erlps__pp_loc__1 [decl_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "proto_must_be_entrypoint"),
                                  decl_0])]
  =
  let    decl1_2 = erlps__mk_entrypoint__1 [decl_0]
  in let
    arg_3 =
      toErl "Use \'entrypoint\' for declaration of ~s (at ~s):\n~s\n"
  in let arg_6 = toErl ""
  in let arg_8 = toErl 3
  in let arg_7 = BIF.erlang__element__2 [arg_8, decl_0]
  in let head_5 = erlps__pp_expr__2 [arg_6, arg_7]
  in let head_11 = erlps__pp_loc__1 [decl_0]
  in let arg_16 = toErl 2
  in let
    arg_17 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__decl__1" [decl1_2]
  in let
    arg_15 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_16, arg_17]
  in let
    head_14 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_15]
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_21 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "proto_in_namespace"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl "Namespaces cannot contain function prototypes (at ~s).\n"
  in let head_3 = erlps__pp_loc__1 [decl_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "entrypoint_in_namespace"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "Namespaces cannot contain entrypoints (at ~s). Use \'function\' instead.\n"
  in let head_3 = erlps__pp_loc__1 [decl_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "private_entrypoint"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "The entrypoint ~s (at ~s) cannot be private. Use \'function\' instead.\n"
  in let arg_4 = toErl ""
  in let arg_6 = toErl 3
  in let arg_5 = BIF.erlang__element__2 [arg_6, decl_0]
  in let head_3 = erlps__pp_expr__2 [arg_4, arg_5]
  in let head_9 = erlps__pp_loc__1 [decl_0]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "private_and_public"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "The function ~s (at ~s) cannot be both public and private.\n"
  in let arg_4 = toErl ""
  in let arg_6 = toErl 3
  in let arg_5 = BIF.erlang__element__2 [arg_6, decl_0]
  in let head_3 = erlps__pp_expr__2 [arg_4, arg_5]
  in let head_9 = erlps__pp_loc__1 [decl_0]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "contract_has_no_entrypoints"),
                                  con_0])]
  =
  let   
    arg_1 =
      toErl
        "The contract ~s (at ~s) has no entrypoints. Since Sophia version 3.2, public\ncontract functions must be declared with the \'entrypoint\' keyword instead of\n\'function\'.\n"
  in let arg_4 = toErl ""
  in let head_3 = erlps__pp_expr__2 [arg_4, con_0]
  in let head_7 = erlps__pp_loc__1 [con_0]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList)]
  in let arg_11 = erlps__pos__1 [con_0]
  in erlps__mk_t_err__2 [arg_11, msg_10]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "definition_in_contract_interface"),
                                  ann_0,
                                  (ErlangTuple [(ErlangAtom "id"), _, id_1])])]
  =
  let   
    msg_2 =
      toErl
        "Contract interfaces cannot contain defined functions or entrypoints.\n"
  in let
    arg_3 =
      toErl
        "Fix: replace the definition of \'~s\' by a type signature.\n"
  in let
    cxt_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons id_1 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__3 [arg_8, msg_2, cxt_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unbound_type"),
                                  type_0])]
  =
  let    arg_1 = toErl "Unbound type ~s (at ~s).\n"
  in let arg_4 = toErl ""
  in let head_3 = erlps__pp_type__2 [arg_4, type_0]
  in let head_7 = erlps__pp_loc__1 [type_0]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList)]
  in let arg_11 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_11, msg_10]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "new_tuple_syntax"),
                                  ann_0, ts_1])]
  =
  let   
    arg_2 =
      toErl
        "Invalid type\n~s  (at ~s)\nThe syntax of tuple types changed in Sophia version 4.0. Did you mean\n~s\n"
  in let arg_5 = toErl "  "
  in let arg_6 = ErlangTuple [ErlangAtom "args_t", ann_0, ts_1]
  in let head_4 = erlps__pp_type__2 [arg_5, arg_6]
  in let head_11 = erlps__pp_loc__1 [ann_0]
  in let arg_15 = toErl "  "
  in let arg_16 = ErlangTuple [ErlangAtom "tuple_t", ann_0, ts_1]
  in let head_14 = erlps__pp_type__2 [arg_15, arg_16]
  in let
    msg_21 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_22 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_22, msg_21]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "map_in_map_key"),
                                  ann_0, keytype_1])]
  =
  let    arg_2 = toErl "Invalid key type\n~s\n"
  in let arg_5 = toErl "  "
  in let head_4 = erlps__pp_type__2 [arg_5, keytype_1]
  in let
    msg_8 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 ErlangEmptyList]
  in let cxt_9 = toErl "Map keys cannot contain other maps.\n"
  in let arg_10 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__3 [arg_10, msg_8, cxt_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "cannot_call_init_function"),
                                  ann_0])]
  =
  let   
    msg_1 =
      toErl
        "The \'init\' function is called exclusively by the create contract transaction\nand cannot be called from the contract code.\n"
  in let arg_2 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "contract_treated_as_namespace"),
                                  ann_0,
                                  qname_3@(ErlangCons con_1 (ErlangCons fun_2 (ErlangEmptyList)))])]
  =
  let   
    arg_4 = toErl "Invalid call to contract entrypoint \'~s\'.\n"
  in let arg_8 = toErl "."
  in let
    head_6 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [qname_3, arg_8]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons head_6 ErlangEmptyList]
  in let
    arg_11 = toErl "It must be called as \'c.~s\' for some c : ~s.\n"
  in let
    cxt_17 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_11, ErlangCons fun_2 (ErlangCons con_1 ErlangEmptyList)]
  in let arg_18 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__3 [arg_18, msg_10, cxt_17]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "bad_top_level_decl"),
                                  decl_0])]
  =
  let    arg_2 = toErl 1
  in let case_1 = BIF.erlang__element__2 [arg_2, decl_0]
  in let
    what_4 =
      case case_1 of
        (ErlangAtom "letval") -> toErl "function or entrypoint"
        _ -> toErl "contract or namespace"
  in let arg_5 = toErl 3
  in let id_7 = BIF.erlang__element__2 [arg_5, decl_0]
  in let
    arg_8 =
      toErl "The definition of \'~s\' must appear inside a ~s.\n"
  in let arg_11 = toErl ""
  in let head_10 = erlps__pp_expr__2 [arg_11, id_7]
  in let
    msg_16 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_8, ErlangCons head_10 (ErlangCons what_4 ErlangEmptyList)]
  in let arg_17 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_17, msg_16]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unknown_byte_length"),
                                  type_0])]
  =
  let    arg_1 = toErl "Cannot resolve length of byte array.\n"
  in let
    msg_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangEmptyList]
  in let arg_4 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_4, msg_3]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unsolved_bytes_constraint"),
                                  ann_0, (ErlangAtom "concat"), a_1, b_2, c_3])]
  =
  let   
    arg_4 =
      toErl
        "Failed to resolve byte array lengths in call to Bytes.concat with arguments of type\n~s  (at ~s)\n~s  (at ~s)\nand result type\n~s  (at ~s)\n"
  in let arg_7 = toErl "  - "
  in let head_6 = erlps__pp_type__2 [arg_7, a_1]
  in let head_10 = erlps__pp_loc__1 [a_1]
  in let arg_14 = toErl "  - "
  in let head_13 = erlps__pp_type__2 [arg_14, b_2]
  in let head_17 = erlps__pp_loc__1 [b_2]
  in let arg_21 = toErl "  - "
  in let head_20 = erlps__pp_type__2 [arg_21, c_3]
  in let head_24 = erlps__pp_loc__1 [c_3]
  in let
    msg_27 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4,
         ErlangCons head_6
           (ErlangCons head_10
              (ErlangCons head_13
                 (ErlangCons head_17
                    (ErlangCons head_20
                       (ErlangCons head_24 ErlangEmptyList)))))]
  in let arg_28 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_28, msg_27]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unsolved_bytes_constraint"),
                                  ann_0, (ErlangAtom "split"), a_1, b_2, c_3])]
  =
  let   
    arg_4 =
      toErl
        "Failed to resolve byte array lengths in call to Bytes.split with argument of type\n~s  (at ~s)\nand result types\n~s  (at ~s)\n~s  (at ~s)\n"
  in let arg_7 = toErl "  - "
  in let head_6 = erlps__pp_type__2 [arg_7, c_3]
  in let head_10 = erlps__pp_loc__1 [c_3]
  in let arg_14 = toErl "  - "
  in let head_13 = erlps__pp_type__2 [arg_14, a_1]
  in let head_17 = erlps__pp_loc__1 [a_1]
  in let arg_21 = toErl "  - "
  in let head_20 = erlps__pp_type__2 [arg_21, b_2]
  in let head_24 = erlps__pp_loc__1 [b_2]
  in let
    msg_27 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4,
         ErlangCons head_6
           (ErlangCons head_10
              (ErlangCons head_13
                 (ErlangCons head_17
                    (ErlangCons head_20
                       (ErlangCons head_24 ErlangEmptyList)))))]
  in let arg_28 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_28, msg_27]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "failed_to_get_compiler_version"),
                                  err_0])]
  =
  let   
    arg_1 = toErl "Failed to get compiler version. Error:\n  ~p\n"
  in let
    msg_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons err_0 ErlangEmptyList]
  in let arg_7 = toErl 0
  in let arg_8 = toErl 0
  in let arg_6 = erlps__pos__2 [arg_7, arg_8]
  in erlps__mk_t_err__2 [arg_6, msg_5]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "compiler_version_mismatch"),
                                  ann_0, version_1, op_2, bound_3])]
  =
  let   
    printv_14 =
      ErlangFun 1
        (let
           lambda_4 [v_6] =
             let   
               arg_7 =
                 flmap
                   (\ lc_10 ->
                      let lcRet_11 = BIF.erlang__integer_to_list__1 [lc_10]
                      in ErlangCons lcRet_11 ErlangEmptyList)
                   v_6
             in let arg_13 = toErl "."
             in
               BIF.do_remote_fun_call "String" "erlps__join__2" [arg_7, arg_13]
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    arg_15 =
      toErl
        "Cannot compile with this version of the compiler,\nbecause it does not satisfy the constraint ~s ~s ~s\n"
  in let
    head_17 =
      BIF.erlang__apply__2
        [printv_14, ErlangCons version_1 ErlangEmptyList]
  in let
    head_23 =
      BIF.erlang__apply__2
        [printv_14, ErlangCons bound_3 ErlangEmptyList]
  in let
    msg_27 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_15,
         ErlangCons head_17
           (ErlangCons op_2 (ErlangCons head_23 ErlangEmptyList))]
  in let arg_28 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_28, msg_27]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "empty_record_or_map_update"),
                                  expr_0])]
  =
  let    arg_1 = toErl "Empty record/map update\n~s"
  in let arg_4 = toErl "  "
  in let head_3 = erlps__pp_expr__2 [arg_4, expr_0]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [expr_0]
  in erlps__mk_t_err__2 [arg_8, msg_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "mixed_record_and_map"),
                                  expr_0])]
  =
  let    arg_1 = toErl "Mixed record fields and map keys in\n~s"
  in let arg_4 = toErl "  "
  in let head_3 = erlps__pp_expr__2 [arg_4, expr_0]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [expr_0]
  in erlps__mk_t_err__2 [arg_8, msg_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "named_argument_must_be_literal_bool"),
                                  name_0, arg_1])]
  =
  let   
    arg_2 =
      toErl
        "Invalid \'~s\' argument\n~s\nIt must be either \'true\' or \'false\'."
  in let arg_7 = toErl "  "
  in let arg_8 = erlps__instantiate__1 [arg_1]
  in let head_6 = erlps__pp_expr__2 [arg_7, arg_8]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [arg_1]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "conflicting_updates_for_field"),
                                  upd_0, key_1])]
  =
  let    arg_2 = toErl "Conflicting updates for field \'~s\'\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons key_1 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [upd_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "ambiguous_main_contract"),
                                  ann_0])]
  =
  let   
    msg_1 =
      toErl
        "Could not deduce the main contract. You can point it out manually with the `main` keyword."
  in let arg_2 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "main_contract_undefined"),
                                  ann_0])]
  =
  let    msg_1 = toErl "No contract defined.\n"
  in let arg_2 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "multiple_main_contracts"),
                                  ann_0])]
  =
  let    msg_1 = toErl "Only one main contract can be defined.\n"
  in let arg_2 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unify_varargs"),
                                  when_0])]
  =
  let    msg_1 = toErl "Cannot unify variable argument list.\n"
  in let matchExpr_5 = erlps__pp_when__1 [when_0]
  in
    case matchExpr_5 of
      (ErlangTuple [pos_3, ctxt_4]) ->
        erlps__mk_t_err__3 [pos_3, msg_1, ctxt_4]
      _ -> EXC.badmatch matchExpr_5
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "clone_no_contract"),
                                  ann_0])]
  =
  let   
    msg_1 =
      toErl
        "Chain.clone requires `ref` named argument of contract type.\n"
  in let arg_2 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "contract_lacks_definition"),
                                  type_0, when_1])]
  =
  let    arg_2 = toErl "~s is not implemented.\n"
  in let head_4 = erlps__pp_type__1 [type_0]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 ErlangEmptyList]
  in let matchExpr_11 = erlps__pp_when__1 [when_1]
  in
    case matchExpr_11 of
      (ErlangTuple [pos_9, ctxt_10]) ->
        erlps__mk_t_err__3 [pos_9, msg_7, ctxt_10]
      _ -> EXC.badmatch matchExpr_11
erlps__mk_error__1 [err_0] =
  let    arg_1 = toErl "Unknown error: ~p\n"
  in let
    msg_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons err_0 ErlangEmptyList]
  in let arg_7 = toErl 0
  in let arg_8 = toErl 0
  in let arg_6 = erlps__pos__2 [arg_7, arg_8]
  in erlps__mk_t_err__2 [arg_6, msg_5]
erlps__mk_error__1 [arg_10] = EXC.function_clause unit
erlps__mk_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_error__1) args

erlps__mk_entrypoint__1 :: ErlangFun
erlps__mk_entrypoint__1 [decl_0] =
  let    arg_5 = toErl 1
  in let arg_8 = toErl 1
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [decl_0]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [ErlangAtom "private", arg_8, arg_9]
  in let
    lop_3 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [ErlangAtom "public", arg_5, arg_6]
  in let
    tail_2 =
      BIF.erlang__op_unAppend
        [lop_3,
         ErlangCons (ErlangAtom "public")
           (ErlangCons (ErlangAtom "private") ErlangEmptyList)]
  in
    BIF.do_remote_fun_call "Aeso.Syntax" "erlps__set_ann__2"
      [ErlangCons (ErlangAtom "entrypoint") tail_2, decl_0]
erlps__mk_entrypoint__1 [arg_19] = EXC.function_clause unit
erlps__mk_entrypoint__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_entrypoint__1) args

erlps__pp_when__1 :: ErlangFun
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "todo"), what_0])] =
  let    arg_2 = toErl 0
  in let arg_3 = toErl 0
  in let tup_el_1 = erlps__pos__2 [arg_2, arg_3]
  in let arg_5 = toErl "[TODO] ~p\n"
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons what_0 ErlangEmptyList]
  in ErlangTuple [tup_el_1, tup_el_4]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "at"), ann_0])] =
  let    tup_el_1 = erlps__pos__1 [ann_0]
  in let arg_4 = toErl "at ~s\n"
  in let head_6 = erlps__pp_loc__1 [ann_0]
  in let
    tup_el_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons head_6 ErlangEmptyList]
  in ErlangTuple [tup_el_1, tup_el_3]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "check_typesig"),
                                 name_0, inferred_1, given_2])]
  =
  let    tup_el_3 = erlps__pos__1 [given_2]
  in let
    arg_6 =
      toErl
        "when checking the definition of ~s (at ~s)\n  inferred type: ~s\n  given type:    ~s\n"
  in let head_10 = erlps__pp_loc__1 [given_2]
  in let arg_14 = erlps__instantiate__1 [inferred_1]
  in let head_13 = erlps__pp__1 [arg_14]
  in let arg_18 = erlps__instantiate__1 [given_2]
  in let head_17 = erlps__pp__1 [arg_18]
  in let
    tup_el_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_6,
         ErlangCons name_0
           (ErlangCons head_10
              (ErlangCons head_13 (ErlangCons head_17 ErlangEmptyList)))]
  in ErlangTuple [tup_el_3, tup_el_5]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "infer_app"), fun_0,
                                 namedargs_1, args_2, inferred0_3,
                                 argtypes0_4])]
  =
  let    inferred_6 = erlps__instantiate__1 [inferred0_3]
  in let argtypes_8 = erlps__instantiate__1 [argtypes0_4]
  in let tup_el_9 = erlps__pos__1 [fun_0]
  in let
    arg_12 =
      toErl
        "when checking the application at ~s of\n~s\nto arguments\n~s"
  in let head_14 = erlps__pp_loc__1 [fun_0]
  in let arg_18 = toErl "  "
  in let head_17 = erlps__pp_typed__3 [arg_18, fun_0, inferred_6]
  in let
    lop_23 =
      flmap
        (\ lc_26 ->
           let    arg_29 = toErl "  "
           in let head_28 = erlps__pp_expr__2 [arg_29, lc_26]
           in let head_32 = toErl "\n"
           in
             ErlangCons
               (ErlangCons head_28 (ErlangCons head_32 ErlangEmptyList))
               ErlangEmptyList)
        namedargs_1
  in let
    lcSrc_35 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [args_2, argtypes_8]
  in let
    rop_34 =
      flmap
        (\ lc_40 ->
           case lc_40 of
             (ErlangTuple [arg_38, argt_39]) ->
               let    arg_43 = toErl "  "
               in let head_42 = erlps__pp_typed__3 [arg_43, arg_38, argt_39]
               in let head_47 = toErl "\n"
               in
                 ErlangCons
                   (ErlangCons head_42 (ErlangCons head_47 ErlangEmptyList))
                   ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_35
  in let head_22 = BIF.erlang__op_append [lop_23, rop_34]
  in let
    tup_el_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_12,
         ErlangCons head_14
           (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
  in ErlangTuple [tup_el_9, tup_el_11]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "field_constraint"),
                                 fieldtype0_0, inferredtype0_1, fld_2])]
  =
  let    fieldtype_4 = erlps__instantiate__1 [fieldtype0_0]
  in let inferredtype_6 = erlps__instantiate__1 [inferredtype0_1]
  in let tup_el_7 = erlps__pos__1 [fld_2]
  in let
    tup_el_9 =
      case fld_2 of
        (ErlangTuple [(ErlangAtom "var_args"), _ann_11, _fun_12]) ->
          let   
            arg_13 =
              toErl
                "when checking contract construction of type\n~s (at ~s)\nagainst the expected type\n~s\n"
          in let arg_16 = toErl "  "
          in let head_15 = erlps__pp_type__2 [arg_16, fieldtype_4]
          in let head_19 = erlps__pp_loc__1 [fld_2]
          in let arg_23 = toErl "  "
          in let head_22 = erlps__pp_type__2 [arg_23, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_13,
               ErlangCons head_15
                 (ErlangCons head_19 (ErlangCons head_22 ErlangEmptyList))]
        (ErlangTuple [(ErlangAtom "field"), _ann_26, lv_27, id_28,
                      e_29]) ->
          let   
            arg_30 =
              toErl
                "when checking the assignment of the field\n~s (at ~s)\nto the old value ~s and the new value\n~s\n"
          in let arg_33 = toErl "  "
          in let
            arg_34 =
              ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_27]
          in let head_32 = erlps__pp_typed__3 [arg_33, arg_34, fieldtype_4]
          in let head_40 = erlps__pp_loc__1 [fld_2]
          in let head_43 = erlps__pp__1 [id_28]
          in let arg_47 = toErl "  "
          in let
            head_46 = erlps__pp_typed__3 [arg_47, e_29, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_30,
               ErlangCons head_32
                 (ErlangCons head_40
                    (ErlangCons head_43 (ErlangCons head_46 ErlangEmptyList)))]
        (ErlangTuple [(ErlangAtom "field"), _ann_51, lv_52, e_53]) ->
          let   
            arg_54 =
              toErl
                "when checking the assignment of the field\n~s (at ~s)\nto the value\n~s\n"
          in let arg_57 = toErl "  "
          in let
            arg_58 =
              ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_52]
          in let head_56 = erlps__pp_typed__3 [arg_57, arg_58, fieldtype_4]
          in let head_64 = erlps__pp_loc__1 [fld_2]
          in let arg_68 = toErl "  "
          in let
            head_67 = erlps__pp_typed__3 [arg_68, e_53, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_54,
               ErlangCons head_56
                 (ErlangCons head_64 (ErlangCons head_67 ErlangEmptyList))]
        (ErlangTuple [(ErlangAtom "proj"), _ann_72, _rec_73, _fld_74]) ->
          let   
            arg_75 =
              toErl
                "when checking the record projection at ~s\n~s\nagainst the expected type\n~s\n"
          in let head_77 = erlps__pp_loc__1 [fld_2]
          in let arg_81 = toErl "  "
          in let head_80 = erlps__pp_typed__3 [arg_81, fld_2, fieldtype_4]
          in let arg_86 = toErl "  "
          in let head_85 = erlps__pp_type__2 [arg_86, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_75,
               ErlangCons head_77
                 (ErlangCons head_80 (ErlangCons head_85 ErlangEmptyList))]
        something_else -> EXC.case_clause something_else
  in ErlangTuple [tup_el_7, tup_el_9]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "record_constraint"),
                                 rectype0_0, inferredtype0_1, fld_2])]
  =
  let    rectype_4 = erlps__instantiate__1 [rectype0_0]
  in let inferredtype_6 = erlps__instantiate__1 [inferredtype0_1]
  in let matchExpr_10 = erlps__pp_why_record__1 [fld_2]
  in
    case matchExpr_10 of
      (ErlangTuple [pos_8, whyrec_9]) ->
        case fld_2 of
          (ErlangTuple [(ErlangAtom "var_args"), _ann_12, _fun_13]) ->
            let   
              arg_16 =
                toErl
                  "when checking that contract construction of type\n~s\n~s\nmatches the expected type\n~s\n"
            in let arg_19 = toErl "  "
            in let head_18 = erlps__pp_type__2 [arg_19, rectype_4]
            in let arg_25 = toErl "  "
            in let head_24 = erlps__pp_type__2 [arg_25, inferredtype_6]
            in let
              tup_el_15 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_16,
                   ErlangCons head_18
                     (ErlangCons whyrec_9 (ErlangCons head_24 ErlangEmptyList))]
            in ErlangTuple [pos_8, tup_el_15]
          (ErlangTuple [(ErlangAtom "field"), _ann_28, _lv_29, _id_30,
                        _e_31]) ->
            let   
              arg_34 =
                toErl
                  "when checking that the record type\n~s\n~s\nmatches the expected type\n~s\n"
            in let arg_37 = toErl "  "
            in let head_36 = erlps__pp_type__2 [arg_37, rectype_4]
            in let arg_43 = toErl "  "
            in let head_42 = erlps__pp_type__2 [arg_43, inferredtype_6]
            in let
              tup_el_33 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_34,
                   ErlangCons head_36
                     (ErlangCons whyrec_9 (ErlangCons head_42 ErlangEmptyList))]
            in ErlangTuple [pos_8, tup_el_33]
          (ErlangTuple [(ErlangAtom "field"), _ann_46, _lv_47, _e_48]) ->
            let   
              arg_51 =
                toErl
                  "when checking that the record type\n~s\n~s\nmatches the expected type\n~s\n"
            in let arg_54 = toErl "  "
            in let head_53 = erlps__pp_type__2 [arg_54, rectype_4]
            in let arg_60 = toErl "  "
            in let head_59 = erlps__pp_type__2 [arg_60, inferredtype_6]
            in let
              tup_el_50 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_51,
                   ErlangCons head_53
                     (ErlangCons whyrec_9 (ErlangCons head_59 ErlangEmptyList))]
            in ErlangTuple [pos_8, tup_el_50]
          (ErlangTuple [(ErlangAtom "proj"), _ann_63, rec_64,
                        _fldname_65]) ->
            let    tup_el_66 = erlps__pos__1 [rec_64]
            in let
              arg_69 =
                toErl
                  "when checking that the expression\n~s (at ~s)\nhas type\n~s\n~s\n"
            in let arg_72 = toErl "  "
            in let
              head_71 = erlps__pp_typed__3 [arg_72, rec_64, inferredtype_6]
            in let head_76 = erlps__pp_loc__1 [rec_64]
            in let arg_80 = toErl "  "
            in let head_79 = erlps__pp_type__2 [arg_80, rectype_4]
            in let
              tup_el_68 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_69,
                   ErlangCons head_71
                     (ErlangCons head_76
                        (ErlangCons head_79
                           (ErlangCons whyrec_9 ErlangEmptyList)))]
            in ErlangTuple [tup_el_66, tup_el_68]
          something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_10
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "if_branches"),
                                 then_0, thentype0_1, else_2, elsetype0_3])]
  =
  let    arg_4 = ErlangTuple [thentype0_1, elsetype0_3]
  in let matchExpr_9 = erlps__instantiate__1 [arg_4]
  in
    case matchExpr_9 of
      (ErlangTuple [thentype_7, elsetype_8]) ->
        let    head_10 = ErlangTuple [then_0, thentype_7]
        in let lcSrc_14 = erlps__if_branches__1 [else_2]
        in let
          tail_13 =
            flmap
              (\ lc_17 ->
                 let lcRet_18 = ErlangTuple [lc_17, elsetype_8]
                 in ErlangCons lcRet_18 ErlangEmptyList)
              lcSrc_14
        in let arg_24 = toErl 1
        in let arg_25 = BIF.erlang__hd__1 [ErlangCons head_10 tail_13]
        in let arg_23 = BIF.erlang__element__2 [arg_24, arg_25]
        in let tup_el_22 = erlps__pos__1 [arg_23]
        in let
          arg_28 = toErl "when comparing the types of the if-branches\n~s"
        in let
          head_30 =
            flmap
              (\ lc_34 ->
                 case lc_34 of
                   (ErlangTuple [b_32, btype_33]) ->
                     let    arg_36 = toErl "~s (at ~s)\n"
                     in let arg_39 = toErl "  - "
                     in let
                       head_38 = erlps__pp_typed__3 [arg_39, b_32, btype_33]
                     in let head_43 = erlps__pp_loc__1 [b_32]
                     in let
                       lcRet_35 =
                         BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                           [arg_36,
                            ErlangCons head_38
                              (ErlangCons head_43 ErlangEmptyList)]
                     in ErlangCons lcRet_35 ErlangEmptyList
                   _ -> ErlangEmptyList)
              (ErlangCons head_10 tail_13)
        in let
          tup_el_27 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_28, ErlangCons head_30 ErlangEmptyList]
        in ErlangTuple [tup_el_22, tup_el_27]
      _ -> EXC.badmatch matchExpr_9
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "case_pat"), pat_0,
                                 pattype0_1, exprtype0_2])]
  =
  let    arg_3 = ErlangTuple [pattype0_1, exprtype0_2]
  in let matchExpr_8 = erlps__instantiate__1 [arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [pattype_6, exprtype_7]) ->
        let    tup_el_9 = erlps__pos__1 [pat_0]
        in let
          arg_12 =
            toErl
              "when checking the type of the pattern at ~s\n~s\nagainst the expected type\n~s\n"
        in let head_14 = erlps__pp_loc__1 [pat_0]
        in let arg_18 = toErl "  "
        in let head_17 = erlps__pp_typed__3 [arg_18, pat_0, pattype_6]
        in let arg_23 = toErl "  "
        in let head_22 = erlps__pp_type__2 [arg_23, exprtype_7]
        in let
          tup_el_11 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_12,
               ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
        in ErlangTuple [tup_el_9, tup_el_11]
      _ -> EXC.badmatch matchExpr_8
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "check_expr"),
                                 expr_0, inferred0_1, expected0_2])]
  =
  let    arg_3 = ErlangTuple [inferred0_1, expected0_2]
  in let matchExpr_8 = erlps__instantiate__1 [arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [inferred_6, expected_7]) ->
        let    tup_el_9 = erlps__pos__1 [expr_0]
        in let
          arg_12 =
            toErl
              "when checking the type of the expression at ~s\n~s\nagainst the expected type\n~s\n"
        in let head_14 = erlps__pp_loc__1 [expr_0]
        in let arg_18 = toErl "  "
        in let head_17 = erlps__pp_typed__3 [arg_18, expr_0, inferred_6]
        in let arg_23 = toErl "  "
        in let head_22 = erlps__pp_type__2 [arg_23, expected_7]
        in let
          tup_el_11 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_12,
               ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
        in ErlangTuple [tup_el_9, tup_el_11]
      _ -> EXC.badmatch matchExpr_8
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "checking_init_type"),
                                 ann_0])]
  =
  let    tup_el_1 = erlps__pos__1 [ann_0]
  in let
    arg_4 =
      toErl
        "when checking that \'init\' returns a value of type \'state\' at ~s\n"
  in let head_6 = erlps__pp_loc__1 [ann_0]
  in let
    tup_el_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons head_6 ErlangEmptyList]
  in ErlangTuple [tup_el_1, tup_el_3]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "list_comp"),
                                 bindexpr_0, inferred0_1, expected0_2])]
  =
  let    arg_3 = ErlangTuple [inferred0_1, expected0_2]
  in let matchExpr_8 = erlps__instantiate__1 [arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [inferred_6, expected_7]) ->
        let    tup_el_9 = erlps__pos__1 [bindexpr_0]
        in let
          arg_12 =
            toErl
              "when checking rvalue of list comprehension binding at ~s\n~s\nagainst type \n~s\n"
        in let head_14 = erlps__pp_loc__1 [bindexpr_0]
        in let arg_18 = toErl "  "
        in let
          head_17 = erlps__pp_typed__3 [arg_18, bindexpr_0, inferred_6]
        in let arg_23 = toErl "  "
        in let head_22 = erlps__pp_type__2 [arg_23, expected_7]
        in let
          tup_el_11 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_12,
               ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
        in ErlangTuple [tup_el_9, tup_el_11]
      _ -> EXC.badmatch matchExpr_8
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "check_named_arg_constraint"),
                                 c_0])]
  =
  let
    arg_4 =
      case c_0 of
        (ErlangTuple arr_3) | (DM.Just field_2) <- (arr_3 DA.!! 2) ->
          field_2
        _ -> EXC.badrecord (ErlangAtom "named_argument_constraint")
  in
    case arg_4 of
      (ErlangTuple [(ErlangAtom "id"), _, name_5]) ->
        let   
          lcSrc_7 =
            case c_0 of
              (ErlangTuple arr_10) | (DM.Just field_9) <- (arr_10 DA.!! 1) ->
                field_9
              _ -> EXC.badrecord (ErlangAtom "named_argument_constraint")
        in let
          matchExpr_19 =
            flmap
              (\ lc_13 ->
                 case lc_13 of
                   (ErlangTuple [(ErlangAtom "named_arg_t"), _,
                                 (ErlangTuple [(ErlangAtom "id"), _, name1_11]),
                                 type_12, _]) ->
                     let cond_14 = BIF.erlang__op_eq [name1_11, name_5]
                     in
                       case cond_14 of
                         (ErlangAtom "true") ->
                           ErlangCons type_12 ErlangEmptyList
                         _ -> ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_7
        in
          case matchExpr_19 of
            (ErlangCons type_18 _) ->
              let   
                arg_20 =
                  toErl
                    "when checking named argument\n~s\nagainst inferred type\n~s"
              in let arg_23 = toErl "  "
              in let head_22 = erlps__pp_typed__3 [arg_23, arg_4, type_18]
              in let arg_28 = toErl "  "
              in let
                arg_29 =
                  case c_0 of
                    (ErlangTuple arr_32) | (DM.Just field_31) <-
                                             (arr_32 DA.!! 3) ->
                      field_31
                    _ -> EXC.badrecord (ErlangAtom "named_argument_constraint")
              in let head_27 = erlps__pp_type__2 [arg_28, arg_29]
              in let
                err_34 =
                  BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                    [arg_20,
                     ErlangCons head_22 (ErlangCons head_27 ErlangEmptyList)]
              in let tup_el_35 = erlps__pos__1 [arg_4]
              in ErlangTuple [tup_el_35, err_34]
            _ -> EXC.badmatch matchExpr_19
      _ -> EXC.badmatch arg_4
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "checking_init_args"),
                                 ann_0, con0_1, argtypes0_2])]
  =
  let    con_4 = erlps__instantiate__1 [con0_1]
  in let argtypes_6 = erlps__instantiate__1 [argtypes0_2]
  in let tup_el_7 = erlps__pos__1 [ann_0]
  in let
    arg_10 =
      toErl
        "when checking arguments of ~s\'s init entrypoint to match\n(~s)"
  in let head_12 = erlps__pp_type__1 [con_4]
  in let
    arg_16 =
      flmap
        (\ lc_19 ->
           let lcRet_20 = erlps__pp_type__1 [lc_19]
           in ErlangCons lcRet_20 ErlangEmptyList)
        argtypes_6
  in let arg_22 = toErl ", "
  in let
    head_15 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_16, arg_22]
  in let
    tup_el_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_10, ErlangCons head_12 (ErlangCons head_15 ErlangEmptyList)]
  in ErlangTuple [tup_el_7, tup_el_9]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "return_contract"),
                                 app_0, con0_1])]
  =
  let    con_3 = erlps__instantiate__1 [con0_1]
  in let tup_el_4 = erlps__pos__1 [app_0]
  in let
    arg_7 =
      toErl
        "when checking that expression returns contract of type\n~s"
  in let arg_10 = toErl "  "
  in let head_9 = erlps__pp_type__2 [arg_10, con_3]
  in let
    tup_el_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_7, ErlangCons head_9 ErlangEmptyList]
  in ErlangTuple [tup_el_4, tup_el_6]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "arg_name"), id1_0,
                                 id2_1, when_2])]
  =
  let matchExpr_6 = erlps__pp_when__1 [when_2]
  in
    case matchExpr_6 of
      (ErlangTuple [pos_4, ctx_5]) ->
        let   
          arg_9 =
            toErl "when unifying names of named arguments: ~s and ~s\n~s"
        in let head_11 = erlps__pp_expr__1 [id1_0]
        in let head_14 = erlps__pp_expr__1 [id2_1]
        in let
          tup_el_8 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_9,
               ErlangCons head_11
                 (ErlangCons head_14 (ErlangCons ctx_5 ErlangEmptyList))]
        in ErlangTuple [pos_4, tup_el_8]
      _ -> EXC.badmatch matchExpr_6
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "var_args"), ann_0,
                                 fun_1])]
  =
  let    tup_el_2 = erlps__pos__1 [ann_0]
  in let
    arg_5 =
      toErl "when resolving arguments of variadic function\n~s\n"
  in let arg_8 = toErl "  "
  in let head_7 = erlps__pp_expr__2 [arg_8, fun_1]
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons head_7 ErlangEmptyList]
  in ErlangTuple [tup_el_2, tup_el_4]
erlps__pp_when__1 [(ErlangAtom "unknown")] =
  let    arg_1 = toErl 0
  in let arg_2 = toErl 0
  in let tup_el_0 = erlps__pos__2 [arg_1, arg_2]
  in let tup_el_3 = toErl ""
  in ErlangTuple [tup_el_0, tup_el_3]
erlps__pp_when__1 [arg_4] = EXC.function_clause unit
erlps__pp_when__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_when__1) args

erlps__pp_why_record__1 :: ErlangFun
erlps__pp_why_record__1 [(ErlangTuple [(ErlangAtom "var_args"),
                                       ann_0, fun_1])]
  =
  let    tup_el_2 = erlps__pos__1 [ann_0]
  in let
    arg_5 =
      toErl "arising from resolution of variadic function ~s (at ~s)"
  in let head_7 = erlps__pp_expr__1 [fun_1]
  in let head_10 = erlps__pp_loc__1 [fun_1]
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList)]
  in ErlangTuple [tup_el_2, tup_el_4]
erlps__pp_why_record__1 [fld_3@(ErlangTuple [(ErlangAtom "field"),
                                             _ann_0, lv_1, _e_2])]
  =
  let    tup_el_4 = erlps__pos__1 [fld_3]
  in let
    arg_7 =
      toErl "arising from an assignment of the field ~s (at ~s)"
  in let
    arg_10 = ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_1]
  in let head_9 = erlps__pp_expr__1 [arg_10]
  in let head_15 = erlps__pp_loc__1 [fld_3]
  in let
    tup_el_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_7, ErlangCons head_9 (ErlangCons head_15 ErlangEmptyList)]
  in ErlangTuple [tup_el_4, tup_el_6]
erlps__pp_why_record__1 [fld_4@(ErlangTuple [(ErlangAtom "field"),
                                             _ann_0, lv_1, _alias_2, _e_3])]
  =
  let    tup_el_5 = erlps__pos__1 [fld_4]
  in let
    arg_8 =
      toErl "arising from an assignment of the field ~s (at ~s)"
  in let
    arg_11 = ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_1]
  in let head_10 = erlps__pp_expr__1 [arg_11]
  in let head_16 = erlps__pp_loc__1 [fld_4]
  in let
    tup_el_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_8, ErlangCons head_10 (ErlangCons head_16 ErlangEmptyList)]
  in ErlangTuple [tup_el_5, tup_el_7]
erlps__pp_why_record__1 [(ErlangTuple [(ErlangAtom "proj"),
                                       _ann_0, rec_1, fldname_2])]
  =
  let    tup_el_3 = erlps__pos__1 [rec_1]
  in let
    arg_6 =
      toErl "arising from the projection of the field ~s (at ~s)"
  in let head_8 = erlps__pp__1 [fldname_2]
  in let head_11 = erlps__pp_loc__1 [rec_1]
  in let
    tup_el_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_6, ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList)]
  in ErlangTuple [tup_el_3, tup_el_5]
erlps__pp_why_record__1 [arg_14] = EXC.function_clause unit
erlps__pp_why_record__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_why_record__1) args

erlps__if_branches__1 :: ErlangFun
erlps__if_branches__1 [if_3@(ErlangTuple [(ErlangAtom "if"),
                                          ann_0, _, then_1, else_2])]
  =
  let
    case_4 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [ErlangAtom "format", ann_0]
  in
    case case_4 of
      (ErlangAtom "elif") ->
        let tail_8 = erlps__if_branches__1 [else_2]
        in ErlangCons then_1 tail_8
      _ -> ErlangCons if_3 ErlangEmptyList
erlps__if_branches__1 [e_0] = ErlangCons e_0 ErlangEmptyList
erlps__if_branches__1 [arg_3] = EXC.function_clause unit
erlps__if_branches__1 args =
  EXC.badarity (ErlangFun 1 erlps__if_branches__1) args

erlps__pp_typed__3 :: ErlangFun
erlps__pp_typed__3 [label_0, e_1,
                    t_2@(ErlangTuple [(ErlangAtom "type_sig"), _, _, _, _, _])]
  =
  let arg_5 = erlps__typesig_to_fun_t__1 [t_2]
  in erlps__pp_typed__3 [label_0, e_1, arg_5]
erlps__pp_typed__3 [label_0,
                    (ErlangTuple [(ErlangAtom "typed"), _, expr_1, _]), type_2]
  =
  erlps__pp_typed__3 [label_0, expr_1, type_2]
erlps__pp_typed__3 [label_0, expr_1, type_2] =
  let
    arg_4 =
      ErlangTuple [ErlangAtom "typed", ErlangEmptyList, expr_1, type_2]
  in erlps__pp_expr__2 [label_0, arg_4]
erlps__pp_typed__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__pp_typed__3 args =
  EXC.badarity (ErlangFun 3 erlps__pp_typed__3) args

erlps__pp_expr__1 :: ErlangFun
erlps__pp_expr__1 [expr_0] =
  let arg_1 = toErl ""
  in erlps__pp_expr__2 [arg_1, expr_0]
erlps__pp_expr__1 [arg_3] = EXC.function_clause unit
erlps__pp_expr__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_expr__1) args

erlps__pp_expr__2 :: ErlangFun
erlps__pp_expr__2 [label_0, expr_1] =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [label_0]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__expr__2"
        [expr_1,
         ErlangCons (ErlangAtom "show_generated") ErlangEmptyList]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Prettypr" "erlps__beside__2"
        [arg_3, arg_5]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_2]
erlps__pp_expr__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__pp_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_expr__2) args

erlps__pp_type__1 :: ErlangFun
erlps__pp_type__1 [type_0] =
  let arg_1 = toErl ""
  in erlps__pp_type__2 [arg_1, type_0]
erlps__pp_type__1 [arg_3] = EXC.function_clause unit
erlps__pp_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_type__1) args

erlps__pp_type__2 :: ErlangFun
erlps__pp_type__2 [label_0, type_1] =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [label_0]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__type__2"
        [type_1,
         ErlangCons (ErlangAtom "show_generated") ErlangEmptyList]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Prettypr" "erlps__beside__2"
        [arg_3, arg_5]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_2]
erlps__pp_type__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__pp_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_type__2) args

erlps__src_file__1 :: ErlangFun
erlps__src_file__1 [t_0] =
  BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
    [ErlangAtom "file", t_0, ErlangAtom "no_file"]
erlps__src_file__1 [arg_4] = EXC.function_clause unit
erlps__src_file__1 args =
  EXC.badarity (ErlangFun 1 erlps__src_file__1) args

erlps__line_number__1 :: ErlangFun
erlps__line_number__1 [t_0] =
  let arg_3 = toErl 0
  in
    BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
      [ErlangAtom "line", t_0, arg_3]
erlps__line_number__1 [arg_4] = EXC.function_clause unit
erlps__line_number__1 args =
  EXC.badarity (ErlangFun 1 erlps__line_number__1) args

erlps__column_number__1 :: ErlangFun
erlps__column_number__1 [t_0] =
  let arg_3 = toErl 0
  in
    BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
      [ErlangAtom "col", t_0, arg_3]
erlps__column_number__1 [arg_4] = EXC.function_clause unit
erlps__column_number__1 args =
  EXC.badarity (ErlangFun 1 erlps__column_number__1) args

erlps__pos__1 :: ErlangFun
erlps__pos__1 [t_0] =
  let    arg_1 = erlps__src_file__1 [t_0]
  in let arg_3 = erlps__line_number__1 [t_0]
  in let arg_5 = erlps__column_number__1 [t_0]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__3"
      [arg_1, arg_3, arg_5]
erlps__pos__1 [arg_7] = EXC.function_clause unit
erlps__pos__1 args =
  EXC.badarity (ErlangFun 1 erlps__pos__1) args

erlps__pos__2 :: ErlangFun
erlps__pos__2 [l_0, c_1] =
  BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__2" [l_0, c_1]
erlps__pos__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__pos__2 args =
  EXC.badarity (ErlangFun 2 erlps__pos__2) args

erlps__loc__1 :: ErlangFun
erlps__loc__1 [t_0] =
  let    tup_el_1 = erlps__line_number__1 [t_0]
  in let tup_el_3 = erlps__column_number__1 [t_0]
  in ErlangTuple [tup_el_1, tup_el_3]
erlps__loc__1 [arg_5] = EXC.function_clause unit
erlps__loc__1 args =
  EXC.badarity (ErlangFun 1 erlps__loc__1) args

erlps__pp_loc__1 :: ErlangFun
erlps__pp_loc__1 [t_0] =
  let matchExpr_4 = erlps__loc__1 [t_0]
  in
    case matchExpr_4 of
      (ErlangTuple [line_2, col_3]) ->
        let case_5 = ErlangTuple [line_2, col_3]
        in
          case case_5 of
            (ErlangTuple [(ErlangInt num_8), (ErlangInt num_9)]) | (ErlangInt
                                                                      num_8) ==
                                                                     (toErl 0)
                                                                 , (ErlangInt
                                                                      num_9) ==
                                                                     (toErl
                                                                        0) ->
              toErl "(builtin location)"
            _ ->
              let arg_10 = toErl "line ~p, column ~p"
              in
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_10, ErlangCons line_2 (ErlangCons col_3 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_4
erlps__pp_loc__1 [arg_16] = EXC.function_clause unit
erlps__pp_loc__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_loc__1) args

erlps__plural__3 :: ErlangFun
erlps__plural__3 [no_0, _yes_1, (ErlangCons _ (ErlangEmptyList))]
  =
  no_0
erlps__plural__3 [_no_0, yes_1, _] = yes_1
erlps__plural__3 [arg_2, arg_3, arg_4] = EXC.function_clause unit
erlps__plural__3 args =
  EXC.badarity (ErlangFun 3 erlps__plural__3) args

erlps__pp__1 :: ErlangFun
erlps__pp__1 [t_0@(ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                _, _])]
  =
  let arg_1 = erlps__typesig_to_fun_t__1 [t_0]
  in erlps__pp__1 [arg_1]
erlps__pp__1 [(ErlangEmptyList)] = toErl ""
erlps__pp__1 [(ErlangCons t_0 (ErlangEmptyList))] =
  erlps__pp__1 [t_0]
erlps__pp__1 [(ErlangCons t_0 ts_1)] =
  let    head_2 = erlps__pp__1 [t_0]
  in let head_5 = toErl ", "
  in let tail_6 = erlps__pp__1 [ts_1]
  in ErlangCons head_2 (ErlangCons head_5 tail_6)
erlps__pp__1 [(ErlangTuple [(ErlangAtom "id"), _, name_0])] =
  name_0
erlps__pp__1 [(ErlangTuple [(ErlangAtom "qid"), _, name_0])] =
  let arg_2 = toErl "."
  in
    BIF.do_remote_fun_call "String" "erlps__join__2" [name_0, arg_2]
erlps__pp__1 [(ErlangTuple [(ErlangAtom "con"), _, name_0])] =
  name_0
erlps__pp__1 [(ErlangTuple [(ErlangAtom "qcon"), _, name_0])] =
  let arg_2 = toErl "."
  in
    BIF.do_remote_fun_call "String" "erlps__join__2" [name_0, arg_2]
erlps__pp__1 [(ErlangTuple [(ErlangAtom "uvar"), _, ref_0])] =
  let    head_1 = toErl "?u"
  in let arg_5 = toErl 16384
  in let arg_3 = BIF.erlang__phash2__2 [ref_0, arg_5]
  in let tail_2 = BIF.erlang__integer_to_list__1 [arg_3]
  in ErlangCons head_1 tail_2
erlps__pp__1 [(ErlangTuple [(ErlangAtom "tvar"), _, name_0])] =
  name_0
erlps__pp__1 [(ErlangTuple [(ErlangAtom "if_t"), _, id_0, then_1,
                            else_2])]
  =
  let    head_3 = toErl "if("
  in let
    head_5 =
      erlps__pp__1
        [ErlangCons id_0
           (ErlangCons then_1 (ErlangCons else_2 ErlangEmptyList))]
  in let head_14 = toErl ")"
  in
    ErlangCons head_3
      (ErlangCons head_5 (ErlangCons head_14 ErlangEmptyList))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "tuple_t"), _,
                            (ErlangEmptyList)])]
  =
  toErl "unit"
erlps__pp__1 [(ErlangTuple [(ErlangAtom "tuple_t"), _, cpts_0])]
  =
  let    head_1 = toErl "("
  in let arg_5 = ErlangFun 1 erlps__pp__1
  in let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_5, cpts_0]
  in let arg_7 = toErl " * "
  in let
    head_3 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_4, arg_7]
  in let head_9 = toErl ")"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _,
                            (ErlangAtom "any")])]
  =
  toErl "bytes(_)"
erlps__pp__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _, len_0])] =
  let    head_1 = toErl "bytes("
  in let head_3 = BIF.erlang__integer_to_list__1 [len_0]
  in let head_6 = toErl ")"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "app_t"), _, t_0,
                            (ErlangEmptyList)])]
  =
  erlps__pp__1 [t_0]
erlps__pp__1 [(ErlangTuple [(ErlangAtom "app_t"), _, type_0,
                            args_1])]
  =
  let    head_2 = erlps__pp__1 [type_0]
  in let head_5 = toErl "("
  in let head_7 = erlps__pp__1 [args_1]
  in let head_10 = toErl ")"
  in
    ErlangCons head_2
      (ErlangCons head_5
         (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList)))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "named_arg_t"), _,
                            name_0, type_1, _default_2])]
  =
  let    head_3 = erlps__pp__1 [name_0]
  in let head_6 = toErl " : "
  in let head_8 = erlps__pp__1 [type_1]
  in
    ErlangCons head_3
      (ErlangCons head_6 (ErlangCons head_8 ErlangEmptyList))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "fun_t"), _,
                            named_0@(ErlangTuple [(ErlangAtom "uvar"), _, _]),
                            as_1, b_2])]
  =
  let    head_3 = toErl "("
  in let head_5 = erlps__pp__1 [named_0]
  in let head_8 = toErl " | "
  in let head_10 = erlps__pp__1 [as_1]
  in let head_13 = toErl ") => "
  in let head_15 = erlps__pp__1 [b_2]
  in
    ErlangCons head_3
      (ErlangCons head_5
         (ErlangCons head_8
            (ErlangCons head_10
               (ErlangCons head_13 (ErlangCons head_15 ErlangEmptyList)))))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "fun_t"), _, named_0,
                            as_1, b_2])]
  | isEList named_0 =
  let    head_3 = toErl "("
  in let arg_6 = BIF.erlang__op_append [named_0, as_1]
  in let head_5 = erlps__pp__1 [arg_6]
  in let head_10 = toErl ") => "
  in let head_12 = erlps__pp__1 [b_2]
  in
    ErlangCons head_3
      (ErlangCons head_5
         (ErlangCons head_10 (ErlangCons head_12 ErlangEmptyList)))
erlps__pp__1 [other_0] =
  let arg_1 = toErl "~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons other_0 ErlangEmptyList]
erlps__pp__1 [arg_5] = EXC.function_clause unit
erlps__pp__1 args = EXC.badarity (ErlangFun 1 erlps__pp__1) args

erlps__desugar__1 :: ErlangFun
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "record"), ann_0,
                                 rec_1, updates_2])]
  =
  let tup_el_6 = erlps__desugar_updates__1 [updates_2]
  in ErlangTuple [ErlangAtom "record", ann_0, rec_1, tup_el_6]
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "map"), ann_0,
                                 map_1, updates_2])]
  =
  let tup_el_6 = erlps__desugar_updates__1 [updates_2]
  in ErlangTuple [ErlangAtom "map", ann_0, map_1, tup_el_6]
erlps__desugar__1 [(ErlangCons h_0 t_1)] =
  let    head_2 = erlps__desugar__1 [h_0]
  in let tail_4 = erlps__desugar__1 [t_1]
  in ErlangCons head_2 tail_4
erlps__desugar__1 [t_0] | isETuple t_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [t_0]
  in let arg_1 = erlps__desugar__1 [arg_2]
  in BIF.erlang__list_to_tuple__1 [arg_1]
erlps__desugar__1 [x_0] = x_0
erlps__desugar__1 [arg_1] = EXC.function_clause unit
erlps__desugar__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar__1) args

erlps__desugar_updates__1 :: ErlangFun
erlps__desugar_updates__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__desugar_updates__1 [(ErlangCons upd_0 updates_1)] =
  let matchExpr_6 = erlps__update_key__1 [upd_0]
  in
    case matchExpr_6 of
      (ErlangTuple [key_3, makefield_4, rest_5]) ->
        let matchExpr_11 = erlps__updates_key__2 [key_3, updates_1]
        in
          case matchExpr_11 of
            (ErlangTuple [more_9, updates1_10]) ->
              let   
                arg_13 =
                  flmap
                    (\ lc_17 ->
                       case lc_17 of
                         (ErlangEmptyList) ->
                           ErlangCons ErlangEmptyList ErlangEmptyList
                         _ -> ErlangEmptyList)
                    (ErlangCons rest_5 more_9)
              in let case_12 = BIF.erlang__length__1 [arg_13]
              in let
                _ =
                  case case_12 of
                    n_19 | weakGt n_19 (toErl 1) ->
                      let
                        arg_20 =
                          ErlangTuple
                            [ErlangAtom "conflicting_updates_for_field", upd_0,
                             key_3]
                      in erlps__type_error__1 [arg_20]
                    _ -> ErlangAtom "ok"
              in let
                arg_25 =
                  BIF.do_remote_fun_call "Lists" "erlps__append__1"
                    [ErlangCons rest_5 more_9]
              in let
                head_24 =
                  BIF.erlang__apply__2
                    [makefield_4, ErlangCons arg_25 ErlangEmptyList]
              in let tail_30 = erlps__desugar_updates__1 [updates1_10]
              in ErlangCons head_24 tail_30
            _ -> EXC.badmatch matchExpr_11
      _ -> EXC.badmatch matchExpr_6
erlps__desugar_updates__1 [arg_32] = EXC.function_clause unit
erlps__desugar_updates__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar_updates__1) args

erlps__update_key__1 :: ErlangFun
erlps__update_key__1 [fld_1@(ErlangTuple [(ErlangAtom "field"),
                                          _,
                                          (ErlangCons elim_0 (ErlangEmptyList)),
                                          _])]
  =
  let    tup_el_2 = erlps__elim_key__1 [elim_0]
  in let
    tup_el_4 =
      ErlangFun 1
        (let
           lambda_5 [_] = fld_1
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in ErlangTuple [tup_el_2, tup_el_4, ErlangEmptyList]
erlps__update_key__1 [fld_1@(ErlangTuple [(ErlangAtom "field"),
                                          _,
                                          (ErlangCons elim_0 (ErlangEmptyList)),
                                          _, _])]
  =
  let    tup_el_2 = erlps__elim_key__1 [elim_0]
  in let
    tup_el_4 =
      ErlangFun 1
        (let
           lambda_5 [_] = fld_1
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in ErlangTuple [tup_el_2, tup_el_4, ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons p_2@(ErlangTuple [(ErlangAtom "proj"),
                                                                  _,
                                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                name_1])]) rest_3),
                                    value_4])]
  =
  let   
    tup_el_6 =
      ErlangFun 1
        (let
           lambda_7 [flds_9] =
             let    tup_el_18 = toErl "__x"
             in let
               tup_el_15 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_18]
             in let tup_el_25 = toErl "__x"
             in let
               arg_22 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_25]
             in let arg_20 = erlps__map_or_record__3 [ann_0, arg_22, flds_9]
             in let tup_el_19 = erlps__desugar__1 [arg_20]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons p_2 ErlangEmptyList,
                  tup_el_15, tup_el_19]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    head_28 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_3, value_4]
  in
    ErlangTuple
      [name_1, tup_el_6, ErlangCons head_28 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons p_2@(ErlangTuple [(ErlangAtom "proj"),
                                                                  _,
                                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                name_1])]) rest_3),
                                    id_4, value_5])]
  =
  let   
    tup_el_7 =
      ErlangFun 1
        (let
           lambda_8 [flds_10] =
             let    tup_el_19 = toErl "__x"
             in let
               tup_el_16 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_19]
             in let tup_el_26 = toErl "__x"
             in let
               arg_23 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_26]
             in let arg_21 = erlps__map_or_record__3 [ann_0, arg_23, flds_10]
             in let tup_el_20 = erlps__desugar__1 [arg_21]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons p_2 ErlangEmptyList,
                  tup_el_16, tup_el_20]
           lambda_8 [arg_9] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
         in lambda_8)
  in let
    head_29 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_3, id_4, value_5]
  in
    ErlangTuple
      [name_1, tup_el_7, ErlangCons head_29 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _,
                                                                  _]) rest_2),
                                    value_3])]
  =
  let   
    tup_el_5 =
      ErlangFun 1
        (let
           lambda_6 [flds_8] =
             let    tup_el_17 = toErl "__x"
             in let
               tup_el_14 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_17]
             in let tup_el_24 = toErl "__x"
             in let
               arg_21 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_24]
             in let arg_19 = erlps__map_or_record__3 [ann_0, arg_21, flds_8]
             in let tup_el_18 = erlps__desugar__1 [arg_19]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_14, tup_el_18]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    head_27 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, value_3]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_5,
       ErlangCons head_27 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _, _,
                                                                  _]) rest_2),
                                    value_3])]
  =
  let   
    tup_el_5 =
      ErlangFun 1
        (let
           lambda_6 [flds_8] =
             let    tup_el_17 = toErl "__x"
             in let
               tup_el_14 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_17]
             in let tup_el_24 = toErl "__x"
             in let
               arg_21 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_24]
             in let arg_19 = erlps__map_or_record__3 [ann_0, arg_21, flds_8]
             in let tup_el_18 = erlps__desugar__1 [arg_19]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_14, tup_el_18]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    head_27 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, value_3]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_5,
       ErlangCons head_27 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _, _,
                                                                  _]) rest_2),
                                    id_3, value_4])]
  =
  let   
    tup_el_6 =
      ErlangFun 1
        (let
           lambda_7 [flds_9] =
             let    tup_el_18 = toErl "__x"
             in let
               tup_el_15 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_18]
             in let tup_el_25 = toErl "__x"
             in let
               arg_22 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_25]
             in let arg_20 = erlps__map_or_record__3 [ann_0, arg_22, flds_9]
             in let tup_el_19 = erlps__desugar__1 [arg_20]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_15, tup_el_19]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    head_28 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, id_3, value_4]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_6,
       ErlangCons head_28 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _,
                                                                  _]) rest_2),
                                    id_3, value_4])]
  =
  let   
    tup_el_6 =
      ErlangFun 1
        (let
           lambda_7 [flds_9] =
             let    tup_el_18 = toErl "__x"
             in let
               tup_el_15 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_18]
             in let tup_el_25 = toErl "__x"
             in let
               arg_22 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_25]
             in let arg_20 = erlps__map_or_record__3 [ann_0, arg_22, flds_9]
             in let tup_el_19 = erlps__desugar__1 [arg_20]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_15, tup_el_19]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    head_28 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, id_3, value_4]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_6,
       ErlangCons head_28 ErlangEmptyList]
erlps__update_key__1 [arg_35] = EXC.function_clause unit
erlps__update_key__1 args =
  EXC.badarity (ErlangFun 1 erlps__update_key__1) args

erlps__map_or_record__3 :: ErlangFun
erlps__map_or_record__3 [ann_0, val_1,
                         flds_3@(ErlangCons fld_2 _)]
  =
  let    arg_5 = toErl 3
  in let case_4 = BIF.erlang__element__2 [arg_5, fld_2]
  in let
    kind_7 =
      case case_4 of
        (ErlangCons (ErlangTuple [(ErlangAtom "proj"), _, _]) _) ->
          ErlangAtom "record"
        (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), _, _]) _) ->
          ErlangAtom "map"
        (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), _, _, _]) _) ->
          ErlangAtom "map"
        something_else -> EXC.case_clause something_else
  in ErlangTuple [kind_7, ann_0, val_1, flds_3]
erlps__map_or_record__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__map_or_record__3 args =
  EXC.badarity (ErlangFun 3 erlps__map_or_record__3) args

erlps__elim_key__1 :: ErlangFun
erlps__elim_key__1 [(ErlangTuple [(ErlangAtom "proj"), _,
                                  (ErlangTuple [(ErlangAtom "id"), _,
                                                name_0])])]
  =
  name_0
erlps__elim_key__1 [(ErlangTuple [(ErlangAtom "map_get"), _, _,
                                  _])]
  =
  ErlangAtom "map_key"
erlps__elim_key__1 [(ErlangTuple [(ErlangAtom "map_get"), _, _])]
  =
  ErlangAtom "map_key"
erlps__elim_key__1 [arg_0] = EXC.function_clause unit
erlps__elim_key__1 args =
  EXC.badarity (ErlangFun 1 erlps__elim_key__1) args

erlps__updates_key__2 :: ErlangFun
erlps__updates_key__2 [(ErlangAtom "map_key"), updates_0] =
  ErlangTuple [ErlangEmptyList, updates_0]
erlps__updates_key__2 [name_0, updates_1] =
  let   
    xs_18 =
      flmap
        (\ lc_4 ->
           let head_6 = erlps__update_key__1 [lc_4]
           in
             flmap
               (\ lc_11 ->
                  case lc_11 of
                    (ErlangTuple [name1_9, _, rest_10]) ->
                      let    tup_el_14 = BIF.erlang__op_eq [name1_9, name_0]
                      in let lcRet_12 = ErlangTuple [lc_4, tup_el_14, rest_10]
                      in ErlangCons lcRet_12 ErlangEmptyList
                    _ -> ErlangEmptyList)
               (ErlangCons head_6 ErlangEmptyList))
        updates_1
  in let
    updates1_23 =
      flmap
        (\ lc_21 ->
           case lc_21 of
             (ErlangTuple [upd_20, (ErlangAtom "false"), _]) ->
               ErlangCons upd_20 ErlangEmptyList
             _ -> ErlangEmptyList)
        xs_18
  in let
    more_28 =
      flmap
        (\ lc_26 ->
           case lc_26 of
             (ErlangTuple [_, (ErlangAtom "true"), rest_25]) ->
               ErlangCons rest_25 ErlangEmptyList
             _ -> ErlangEmptyList)
        xs_18
  in ErlangTuple [more_28, updates1_23]
erlps__updates_key__2 [arg_31, arg_32] = EXC.function_clause unit
erlps__updates_key__2 args =
  EXC.badarity (ErlangFun 2 erlps__updates_key__2) args

erlps__indexed__2 :: ErlangFun
erlps__indexed__2 [i_0, xs_1] =
  let    rop_7 = BIF.erlang__length__1 [xs_1]
  in let lop_5 = BIF.erlang__op_plus [i_0, rop_7]
  in let rop_9 = toErl 1
  in let arg_4 = BIF.erlang__op_minus [lop_5, rop_9]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [i_0, arg_4]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_2, xs_1]
erlps__indexed__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__indexed__2 args =
  EXC.badarity (ErlangFun 2 erlps__indexed__2) args