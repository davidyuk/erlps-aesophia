module Aeso.Ast.Infer.Types(erlps__infer__1, erlps__infer__2,
                            erlps__unfold_types_in_type__3,
                            erlps__pp_type__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__push_scope__3 :: ErlangFun
erlps__push_scope__3 [kind_0, con_1, env_2] =
  let   
    ann_4 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [con_1]
  in let name_6 = erlps__name__1 [con_1]
  in let
    lop_7 =
      case env_2 of
        (ErlangTuple arr_10) | (DM.Just field_9) <- (arr_10 DA.!! 5) ->
          field_9
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    new_14 =
      BIF.erlang__op_append [lop_7, ErlangCons name_6 ErlangEmptyList]
  in let
    map_18 =
      case env_2 of
        (ErlangTuple arr_21) | (DM.Just field_20) <- (arr_21 DA.!! 1) ->
          field_20
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    val_23 =
      ErlangTuple
        [ErlangAtom "scope", ErlangEmptyList, ErlangEmptyList,
         ErlangAtom "public", kind_0, ann_4]
  in let mapExt_30 = ErlangMap (Map.singleton new_14 val_23)
  in let record_updt_17 = BIF.maps__merge__2 [map_18, mapExt_30]
  in
    case env_2 of
      (ErlangTuple [(ErlangAtom "env"), scopes_32, vars_33,
                    typevars_34, fields_35, namespace_36, in_pattern_37,
                    stateful_38, current_function_39, what_40]) ->
        ErlangTuple
          [ErlangAtom "env", record_updt_17, vars_33, typevars_34,
           fields_35, new_14, in_pattern_37, stateful_38,
           current_function_39, what_40]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__push_scope__3 [arg_41, arg_42, arg_43] =
  EXC.function_clause unit
erlps__push_scope__3 args =
  EXC.badarity (ErlangFun 3 erlps__push_scope__3) args

erlps__pop_scope__1 :: ErlangFun
erlps__pop_scope__1 [env_0] =
  let   
    arg_3 =
      case env_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 5) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    record_updt_2 =
      BIF.do_remote_fun_call "Lists" "erlps__droplast__1" [arg_3]
  in
    case env_0 of
      (ErlangTuple [(ErlangAtom "env"), scopes_7, vars_8, typevars_9,
                    fields_10, namespace_11, in_pattern_12, stateful_13,
                    current_function_14, what_15]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_7, vars_8, typevars_9, fields_10,
           record_updt_2, in_pattern_12, stateful_13, current_function_14,
           what_15]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__pop_scope__1 [arg_16] = EXC.function_clause unit
erlps__pop_scope__1 args =
  EXC.badarity (ErlangFun 1 erlps__pop_scope__1) args

erlps__get_scope__2 :: ErlangFun
erlps__get_scope__2 [(ErlangTuple [(ErlangAtom "env"), scopes_0,
                                   _, _, _, _, _, _, _, _]),
                     name_1]
  =
  BIF.do_remote_fun_call "Maps" "erlps__get__3"
    [name_1, scopes_0, ErlangAtom "false"]
erlps__get_scope__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__get_scope__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_scope__2) args

erlps__on_current_scope__2 :: ErlangFun
erlps__on_current_scope__2 [env_2@(ErlangTuple [(ErlangAtom "env"),
                                                scopes_0, _, _, _, ns_1, _, _,
                                                _, _]),
                            fun_3]
  =
  let    scope_6 = BIF.maps__get__2 [ns_1, scopes_0]
  in let
    val_11 =
      BIF.erlang__apply__2 [fun_3, ErlangCons scope_6 ErlangEmptyList]
  in let mapExt_14 = ErlangMap (Map.singleton ns_1 val_11)
  in let record_updt_8 = BIF.maps__merge__2 [scopes_0, mapExt_14]
  in
    case env_2 of
      (ErlangTuple [(ErlangAtom "env"), scopes_16, vars_17,
                    typevars_18, fields_19, namespace_20, in_pattern_21,
                    stateful_22, current_function_23, what_24]) ->
        ErlangTuple
          [ErlangAtom "env", record_updt_8, vars_17, typevars_18,
           fields_19, namespace_20, in_pattern_21, stateful_22,
           current_function_23, what_24]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__on_current_scope__2 [arg_25, arg_26] =
  EXC.function_clause unit
erlps__on_current_scope__2 args =
  EXC.badarity (ErlangFun 2 erlps__on_current_scope__2) args

erlps__on_scopes__2 :: ErlangFun
erlps__on_scopes__2 [env_1@(ErlangTuple [(ErlangAtom "env"),
                                         scopes_0, _, _, _, _, _, _, _, _]),
                     fun_2]
  =
  let   
    arg_5 =
      ErlangFun 2
        (let
           lambda_6 [_, scope_9] =
             BIF.erlang__apply__2 [fun_2, ErlangCons scope_9 ErlangEmptyList]
           lambda_6 [arg_7, arg_8] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 2 lambda_6) args
         in lambda_6)
  in let
    record_updt_4 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2" [arg_5, scopes_0]
  in
    case env_1 of
      (ErlangTuple [(ErlangAtom "env"), scopes_13, vars_14,
                    typevars_15, fields_16, namespace_17, in_pattern_18,
                    stateful_19, current_function_20, what_21]) ->
        ErlangTuple
          [ErlangAtom "env", record_updt_4, vars_14, typevars_15,
           fields_16, namespace_17, in_pattern_18, stateful_19,
           current_function_20, what_21]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__on_scopes__2 [arg_22, arg_23] = EXC.function_clause unit
erlps__on_scopes__2 args =
  EXC.badarity (ErlangFun 2 erlps__on_scopes__2) args

erlps__bind_var__3 :: ErlangFun
erlps__bind_var__3 [(ErlangTuple [(ErlangAtom "id"), ann_0,
                                  x_1]),
                    t_2, env_3]
  =
  let    tup_el_8 = ErlangTuple [ann_0, t_2]
  in let head_6 = ErlangTuple [x_1, tup_el_8]
  in let
    tail_11 =
      case env_3 of
        (ErlangTuple arr_14) | (DM.Just field_13) <- (arr_14 DA.!! 2) ->
          field_13
        _ -> EXC.badrecord (ErlangAtom "env")
  in
    case env_3 of
      (ErlangTuple [(ErlangAtom "env"), scopes_15, vars_16,
                    typevars_17, fields_18, namespace_19, in_pattern_20,
                    stateful_21, current_function_22, what_23]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_15, ErlangCons head_6 tail_11,
           typevars_17, fields_18, namespace_19, in_pattern_20, stateful_21,
           current_function_22, what_23]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_var__3 [arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__bind_var__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_var__3) args

erlps__bind_vars__2 :: ErlangFun
erlps__bind_vars__2 [(ErlangEmptyList), env_0] = env_0
erlps__bind_vars__2 [(ErlangCons (ErlangTuple [x_0,
                                               t_1]) vars_2),
                     env_3]
  =
  let arg_5 = erlps__bind_var__3 [x_0, t_1, env_3]
  in erlps__bind_vars__2 [vars_2, arg_5]
erlps__bind_vars__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__bind_vars__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_vars__2) args

erlps__bind_tvars__2 :: ErlangFun
erlps__bind_tvars__2 [xs_0, env_1] =
  let
    record_updt_3 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "tvar"), _, x_5]) ->
               ErlangCons x_5 ErlangEmptyList
             _ -> ErlangEmptyList)
        xs_0
  in
    case env_1 of
      (ErlangTuple [(ErlangAtom "env"), scopes_8, vars_9, typevars_10,
                    fields_11, namespace_12, in_pattern_13, stateful_14,
                    current_function_15, what_16]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_8, vars_9, record_updt_3, fields_11,
           namespace_12, in_pattern_13, stateful_14, current_function_15,
           what_16]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_tvars__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__bind_tvars__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_tvars__2) args

erlps__check_tvar__2 :: ErlangFun
erlps__check_tvar__2 [(ErlangTuple [(ErlangAtom "env"), _, _,
                                    tvars_0, _, _, _, _, _, _]),
                      t_2@(ErlangTuple [(ErlangAtom "tvar"), _, x_1])]
  =
  let   
    lop_4 = BIF.erlang__op_eq [tvars_0, ErlangAtom "unrestricted"]
  in let
    case_3 =
      case lop_4 of
        (ErlangAtom "true") -> ErlangAtom "true"
        (ErlangAtom "false") -> BIF.lists__member__2 [x_1, tvars_0]
        _ -> EXC.badarg1 lop_4
  in let
    _ =
      case case_3 of
        (ErlangAtom "true") -> ErlangAtom "ok"
        (ErlangAtom "false") ->
          let arg_9 = ErlangTuple [ErlangAtom "unbound_type", t_2]
          in erlps__type_error__1 [arg_9]
        something_else -> EXC.case_clause something_else
  in t_2
erlps__check_tvar__2 [arg_12, arg_13] = EXC.function_clause unit
erlps__check_tvar__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_tvar__2) args

erlps__bind_fun__3 :: ErlangFun
erlps__bind_fun__3 [x_0, type_1, env_2] =
  let
    case_3 =
      erlps__lookup_env__4
        [env_2, ErlangAtom "term", ErlangEmptyList,
         ErlangCons x_0 ErlangEmptyList]
  in
    case case_3 of
      (ErlangAtom "false") ->
        erlps__force_bind_fun__3 [x_0, type_1, env_2]
      (ErlangTuple [_qid_13, (ErlangTuple [ann1_14, _])]) ->
        let   
          head_21 =
            BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [type_1]
        in let
          arg_15 =
            ErlangTuple
              [ErlangAtom "duplicate_definition", x_0,
               ErlangCons ann1_14 (ErlangCons head_21 ErlangEmptyList)]
        in let _ = erlps__type_error__1 [arg_15]
        in env_2
      something_else -> EXC.case_clause something_else
erlps__bind_fun__3 [arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__bind_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_fun__3) args

erlps__force_bind_fun__3 :: ErlangFun
erlps__force_bind_fun__3 [x_0, type_1,
                          env_3@(ErlangTuple [(ErlangAtom "env"), _, _, _, _, _,
                                              _, _, _, what_2])]
  =
  let   
    ann_5 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [type_1]
  in let
    nocode_8 =
      erlps__get_option__2 [ErlangAtom "no_code", ErlangAtom "false"]
  in let
    entry_24 =
      case ErlangAtom "true" of
        _ | (ErlangAtom "true") ==
              (falsifyErrors
                 (\ _ ->
                    let    rop_12 = toErl "init"
                    in let lop_10 = BIF.erlang__op_eq [x_0, rop_12]
                    in let
                      lop_9 =
                        case lop_10 of
                          (ErlangAtom "false") -> ErlangAtom "false"
                          (ErlangAtom "true") ->
                            BIF.erlang__op_eq
                              [what_2, ErlangAtom "main_contract"]
                          _ -> EXC.badarg1 lop_10
                    in
                      case lop_9 of
                        (ErlangAtom "false") -> ErlangAtom "false"
                        (ErlangAtom "true") -> BIF.erlang__not__1 [nocode_8]
                        _ -> EXC.badarg1 lop_9)) ->
          ErlangTuple [ErlangAtom "reserved_init", ann_5, type_1]
        _ | weakEq what_2 (ErlangAtom "contract") ->
          ErlangTuple [ErlangAtom "contract_fun", ann_5, type_1]
        _ -> ErlangTuple [ann_5, type_1]
  in let
    arg_26 =
      ErlangFun 1
        (let
           lambda_27 [scope_30@(ErlangTuple [(ErlangAtom "scope"), funs_29,
                                             _, _, _, _])]
             =
             let head_33 = ErlangTuple [x_0, entry_24]
             in
               case scope_30 of
                 (ErlangTuple [(ErlangAtom "scope"), funs_37, types_38,
                               access_39, kind_40, ann_41]) ->
                   ErlangTuple
                     [ErlangAtom "scope", ErlangCons head_33 funs_29, types_38,
                      access_39, kind_40, ann_41]
                 _ -> EXC.badrecord (ErlangAtom "scope")
           lambda_27 [arg_28] = EXC.function_clause unit
           lambda_27 args = EXC.badarity (ErlangFun 1 lambda_27) args
         in lambda_27)
  in erlps__on_current_scope__2 [env_3, arg_26]
erlps__force_bind_fun__3 [arg_42, arg_43, arg_44] =
  EXC.function_clause unit
erlps__force_bind_fun__3 args =
  EXC.badarity (ErlangFun 3 erlps__force_bind_fun__3) args

erlps__bind_funs__2 :: ErlangFun
erlps__bind_funs__2 [(ErlangEmptyList), env_0] = env_0
erlps__bind_funs__2 [(ErlangCons (ErlangTuple [id_0,
                                               type_1]) rest_2),
                     env_3]
  =
  let arg_5 = erlps__bind_fun__3 [id_0, type_1, env_3]
  in erlps__bind_funs__2 [rest_2, arg_5]
erlps__bind_funs__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__bind_funs__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_funs__2) args

erlps__bind_type__4 :: ErlangFun
erlps__bind_type__4 [x_0, ann_1, def_2, env_3] =
  let
    arg_5 =
      ErlangFun 1
        (let
           lambda_6 [scope_9@(ErlangTuple [(ErlangAtom "scope"), _, types_8,
                                           _, _, _])]
             =
             let    tup_el_14 = ErlangTuple [ann_1, def_2]
             in let head_12 = ErlangTuple [x_0, tup_el_14]
             in
               case scope_9 of
                 (ErlangTuple [(ErlangAtom "scope"), funs_18, types_19,
                               access_20, kind_21, ann_22]) ->
                   ErlangTuple
                     [ErlangAtom "scope", funs_18, ErlangCons head_12 types_8,
                      access_20, kind_21, ann_22]
                 _ -> EXC.badrecord (ErlangAtom "scope")
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in erlps__on_current_scope__2 [env_3, arg_5]
erlps__bind_type__4 [arg_23, arg_24, arg_25, arg_26] =
  EXC.function_clause unit
erlps__bind_type__4 args =
  EXC.badarity (ErlangFun 4 erlps__bind_type__4) args

erlps__bind_state__1 :: ErlangFun
erlps__bind_state__1 [env_0] =
  let   
    head_1 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    unit_9 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_1 ErlangEmptyList,
         ErlangEmptyList]
  in let tup_el_15 = toErl "state"
  in let
    arg_12 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_1 ErlangEmptyList, tup_el_15]
  in let case_10 = erlps__lookup_type__2 [env_0, arg_12]
  in let
    state_20 =
      case case_10 of
        (ErlangTuple [s_16, _]) ->
          ErlangTuple
            [ErlangAtom "qid", ErlangCons head_1 ErlangEmptyList, s_16]
        (ErlangAtom "false") -> unit_9
        something_else -> EXC.case_clause something_else
  in let tup_el_23 = toErl "state"
  in let head_22 = ErlangTuple [tup_el_23, state_20]
  in let tup_el_27 = toErl "put"
  in let
    tup_el_28 =
      ErlangTuple
        [ErlangAtom "type_sig",
         ErlangCons (ErlangAtom "stateful")
           (ErlangCons head_1 ErlangEmptyList),
         ErlangAtom "none", ErlangEmptyList,
         ErlangCons state_20 ErlangEmptyList, unit_9]
  in let head_26 = ErlangTuple [tup_el_27, tup_el_28]
  in let
    env1_41 =
      erlps__bind_funs__2
        [ErlangCons head_22 (ErlangCons head_26 ErlangEmptyList), env_0]
  in let tup_el_47 = toErl "event"
  in let
    arg_44 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_1 ErlangEmptyList, tup_el_47]
  in let case_42 = erlps__lookup_type__2 [env_0, arg_44]
  in
    case case_42 of
      (ErlangTuple [e_48, _]) ->
        let   
          event_52 =
            ErlangTuple
              [ErlangAtom "qid", ErlangCons head_1 ErlangEmptyList, e_48]
        in let arg_54 = toErl "event"
        in let
          arg_55 =
            ErlangTuple
              [ErlangAtom "fun_t", ErlangCons head_1 ErlangEmptyList,
               ErlangEmptyList, ErlangCons event_52 ErlangEmptyList, unit_9]
        in let tup_el_68 = toErl "Chain"
        in let
          arg_65 =
            ErlangTuple
              [ErlangAtom "con", ErlangCons head_1 ErlangEmptyList, tup_el_68]
        in let
          arg_63 =
            erlps__push_scope__3 [ErlangAtom "namespace", arg_65, env1_41]
        in let arg_53 = erlps__bind_fun__3 [arg_54, arg_55, arg_63]
        in erlps__pop_scope__1 [arg_53]
      (ErlangAtom "false") -> env1_41
      something_else -> EXC.case_clause something_else
erlps__bind_state__1 [arg_70] = EXC.function_clause unit
erlps__bind_state__1 args =
  EXC.badarity (ErlangFun 1 erlps__bind_state__1) args

erlps__bind_field__3 :: ErlangFun
erlps__bind_field__3 [x_0, info_1,
                      env_3@(ErlangTuple [(ErlangAtom "env"), _, _, _, fields_2,
                                          _, _, _, _, _])]
  =
  let   
    arg_5 =
      ErlangFun 1
        (let
           lambda_6 [infos_8] = ErlangCons info_1 infos_8
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    fields1_15 =
      BIF.do_remote_fun_call "Maps" "erlps__update_with__4"
        [x_0, arg_5, ErlangCons info_1 ErlangEmptyList, fields_2]
  in
    case env_3 of
      (ErlangTuple [(ErlangAtom "env"), scopes_18, vars_19,
                    typevars_20, fields_21, namespace_22, in_pattern_23,
                    stateful_24, current_function_25, what_26]) ->
        ErlangTuple
          [ErlangAtom "env", scopes_18, vars_19, typevars_20, fields1_15,
           namespace_22, in_pattern_23, stateful_24, current_function_25,
           what_26]
      _ -> EXC.badrecord (ErlangAtom "env")
erlps__bind_field__3 [arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__bind_field__3 args =
  EXC.badarity (ErlangFun 3 erlps__bind_field__3) args

erlps__bind_fields__2 :: ErlangFun
erlps__bind_fields__2 [(ErlangEmptyList), env_0] = env_0
erlps__bind_fields__2 [(ErlangCons (ErlangTuple [id_0,
                                                 info_1]) rest_2),
                       env_3]
  =
  let arg_5 = erlps__bind_field__3 [id_0, info_1, env_3]
  in erlps__bind_fields__2 [rest_2, arg_5]
erlps__bind_fields__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__bind_fields__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_fields__2) args

erlps__contract_call_type__1 :: ErlangFun
erlps__contract_call_type__1 [(ErlangTuple [(ErlangAtom "fun_t"),
                                            ann_0, (ErlangEmptyList), args_1,
                                            ret_2])]
  =
  let   
    id_9 =
      ErlangFun 1
        (let
           lambda_3 [x_5] = ErlangTuple [ErlangAtom "id", ann_0, x_5]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let arg_10 = toErl "int"
  in let
    int_12 =
      BIF.erlang__apply__2 [id_9, ErlangCons arg_10 ErlangEmptyList]
  in let
    typed_22 =
      ErlangFun 2
        (let
           lambda_13 [e_16, t_17] =
             ErlangTuple [ErlangAtom "typed", ann_0, e_16, t_17]
           lambda_13 [arg_14, arg_15] = EXC.function_clause unit
           lambda_13 args = EXC.badarity (ErlangFun 2 lambda_13) args
         in lambda_13)
  in let
    named_35 =
      ErlangFun 2
        (let
           lambda_23 [name_26, default_27] =
             let
               tup_el_30 =
                 BIF.erlang__apply__2 [id_9, ErlangCons name_26 ErlangEmptyList]
             in
               ErlangTuple
                 [ErlangAtom "named_arg_t", ann_0, tup_el_30, int_12,
                  default_27]
           lambda_23 [arg_24, arg_25] = EXC.function_clause unit
           lambda_23 args = EXC.badarity (ErlangFun 2 lambda_23) args
         in lambda_23)
  in let arg_40 = toErl "gas"
  in let head_50 = toErl "Call"
  in let head_52 = toErl "gas_left"
  in let
    arg_46 =
      ErlangTuple
        [ErlangAtom "qid", ann_0,
         ErlangCons head_50 (ErlangCons head_52 ErlangEmptyList)]
  in let
    arg_54 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_0, ErlangEmptyList, ErlangEmptyList,
         int_12]
  in let
    tup_el_45 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_46 (ErlangCons arg_54 ErlangEmptyList)]
  in let
    arg_42 =
      ErlangTuple [ErlangAtom "app", ann_0, tup_el_45, ErlangEmptyList]
  in let
    arg_41 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_42 (ErlangCons int_12 ErlangEmptyList)]
  in let
    head_39 =
      BIF.erlang__apply__2
        [named_35, ErlangCons arg_40 (ErlangCons arg_41 ErlangEmptyList)]
  in let arg_67 = toErl "value"
  in let tup_el_72 = toErl 0
  in let arg_69 = ErlangTuple [ErlangAtom "int", ann_0, tup_el_72]
  in let
    arg_68 =
      BIF.erlang__apply__2
        [typed_22, ErlangCons arg_69 (ErlangCons int_12 ErlangEmptyList)]
  in let
    head_66 =
      BIF.erlang__apply__2
        [named_35, ErlangCons arg_67 (ErlangCons arg_68 ErlangEmptyList)]
  in
    ErlangTuple
      [ErlangAtom "fun_t", ann_0,
       ErlangCons head_39 (ErlangCons head_66 ErlangEmptyList), args_1,
       ret_2]
erlps__contract_call_type__1 [arg_79] = EXC.function_clause unit
erlps__contract_call_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__contract_call_type__1) args

erlps__bind_contract__2 :: ErlangFun
erlps__bind_contract__2 [(ErlangTuple [(ErlangAtom "contract"),
                                       ann_0, id_1, contents_2]),
                         env_3]
  =
  let    key_5 = erlps__name__1 [id_1]
  in let
    head_6 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    lop_11 =
      flmap
        (\ lc_16 ->
           case lc_16 of
             (ErlangTuple [(ErlangAtom "fun_decl"), annf_13, entrypoint_14,
                           type_15]) ->
               let    tup_el_21 = erlps__contract_call_type__1 [type_15]
               in let
                 lcRet_17 =
                   ErlangTuple
                     [ErlangAtom "field_t", annf_13, entrypoint_14, tup_el_21]
               in ErlangCons lcRet_17 ErlangEmptyList
             _ -> ErlangEmptyList)
        contents_2
  in let tup_el_30 = toErl "address"
  in let
    tup_el_27 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_6 ErlangEmptyList, tup_el_30]
  in let tup_el_34 = toErl "address"
  in let
    tup_el_31 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_6 ErlangEmptyList, tup_el_34]
  in let
    head_24 =
      ErlangTuple
        [ErlangAtom "field_t", ErlangCons head_6 ErlangEmptyList,
         tup_el_27, tup_el_31]
  in let
    fields_36 =
      BIF.erlang__op_append
        [lop_11, ErlangCons head_24 ErlangEmptyList]
  in let
    fieldinfo_50 =
      flmap
        (\ lc_41 ->
           case lc_41 of
             (ErlangTuple [(ErlangAtom "field_t"), _,
                           (ErlangTuple [(ErlangAtom "id"), fieldann_38,
                                         entrypoint_39]),
                           type_40]) ->
               let   
                 tup_el_44 =
                   ErlangTuple
                     [ErlangAtom "field_info", fieldann_38, type_40, id_1,
                      ErlangAtom "contract"]
               in let lcRet_42 = ErlangTuple [entrypoint_39, tup_el_44]
               in ErlangCons lcRet_42 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_36
  in let
    tup_el_55 = ErlangTuple [ErlangAtom "contract_t", fields_36]
  in let arg_53 = ErlangTuple [ErlangEmptyList, tup_el_55]
  in let arg_58 = erlps__bind_fields__2 [fieldinfo_50, env_3]
  in erlps__bind_type__4 [key_5, ann_0, arg_53, arg_58]
erlps__bind_contract__2 [arg_61, arg_62] =
  EXC.function_clause unit
erlps__bind_contract__2 args =
  EXC.badarity (ErlangFun 2 erlps__bind_contract__2) args

erlps__possible_scopes__2 :: ErlangFun
erlps__possible_scopes__2 [(ErlangTuple [(ErlangAtom "env"), _,
                                         _, _, _, current_0, _, _, _, _]),
                           name_1]
  =
  let   
    qual_3 =
      BIF.do_remote_fun_call "Lists" "erlps__droplast__1" [name_1]
  in let arg_5 = toErl 0
  in let arg_6 = BIF.erlang__length__1 [current_0]
  in let
    lcSrc_4 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_5, arg_6]
  in
    flmap
      (\ lc_9 ->
         let   
           lop_11 =
             BIF.do_remote_fun_call "Lists" "erlps__sublist__2"
               [current_0, lc_9]
         in let lcRet_10 = BIF.erlang__op_append [lop_11, qual_3]
         in ErlangCons lcRet_10 ErlangEmptyList)
      lcSrc_4
erlps__possible_scopes__2 [arg_15, arg_16] =
  EXC.function_clause unit
erlps__possible_scopes__2 args =
  EXC.badarity (ErlangFun 2 erlps__possible_scopes__2) args

erlps__lookup_type__2 :: ErlangFun
erlps__lookup_type__2 [env_0, id_1] =
  let   
    arg_4 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [id_1]
  in let arg_6 = erlps__qname__1 [id_1]
  in erlps__lookup_env__4 [env_0, ErlangAtom "type", arg_4, arg_6]
erlps__lookup_type__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__lookup_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_type__2) args

erlps__lookup_env__4 :: ErlangFun
erlps__lookup_env__4 [env_0, kind_1, ann_2, name_3] =
  let
    var_12 =
      case name_3 of
        (ErlangCons x_5 (ErlangEmptyList)) | weakEq kind_1
                                               (ErlangAtom "term") ->
          let
            arg_7 =
              case env_0 of
                (ErlangTuple arr_10) | (DM.Just field_9) <- (arr_10 DA.!! 2) ->
                  field_9
                _ -> EXC.badrecord (ErlangAtom "env")
          in
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [x_5, arg_7, ErlangAtom "false"]
        _ -> ErlangAtom "false"
  in
    case var_12 of
      (ErlangTuple [ann1_14, type_15]) ->
        let tup_el_17 = ErlangTuple [ann1_14, type_15]
        in ErlangTuple [name_3, tup_el_17]
      (ErlangAtom "false") ->
        let    lcSrc_20 = erlps__possible_scopes__2 [env_0, name_3]
        in let
          names_31 =
            flmap
              (\ lc_24 ->
                 let   
                   head_28 =
                     BIF.do_remote_fun_call "Lists" "erlps__last__1" [name_3]
                 in let
                   lcRet_25 =
                     BIF.erlang__op_append
                       [lc_24, ErlangCons head_28 ErlangEmptyList]
                 in ErlangCons lcRet_25 ErlangEmptyList)
              lcSrc_20
        in let
          case_32 =
            flmap
              (\ lc_35 ->
                 let
                   head_37 = erlps__lookup_env1__4 [env_0, kind_1, ann_2, lc_35]
                 in
                   flmap
                     (\ lc_44 ->
                        let
                          cond_45 =
                            BIF.erlang__op_neq [lc_44, ErlangAtom "false"]
                        in
                          case cond_45 of
                            (ErlangAtom "true") ->
                              ErlangCons lc_44 ErlangEmptyList
                            _ -> ErlangEmptyList)
                     (ErlangCons head_37 ErlangEmptyList))
              names_31
        in
          case case_32 of
            (ErlangEmptyList) -> ErlangAtom "false"
            (ErlangCons res_49 (ErlangEmptyList)) -> res_49
            many_50 ->
              let   
                tup_el_53 =
                  flmap
                    (\ lc_57 ->
                       case lc_57 of
                         (ErlangTuple [q_55, (ErlangTuple [a_56, _])]) ->
                           let
                             lcRet_58 =
                               ErlangTuple [ErlangAtom "qid", a_56, q_55]
                           in ErlangCons lcRet_58 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    many_50
              in let
                arg_51 = ErlangTuple [ErlangAtom "ambiguous_name", tup_el_53]
              in let _ = erlps__type_error__1 [arg_51]
              in ErlangAtom "false"
      something_else -> EXC.case_clause something_else
erlps__lookup_env__4 [arg_62, arg_63, arg_64, arg_65] =
  EXC.function_clause unit
erlps__lookup_env__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_env__4) args

erlps__lookup_env1__4 :: ErlangFun
erlps__lookup_env1__4 [(ErlangTuple [(ErlangAtom "env"),
                                     scopes_0, _, _, _, current_1, _, _, _, _]),
                       kind_2, ann_3, qname_4]
  =
  let   
    qual_6 =
      BIF.do_remote_fun_call "Lists" "erlps__droplast__1" [qname_4]
  in let
    name_8 =
      BIF.do_remote_fun_call "Lists" "erlps__last__1" [qname_4]
  in let
    allowprivate_11 =
      BIF.do_remote_fun_call "Lists" "erlps__prefix__2"
        [qual_6, current_1]
  in let
    case_12 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [qual_6, scopes_0, ErlangAtom "false"]
  in
    case case_12 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangTuple [(ErlangAtom "scope"), funs_16, types_17, _, _,
                    _]) ->
        let   
          defs_19 =
            case kind_2 of
              (ErlangAtom "type") -> types_17
              (ErlangAtom "term") -> funs_16
              something_else -> EXC.case_clause something_else
        in let
          case_20 =
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [name_8, defs_19, ErlangAtom "false"]
        in
          case case_20 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangTuple [(ErlangAtom "reserved_init"), ann1_24, type_25]) ->
              let   
                arg_26 =
                  ErlangTuple [ErlangAtom "cannot_call_init_function", ann_3]
              in let _ = erlps__type_error__1 [arg_26]
              in let tup_el_30 = ErlangTuple [ann1_24, type_25]
              in ErlangTuple [qname_4, tup_el_30]
            (ErlangTuple [(ErlangAtom "contract_fun"), ann1_33, type_34]) ->
              let   
                arg_35 =
                  ErlangTuple
                    [ErlangAtom "contract_treated_as_namespace", ann_3, qname_4]
              in let _ = erlps__type_error__1 [arg_35]
              in let tup_el_40 = ErlangTuple [ann1_33, type_34]
              in ErlangTuple [qname_4, tup_el_40]
            e_44@(ErlangTuple [ann1_43, _]) ->
              let    op_arg_47 = erlps__is_private__1 [ann1_43]
              in let lop_46 = BIF.erlang__not__1 [op_arg_47]
              in let
                case_45 =
                  case lop_46 of
                    (ErlangAtom "true") -> ErlangAtom "true"
                    (ErlangAtom "false") -> allowprivate_11
                    _ -> EXC.badarg1 lop_46
              in
                case case_45 of
                  (ErlangAtom "true") -> ErlangTuple [qname_4, e_44]
                  (ErlangAtom "false") -> ErlangAtom "false"
                  something_else -> EXC.case_clause something_else
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__lookup_env1__4 [arg_51, arg_52, arg_53, arg_54] =
  EXC.function_clause unit
erlps__lookup_env1__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_env1__4) args

erlps__lookup_record_field__2 :: ErlangFun
erlps__lookup_record_field__2 [env_0, fieldname_1] =
  let
    arg_3 =
      case env_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 4) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "env")
  in
    BIF.do_remote_fun_call "Maps" "erlps__get__3"
      [fieldname_1, arg_3, ErlangEmptyList]
erlps__lookup_record_field__2 [arg_8, arg_9] =
  EXC.function_clause unit
erlps__lookup_record_field__2 args =
  EXC.badarity (ErlangFun 2 erlps__lookup_record_field__2) args

erlps__lookup_record_field__3 :: ErlangFun
erlps__lookup_record_field__3 [env_0, fieldname_1, kind_2] =
  let lcSrc_3 = erlps__lookup_record_field__2 [env_0, fieldname_1]
  in
    flmap
      (\ lc_8 ->
         case lc_8 of
           fld_7@(ErlangTuple [(ErlangAtom "field_info"), _, _, _, k_6]) ->
             let    lop_10 = BIF.erlang__op_eq [kind_2, ErlangAtom "project"]
             in let
               cond_9 =
                 case lop_10 of
                   (ErlangAtom "true") -> ErlangAtom "true"
                   (ErlangAtom "false") ->
                     BIF.erlang__op_neq [k_6, ErlangAtom "contract"]
                   _ -> EXC.badarg1 lop_10
             in
               case cond_9 of
                 (ErlangAtom "true") -> ErlangCons fld_7 ErlangEmptyList
                 _ -> ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_3
erlps__lookup_record_field__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__lookup_record_field__3 args =
  EXC.badarity (ErlangFun 3 erlps__lookup_record_field__3) args

erlps__qname__1 :: ErlangFun
erlps__qname__1 [(ErlangTuple [(ErlangAtom "id"), _, x_0])] =
  ErlangCons x_0 ErlangEmptyList
erlps__qname__1 [(ErlangTuple [(ErlangAtom "qid"), _, xs_0])] =
  xs_0
erlps__qname__1 [(ErlangTuple [(ErlangAtom "con"), _, x_0])] =
  ErlangCons x_0 ErlangEmptyList
erlps__qname__1 [(ErlangTuple [(ErlangAtom "qcon"), _, xs_0])] =
  xs_0
erlps__qname__1 [arg_1] = EXC.function_clause unit
erlps__qname__1 args =
  EXC.badarity (ErlangFun 1 erlps__qname__1) args

erlps__name__1 :: ErlangFun
erlps__name__1 [(ErlangTuple [_, _, x_0])] = x_0
erlps__name__1 [arg_1] = EXC.function_clause unit
erlps__name__1 args =
  EXC.badarity (ErlangFun 1 erlps__name__1) args

erlps__qid__2 :: ErlangFun
erlps__qid__2 [ann_0, (ErlangCons x_1 (ErlangEmptyList))] =
  ErlangTuple [ErlangAtom "id", ann_0, x_1]
erlps__qid__2 [ann_0, xs_1] =
  ErlangTuple [ErlangAtom "qid", ann_0, xs_1]
erlps__qid__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__qid__2 args =
  EXC.badarity (ErlangFun 2 erlps__qid__2) args

erlps__qcon__2 :: ErlangFun
erlps__qcon__2 [ann_0, (ErlangCons x_1 (ErlangEmptyList))] =
  ErlangTuple [ErlangAtom "con", ann_0, x_1]
erlps__qcon__2 [ann_0, xs_1] =
  ErlangTuple [ErlangAtom "qcon", ann_0, xs_1]
erlps__qcon__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__qcon__2 args =
  EXC.badarity (ErlangFun 2 erlps__qcon__2) args

erlps__set_qname__2 :: ErlangFun
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "id"), ann_1, _])]
  =
  erlps__qid__2 [ann_1, xs_0]
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "qid"), ann_1, _])]
  =
  erlps__qid__2 [ann_1, xs_0]
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "con"), ann_1, _])]
  =
  erlps__qcon__2 [ann_1, xs_0]
erlps__set_qname__2 [xs_0,
                     (ErlangTuple [(ErlangAtom "qcon"), ann_1, _])]
  =
  erlps__qcon__2 [ann_1, xs_0]
erlps__set_qname__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__set_qname__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_qname__2) args

erlps__is_private__1 :: ErlangFun
erlps__is_private__1 [ann_0] =
  BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
    [ErlangAtom "private", ann_0, ErlangAtom "false"]
erlps__is_private__1 [arg_4] = EXC.function_clause unit
erlps__is_private__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_private__1) args

erlps__global_env__0 :: ErlangFun
erlps__global_env__0 [] =
  let   
    head_0 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let tup_el_7 = toErl "int"
  in let
    int_8 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_7]
  in let tup_el_11 = toErl "bool"
  in let
    bool_12 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_11]
  in let tup_el_15 = toErl "string"
  in let
    string_16 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_15]
  in let tup_el_19 = toErl "address"
  in let
    address_20 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_19]
  in let tup_el_23 = toErl "hash"
  in let
    hash_24 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_23]
  in let tup_el_27 = toErl "bits"
  in let
    bits_28 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_27]
  in let
    bytes_35 =
      ErlangFun 1
        (let
           lambda_29 [len_31] =
             ErlangTuple
               [ErlangAtom "bytes_t", ErlangCons head_0 ErlangEmptyList, len_31]
           lambda_29 [arg_30] = EXC.function_clause unit
           lambda_29 args = EXC.badarity (ErlangFun 1 lambda_29) args
         in lambda_29)
  in let
    oracle_52 =
      ErlangFun 2
        (let
           lambda_36 [q_39, r_40] =
             let    tup_el_46 = toErl "oracle"
             in let
               tup_el_43 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_46]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_43, ErlangCons q_39 (ErlangCons r_40 ErlangEmptyList)]
           lambda_36 [arg_37, arg_38] = EXC.function_clause unit
           lambda_36 args = EXC.badarity (ErlangFun 2 lambda_36) args
         in lambda_36)
  in let
    query_69 =
      ErlangFun 2
        (let
           lambda_53 [q_56, r_57] =
             let    tup_el_63 = toErl "oracle_query"
             in let
               tup_el_60 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_63]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_60, ErlangCons q_56 (ErlangCons r_57 ErlangEmptyList)]
           lambda_53 [arg_54, arg_55] = EXC.function_clause unit
           lambda_53 args = EXC.badarity (ErlangFun 2 lambda_53) args
         in lambda_53)
  in let
    unit_73 =
      ErlangTuple
        [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
         ErlangEmptyList]
  in let
    list_86 =
      ErlangFun 1
        (let
           lambda_74 [t_76] =
             let    tup_el_82 = toErl "list"
             in let
               tup_el_79 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_82]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_79, ErlangCons t_76 ErlangEmptyList]
           lambda_74 [arg_75] = EXC.function_clause unit
           lambda_74 args = EXC.badarity (ErlangFun 1 lambda_74) args
         in lambda_74)
  in let
    option_99 =
      ErlangFun 1
        (let
           lambda_87 [t_89] =
             let    tup_el_95 = toErl "option"
             in let
               tup_el_92 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_95]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_92, ErlangCons t_89 ErlangEmptyList]
           lambda_87 [arg_88] = EXC.function_clause unit
           lambda_87 args = EXC.badarity (ErlangFun 1 lambda_87) args
         in lambda_87)
  in let
    map_116 =
      ErlangFun 2
        (let
           lambda_100 [a_103, b_104] =
             let    tup_el_110 = toErl "map"
             in let
               tup_el_107 =
                 ErlangTuple
                   [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList,
                    tup_el_110]
             in
               ErlangTuple
                 [ErlangAtom "app_t", ErlangCons head_0 ErlangEmptyList,
                  tup_el_107,
                  ErlangCons a_103 (ErlangCons b_104 ErlangEmptyList)]
           lambda_100 [arg_101, arg_102] = EXC.function_clause unit
           lambda_100 args = EXC.badarity (ErlangFun 2 lambda_100) args
         in lambda_100)
  in let
    pair_129 =
      ErlangFun 2
        (let
           lambda_117 [a_120, b_121] =
             ErlangTuple
               [ErlangAtom "tuple_t", ErlangCons head_0 ErlangEmptyList,
                ErlangCons a_120 (ErlangCons b_121 ErlangEmptyList)]
           lambda_117 [arg_118, arg_119] = EXC.function_clause unit
           lambda_117 args = EXC.badarity (ErlangFun 2 lambda_117) args
         in lambda_117)
  in let
    func_143 =
      ErlangFun 3
        (let
           lambda_130 [c_134, ts_135, t_136] =
             ErlangTuple
               [ErlangAtom "type_sig", ErlangCons head_0 ErlangEmptyList, c_134,
                ErlangEmptyList, ts_135, t_136]
           lambda_130 [arg_131, arg_132, arg_133] = EXC.function_clause unit
           lambda_130 args = EXC.badarity (ErlangFun 3 lambda_130) args
         in lambda_130)
  in let
    fun_153 =
      ErlangFun 2
        (let
           lambda_144 [ts_147, t_148] =
             BIF.erlang__apply__2
               [func_143,
                ErlangCons (ErlangAtom "none")
                  (ErlangCons ts_147 (ErlangCons t_148 ErlangEmptyList))]
           lambda_144 [arg_145, arg_146] = EXC.function_clause unit
           lambda_144 args = EXC.badarity (ErlangFun 2 lambda_144) args
         in lambda_144)
  in let
    fun1_164 =
      ErlangFun 2
        (let
           lambda_154 [s_157, t_158] =
             BIF.erlang__apply__2
               [fun_153,
                ErlangCons (ErlangCons s_157 ErlangEmptyList)
                  (ErlangCons t_158 ErlangEmptyList)]
           lambda_154 [arg_155, arg_156] = EXC.function_clause unit
           lambda_154 args = EXC.badarity (ErlangFun 2 lambda_154) args
         in lambda_154)
  in let
    statefun_178 =
      ErlangFun 2
        (let
           lambda_165 [ts_168, t_169] =
             ErlangTuple
               [ErlangAtom "type_sig",
                ErlangCons (ErlangAtom "stateful")
                  (ErlangCons head_0 ErlangEmptyList),
                ErlangAtom "none", ErlangEmptyList, ts_168, t_169]
           lambda_165 [arg_166, arg_167] = EXC.function_clause unit
           lambda_165 args = EXC.badarity (ErlangFun 2 lambda_165) args
         in lambda_165)
  in let
    tvar_187 =
      ErlangFun 1
        (let
           lambda_179 [x_181] =
             let    lop_185 = toErl "\'"
             in let tup_el_184 = BIF.erlang__op_append [lop_185, x_181]
             in
               ErlangTuple
                 [ErlangAtom "tvar", ErlangCons head_0 ErlangEmptyList,
                  tup_el_184]
           lambda_179 [arg_180] = EXC.function_clause unit
           lambda_179 args = EXC.badarity (ErlangFun 1 lambda_179) args
         in lambda_179)
  in let tup_el_190 = toErl "signature"
  in let
    signid_191 =
      ErlangTuple
        [ErlangAtom "id", ErlangCons head_0 ErlangEmptyList, tup_el_190]
  in let bin_el_195 = toErl 0
  in let
    tup_el_194 =
      ErlangBinary (BIN.fromInt bin_el_195 (toErl 64) 8 BIN.Big)
  in let
    signdef_196 =
      ErlangTuple
        [ErlangAtom "bytes", ErlangCons head_0 ErlangEmptyList,
         tup_el_194]
  in let
    tup_el_201 =
      ErlangTuple
        [ErlangAtom "typed", ErlangCons head_0 ErlangEmptyList,
         signdef_196, signid_191]
  in let
    signature_206 =
      ErlangTuple
        [ErlangAtom "named_arg_t", ErlangCons head_0 ErlangEmptyList,
         signid_191, signid_191, tup_el_201]
  in let
    signfun_222 =
      ErlangFun 2
        (let
           lambda_207 [ts_210, t_211] =
             ErlangTuple
               [ErlangAtom "type_sig",
                ErlangCons (ErlangAtom "stateful")
                  (ErlangCons head_0 ErlangEmptyList),
                ErlangAtom "none", ErlangCons signature_206 ErlangEmptyList,
                ts_210, t_211]
           lambda_207 [arg_208, arg_209] = EXC.function_clause unit
           lambda_207 args = EXC.badarity (ErlangFun 2 lambda_207) args
         in lambda_207)
  in let head_226 = toErl "Chain"
  in let head_228 = toErl "ttl"
  in let
    ttl_230 =
      ErlangTuple
        [ErlangAtom "qid", ErlangCons head_0 ErlangEmptyList,
         ErlangCons head_226 (ErlangCons head_228 ErlangEmptyList)]
  in let head_234 = toErl "a"
  in let head_236 = toErl "q"
  in let head_238 = toErl "r"
  in let head_240 = toErl "k"
  in let head_242 = toErl "v"
  in let
    matchExpr_249 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [tvar_187,
         ErlangCons head_234
           (ErlangCons head_236
              (ErlangCons head_238
                 (ErlangCons head_240 (ErlangCons head_242 ErlangEmptyList))))]
  in
    case matchExpr_249 of
      (ErlangCons a_244 (ErlangCons q_245 (ErlangCons r_246 (ErlangCons k_247 (ErlangCons v_248 (ErlangEmptyList)))))) ->
        let   
          mkdefs_264 =
            ErlangFun 1
              (let
                 lambda_250 [defs_252] =
                   flmap
                     (\ lc_256 ->
                        case lc_256 of
                          (ErlangTuple [x_254, t_255]) ->
                            let   
                              tup_el_261 =
                                case ErlangAtom "true" of
                                  _ | isEInt t_255 ->
                                    ErlangTuple [ErlangAtom "builtin", t_255]
                                  _ -> t_255
                            in let
                              tup_el_259 =
                                ErlangTuple
                                  [ErlangCons head_0 ErlangEmptyList,
                                   tup_el_261]
                            in let lcRet_257 = ErlangTuple [x_254, tup_el_259]
                            in ErlangCons lcRet_257 ErlangEmptyList
                          _ -> ErlangEmptyList)
                     defs_252
                 lambda_250 [arg_251] = EXC.function_clause unit
                 lambda_250 args = EXC.badarity (ErlangFun 1 lambda_250) args
               in lambda_250)
        in let tup_el_269 = toErl "None"
        in let
          tup_el_270 =
            BIF.erlang__apply__2
              [option_99, ErlangCons a_244 ErlangEmptyList]
        in let head_268 = ErlangTuple [tup_el_269, tup_el_270]
        in let tup_el_275 = toErl "Some"
        in let
          arg_278 =
            BIF.erlang__apply__2
              [option_99, ErlangCons a_244 ErlangEmptyList]
        in let
          tup_el_276 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons a_244 (ErlangCons arg_278 ErlangEmptyList)]
        in let head_274 = ErlangTuple [tup_el_275, tup_el_276]
        in let tup_el_284 = toErl "RelativeTTL"
        in let
          tup_el_285 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons int_8 (ErlangCons ttl_230 ErlangEmptyList)]
        in let head_283 = ErlangTuple [tup_el_284, tup_el_285]
        in let tup_el_291 = toErl "FixedTTL"
        in let
          tup_el_292 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons int_8 (ErlangCons ttl_230 ErlangEmptyList)]
        in let head_290 = ErlangTuple [tup_el_291, tup_el_292]
        in let tup_el_298 = toErl "abort"
        in let
          tup_el_299 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons string_16 (ErlangCons a_244 ErlangEmptyList)]
        in let head_297 = ErlangTuple [tup_el_298, tup_el_299]
        in let tup_el_305 = toErl "require"
        in let
          tup_el_306 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bool_12 (ErlangCons string_16 ErlangEmptyList))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_304 = ErlangTuple [tup_el_305, tup_el_306]
        in let
          tup_el_266 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_268
                    (ErlangCons head_274
                       (ErlangCons head_283
                          (ErlangCons head_290
                             (ErlangCons head_297
                                (ErlangCons head_304 ErlangEmptyList))))))
                 ErlangEmptyList]
        in let tup_el_319 = toErl "int"
        in let tup_el_320 = toErl 0
        in let head_318 = ErlangTuple [tup_el_319, tup_el_320]
        in let tup_el_323 = toErl "bool"
        in let tup_el_324 = toErl 0
        in let head_322 = ErlangTuple [tup_el_323, tup_el_324]
        in let tup_el_327 = toErl "char"
        in let tup_el_328 = toErl 0
        in let head_326 = ErlangTuple [tup_el_327, tup_el_328]
        in let tup_el_331 = toErl "string"
        in let tup_el_332 = toErl 0
        in let head_330 = ErlangTuple [tup_el_331, tup_el_332]
        in let tup_el_335 = toErl "address"
        in let tup_el_336 = toErl 0
        in let head_334 = ErlangTuple [tup_el_335, tup_el_336]
        in let tup_el_339 = toErl "unit"
        in let tup_el_342 = ErlangTuple [ErlangAtom "alias_t", unit_73]
        in let tup_el_340 = ErlangTuple [ErlangEmptyList, tup_el_342]
        in let head_338 = ErlangTuple [tup_el_339, tup_el_340]
        in let tup_el_347 = toErl "hash"
        in let arg_353 = toErl 32
        in let
          tup_el_352 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_353 ErlangEmptyList]
        in let
          tup_el_350 = ErlangTuple [ErlangAtom "alias_t", tup_el_352]
        in let tup_el_348 = ErlangTuple [ErlangEmptyList, tup_el_350]
        in let head_346 = ErlangTuple [tup_el_347, tup_el_348]
        in let tup_el_357 = toErl "signature"
        in let arg_363 = toErl 64
        in let
          tup_el_362 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_363 ErlangEmptyList]
        in let
          tup_el_360 = ErlangTuple [ErlangAtom "alias_t", tup_el_362]
        in let tup_el_358 = ErlangTuple [ErlangEmptyList, tup_el_360]
        in let head_356 = ErlangTuple [tup_el_357, tup_el_358]
        in let tup_el_367 = toErl "bits"
        in let tup_el_368 = toErl 0
        in let head_366 = ErlangTuple [tup_el_367, tup_el_368]
        in let tup_el_371 = toErl "option"
        in let tup_el_372 = toErl 1
        in let head_370 = ErlangTuple [tup_el_371, tup_el_372]
        in let tup_el_375 = toErl "list"
        in let tup_el_376 = toErl 1
        in let head_374 = ErlangTuple [tup_el_375, tup_el_376]
        in let tup_el_379 = toErl "map"
        in let tup_el_380 = toErl 2
        in let head_378 = ErlangTuple [tup_el_379, tup_el_380]
        in let tup_el_383 = toErl "oracle"
        in let tup_el_384 = toErl 2
        in let head_382 = ErlangTuple [tup_el_383, tup_el_384]
        in let tup_el_387 = toErl "oracle_query"
        in let tup_el_388 = toErl 2
        in let head_386 = ErlangTuple [tup_el_387, tup_el_388]
        in let
          tup_el_316 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_318
                    (ErlangCons head_322
                       (ErlangCons head_326
                          (ErlangCons head_330
                             (ErlangCons head_334
                                (ErlangCons head_338
                                   (ErlangCons head_346
                                      (ErlangCons head_356
                                         (ErlangCons head_366
                                            (ErlangCons head_370
                                               (ErlangCons head_374
                                                  (ErlangCons head_378
                                                     (ErlangCons head_382
                                                        (ErlangCons head_386
                                                           ErlangEmptyList))))))))))))))
                 ErlangEmptyList]
        in let
          head_394 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          topscope_398 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_266, tup_el_316, ErlangAtom "public",
               ErlangAtom "namespace", ErlangCons head_394 ErlangEmptyList]
        in let tup_el_403 = toErl "spend"
        in let
          tup_el_404 =
            BIF.erlang__apply__2
              [statefun_178,
               ErlangCons
                 (ErlangCons address_20 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_402 = ErlangTuple [tup_el_403, tup_el_404]
        in let tup_el_414 = toErl "balance"
        in let
          tup_el_415 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons address_20 (ErlangCons int_8 ErlangEmptyList)]
        in let head_413 = ErlangTuple [tup_el_414, tup_el_415]
        in let tup_el_421 = toErl "block_hash"
        in let
          arg_424 =
            BIF.erlang__apply__2
              [option_99, ErlangCons hash_24 ErlangEmptyList]
        in let
          tup_el_422 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons int_8 (ErlangCons arg_424 ErlangEmptyList)]
        in let head_420 = ErlangTuple [tup_el_421, tup_el_422]
        in let tup_el_430 = toErl "coinbase"
        in let head_429 = ErlangTuple [tup_el_430, address_20]
        in let tup_el_434 = toErl "timestamp"
        in let head_433 = ErlangTuple [tup_el_434, int_8]
        in let tup_el_438 = toErl "block_height"
        in let head_437 = ErlangTuple [tup_el_438, int_8]
        in let tup_el_442 = toErl "difficulty"
        in let head_441 = ErlangTuple [tup_el_442, int_8]
        in let tup_el_446 = toErl "gas_limit"
        in let head_445 = ErlangTuple [tup_el_446, int_8]
        in let
          tup_el_400 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_402
                    (ErlangCons head_413
                       (ErlangCons head_420
                          (ErlangCons head_429
                             (ErlangCons head_433
                                (ErlangCons head_437
                                   (ErlangCons head_441
                                      (ErlangCons head_445
                                         ErlangEmptyList))))))))
                 ErlangEmptyList]
        in let tup_el_453 = toErl "ttl"
        in let tup_el_454 = toErl 0
        in let head_452 = ErlangTuple [tup_el_453, tup_el_454]
        in let
          tup_el_450 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons (ErlangCons head_452 ErlangEmptyList) ErlangEmptyList]
        in let
          head_460 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          chainscope_464 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_400, tup_el_450, ErlangAtom "public",
               ErlangAtom "namespace", ErlangCons head_460 ErlangEmptyList]
        in let tup_el_469 = toErl "address"
        in let head_468 = ErlangTuple [tup_el_469, address_20]
        in let tup_el_473 = toErl "creator"
        in let head_472 = ErlangTuple [tup_el_473, address_20]
        in let tup_el_477 = toErl "balance"
        in let head_476 = ErlangTuple [tup_el_477, int_8]
        in let
          tup_el_466 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_468
                    (ErlangCons head_472 (ErlangCons head_476 ErlangEmptyList)))
                 ErlangEmptyList]
        in let
          head_485 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          contractscope_489 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_466, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_485 ErlangEmptyList]
        in let tup_el_494 = toErl "origin"
        in let head_493 = ErlangTuple [tup_el_494, address_20]
        in let tup_el_498 = toErl "caller"
        in let head_497 = ErlangTuple [tup_el_498, address_20]
        in let tup_el_502 = toErl "value"
        in let head_501 = ErlangTuple [tup_el_502, int_8]
        in let tup_el_506 = toErl "gas_price"
        in let head_505 = ErlangTuple [tup_el_506, int_8]
        in let tup_el_510 = toErl "gas_left"
        in let
          tup_el_511 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons ErlangEmptyList (ErlangCons int_8 ErlangEmptyList)]
        in let head_509 = ErlangTuple [tup_el_510, tup_el_511]
        in let
          tup_el_491 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_493
                    (ErlangCons head_497
                       (ErlangCons head_501
                          (ErlangCons head_505
                             (ErlangCons head_509 ErlangEmptyList)))))
                 ErlangEmptyList]
        in let
          head_521 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          callscope_525 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_491, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_521 ErlangEmptyList]
        in let tup_el_530 = toErl "register"
        in let
          arg_539 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_531 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons address_20
                    (ErlangCons int_8 (ErlangCons ttl_230 ErlangEmptyList)))
                 (ErlangCons arg_539 ErlangEmptyList)]
        in let head_529 = ErlangTuple [tup_el_530, tup_el_531]
        in let tup_el_546 = toErl "query_fee"
        in let
          head_549 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_547 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons (ErlangCons head_549 ErlangEmptyList)
                 (ErlangCons int_8 ErlangEmptyList)]
        in let head_545 = ErlangTuple [tup_el_546, tup_el_547]
        in let tup_el_558 = toErl "query"
        in let
          head_561 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          arg_574 =
            BIF.erlang__apply__2
              [query_69, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_559 =
            BIF.erlang__apply__2
              [statefun_178,
               ErlangCons
                 (ErlangCons head_561
                    (ErlangCons q_245
                       (ErlangCons int_8
                          (ErlangCons ttl_230
                             (ErlangCons ttl_230 ErlangEmptyList)))))
                 (ErlangCons arg_574 ErlangEmptyList)]
        in let head_557 = ErlangTuple [tup_el_558, tup_el_559]
        in let tup_el_581 = toErl "get_question"
        in let
          head_584 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          head_589 =
            BIF.erlang__apply__2
              [query_69, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_582 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons head_584 (ErlangCons head_589 ErlangEmptyList))
                 (ErlangCons q_245 ErlangEmptyList)]
        in let head_580 = ErlangTuple [tup_el_581, tup_el_582]
        in let tup_el_598 = toErl "respond"
        in let
          head_601 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          head_606 =
            BIF.erlang__apply__2
              [query_69, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_599 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons head_601
                    (ErlangCons head_606 (ErlangCons r_246 ErlangEmptyList)))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_597 = ErlangTuple [tup_el_598, tup_el_599]
        in let tup_el_617 = toErl "extend"
        in let
          head_620 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_618 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons head_620 (ErlangCons ttl_230 ErlangEmptyList))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_616 = ErlangTuple [tup_el_617, tup_el_618]
        in let tup_el_631 = toErl "get_answer"
        in let
          head_634 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          head_639 =
            BIF.erlang__apply__2
              [query_69, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          arg_644 =
            erlps__option_t__2 [ErlangCons head_0 ErlangEmptyList, r_246]
        in let
          tup_el_632 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons head_634 (ErlangCons head_639 ErlangEmptyList))
                 (ErlangCons arg_644 ErlangEmptyList)]
        in let head_630 = ErlangTuple [tup_el_631, tup_el_632]
        in let tup_el_650 = toErl "check"
        in let
          head_653 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_651 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons (ErlangCons head_653 ErlangEmptyList)
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_649 = ErlangTuple [tup_el_650, tup_el_651]
        in let tup_el_662 = toErl "check_query"
        in let
          head_665 =
            BIF.erlang__apply__2
              [oracle_52, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          head_670 =
            BIF.erlang__apply__2
              [query_69, ErlangCons q_245 (ErlangCons r_246 ErlangEmptyList)]
        in let
          tup_el_663 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons head_665 (ErlangCons head_670 ErlangEmptyList))
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_661 = ErlangTuple [tup_el_662, tup_el_663]
        in let
          tup_el_527 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_529
                    (ErlangCons head_545
                       (ErlangCons head_557
                          (ErlangCons head_580
                             (ErlangCons head_597
                                (ErlangCons head_616
                                   (ErlangCons head_630
                                      (ErlangCons head_649
                                         (ErlangCons head_661
                                            ErlangEmptyList)))))))))
                 ErlangEmptyList]
        in let
          head_683 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          oraclescope_687 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_527, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_683 ErlangEmptyList]
        in let tup_el_692 = toErl "resolve"
        in let
          arg_699 =
            erlps__option_t__2 [ErlangCons head_0 ErlangEmptyList, a_244]
        in let
          tup_el_693 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons string_16 (ErlangCons string_16 ErlangEmptyList))
                 (ErlangCons arg_699 ErlangEmptyList)]
        in let head_691 = ErlangTuple [tup_el_692, tup_el_693]
        in let tup_el_705 = toErl "preclaim"
        in let
          tup_el_706 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons address_20 (ErlangCons hash_24 ErlangEmptyList))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_704 = ErlangTuple [tup_el_705, tup_el_706]
        in let tup_el_716 = toErl "claim"
        in let
          tup_el_717 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons address_20
                    (ErlangCons string_16
                       (ErlangCons int_8 (ErlangCons int_8 ErlangEmptyList))))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_715 = ErlangTuple [tup_el_716, tup_el_717]
        in let tup_el_731 = toErl "transfer"
        in let
          tup_el_732 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons address_20
                    (ErlangCons address_20
                       (ErlangCons string_16 ErlangEmptyList)))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_730 = ErlangTuple [tup_el_731, tup_el_732]
        in let tup_el_744 = toErl "revoke"
        in let
          tup_el_745 =
            BIF.erlang__apply__2
              [signfun_222,
               ErlangCons
                 (ErlangCons address_20 (ErlangCons string_16 ErlangEmptyList))
                 (ErlangCons unit_73 ErlangEmptyList)]
        in let head_743 = ErlangTuple [tup_el_744, tup_el_745]
        in let
          tup_el_689 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_691
                    (ErlangCons head_704
                       (ErlangCons head_715
                          (ErlangCons head_730
                             (ErlangCons head_743 ErlangEmptyList)))))
                 ErlangEmptyList]
        in let
          head_759 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          aensscope_763 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_689, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_759 ErlangEmptyList]
        in let tup_el_768 = toErl "from_list"
        in let
          arg_771 =
            BIF.erlang__apply__2
              [pair_129, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          arg_770 =
            BIF.erlang__apply__2
              [list_86, ErlangCons arg_771 ErlangEmptyList]
        in let
          arg_776 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          tup_el_769 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons arg_770 (ErlangCons arg_776 ErlangEmptyList)]
        in let head_767 = ErlangTuple [tup_el_768, tup_el_769]
        in let tup_el_783 = toErl "to_list"
        in let
          arg_785 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          arg_790 =
            BIF.erlang__apply__2
              [pair_129, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          arg_789 =
            BIF.erlang__apply__2
              [list_86, ErlangCons arg_790 ErlangEmptyList]
        in let
          tup_el_784 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons arg_785 (ErlangCons arg_789 ErlangEmptyList)]
        in let head_782 = ErlangTuple [tup_el_783, tup_el_784]
        in let tup_el_798 = toErl "lookup"
        in let
          head_803 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          arg_808 =
            BIF.erlang__apply__2
              [option_99, ErlangCons v_248 ErlangEmptyList]
        in let
          tup_el_799 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons k_247 (ErlangCons head_803 ErlangEmptyList))
                 (ErlangCons arg_808 ErlangEmptyList)]
        in let head_797 = ErlangTuple [tup_el_798, tup_el_799]
        in let tup_el_814 = toErl "lookup_default"
        in let
          head_819 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          tup_el_815 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons k_247
                    (ErlangCons head_819 (ErlangCons v_248 ErlangEmptyList)))
                 (ErlangCons v_248 ErlangEmptyList)]
        in let head_813 = ErlangTuple [tup_el_814, tup_el_815]
        in let tup_el_830 = toErl "delete"
        in let
          head_835 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          arg_840 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          tup_el_831 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons k_247 (ErlangCons head_835 ErlangEmptyList))
                 (ErlangCons arg_840 ErlangEmptyList)]
        in let head_829 = ErlangTuple [tup_el_830, tup_el_831]
        in let tup_el_847 = toErl "member"
        in let
          head_852 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          tup_el_848 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons k_247 (ErlangCons head_852 ErlangEmptyList))
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_846 = ErlangTuple [tup_el_847, tup_el_848]
        in let tup_el_861 = toErl "size"
        in let
          arg_863 =
            BIF.erlang__apply__2
              [map_116, ErlangCons k_247 (ErlangCons v_248 ErlangEmptyList)]
        in let
          tup_el_862 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons arg_863 (ErlangCons int_8 ErlangEmptyList)]
        in let head_860 = ErlangTuple [tup_el_861, tup_el_862]
        in let
          tup_el_765 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_767
                    (ErlangCons head_782
                       (ErlangCons head_797
                          (ErlangCons head_813
                             (ErlangCons head_829
                                (ErlangCons head_846
                                   (ErlangCons head_860 ErlangEmptyList)))))))
                 ErlangEmptyList]
        in let
          head_875 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          mapscope_879 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_765, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_875 ErlangEmptyList]
        in let tup_el_884 = toErl "verify_sig"
        in let
          tup_el_885 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons hash_24
                    (ErlangCons address_20
                       (ErlangCons signid_191 ErlangEmptyList)))
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_883 = ErlangTuple [tup_el_884, tup_el_885]
        in let tup_el_897 = toErl "verify_sig_secp256k1"
        in let arg_903 = toErl 64
        in let
          head_902 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_903 ErlangEmptyList]
        in let
          tup_el_898 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons hash_24
                    (ErlangCons head_902
                       (ErlangCons signid_191 ErlangEmptyList)))
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_896 = ErlangTuple [tup_el_897, tup_el_898]
        in let tup_el_912 = toErl "ecverify_secp256k1"
        in let arg_918 = toErl 20
        in let
          head_917 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_918 ErlangEmptyList]
        in let arg_922 = toErl 65
        in let
          head_921 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_922 ErlangEmptyList]
        in let
          tup_el_913 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons hash_24
                    (ErlangCons head_917 (ErlangCons head_921 ErlangEmptyList)))
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_911 = ErlangTuple [tup_el_912, tup_el_913]
        in let tup_el_929 = toErl "ecrecover_secp256k1"
        in let arg_935 = toErl 65
        in let
          head_934 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_935 ErlangEmptyList]
        in let arg_940 = toErl 20
        in let
          arg_939 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons arg_940 ErlangEmptyList]
        in let
          arg_938 =
            BIF.erlang__apply__2
              [option_99, ErlangCons arg_939 ErlangEmptyList]
        in let
          tup_el_930 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons hash_24 (ErlangCons head_934 ErlangEmptyList))
                 (ErlangCons arg_938 ErlangEmptyList)]
        in let head_928 = ErlangTuple [tup_el_929, tup_el_930]
        in let tup_el_946 = toErl "sha3"
        in let
          tup_el_947 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons a_244 (ErlangCons hash_24 ErlangEmptyList)]
        in let head_945 = ErlangTuple [tup_el_946, tup_el_947]
        in let tup_el_953 = toErl "sha256"
        in let
          tup_el_954 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons a_244 (ErlangCons hash_24 ErlangEmptyList)]
        in let head_952 = ErlangTuple [tup_el_953, tup_el_954]
        in let tup_el_960 = toErl "blake2b"
        in let
          tup_el_961 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons a_244 (ErlangCons hash_24 ErlangEmptyList)]
        in let head_959 = ErlangTuple [tup_el_960, tup_el_961]
        in let
          tup_el_881 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_883
                    (ErlangCons head_896
                       (ErlangCons head_911
                          (ErlangCons head_928
                             (ErlangCons head_945
                                (ErlangCons head_952
                                   (ErlangCons head_959 ErlangEmptyList)))))))
                 ErlangEmptyList]
        in let
          head_971 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          cryptoscope_975 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_881, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_971 ErlangEmptyList]
        in let tup_el_980 = toErl "tx_hash"
        in let
          tup_el_981 =
            BIF.erlang__apply__2
              [option_99, ErlangCons hash_24 ErlangEmptyList]
        in let head_979 = ErlangTuple [tup_el_980, tup_el_981]
        in let
          tup_el_977 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons (ErlangCons head_979 ErlangEmptyList) ErlangEmptyList]
        in let
          head_990 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          authscope_994 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_977, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_990 ErlangEmptyList]
        in let tup_el_999 = toErl "length"
        in let
          tup_el_1000 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons string_16 (ErlangCons int_8 ErlangEmptyList)]
        in let head_998 = ErlangTuple [tup_el_999, tup_el_1000]
        in let tup_el_1006 = toErl "concat"
        in let
          tup_el_1007 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons string_16 (ErlangCons string_16 ErlangEmptyList))
                 (ErlangCons string_16 ErlangEmptyList)]
        in let head_1005 = ErlangTuple [tup_el_1006, tup_el_1007]
        in let tup_el_1017 = toErl "sha3"
        in let
          tup_el_1018 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons string_16 (ErlangCons hash_24 ErlangEmptyList)]
        in let head_1016 = ErlangTuple [tup_el_1017, tup_el_1018]
        in let tup_el_1024 = toErl "sha256"
        in let
          tup_el_1025 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons string_16 (ErlangCons hash_24 ErlangEmptyList)]
        in let head_1023 = ErlangTuple [tup_el_1024, tup_el_1025]
        in let tup_el_1031 = toErl "blake2b"
        in let
          tup_el_1032 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons string_16 (ErlangCons hash_24 ErlangEmptyList)]
        in let head_1030 = ErlangTuple [tup_el_1031, tup_el_1032]
        in let
          tup_el_996 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_998
                    (ErlangCons head_1005
                       (ErlangCons head_1016
                          (ErlangCons head_1023
                             (ErlangCons head_1030 ErlangEmptyList)))))
                 ErlangEmptyList]
        in let
          head_1042 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          stringscope_1046 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_996, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1042 ErlangEmptyList]
        in let tup_el_1051 = toErl "set"
        in let
          tup_el_1052 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bits_28 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons bits_28 ErlangEmptyList)]
        in let head_1050 = ErlangTuple [tup_el_1051, tup_el_1052]
        in let tup_el_1062 = toErl "clear"
        in let
          tup_el_1063 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bits_28 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons bits_28 ErlangEmptyList)]
        in let head_1061 = ErlangTuple [tup_el_1062, tup_el_1063]
        in let tup_el_1073 = toErl "test"
        in let
          tup_el_1074 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bits_28 (ErlangCons int_8 ErlangEmptyList))
                 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_1072 = ErlangTuple [tup_el_1073, tup_el_1074]
        in let tup_el_1084 = toErl "sum"
        in let
          tup_el_1085 =
            BIF.erlang__apply__2
              [fun1_164, ErlangCons bits_28 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1083 = ErlangTuple [tup_el_1084, tup_el_1085]
        in let tup_el_1091 = toErl "intersection"
        in let
          tup_el_1092 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bits_28 (ErlangCons bits_28 ErlangEmptyList))
                 (ErlangCons bits_28 ErlangEmptyList)]
        in let head_1090 = ErlangTuple [tup_el_1091, tup_el_1092]
        in let tup_el_1102 = toErl "union"
        in let
          tup_el_1103 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bits_28 (ErlangCons bits_28 ErlangEmptyList))
                 (ErlangCons bits_28 ErlangEmptyList)]
        in let head_1101 = ErlangTuple [tup_el_1102, tup_el_1103]
        in let tup_el_1113 = toErl "difference"
        in let
          tup_el_1114 =
            BIF.erlang__apply__2
              [fun_153,
               ErlangCons
                 (ErlangCons bits_28 (ErlangCons bits_28 ErlangEmptyList))
                 (ErlangCons bits_28 ErlangEmptyList)]
        in let head_1112 = ErlangTuple [tup_el_1113, tup_el_1114]
        in let tup_el_1124 = toErl "none"
        in let head_1123 = ErlangTuple [tup_el_1124, bits_28]
        in let tup_el_1128 = toErl "all"
        in let head_1127 = ErlangTuple [tup_el_1128, bits_28]
        in let
          tup_el_1048 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_1050
                    (ErlangCons head_1061
                       (ErlangCons head_1072
                          (ErlangCons head_1083
                             (ErlangCons head_1090
                                (ErlangCons head_1101
                                   (ErlangCons head_1112
                                      (ErlangCons head_1123
                                         (ErlangCons head_1127
                                            ErlangEmptyList)))))))))
                 ErlangEmptyList]
        in let
          head_1136 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          bitsscope_1140 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1048, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1136 ErlangEmptyList]
        in let tup_el_1145 = toErl "to_int"
        in let
          arg_1147 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          tup_el_1146 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons arg_1147 (ErlangCons int_8 ErlangEmptyList)]
        in let head_1144 = ErlangTuple [tup_el_1145, tup_el_1146]
        in let tup_el_1154 = toErl "to_str"
        in let
          arg_1156 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          tup_el_1155 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons arg_1156 (ErlangCons string_16 ErlangEmptyList)]
        in let head_1153 = ErlangTuple [tup_el_1154, tup_el_1155]
        in let tup_el_1163 = toErl "concat"
        in let
          head_1167 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          head_1171 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_1175 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          tup_el_1164 =
            BIF.erlang__apply__2
              [func_143,
               ErlangCons (ErlangAtom "bytes_concat")
                 (ErlangCons
                    (ErlangCons head_1167
                       (ErlangCons head_1171 ErlangEmptyList))
                    (ErlangCons arg_1175 ErlangEmptyList))]
        in let head_1162 = ErlangTuple [tup_el_1163, tup_el_1164]
        in let tup_el_1181 = toErl "split"
        in let
          head_1185 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_1190 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_1193 =
            BIF.erlang__apply__2
              [bytes_35, ErlangCons (ErlangAtom "any") ErlangEmptyList]
        in let
          arg_1189 =
            BIF.erlang__apply__2
              [pair_129,
               ErlangCons arg_1190 (ErlangCons arg_1193 ErlangEmptyList)]
        in let
          tup_el_1182 =
            BIF.erlang__apply__2
              [func_143,
               ErlangCons (ErlangAtom "bytes_split")
                 (ErlangCons (ErlangCons head_1185 ErlangEmptyList)
                    (ErlangCons arg_1189 ErlangEmptyList))]
        in let head_1180 = ErlangTuple [tup_el_1181, tup_el_1182]
        in let
          tup_el_1142 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_1144
                    (ErlangCons head_1153
                       (ErlangCons head_1162
                          (ErlangCons head_1180 ErlangEmptyList))))
                 ErlangEmptyList]
        in let
          head_1204 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          bytesscope_1208 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1142, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1204 ErlangEmptyList]
        in let tup_el_1213 = toErl "to_str"
        in let
          tup_el_1214 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons int_8 (ErlangCons string_16 ErlangEmptyList)]
        in let head_1212 = ErlangTuple [tup_el_1213, tup_el_1214]
        in let
          tup_el_1210 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons (ErlangCons head_1212 ErlangEmptyList)
                 ErlangEmptyList]
        in let
          head_1224 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          intscope_1228 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1210, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1224 ErlangEmptyList]
        in let tup_el_1233 = toErl "to_str"
        in let
          tup_el_1234 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons address_20 (ErlangCons string_16 ErlangEmptyList)]
        in let head_1232 = ErlangTuple [tup_el_1233, tup_el_1234]
        in let tup_el_1240 = toErl "to_contract"
        in let
          tup_el_1241 =
            BIF.erlang__apply__2
              [func_143,
               ErlangCons (ErlangAtom "address_to_contract")
                 (ErlangCons (ErlangCons address_20 ErlangEmptyList)
                    (ErlangCons a_244 ErlangEmptyList))]
        in let head_1239 = ErlangTuple [tup_el_1240, tup_el_1241]
        in let tup_el_1250 = toErl "is_oracle"
        in let
          tup_el_1251 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons address_20 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_1249 = ErlangTuple [tup_el_1250, tup_el_1251]
        in let tup_el_1257 = toErl "is_contract"
        in let
          tup_el_1258 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons address_20 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_1256 = ErlangTuple [tup_el_1257, tup_el_1258]
        in let tup_el_1264 = toErl "is_payable"
        in let
          tup_el_1265 =
            BIF.erlang__apply__2
              [fun1_164,
               ErlangCons address_20 (ErlangCons bool_12 ErlangEmptyList)]
        in let head_1263 = ErlangTuple [tup_el_1264, tup_el_1265]
        in let
          tup_el_1230 =
            BIF.erlang__apply__2
              [mkdefs_264,
               ErlangCons
                 (ErlangCons head_1232
                    (ErlangCons head_1239
                       (ErlangCons head_1249
                          (ErlangCons head_1256
                             (ErlangCons head_1263 ErlangEmptyList)))))
                 ErlangEmptyList]
        in let
          head_1275 =
            ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let
          addressscope_1279 =
            ErlangTuple
              [ErlangAtom "scope", tup_el_1230, ErlangEmptyList,
               ErlangAtom "public", ErlangAtom "namespace",
               ErlangCons head_1275 ErlangEmptyList]
        in let head_1284 = toErl "Chain"
        in let head_1287 = toErl "Contract"
        in let head_1290 = toErl "Call"
        in let head_1293 = toErl "Oracle"
        in let head_1296 = toErl "AENS"
        in let head_1299 = toErl "Map"
        in let head_1302 = toErl "Auth"
        in let head_1305 = toErl "Crypto"
        in let head_1308 = toErl "String"
        in let head_1311 = toErl "Bits"
        in let head_1314 = toErl "Bytes"
        in let head_1317 = toErl "Int"
        in let head_1320 = toErl "Address"
        in let
          tup_el_1281 =
            ErlangMap
              (Map.fromFoldable
                 [DT.Tuple ErlangEmptyList topscope_398,
                  DT.Tuple (ErlangCons head_1284 ErlangEmptyList)
                    chainscope_464,
                  DT.Tuple (ErlangCons head_1287 ErlangEmptyList)
                    contractscope_489,
                  DT.Tuple (ErlangCons head_1290 ErlangEmptyList) callscope_525,
                  DT.Tuple (ErlangCons head_1293 ErlangEmptyList)
                    oraclescope_687,
                  DT.Tuple (ErlangCons head_1296 ErlangEmptyList) aensscope_763,
                  DT.Tuple (ErlangCons head_1299 ErlangEmptyList) mapscope_879,
                  DT.Tuple (ErlangCons head_1302 ErlangEmptyList) authscope_994,
                  DT.Tuple (ErlangCons head_1305 ErlangEmptyList)
                    cryptoscope_975,
                  DT.Tuple (ErlangCons head_1308 ErlangEmptyList)
                    stringscope_1046,
                  DT.Tuple (ErlangCons head_1311 ErlangEmptyList)
                    bitsscope_1140,
                  DT.Tuple (ErlangCons head_1314 ErlangEmptyList)
                    bytesscope_1208,
                  DT.Tuple (ErlangCons head_1317 ErlangEmptyList) intscope_1228,
                  DT.Tuple (ErlangCons head_1320 ErlangEmptyList)
                    addressscope_1279])
        in let tup_el_1338 = ErlangMap Map.empty
        in
          ErlangTuple
            [ErlangAtom "env", tup_el_1281, ErlangEmptyList,
             ErlangAtom "unrestricted", tup_el_1338, ErlangEmptyList,
             ErlangAtom "false", ErlangAtom "false", ErlangAtom "none",
             ErlangAtom "top"]
      _ -> EXC.badmatch matchExpr_249
erlps__global_env__0 args =
  EXC.badarity (ErlangFun 0 erlps__global_env__0) args

erlps__option_t__2 :: ErlangFun
erlps__option_t__2 [as_0, t_1] =
  let    tup_el_7 = toErl "option"
  in let tup_el_4 = ErlangTuple [ErlangAtom "id", as_0, tup_el_7]
  in
    ErlangTuple
      [ErlangAtom "app_t", as_0, tup_el_4,
       ErlangCons t_1 ErlangEmptyList]
erlps__option_t__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__option_t__2 args =
  EXC.badarity (ErlangFun 2 erlps__option_t__2) args

erlps__map_t__3 :: ErlangFun
erlps__map_t__3 [as_0, k_1, v_2] =
  let    tup_el_8 = toErl "map"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", as_0, tup_el_8]
  in
    ErlangTuple
      [ErlangAtom "app_t", as_0, tup_el_5,
       ErlangCons k_1 (ErlangCons v_2 ErlangEmptyList)]
erlps__map_t__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__map_t__3 args =
  EXC.badarity (ErlangFun 3 erlps__map_t__3) args

erlps__infer__1 :: ErlangFun
erlps__infer__1 [contracts_0] =
  erlps__infer__2 [contracts_0, ErlangEmptyList]
erlps__infer__1 [arg_3] = EXC.function_clause unit
erlps__infer__1 args =
  EXC.badarity (ErlangFun 1 erlps__infer__1) args

erlps__init_env__1 :: ErlangFun
erlps__init_env__1 [_options_0] = erlps__global_env__0 []
erlps__init_env__1 [arg_1] = EXC.function_clause unit
erlps__init_env__1 args =
  EXC.badarity (ErlangFun 1 erlps__init_env__1) args

erlps__infer__2 :: ErlangFun
erlps__infer__2 [(ErlangEmptyList), options_0] =
  let    _ = erlps__create_type_errors__0 []
  in let
    tup_el_3 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "src_file", options_0, ErlangAtom "no_file"]
  in let arg_1 = ErlangTuple [ErlangAtom "no_decls", tup_el_3]
  in let _ = erlps__type_error__1 [arg_1]
  in let arg_7 = erlps__init_env__1 [options_0]
  in erlps__destroy_and_report_type_errors__1 [arg_7]
erlps__infer__2 [contracts_0, options_1] =
  let _ = erlps__ets_init__0 []
  in
    EXC.tryCatchFinally
      (\ _ ->
         let    env_3 = erlps__init_env__1 [options_1]
         in let _ = erlps__create_options__1 [options_1]
         in let
           _ =
             erlps__ets_new__2
               [ErlangAtom "type_vars",
                ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
         in let _ = erlps__check_modifiers__2 [env_3, contracts_0]
         in let
           matchExpr_17 =
             erlps__infer1__4 [env_3, contracts_0, ErlangEmptyList, options_1]
         in
           case matchExpr_17 of
             (ErlangTuple [env1_15, decls_16]) ->
               let   
                 case_18 =
                   BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
                     [ErlangAtom "dont_unfold", options_1, ErlangAtom "false"]
               in let
                 matchExpr_41 =
                   case case_18 of
                     (ErlangAtom "true") ->
                       ErlangTuple [env1_15, decls_16, decls_16]
                     (ErlangAtom "false") ->
                       let   
                         arg_26 =
                           ErlangFun 1
                             (let
                                lambda_27 [scope_29] =
                                  erlps__unfold_record_types__2
                                    [env1_15, scope_29]
                                lambda_27 [arg_28] = EXC.function_clause unit
                                lambda_27 args =
                                  EXC.badarity (ErlangFun 1 lambda_27) args
                              in lambda_27)
                       in let e_32 = erlps__on_scopes__2 [env1_15, arg_26]
                       in let
                         tup_el_35 =
                           erlps__unfold_record_types__2 [e_32, decls_16]
                       in ErlangTuple [e_32, decls_16, tup_el_35]
                     something_else -> EXC.case_clause something_else
               in
                 case matchExpr_41 of
                   (ErlangTuple [env2_38, declsfolded_39, declsunfolded_40]) ->
                     let
                       case_42 =
                         BIF.do_remote_fun_call "Proplists"
                           "erlps__get_value__3"
                           [ErlangAtom "return_env", options_1,
                            ErlangAtom "false"]
                     in
                       case case_42 of
                         (ErlangAtom "false") ->
                           ErlangTuple [declsfolded_39, declsunfolded_40]
                         (ErlangAtom "true") ->
                           ErlangTuple
                             [env2_38, declsfolded_39, declsunfolded_40]
                         something_else -> EXC.case_clause something_else
                   _ -> EXC.badmatch matchExpr_41
             _ -> EXC.badmatch matchExpr_17)
      (\ ex_52 -> EXC.raise ex_52) (\ _ -> erlps__clean_up_ets__0 [])
erlps__infer__2 [arg_54, arg_55] = EXC.function_clause unit
erlps__infer__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer__2) args

erlps__infer1__4 :: ErlangFun
erlps__infer1__4 [env_0, (ErlangEmptyList), acc_1, _options_2] =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in ErlangTuple [env_0, tup_el_4]
erlps__infer1__4 [env_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "contract"), ann_1,
                                            conname_2, code_3]) rest_4),
                  acc_5, options_6]
  =
  let   
    _ =
      erlps__check_scope_name_clash__3
        [env_0, ErlangAtom "contract", conname_2]
  in let
    what_10 =
      case ErlangAtom "true" of
        _ | weakEq rest_4 ErlangEmptyList -> ErlangAtom "main_contract"
        _ -> ErlangAtom "contract"
  in let
    arg_11 =
      erlps__push_scope__3 [ErlangAtom "contract", conname_2, env_0]
  in let
    matchExpr_20 =
      erlps__infer_contract_top__4 [arg_11, what_10, code_3, options_6]
  in
    case matchExpr_20 of
      (ErlangTuple [env1_18, code1_19]) ->
        let   
          contract1_25 =
            ErlangTuple [ErlangAtom "contract", ann_1, conname_2, code1_19]
        in let env2_27 = erlps__pop_scope__1 [env1_18]
        in let env3_30 = erlps__bind_contract__2 [contract1_25, env2_27]
        in
          erlps__infer1__4
            [env3_30, rest_4, ErlangCons contract1_25 acc_5, options_6]
      _ -> EXC.badmatch matchExpr_20
erlps__infer1__4 [env_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "namespace"), ann_1,
                                            name_2, code_3]) rest_4),
                  acc_5, options_6]
  =
  let   
    _ =
      erlps__check_scope_name_clash__3
        [env_0, ErlangAtom "namespace", name_2]
  in let
    arg_10 =
      erlps__push_scope__3 [ErlangAtom "namespace", name_2, env_0]
  in let
    matchExpr_19 =
      erlps__infer_contract_top__4
        [arg_10, ErlangAtom "namespace", code_3, options_6]
  in
    case matchExpr_19 of
      (ErlangTuple [env1_17, code1_18]) ->
        let   
          namespace1_24 =
            ErlangTuple [ErlangAtom "namespace", ann_1, name_2, code1_18]
        in let arg_25 = erlps__pop_scope__1 [env1_17]
        in
          erlps__infer1__4
            [arg_25, rest_4, ErlangCons namespace1_24 acc_5, options_6]
      _ -> EXC.badmatch matchExpr_19
erlps__infer1__4 [env_0,
                  (ErlangCons (ErlangTuple [(ErlangAtom "pragma"), _,
                                            _]) rest_1),
                  acc_2, options_3]
  =
  erlps__infer1__4 [env_0, rest_1, acc_2, options_3]
erlps__infer1__4 [arg_8, arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__infer1__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer1__4) args

erlps__check_scope_name_clash__3 :: ErlangFun
erlps__check_scope_name_clash__3 [env_0, kind_1, name_2] =
  let    arg_5 = erlps__qname__1 [name_2]
  in let case_3 = erlps__get_scope__2 [env_0, arg_5]
  in
    case case_3 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      (ErlangTuple [(ErlangAtom "scope"), _, _, _, k_7, ann_8]) ->
        let    _ = erlps__create_type_errors__0 []
        in let
          arg_9 =
            ErlangTuple
              [ErlangAtom "duplicate_scope", kind_1, name_2, k_7, ann_8]
        in let _ = erlps__type_error__1 [arg_9]
        in erlps__destroy_and_report_type_errors__1 [env_0]
      something_else -> EXC.case_clause something_else
erlps__check_scope_name_clash__3 [arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__check_scope_name_clash__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_scope_name_clash__3) args

erlps__infer_contract_top__4 :: ErlangFun
erlps__infer_contract_top__4 [env_0, kind_1, defs0_2, options_3]
  =
  let    _ = erlps__create_type_errors__0 []
  in let defs_5 = erlps__desugar__1 [defs0_2]
  in let _ = erlps__destroy_and_report_type_errors__1 [env_0]
  in erlps__infer_contract__4 [env_0, kind_1, defs_5, options_3]
erlps__infer_contract_top__4 [arg_11, arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__infer_contract_top__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_contract_top__4) args

erlps__infer_contract__4 :: ErlangFun
erlps__infer_contract__4 [env0_0, what_1, defs0_2, options_3] =
  let    _ = erlps__create_type_errors__0 []
  in let defs01_5 = erlps__process_blocks__1 [defs0_2]
  in let
    case_6 =
      BIF.lists__member__2 [ErlangAtom "debug_mode", options_3]
  in let
    defs_11 =
      case case_6 of
        (ErlangAtom "true") ->
          erlps__expose_internals__2 [defs01_5, what_1]
        (ErlangAtom "false") -> defs01_5
        something_else -> EXC.case_clause something_else
  in let _ = erlps__destroy_and_report_type_errors__1 [env0_0]
  in let
    env_24 =
      case env0_0 of
        (ErlangTuple [(ErlangAtom "env"), scopes_15, vars_16,
                      typevars_17, fields_18, namespace_19, in_pattern_20,
                      stateful_21, current_function_22, what_23]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_15, vars_16, typevars_17, fields_18,
             namespace_19, in_pattern_20, stateful_21, current_function_22,
             what_1]
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    kind_27 =
      ErlangFun 1
        (let
           lambda_25 [(ErlangTuple [(ErlangAtom "type_def"), _, _, _, _])] =
             ErlangAtom "type"
           lambda_25 [(ErlangTuple [(ErlangAtom "letfun"), _, _, _, _, _])]
             =
             ErlangAtom "function"
           lambda_25 [(ErlangTuple [(ErlangAtom "fun_clauses"), _, _, _,
                                    _])]
             =
             ErlangAtom "function"
           lambda_25 [(ErlangTuple [(ErlangAtom "fun_decl"), _, _, _])] =
             ErlangAtom "prototype"
           lambda_25 [_] = ErlangAtom "unexpected"
           lambda_25 [arg_26] = EXC.function_clause unit
           lambda_25 args = EXC.badarity (ErlangFun 1 lambda_25) args
         in lambda_25)
  in let
    get_40 =
      ErlangFun 1
        (let
           lambda_28 [k_30] =
             flmap
               (\ lc_33 ->
                  let   
                    lop_35 =
                      BIF.erlang__apply__2
                        [kind_27, ErlangCons lc_33 ErlangEmptyList]
                  in let cond_34 = BIF.erlang__op_eq [lop_35, k_30]
                  in
                    case cond_34 of
                      (ErlangAtom "true") -> ErlangCons lc_33 ErlangEmptyList
                      _ -> ErlangEmptyList)
               defs_11
           lambda_28 [arg_29] = EXC.function_clause unit
           lambda_28 args = EXC.badarity (ErlangFun 1 lambda_28) args
         in lambda_28)
  in let
    arg_42 =
      BIF.erlang__apply__2
        [get_40, ErlangCons (ErlangAtom "type") ErlangEmptyList]
  in let matchExpr_47 = erlps__check_typedefs__2 [env_24, arg_42]
  in
    case matchExpr_47 of
      (ErlangTuple [env1_45, typedefs_46]) ->
        let    _ = erlps__create_type_errors__0 []
        in let
          arg_48 =
            BIF.erlang__apply__2
              [get_40, ErlangCons (ErlangAtom "unexpected") ErlangEmptyList]
        in let _ = erlps__check_unexpected__1 [arg_48]
        in let
          env2_53 =
            case what_1 of
              (ErlangAtom "namespace") -> env1_45
              (ErlangAtom "contract") -> env1_45
              (ErlangAtom "main_contract") -> erlps__bind_state__1 [env1_45]
              something_else -> EXC.case_clause something_else
        in let
          lcSrc_55 =
            BIF.erlang__apply__2
              [get_40, ErlangCons (ErlangAtom "prototype") ErlangEmptyList]
        in let
          arg_54 =
            flmap
              (\ lc_59 ->
                 let lcRet_60 = erlps__check_fundecl__2 [env1_45, lc_59]
                 in ErlangCons lcRet_60 ErlangEmptyList)
              lcSrc_55
        in let
          matchExpr_65 =
            BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_54]
        in
          case matchExpr_65 of
            (ErlangTuple [protosigs_63, decls_64]) ->
              let    env3_68 = erlps__bind_funs__2 [protosigs_63, env2_53]
              in let
                functions_71 =
                  BIF.erlang__apply__2
                    [get_40, ErlangCons (ErlangAtom "function") ErlangEmptyList]
              in let
                funbind_88 =
                  ErlangFun 1
                    (let
                       lambda_72 [(ErlangTuple [(ErlangAtom "letfun"), ann_74,
                                                (ErlangTuple [(ErlangAtom "id"),
                                                              _, fun_75]),
                                                _, _, _])]
                         =
                         let
                           tup_el_77 =
                             ErlangTuple
                               [ErlangAtom "tuple_t", ann_74, ErlangEmptyList]
                         in ErlangTuple [fun_75, tup_el_77]
                       lambda_72 [(ErlangTuple [(ErlangAtom "fun_clauses"),
                                                ann_81,
                                                (ErlangTuple [(ErlangAtom "id"),
                                                              _, fun_82]),
                                                _, _])]
                         =
                         let
                           tup_el_84 =
                             ErlangTuple
                               [ErlangAtom "tuple_t", ann_81, ErlangEmptyList]
                         in ErlangTuple [fun_82, tup_el_84]
                       lambda_72 [arg_73] = EXC.function_clause unit
                       lambda_72 args =
                         EXC.badarity (ErlangFun 1 lambda_72) args
                     in lambda_72)
              in let
                funname_96 =
                  ErlangFun 1
                    (let
                       lambda_89 [def_91] =
                         let
                           matchExpr_95 =
                             BIF.erlang__apply__2
                               [funbind_88, ErlangCons def_91 ErlangEmptyList]
                         in
                           case matchExpr_95 of
                             (ErlangTuple [name_94, _]) -> name_94
                             _ -> EXC.badmatch matchExpr_95
                       lambda_89 [arg_90] = EXC.function_clause unit
                       lambda_89 args =
                         EXC.badarity (ErlangFun 1 lambda_89) args
                     in lambda_89)
              in let
                arg_97 =
                  BIF.do_remote_fun_call "Lists" "erlps__map__2"
                    [funbind_88, functions_71]
              in let
                head_111 =
                  ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
              in let
                val_104 =
                  ErlangTuple
                    [ErlangAtom "scope", ErlangEmptyList, ErlangEmptyList,
                     ErlangAtom "public", ErlangAtom "namespace",
                     ErlangCons head_111 ErlangEmptyList]
              in let
                tup_el_102 = ErlangMap (Map.singleton ErlangEmptyList val_104)
              in let tup_el_117 = ErlangMap Map.empty
              in let
                arg_100 =
                  ErlangTuple
                    [ErlangAtom "env", tup_el_102, ErlangEmptyList,
                     ErlangAtom "unrestricted", tup_el_117, ErlangEmptyList,
                     ErlangAtom "false", ErlangAtom "false", ErlangAtom "none",
                     ErlangAtom "top"]
              in let matchExpr_123 = erlps__bind_funs__2 [arg_97, arg_100]
              in let
                arg_124 =
                  flmap
                    (\ lc_127 ->
                       let   
                         tup_el_129 =
                           BIF.erlang__apply__2
                             [funname_96, ErlangCons lc_127 ErlangEmptyList]
                       in let lcRet_128 = ErlangTuple [tup_el_129, lc_127]
                       in ErlangCons lcRet_128 ErlangEmptyList)
                    functions_71
              in let funmap_133 = BIF.maps__from_list__1 [arg_124]
              in let _ = erlps__check_reserved_entrypoints__1 [funmap_133]
              in let
                arg_135 =
                  ErlangFun 2
                    (let
                       lambda_136 [_, def_139] =
                         BIF.do_remote_fun_call "Aeso.Syntax.Utils"
                           "erlps__used_ids__1" [def_139]
                       lambda_136 [arg_137, arg_138] = EXC.function_clause unit
                       lambda_136 args =
                         EXC.badarity (ErlangFun 2 lambda_136) args
                     in lambda_136)
              in let
                depgraph_142 =
                  BIF.do_remote_fun_call "Maps" "erlps__map__2"
                    [arg_135, funmap_133]
              in let
                sccs_144 =
                  BIF.do_remote_fun_call "Aeso.Utils" "erlps__scc__1"
                    [depgraph_142]
              in let
                matchExpr_151 =
                  erlps__check_sccs__4
                    [env3_68, funmap_133, sccs_144, ErlangEmptyList]
              in
                case matchExpr_151 of
                  (ErlangTuple [env4_149, defs1_150]) ->
                    let   
                      _ =
                        erlps__check_state_dependencies__2 [env4_149, defs1_150]
                    in let
                      _ = erlps__destroy_and_report_type_errors__1 [env4_149]
                    in let rop_158 = BIF.erlang__op_append [decls_64, defs1_150]
                    in let
                      tup_el_156 = BIF.erlang__op_append [typedefs_46, rop_158]
                    in ErlangTuple [env4_149, tup_el_156]
                  _ -> EXC.badmatch matchExpr_151
            _ -> EXC.badmatch matchExpr_65
      _ -> EXC.badmatch matchExpr_47
erlps__infer_contract__4 [arg_161, arg_162, arg_163, arg_164] =
  EXC.function_clause unit
erlps__infer_contract__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_contract__4) args

erlps__process_blocks__1 :: ErlangFun
erlps__process_blocks__1 [decls_0] =
  let
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "block"), ann_4, ds_5])] =
             erlps__process_block__2 [ann_4, ds_5]
           lambda_2 [decl_8] = ErlangCons decl_8 ErlangEmptyList
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in
    BIF.do_remote_fun_call "Lists" "erlps__flatmap__2"
      [arg_1, decls_0]
erlps__process_blocks__1 [arg_12] = EXC.function_clause unit
erlps__process_blocks__1 args =
  EXC.badarity (ErlangFun 1 erlps__process_blocks__1) args

erlps__process_block__2 :: ErlangFun
erlps__process_block__2 [_, (ErlangEmptyList)] = ErlangEmptyList
erlps__process_block__2 [_,
                         (ErlangCons decl_0 (ErlangEmptyList))]
  =
  ErlangCons decl_0 ErlangEmptyList
erlps__process_block__2 [_ann_0, (ErlangCons decl_1 decls_2)] =
  let
    isthis_11 =
      ErlangFun 1
        (let
           lambda_3 [name_5] =
             ErlangFun 1
               (let
                  lambda_6 [(ErlangTuple [(ErlangAtom "letfun"), _,
                                          (ErlangTuple [(ErlangAtom "id"), _,
                                                        name1_8]),
                                          _, _, _])]
                    =
                    BIF.erlang__op_eq [name_5, name1_8]
                  lambda_6 [_] = ErlangAtom "false"
                  lambda_6 [arg_7] = EXC.function_clause unit
                  lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
                in lambda_6)
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in
    case decl_1 of
      (ErlangTuple [(ErlangAtom "fun_decl"), ann1_13,
                    id_15@(ErlangTuple [(ErlangAtom "id"), _, name_14]),
                    type_16]) ->
        let   
          arg_17 =
            BIF.erlang__apply__2
              [isthis_11, ErlangCons name_14 ErlangEmptyList]
        in let
          matchExpr_23 =
            BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
              [arg_17, decls_2]
        in
          case matchExpr_23 of
            (ErlangTuple [clauses_21, rest_22]) ->
              let   
                _ =
                  flmap
                    (\ lc_26 ->
                       let   
                         arg_28 =
                           ErlangTuple
                             [ErlangAtom "mismatched_decl_in_funblock", name_14,
                              lc_26]
                       in let lcRet_27 = erlps__type_error__1 [arg_28]
                       in ErlangCons lcRet_27 ErlangEmptyList)
                    rest_22
              in let
                head_32 =
                  ErlangTuple
                    [ErlangAtom "fun_clauses", ann1_13, id_15, type_16,
                     clauses_21]
              in ErlangCons head_32 ErlangEmptyList
            _ -> EXC.badmatch matchExpr_23
      (ErlangTuple [(ErlangAtom "letfun"), ann1_39,
                    id_41@(ErlangTuple [(ErlangAtom "id"), _, name_40]), _, _,
                    _]) ->
        let   
          arg_42 =
            BIF.erlang__apply__2
              [isthis_11, ErlangCons name_40 ErlangEmptyList]
        in let
          matchExpr_50 =
            BIF.do_remote_fun_call "Lists" "erlps__splitwith__2"
              [arg_42, ErlangCons decl_1 decls_2]
        in
          case matchExpr_50 of
            (ErlangTuple [clauses_48, rest_49]) ->
              let   
                _ =
                  flmap
                    (\ lc_53 ->
                       let   
                         arg_55 =
                           ErlangTuple
                             [ErlangAtom "mismatched_decl_in_funblock", name_40,
                              lc_53]
                       in let lcRet_54 = erlps__type_error__1 [arg_55]
                       in ErlangCons lcRet_54 ErlangEmptyList)
                    rest_49
              in let
                head_66 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
              in let tup_el_70 = toErl "_"
              in let
                tup_el_63 =
                  ErlangTuple
                    [ErlangAtom "id", ErlangCons head_66 ann1_39, tup_el_70]
              in let
                head_59 =
                  ErlangTuple
                    [ErlangAtom "fun_clauses", ann1_39, id_41, tup_el_63,
                     clauses_48]
              in ErlangCons head_59 ErlangEmptyList
            _ -> EXC.badmatch matchExpr_50
      something_else -> EXC.case_clause something_else
erlps__process_block__2 [arg_73, arg_74] =
  EXC.function_clause unit
erlps__process_block__2 args =
  EXC.badarity (ErlangFun 2 erlps__process_block__2) args

erlps__expose_internals__2 :: ErlangFun
erlps__expose_internals__2 [defs_0, what_1] =
  flmap
    (\ lc_4 ->
       let    arg_6 = toErl 2
       in let ann_8 = BIF.erlang__element__2 [arg_6, lc_4]
       in let
         newann_26 =
           case what_1 of
             (ErlangAtom "namespace") ->
               flmap
                 (\ lc_12 ->
                    let   
                      rop_15 =
                        ErlangTuple [ErlangAtom "private", ErlangAtom "true"]
                    in let cond_13 = BIF.erlang__op_neq [lc_12, rop_15]
                    in
                      case cond_13 of
                        (ErlangAtom "true") ->
                          let
                            cond_18 =
                              BIF.erlang__op_neq [lc_12, ErlangAtom "private"]
                          in
                            case cond_18 of
                              (ErlangAtom "true") ->
                                ErlangCons lc_12 ErlangEmptyList
                              _ -> ErlangEmptyList
                        _ -> ErlangEmptyList)
                 ann_8
             (ErlangAtom "main_contract") ->
               let
                 head_22 =
                   ErlangTuple [ErlangAtom "entrypoint", ErlangAtom "true"]
               in ErlangCons head_22 ann_8
             (ErlangAtom "contract") -> ann_8
             something_else -> EXC.case_clause something_else
       in let arg_27 = toErl 2
       in let
         def1_30 = BIF.erlang__setelement__3 [arg_27, lc_4, newann_26]
       in let
         lcRet_5 =
           case def1_30 of
             (ErlangTuple [(ErlangAtom "fun_clauses"), ans_32, id_33, t_34,
                           clauses_35]) ->
               let tup_el_40 = erlps__expose_internals__2 [clauses_35, what_1]
               in
                 ErlangTuple
                   [ErlangAtom "fun_clauses", ans_32, id_33, t_34, tup_el_40]
             _ -> def1_30
       in ErlangCons lcRet_5 ErlangEmptyList)
    defs_0
erlps__expose_internals__2 [arg_43, arg_44] =
  EXC.function_clause unit
erlps__expose_internals__2 args =
  EXC.badarity (ErlangFun 2 erlps__expose_internals__2) args

erlps__check_typedefs__2 :: ErlangFun
erlps__check_typedefs__2 [env_1@(ErlangTuple [(ErlangAtom "env"),
                                              _, _, _, _, ns_0, _, _, _, _]),
                          defs_2]
  =
  let    _ = erlps__create_type_errors__0 []
  in let
    getname_6 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "type_def"), _,
                                   (ErlangTuple [(ErlangAtom "id"), _, name_5]),
                                   _, _])]
             =
             name_5
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    arg_7 =
      flmap
        (\ lc_10 ->
           let   
             tup_el_12 =
               BIF.erlang__apply__2
                 [getname_6, ErlangCons lc_10 ErlangEmptyList]
           in let lcRet_11 = ErlangTuple [tup_el_12, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        defs_2
  in let typemap_16 = BIF.maps__from_list__1 [arg_7]
  in let
    arg_17 =
      ErlangFun 2
        (let
           lambda_18 [_, def_21] =
             BIF.do_remote_fun_call "Aeso.Syntax.Utils" "erlps__used_types__2"
               [ns_0, def_21]
           lambda_18 [arg_19, arg_20] = EXC.function_clause unit
           lambda_18 args = EXC.badarity (ErlangFun 2 lambda_18) args
         in lambda_18)
  in let
    depgraph_25 =
      BIF.do_remote_fun_call "Maps" "erlps__map__2"
        [arg_17, typemap_16]
  in let
    sccs_27 =
      BIF.do_remote_fun_call "Aeso.Utils" "erlps__scc__1" [depgraph_25]
  in let
    matchExpr_34 =
      erlps__check_typedef_sccs__4
        [env_1, typemap_16, sccs_27, ErlangEmptyList]
  in
    case matchExpr_34 of
      (ErlangTuple [env1_32, defs1_33]) ->
        let _ = erlps__destroy_and_report_type_errors__1 [env_1]
        in ErlangTuple [env1_32, defs1_33]
      _ -> EXC.badmatch matchExpr_34
erlps__check_typedefs__2 [arg_38, arg_39] =
  EXC.function_clause unit
erlps__check_typedefs__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_typedefs__2) args

erlps__check_typedef_sccs__4 :: ErlangFun
erlps__check_typedef_sccs__4 [env_0, _typemap_1,
                              (ErlangEmptyList), acc_2]
  =
  let
    tup_el_4 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_2]
  in ErlangTuple [env_0, tup_el_4]
erlps__check_typedef_sccs__4 [env_0, typemap_1,
                              (ErlangCons (ErlangTuple [(ErlangAtom "acyclic"),
                                                        name_2]) sccs_3),
                              acc_4]
  =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_2, typemap_1, ErlangAtom "undefined"]
  in
    case case_5 of
      (ErlangAtom "undefined") ->
        erlps__check_typedef_sccs__4 [env_0, typemap_1, sccs_3, acc_4]
      (ErlangTuple [(ErlangAtom "type_def"), ann_13, d_14, xs_15,
                    def0_16]) ->
        let    arg_21 = erlps__bind_tvars__2 [xs_15, env_0]
        in let arg_20 = erlps__check_typedef__2 [arg_21, def0_16]
        in let
          def_25 = erlps__check_event__4 [env_0, name_2, ann_13, arg_20]
        in let
          head_26 =
            ErlangTuple [ErlangAtom "type_def", ann_13, d_14, xs_15, def_25]
        in let arg_36 = ErlangTuple [xs_15, def_25]
        in let
          env1_40 = erlps__bind_type__4 [name_2, ann_13, arg_36, env_0]
        in
          case def_25 of
            (ErlangTuple [(ErlangAtom "alias_t"), _]) ->
              erlps__check_typedef_sccs__4
                [env1_40, typemap_1, sccs_3, ErlangCons head_26 acc_4]
            (ErlangTuple [(ErlangAtom "record_t"), fields_46]) ->
              let    arg_48 = erlps__app_t__3 [ann_13, d_14, xs_15]
              in let recty_52 = erlps__check_type__2 [env1_40, arg_48]
              in let
                env2_57 =
                  erlps__check_fields__4
                    [env1_40, typemap_1, recty_52, fields_46]
              in
                erlps__check_typedef_sccs__4
                  [env2_57, typemap_1, sccs_3, ErlangCons head_26 acc_4]
            (ErlangTuple [(ErlangAtom "variant_t"), cons_62]) ->
              let    arg_64 = erlps__app_t__3 [ann_13, d_14, xs_15]
              in let target_68 = erlps__check_type__2 [env1_40, arg_64]
              in let
                contype_78 =
                  ErlangFun 1
                    (let
                       lambda_69 [(ErlangEmptyList)] = target_68
                       lambda_69 [args_71] =
                         ErlangTuple
                           [ErlangAtom "type_sig", ann_13, ErlangAtom "none",
                            ErlangEmptyList, args_71, target_68]
                       lambda_69 [arg_70] = EXC.function_clause unit
                       lambda_69 args =
                         EXC.badarity (ErlangFun 1 lambda_69) args
                     in lambda_69)
              in let
                contypes_90 =
                  flmap
                    (\ lc_81 ->
                       case lc_81 of
                         (ErlangTuple [(ErlangAtom "constr_t"), _,
                                       (ErlangTuple [(ErlangAtom "con"), _,
                                                     con_83]),
                                       args_84]) ->
                           let
                             tup_el_87 =
                               BIF.erlang__apply__2
                                 [contype_78,
                                  ErlangCons args_84 ErlangEmptyList]
                             lcRet_82 = ErlangTuple [con_83, tup_el_87]
                           in ErlangCons lcRet_82 ErlangEmptyList
                         _ -> EXC.badmatch lc_81)
                    cons_62
              in let
                arg_91 =
                  flmap
                    (\ lc_95 ->
                       case lc_95 of
                         (ErlangTuple [(ErlangAtom "constr_t"), _, con_93,
                                       args_94]) ->
                           let   
                             tup_el_98 =
                               BIF.erlang__apply__2
                                 [contype_78,
                                  ErlangCons args_94 ErlangEmptyList]
                           in let lcRet_96 = ErlangTuple [con_93, tup_el_98]
                           in ErlangCons lcRet_96 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    cons_62
              in let _ = erlps__check_repeated_constructors__1 [arg_91]
              in let
                _ =
                  flmap
                    (\ lc_103 ->
                       case lc_103 of
                         (ErlangTuple [(ErlangAtom "constr_t"), _, con_102,
                                       _]) ->
                           let
                             lcRet_104 =
                               erlps__check_constructor_overlap__3
                                 [env1_40, con_102, target_68]
                           in ErlangCons lcRet_104 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    cons_62
              in let arg_108 = erlps__bind_funs__2 [contypes_90, env1_40]
              in
                erlps__check_typedef_sccs__4
                  [arg_108, typemap_1, sccs_3, ErlangCons head_26 acc_4]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__check_typedef_sccs__4 [env_0, typemap_1,
                              (ErlangCons (ErlangTuple [(ErlangAtom "cyclic"),
                                                        names_2]) sccs_3),
                              acc_4]
  =
  let   
    id_12 =
      ErlangFun 1
        (let
           lambda_5 [x_7] =
             let matchExpr_11 = BIF.maps__get__2 [x_7, typemap_1]
             in
               case matchExpr_11 of
                 (ErlangTuple [(ErlangAtom "type_def"), _, d_10, _, _]) -> d_10
                 _ -> EXC.badmatch matchExpr_11
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in let
    tup_el_15 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [id_12, names_2]
  in let
    arg_13 =
      ErlangTuple
        [ErlangAtom "recursive_types_not_implemented", tup_el_15]
  in let _ = erlps__type_error__1 [arg_13]
  in erlps__check_typedef_sccs__4 [env_0, typemap_1, sccs_3, acc_4]
erlps__check_typedef_sccs__4 [arg_22, arg_23, arg_24, arg_25] =
  EXC.function_clause unit
erlps__check_typedef_sccs__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_typedef_sccs__4) args

erlps__check_typedef__2 :: ErlangFun
erlps__check_typedef__2 [env_0,
                         (ErlangTuple [(ErlangAtom "alias_t"), type_1])]
  =
  let tup_el_3 = erlps__check_type__2 [env_0, type_1]
  in ErlangTuple [ErlangAtom "alias_t", tup_el_3]
erlps__check_typedef__2 [env_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fields_1])]
  =
  let
    tup_el_3 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [(ErlangAtom "field_t"), ann_5, id_6, type_7]) ->
               let    tup_el_13 = erlps__check_type__2 [env_0, type_7]
               in let
                 lcRet_9 =
                   ErlangTuple [ErlangAtom "field_t", ann_5, id_6, tup_el_13]
               in ErlangCons lcRet_9 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_1
  in ErlangTuple [ErlangAtom "record_t", tup_el_3]
erlps__check_typedef__2 [env_0,
                         (ErlangTuple [(ErlangAtom "variant_t"), cons_1])]
  =
  let
    tup_el_3 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [(ErlangAtom "constr_t"), ann_5, con_6, args_7]) ->
               let   
                 tup_el_13 =
                   flmap
                     (\ lc_16 ->
                        let lcRet_17 = erlps__check_type__2 [env_0, lc_16]
                        in ErlangCons lcRet_17 ErlangEmptyList)
                     args_7
               in let
                 lcRet_9 =
                   ErlangTuple [ErlangAtom "constr_t", ann_5, con_6, tup_el_13]
               in ErlangCons lcRet_9 ErlangEmptyList
             _ -> ErlangEmptyList)
        cons_1
  in ErlangTuple [ErlangAtom "variant_t", tup_el_3]
erlps__check_typedef__2 [arg_20, arg_21] =
  EXC.function_clause unit
erlps__check_typedef__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_typedef__2) args

erlps__check_unexpected__1 :: ErlangFun
erlps__check_unexpected__1 [xs_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__type_error__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    xs_0
erlps__check_unexpected__1 [arg_6] = EXC.function_clause unit
erlps__check_unexpected__1 args =
  EXC.badarity (ErlangFun 1 erlps__check_unexpected__1) args

erlps__check_modifiers__2 :: ErlangFun
erlps__check_modifiers__2 [env_0, contracts_1] =
  let    _ = erlps__create_type_errors__0 []
  in let _ = erlps__check_modifiers___2 [env_0, contracts_1]
  in erlps__destroy_and_report_type_errors__1 [env_0]
erlps__check_modifiers__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__check_modifiers__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_modifiers__2) args

erlps__check_modifiers___2 :: ErlangFun
erlps__check_modifiers___2 [env_0,
                            (ErlangCons (ErlangTuple [(ErlangAtom "contract"),
                                                      _, con_1,
                                                      decls_2]) rest_3)]
  =
  let    ismain_6 = BIF.erlang__op_eq [rest_3, ErlangEmptyList]
  in let
    _ = erlps__check_modifiers1__2 [ErlangAtom "contract", decls_2]
  in let arg_12 = toErl 1
  in let
    tup_el_10 =
      BIF.lists__keymember__3 [ErlangAtom "letfun", arg_12, decls_2]
  in let
    tup_el_14 =
      flmap
        (\ lc_17 ->
           let
             cond_18 =
               BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                 [ErlangAtom "entrypoint", lc_17, ErlangAtom "false"]
           in
             case cond_18 of
               (ErlangAtom "true") -> ErlangCons lc_17 ErlangEmptyList
               _ -> ErlangEmptyList)
        decls_2
  in let case_9 = ErlangTuple [tup_el_10, tup_el_14]
  in let
    _ =
      case case_9 of
        (ErlangTuple [(ErlangAtom "true"), (ErlangEmptyList)]) ->
          let
            arg_23 =
              ErlangTuple [ErlangAtom "contract_has_no_entrypoints", con_1]
          in erlps__type_error__1 [arg_23]
        _ | (ErlangAtom "true") ==
              (falsifyErrors (\ _ -> BIF.erlang__not__1 [ismain_6])) ->
          let
            case_27 =
              flmap
                (\ lc_31 ->
                   case lc_31 of
                     (ErlangTuple [(ErlangAtom "letfun"), ann_29, id_30, _, _,
                                   _]) ->
                       let lcRet_32 = ErlangTuple [ann_29, id_30]
                       in ErlangCons lcRet_32 ErlangEmptyList
                     _ -> ErlangEmptyList)
                decls_2
          in
            case case_27 of
              (ErlangCons (ErlangTuple [ann_35, id_36]) _) ->
                let
                  arg_37 =
                    ErlangTuple
                      [ErlangAtom "definition_in_non_main_contract", ann_35,
                       id_36]
                in erlps__type_error__1 [arg_37]
              (ErlangEmptyList) -> ErlangAtom "ok"
              something_else -> EXC.case_clause something_else
        _ -> ErlangAtom "ok"
  in erlps__check_modifiers___2 [env_0, rest_3]
erlps__check_modifiers___2 [env_0,
                            (ErlangCons (ErlangTuple [(ErlangAtom "namespace"),
                                                      _, _, decls_1]) rest_2)]
  =
  let
    _ = erlps__check_modifiers1__2 [ErlangAtom "namespace", decls_1]
  in erlps__check_modifiers___2 [env_0, rest_2]
erlps__check_modifiers___2 [env_0,
                            (ErlangCons (ErlangTuple [(ErlangAtom "pragma"),
                                                      ann_1, pragma_2]) rest_3)]
  =
  let _ = erlps__check_pragma__3 [env_0, ann_1, pragma_2]
  in erlps__check_modifiers___2 [env_0, rest_3]
erlps__check_modifiers___2 [env_0, (ErlangCons decl_1 rest_2)] =
  let   
    arg_3 = ErlangTuple [ErlangAtom "bad_top_level_decl", decl_1]
  in let _ = erlps__type_error__1 [arg_3]
  in erlps__check_modifiers___2 [env_0, rest_2]
erlps__check_modifiers___2 [_env_0, (ErlangEmptyList)] =
  ErlangAtom "ok"
erlps__check_modifiers___2 [arg_1, arg_2] =
  EXC.function_clause unit
erlps__check_modifiers___2 args =
  EXC.badarity (ErlangFun 2 erlps__check_modifiers___2) args

erlps__check_pragma__3 :: ErlangFun
erlps__check_pragma__3 [_env_0, ann_1,
                        (ErlangTuple [(ErlangAtom "compiler"), op_2, ver_3])]
  =
  let
    case_4 =
      BIF.do_remote_fun_call "Aeso.Compiler"
        "erlps__numeric_version__0" []
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "error"), err_5]) ->
        let
          arg_6 =
            ErlangTuple [ErlangAtom "failed_to_get_compiler_version", err_5]
        in erlps__type_error__1 [arg_6]
      (ErlangTuple [(ErlangAtom "ok"), version_9]) ->
        let   
          strip_22 =
            ErlangFun 1
              (let
                 lambda_10 [v_12] =
                   let   
                     arg_14 =
                       ErlangFun 1
                         (let
                            lambda_15 [x_17] =
                              let rop_19 = toErl 0
                              in BIF.erlang__op_eq [x_17, rop_19]
                            lambda_15 [arg_16] = EXC.function_clause unit
                            lambda_15 args =
                              EXC.badarity (ErlangFun 1 lambda_15) args
                          in lambda_15)
                   in let
                     arg_20 =
                       BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [v_12]
                   in let
                     arg_13 =
                       BIF.do_remote_fun_call "Lists" "erlps__dropwhile__2"
                         [arg_14, arg_20]
                   in
                     BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_13]
                 lambda_10 [arg_11] = EXC.function_clause unit
                 lambda_10 args = EXC.badarity (ErlangFun 1 lambda_10) args
               in lambda_10)
        in let
          head_27 =
            BIF.erlang__apply__2
              [strip_22, ErlangCons version_9 ErlangEmptyList]
        in let
          head_31 =
            BIF.erlang__apply__2 [strip_22, ErlangCons ver_3 ErlangEmptyList]
        in let
          case_23 =
            BIF.erlang__apply__3
              [ErlangAtom "erlang", op_2,
               ErlangCons head_27 (ErlangCons head_31 ErlangEmptyList)]
        in
          case case_23 of
            (ErlangAtom "true") -> ErlangAtom "ok"
            (ErlangAtom "false") ->
              let
                arg_35 =
                  ErlangTuple
                    [ErlangAtom "compiler_version_mismatch", ann_1, version_9,
                     op_2, ver_3]
              in erlps__type_error__1 [arg_35]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__check_pragma__3 [arg_41, arg_42, arg_43] =
  EXC.function_clause unit
erlps__check_pragma__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_pragma__3) args

erlps__check_modifiers1__2 :: ErlangFun
erlps__check_modifiers1__2 [what_0, decls_1] | isEList decls_1 =
  let
    matchExpr_8 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__check_modifiers1__2 [what_0, lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        decls_1
  in ErlangAtom "ok"
erlps__check_modifiers1__2 [what_0, decl_1]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    arg_107 = toErl 1
            in let lop_106 = BIF.erlang__element__2 [arg_107, decl_1]
            in let lop_105 = BIF.erlang__op_eq [lop_106, ErlangAtom "letfun"]
            in
              case lop_105 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  let    arg_111 = toErl 1
                  in let lop_110 = BIF.erlang__element__2 [arg_111, decl_1]
                  in BIF.erlang__op_eq [lop_110, ErlangAtom "fun_decl"]
                _ -> EXC.badarg1 lop_105)) =
  let   
    public_5 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "public", decl_1, ErlangAtom "false"]
  in let
    private_9 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "private", decl_1, ErlangAtom "false"]
  in let
    payable_13 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "payable", decl_1, ErlangAtom "false"]
  in let
    entrypoint_17 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "entrypoint", decl_1, ErlangAtom "false"]
  in let arg_19 = toErl 1
  in let lop_18 = BIF.erlang__element__2 [arg_19, decl_1]
  in let
    fundecl_22 = BIF.erlang__op_eq [lop_18, ErlangAtom "fun_decl"]
  in let arg_23 = toErl 3
  in let matchExpr_26 = BIF.erlang__element__2 [arg_23, decl_1]
  in
    case matchExpr_26 of
      (ErlangTuple [(ErlangAtom "id"), _, name_25]) ->
        let    rop_29 = toErl "init"
        in let lop_27 = BIF.erlang__op_eq [name_25, rop_29]
        in let
          isinit_32 =
            case lop_27 of
              (ErlangAtom "false") -> ErlangAtom "false"
              (ErlangAtom "true") ->
                BIF.erlang__op_eq [what_0, ErlangAtom "contract"]
              _ -> EXC.badarg1 lop_27
        in let
          matchExpr_44 =
            case fundecl_22 of
              (ErlangAtom "true") ->
                let
                  cond_34 =
                    case private_9 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") -> BIF.erlang__not__1 [entrypoint_17]
                      _ -> EXC.badarg1 private_9
                in
                  case cond_34 of
                    (ErlangAtom "true") ->
                      let
                        cond_37 =
                          BIF.erlang__op_eq [what_0, ErlangAtom "contract"]
                      in
                        case cond_37 of
                          (ErlangAtom "true") ->
                            let   
                              arg_41 =
                                ErlangTuple
                                  [ErlangAtom "proto_must_be_entrypoint",
                                   decl_1]
                            in let lcRet_40 = erlps__type_error__1 [arg_41]
                            in ErlangCons lcRet_40 ErlangEmptyList
                          _ -> ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_53 =
            case fundecl_22 of
              (ErlangAtom "true") ->
                let cond_46 = BIF.erlang__op_eq [what_0, ErlangAtom "namespace"]
                in
                  case cond_46 of
                    (ErlangAtom "true") ->
                      let   
                        arg_50 =
                          ErlangTuple [ErlangAtom "proto_in_namespace", decl_1]
                      in let lcRet_49 = erlps__type_error__1 [arg_50]
                      in ErlangCons lcRet_49 ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let cond_54 = BIF.erlang__not__1 [entrypoint_17]
        in let
          matchExpr_61 =
            case cond_54 of
              (ErlangAtom "true") ->
                case isinit_32 of
                  (ErlangAtom "true") ->
                    let   
                      arg_58 =
                        ErlangTuple
                          [ErlangAtom "init_must_be_an_entrypoint", decl_1]
                    in let lcRet_57 = erlps__type_error__1 [arg_58]
                    in ErlangCons lcRet_57 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_68 =
            case payable_13 of
              (ErlangAtom "true") ->
                case isinit_32 of
                  (ErlangAtom "true") ->
                    let   
                      arg_65 =
                        ErlangTuple
                          [ErlangAtom "init_must_not_be_payable", decl_1]
                    in let lcRet_64 = erlps__type_error__1 [arg_65]
                    in ErlangCons lcRet_64 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_81 =
            case public_5 of
              (ErlangAtom "true") ->
                let cond_70 = BIF.erlang__not__1 [private_9]
                in
                  case cond_70 of
                    (ErlangAtom "true") ->
                      let cond_72 = BIF.erlang__not__1 [entrypoint_17]
                      in
                        case cond_72 of
                          (ErlangAtom "true") ->
                            let
                              cond_74 =
                                BIF.erlang__op_eq
                                  [what_0, ErlangAtom "contract"]
                            in
                              case cond_74 of
                                (ErlangAtom "true") ->
                                  let   
                                    arg_78 =
                                      ErlangTuple
                                        [ErlangAtom
                                           "public_modifier_in_contract",
                                         decl_1]
                                  in let
                                    lcRet_77 = erlps__type_error__1 [arg_78]
                                  in ErlangCons lcRet_77 ErlangEmptyList
                                _ -> ErlangEmptyList
                          _ -> ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_90 =
            case entrypoint_17 of
              (ErlangAtom "true") ->
                let cond_83 = BIF.erlang__op_eq [what_0, ErlangAtom "namespace"]
                in
                  case cond_83 of
                    (ErlangAtom "true") ->
                      let   
                        arg_87 =
                          ErlangTuple
                            [ErlangAtom "entrypoint_in_namespace", decl_1]
                      in let lcRet_86 = erlps__type_error__1 [arg_87]
                      in ErlangCons lcRet_86 ErlangEmptyList
                    _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_97 =
            case private_9 of
              (ErlangAtom "true") ->
                case entrypoint_17 of
                  (ErlangAtom "true") ->
                    let   
                      arg_94 =
                        ErlangTuple [ErlangAtom "private_entrypoint", decl_1]
                    in let lcRet_93 = erlps__type_error__1 [arg_94]
                    in ErlangCons lcRet_93 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in let
          matchExpr_104 =
            case private_9 of
              (ErlangAtom "true") ->
                case public_5 of
                  (ErlangAtom "true") ->
                    let   
                      arg_101 =
                        ErlangTuple [ErlangAtom "private_and_public", decl_1]
                    in let lcRet_100 = erlps__type_error__1 [arg_101]
                    in ErlangCons lcRet_100 ErlangEmptyList
                  _ -> ErlangEmptyList
              _ -> ErlangEmptyList
        in ErlangAtom "ok"
      _ -> EXC.badmatch matchExpr_26
erlps__check_modifiers1__2 [_, _] = ErlangAtom "ok"
erlps__check_modifiers1__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__check_modifiers1__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_modifiers1__2) args

erlps__check_type__2 :: ErlangFun
erlps__check_type__2 [env_0, t_1] =
  let arg_4 = toErl 0
  in erlps__check_type__3 [env_0, t_1, arg_4]
erlps__check_type__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__check_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_type__2) args

erlps__check_type__3 :: ErlangFun
erlps__check_type__3 [env_0,
                      t_1@(ErlangTuple [(ErlangAtom "tvar"), _, _]), arity_2]
  =
  let    rop_5 = toErl 0
  in let cond_3 = BIF.erlang__op_neq [arity_2, rop_5]
  in let
    _ =
      case cond_3 of
        (ErlangAtom "true") ->
          let   
            arg_7 = ErlangTuple [ErlangAtom "higher_kinded_typevar", t_1]
          in let lcRet_6 = erlps__type_error__1 [arg_7]
          in ErlangCons lcRet_6 ErlangEmptyList
        _ -> ErlangEmptyList
  in erlps__check_tvar__2 [env_0, t_1]
erlps__check_type__3 [_env_0,
                      x_3@(ErlangTuple [(ErlangAtom "id"), ann_1,
                                        (ErlangCons (ErlangInt num_2) (ErlangEmptyList))]),
                      arity_4]
  | (ErlangInt num_2) == (toErl 95) =
  let _ = erlps__ensure_base_type__2 [x_3, arity_4]
  in erlps__fresh_uvar__1 [ann_1]
erlps__check_type__3 [env_0, x_2@(ErlangTuple [tag_1, _, _]),
                      arity_3]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_30 = BIF.erlang__op_eq [tag_1, ErlangAtom "con"]
            in let
              lop_29 =
                case lop_30 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [tag_1, ErlangAtom "qcon"]
                  _ -> EXC.badarg1 lop_30
            in let
              lop_28 =
                case lop_29 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [tag_1, ErlangAtom "id"]
                  _ -> EXC.badarg1 lop_29
            in
              case lop_28 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [tag_1, ErlangAtom "qid"]
                _ -> EXC.badarg1 lop_28)) =
  let case_4 = erlps__lookup_type__2 [env_0, x_2]
  in
    case case_4 of
      (ErlangTuple [q_7, (ErlangTuple [_, def_8])]) ->
        let   
          arity1_13 =
            case def_8 of
              (ErlangTuple [(ErlangAtom "builtin"), ar_10]) -> ar_10
              (ErlangTuple [args_11, _]) -> BIF.erlang__length__1 [args_11]
              something_else -> EXC.case_clause something_else
        in let cond_14 = BIF.erlang__op_neq [arity_3, arity1_13]
        in let
          _ =
            case cond_14 of
              (ErlangAtom "true") ->
                let   
                  arg_18 =
                    ErlangTuple
                      [ErlangAtom "wrong_type_arguments", x_2, arity_3,
                       arity1_13]
                in let lcRet_17 = erlps__type_error__1 [arg_18]
                in ErlangCons lcRet_17 ErlangEmptyList
              _ -> ErlangEmptyList
        in erlps__set_qname__2 [q_7, x_2]
      (ErlangAtom "false") ->
        let    arg_25 = ErlangTuple [ErlangAtom "unbound_type", x_2]
        in let _ = erlps__type_error__1 [arg_25]
        in x_2
      something_else -> EXC.case_clause something_else
erlps__check_type__3 [env_0,
                      type_3@(ErlangTuple [(ErlangAtom "tuple_t"), ann_1,
                                           types_2]),
                      arity_4]
  =
  let    _ = erlps__ensure_base_type__2 [type_3, arity_4]
  in let
    tup_el_9 =
      flmap
        (\ lc_12 ->
           let    arg_16 = toErl 0
           in let lcRet_13 = erlps__check_type__3 [env_0, lc_12, arg_16]
           in ErlangCons lcRet_13 ErlangEmptyList)
        types_2
  in ErlangTuple [ErlangAtom "tuple_t", ann_1, tup_el_9]
erlps__check_type__3 [_env_0,
                      type_3@(ErlangTuple [(ErlangAtom "bytes_t"), _ann_1,
                                           _len_2]),
                      arity_4]
  =
  let _ = erlps__ensure_base_type__2 [type_3, arity_4]
  in type_3
erlps__check_type__3 [env_0,
                      (ErlangTuple [(ErlangAtom "app_t"), ann_1, type_2,
                                    types_3]),
                      arity_4]
  =
  let   
    types1_12 =
      flmap
        (\ lc_7 ->
           let    arg_11 = toErl 0
           in let lcRet_8 = erlps__check_type__3 [env_0, lc_7, arg_11]
           in ErlangCons lcRet_8 ErlangEmptyList)
        types_3
  in let rop_17 = BIF.erlang__length__1 [types_3]
  in let arg_15 = BIF.erlang__op_plus [arity_4, rop_17]
  in let type1_19 = erlps__check_type__3 [env_0, type_2, arg_15]
  in ErlangTuple [ErlangAtom "app_t", ann_1, type1_19, types1_12]
erlps__check_type__3 [env_0,
                      type_5@(ErlangTuple [(ErlangAtom "fun_t"), ann_1,
                                           namedargs_2, args_3, ret_4]),
                      arity_6]
  =
  let    _ = erlps__ensure_base_type__2 [type_5, arity_6]
  in let
    namedargs1_15 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__check_named_arg__2 [env_0, lc_11]
           in ErlangCons lcRet_12 ErlangEmptyList)
        namedargs_2
  in let
    args1_23 =
      flmap
        (\ lc_18 ->
           let    arg_22 = toErl 0
           in let lcRet_19 = erlps__check_type__3 [env_0, lc_18, arg_22]
           in ErlangCons lcRet_19 ErlangEmptyList)
        args_3
  in let arg_26 = toErl 0
  in let ret1_27 = erlps__check_type__3 [env_0, ret_4, arg_26]
  in
    ErlangTuple
      [ErlangAtom "fun_t", ann_1, namedargs1_15, args1_23, ret1_27]
erlps__check_type__3 [_env_0,
                      type_1@(ErlangTuple [(ErlangAtom "uvar"), _, _]), arity_2]
  =
  let _ = erlps__ensure_base_type__2 [type_1, arity_2]
  in type_1
erlps__check_type__3 [_env_0,
                      (ErlangTuple [(ErlangAtom "args_t"), ann_1, ts_2]), _]
  =
  let   
    arg_3 = ErlangTuple [ErlangAtom "new_tuple_syntax", ann_1, ts_2]
  in let _ = erlps__type_error__1 [arg_3]
  in ErlangTuple [ErlangAtom "tuple_t", ann_1, ts_2]
erlps__check_type__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__check_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_type__3) args

erlps__ensure_base_type__2 :: ErlangFun
erlps__ensure_base_type__2 [type_0, arity_1] =
  let    rop_4 = toErl 0
  in let cond_2 = BIF.erlang__op_neq [arity_1, rop_4]
  in let
    _ =
      case cond_2 of
        (ErlangAtom "true") ->
          let    tup_el_10 = toErl 0
          in let
            arg_6 =
              ErlangTuple
                [ErlangAtom "wrong_type_arguments", type_0, arity_1, tup_el_10]
          in let lcRet_5 = erlps__type_error__1 [arg_6]
          in ErlangCons lcRet_5 ErlangEmptyList
        _ -> ErlangEmptyList
  in ErlangAtom "ok"
erlps__ensure_base_type__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__ensure_base_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__ensure_base_type__2) args

erlps__check_named_arg__2 :: ErlangFun
erlps__check_named_arg__2 [env_0,
                           (ErlangTuple [(ErlangAtom "named_arg_t"), ann_1,
                                         id_2, type_3, default_4])]
  =
  let    type1_7 = erlps__check_type__2 [env_0, type_3]
  in let
    matchExpr_12 = erlps__check_expr__3 [env_0, default_4, type1_7]
  in
    case matchExpr_12 of
      (ErlangTuple [(ErlangAtom "typed"), _, default1_11, _]) ->
        ErlangTuple
          [ErlangAtom "named_arg_t", ann_1, id_2, type1_7, default1_11]
      _ -> EXC.badmatch matchExpr_12
erlps__check_named_arg__2 [arg_18, arg_19] =
  EXC.function_clause unit
erlps__check_named_arg__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_named_arg__2) args

erlps__check_fields__4 :: ErlangFun
erlps__check_fields__4 [env_0, _typemap_1, _, (ErlangEmptyList)]
  =
  env_0
erlps__check_fields__4 [env_0, typemap_1, recty_2,
                        (ErlangCons (ErlangTuple [(ErlangAtom "field_t"), ann_3,
                                                  id_4, type_5]) fields_6)]
  =
  let    arg_7 = erlps__name__1 [id_4]
  in let
    arg_9 =
      ErlangTuple
        [ErlangAtom "field_info", ann_3, type_5, recty_2,
         ErlangAtom "record"]
  in let env1_16 = erlps__bind_field__3 [arg_7, arg_9, env_0]
  in erlps__check_fields__4 [env1_16, typemap_1, recty_2, fields_6]
erlps__check_fields__4 [arg_21, arg_22, arg_23, arg_24] =
  EXC.function_clause unit
erlps__check_fields__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_fields__4) args

erlps__check_event__4 :: ErlangFun
erlps__check_event__4 [env_0,
                       (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList)))))),
                       ann_6, def_7]
  | (ErlangInt num_1) == (toErl 101)
  , (ErlangInt num_2) == (toErl 118)
  , (ErlangInt num_3) == (toErl 101)
  , (ErlangInt num_4) == (toErl 110)
  , (ErlangInt num_5) == (toErl 116) =
  case def_7 of
    (ErlangTuple [(ErlangAtom "variant_t"), cons_9]) ->
      let
        tup_el_11 =
          flmap
            (\ lc_14 ->
               let lcRet_15 = erlps__check_event_con__2 [env_0, lc_14]
               in ErlangCons lcRet_15 ErlangEmptyList)
            cons_9
      in ErlangTuple [ErlangAtom "variant_t", tup_el_11]
    _ ->
      let   
        arg_18 =
          ErlangTuple [ErlangAtom "event_must_be_variant_type", ann_6]
      in let _ = erlps__type_error__1 [arg_18]
      in def_7
erlps__check_event__4 [_env_0, _name_1, _ann_2, def_3] = def_3
erlps__check_event__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__check_event__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_event__4) args

erlps__check_event_con__2 :: ErlangFun
erlps__check_event_con__2 [env_0,
                           (ErlangTuple [(ErlangAtom "constr_t"), ann_1, con_2,
                                         args_3])]
  =
  let   
    isindexed_27 =
      ErlangFun 1
        (let
           lambda_4 [t_6] =
             let    t1_9 = erlps__unfold_types_in_type__2 [env_0, t_6]
             in let tup_el_11 = erlps__is_word_type__1 [t1_9]
             in let tup_el_13 = erlps__is_string_type__1 [t1_9]
             in let
               tup_el_15 =
                 BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                   [ErlangAtom "indexed", t_6, ErlangAtom "false"]
             in let case_10 = ErlangTuple [tup_el_11, tup_el_13, tup_el_15]
             in
               case case_10 of
                 (ErlangTuple [(ErlangAtom "true"), _, _]) ->
                   ErlangAtom "indexed"
                 (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "true"),
                               (ErlangAtom "true")]) ->
                   let
                     arg_19 =
                       ErlangTuple
                         [ErlangAtom "indexed_type_must_be_word", t_6, t1_9]
                   in erlps__type_error__1 [arg_19]
                 (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "true"), _]) ->
                   ErlangAtom "notindexed"
                 (ErlangTuple [(ErlangAtom "false"), (ErlangAtom "false"),
                               _]) ->
                   let   
                     arg_23 =
                       ErlangTuple
                         [ErlangAtom "event_arg_type_word_or_string", t_6, t1_9]
                   in let _ = erlps__type_error__1 [arg_23]
                   in ErlangAtom "error"
                 something_else -> EXC.case_clause something_else
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    indices_30 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [isindexed_27, args_3]
  in let
    indexed_40 =
      flmap
        (\ lc_33 ->
           let   
             lop_35 =
               BIF.erlang__apply__2
                 [isindexed_27, ErlangCons lc_33 ErlangEmptyList]
           in let cond_34 = BIF.erlang__op_eq [lop_35, ErlangAtom "indexed"]
           in
             case cond_34 of
               (ErlangAtom "true") -> ErlangCons lc_33 ErlangEmptyList
               _ -> ErlangEmptyList)
        args_3
  in let
    nonindexed_43 = BIF.erlang__op_unAppend [args_3, indexed_40]
  in let lop_45 = BIF.erlang__length__1 [indexed_40]
  in let rop_47 = toErl 3
  in let cond_44 = BIF.erlang__op_greater [lop_45, rop_47]
  in let
    _ =
      case cond_44 of
        (ErlangAtom "true") ->
          let   
            arg_49 =
              ErlangTuple [ErlangAtom "event_0_to_3_indexed_values", con_2]
          in let lcRet_48 = erlps__type_error__1 [arg_49]
          in ErlangCons lcRet_48 ErlangEmptyList
        _ -> ErlangEmptyList
  in let lop_53 = BIF.erlang__length__1 [nonindexed_43]
  in let rop_55 = toErl 1
  in let cond_52 = BIF.erlang__op_greater [lop_53, rop_55]
  in let
    _ =
      case cond_52 of
        (ErlangAtom "true") ->
          let   
            arg_57 =
              ErlangTuple [ErlangAtom "event_0_to_1_string_values", con_2]
          in let lcRet_56 = erlps__type_error__1 [arg_57]
          in ErlangCons lcRet_56 ErlangEmptyList
        _ -> ErlangEmptyList
  in let head_62 = ErlangTuple [ErlangAtom "indices", indices_30]
  in
    ErlangTuple
      [ErlangAtom "constr_t", ErlangCons head_62 ann_1, con_2, args_3]
erlps__check_event_con__2 [arg_68, arg_69] =
  EXC.function_clause unit
erlps__check_event_con__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_event_con__2) args

erlps__is_word_type__1 :: ErlangFun
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "id"), _,
                                      name_0])]
  =
  let    head_3 = toErl "int"
  in let head_5 = toErl "address"
  in let head_7 = toErl "hash"
  in let head_9 = toErl "bits"
  in let head_11 = toErl "bool"
  in
    BIF.lists__member__2
      [name_0,
       ErlangCons head_3
         (ErlangCons head_5
            (ErlangCons head_7
               (ErlangCons head_9 (ErlangCons head_11 ErlangEmptyList))))]
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "app_t"), _,
                                      (ErlangTuple [(ErlangAtom "id"), _,
                                                    name_0]),
                                      (ErlangCons _ (ErlangCons _ (ErlangEmptyList)))])]
  =
  let    head_3 = toErl "oracle"
  in let head_5 = toErl "oracle_query"
  in
    BIF.lists__member__2
      [name_0, ErlangCons head_3 (ErlangCons head_5 ErlangEmptyList)]
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _,
                                      n_0])]
  =
  let rop_2 = toErl 32
  in BIF.erlang__op_lesserEq [n_0, rop_2]
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "con"), _, _])]
  =
  ErlangAtom "true"
erlps__is_word_type__1 [(ErlangTuple [(ErlangAtom "qcon"), _,
                                      _])]
  =
  ErlangAtom "true"
erlps__is_word_type__1 [_] = ErlangAtom "false"
erlps__is_word_type__1 [arg_0] = EXC.function_clause unit
erlps__is_word_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_word_type__1) args

erlps__is_string_type__1 :: ErlangFun
erlps__is_string_type__1 [(ErlangTuple [(ErlangAtom "id"), _,
                                        (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList)))))))])]
  | (ErlangInt num_0) == (toErl 115)
  , (ErlangInt num_1) == (toErl 116)
  , (ErlangInt num_2) == (toErl 114)
  , (ErlangInt num_3) == (toErl 105)
  , (ErlangInt num_4) == (toErl 110)
  , (ErlangInt num_5) == (toErl 103) =
  ErlangAtom "true"
erlps__is_string_type__1 [(ErlangTuple [(ErlangAtom "bytes_t"),
                                        _, n_0])]
  =
  let rop_2 = toErl 32
  in BIF.erlang__op_greater [n_0, rop_2]
erlps__is_string_type__1 [_] = ErlangAtom "false"
erlps__is_string_type__1 [arg_0] = EXC.function_clause unit
erlps__is_string_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_string_type__1) args

erlps__check_constructor_overlap__3 :: ErlangFun
erlps__check_constructor_overlap__3 [env_0,
                                     con_3@(ErlangTuple [(ErlangAtom "con"),
                                                         ann_1, name_2]),
                                     newtype_4]
  =
  let
    case_5 =
      erlps__lookup_env__4 [env_0, ErlangAtom "term", ann_1, name_2]
  in
    case case_5 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      (ErlangTuple [_, (ErlangTuple [ann_10, type_11])]) | ann_10 ==
                                                             ann_1 ->
        let   
          oldtype_14 =
            case type_11 of
              (ErlangTuple [(ErlangAtom "type_sig"), _, _, _, _, t_13]) -> t_13
              _ -> type_11
        in let oldcon_18 = ErlangTuple [ErlangAtom "con", ann_1, name_2]
        in let head_22 = ErlangTuple [oldcon_18, oldtype_14]
        in let head_26 = ErlangTuple [con_3, newtype_4]
        in let
          arg_19 =
            ErlangTuple
              [ErlangAtom "repeated_constructor",
               ErlangCons head_22 (ErlangCons head_26 ErlangEmptyList)]
        in erlps__type_error__1 [arg_19]
      something_else -> EXC.case_clause something_else
erlps__check_constructor_overlap__3 [arg_30, arg_31, arg_32] =
  EXC.function_clause unit
erlps__check_constructor_overlap__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_constructor_overlap__3)
    args

erlps__check_repeated_constructors__1 :: ErlangFun
erlps__check_repeated_constructors__1 [cons_0] =
  let   
    names_5 =
      flmap
        (\ lc_3 ->
           case lc_3 of
             (ErlangTuple [(ErlangTuple [(ErlangAtom "con"), _, name_2]),
                           _]) ->
               ErlangCons name_2 ErlangEmptyList
             _ -> ErlangEmptyList)
        cons_0
  in let
    rop_8 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [names_5]
  in let arg_6 = BIF.erlang__op_unAppend [names_5, rop_8]
  in let
    duplicated_10 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_6]
  in let
    fail_25 =
      ErlangFun 1
        (let
           lambda_11 [name_13] =
             let   
               tup_el_16 =
                 flmap
                   (\ lc_20 ->
                      case lc_20 of
                        ct_19@(ErlangTuple [(ErlangTuple [(ErlangAtom "con"), _,
                                                          c_18]),
                                            _]) ->
                          let cond_21 = BIF.erlang__op_eq [c_18, name_13]
                          in
                            case cond_21 of
                              (ErlangAtom "true") ->
                                ErlangCons ct_19 ErlangEmptyList
                              _ -> ErlangEmptyList
                        _ -> ErlangEmptyList)
                   cons_0
             in let
               arg_14 =
                 ErlangTuple [ErlangAtom "repeated_constructor", tup_el_16]
             in erlps__type_error__1 [arg_14]
           lambda_11 [arg_12] = EXC.function_clause unit
           lambda_11 args = EXC.badarity (ErlangFun 1 lambda_11) args
         in lambda_11)
  in let
    _ =
      flmap
        (\ lc_28 ->
           let
             lcRet_29 =
               BIF.erlang__apply__2 [fail_25, ErlangCons lc_28 ErlangEmptyList]
           in ErlangCons lcRet_29 ErlangEmptyList)
        duplicated_10
  in ErlangAtom "ok"
erlps__check_repeated_constructors__1 [arg_32] =
  EXC.function_clause unit
erlps__check_repeated_constructors__1 args =
  EXC.badarity (ErlangFun 1 erlps__check_repeated_constructors__1)
    args

erlps__check_sccs__4 :: ErlangFun
erlps__check_sccs__4 [env_0, _, (ErlangEmptyList), acc_1] =
  let
    tup_el_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_1]
  in ErlangTuple [env_0, tup_el_3]
erlps__check_sccs__4 [env_0@(ErlangTuple [(ErlangAtom "env"), _,
                                          _, _, _, _, _, _, _, _]),
                      funs_1,
                      (ErlangCons (ErlangTuple [(ErlangAtom "acyclic"),
                                                x_2]) sccs_3),
                      acc_4]
  =
  let
    case_5 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [x_2, funs_1, ErlangAtom "undefined"]
  in
    case case_5 of
      (ErlangAtom "undefined") ->
        erlps__check_sccs__4 [env_0, funs_1, sccs_3, acc_4]
      def_13 ->
        let matchExpr_18 = erlps__infer_nonrec__2 [env_0, def_13]
        in
          case matchExpr_18 of
            (ErlangTuple [(ErlangTuple [_, typesig_16]), def1_17]) ->
              let env1_22 = erlps__bind_fun__3 [x_2, typesig_16, env_0]
              in
                erlps__check_sccs__4
                  [env1_22, funs_1, sccs_3, ErlangCons def1_17 acc_4]
            _ -> EXC.badmatch matchExpr_18
erlps__check_sccs__4 [env_0@(ErlangTuple [(ErlangAtom "env"), _,
                                          _, _, _, _, _, _, _, _]),
                      funs_1,
                      (ErlangCons (ErlangTuple [(ErlangAtom "cyclic"),
                                                xs_2]) sccs_3),
                      acc_4]
  =
  let   
    defs_11 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = BIF.maps__get__2 [lc_7, funs_1]
           in ErlangCons lcRet_8 ErlangEmptyList)
        xs_2
  in let matchExpr_16 = erlps__infer_letrec__2 [env_0, defs_11]
  in
    case matchExpr_16 of
      (ErlangTuple [typesigs_14, defs1_15]) ->
        let    env1_19 = erlps__bind_funs__2 [typesigs_14, env_0]
        in let arg_23 = BIF.erlang__op_append [defs1_15, acc_4]
        in erlps__check_sccs__4 [env1_19, funs_1, sccs_3, arg_23]
      _ -> EXC.badmatch matchExpr_16
erlps__check_sccs__4 [arg_26, arg_27, arg_28, arg_29] =
  EXC.function_clause unit
erlps__check_sccs__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_sccs__4) args

erlps__check_reserved_entrypoints__1 :: ErlangFun
erlps__check_reserved_entrypoints__1 [funs_0] =
  let    head_1 = toErl "address"
  in let lcSrc_4 = BIF.maps__to_list__1 [funs_0]
  in let
    matchExpr_17 =
      flmap
        (\ lc_8 ->
           case lc_8 of
             (ErlangTuple [name_6, def_7]) ->
               let
                 cond_9 =
                   BIF.lists__member__2
                     [name_6, ErlangCons head_1 ErlangEmptyList]
               in
                 case cond_9 of
                   (ErlangAtom "true") ->
                     let   
                       arg_13 =
                         ErlangTuple
                           [ErlangAtom "reserved_entrypoint", name_6, def_7]
                     in let lcRet_12 = erlps__type_error__1 [arg_13]
                     in ErlangCons lcRet_12 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_4
  in ErlangAtom "ok"
erlps__check_reserved_entrypoints__1 [arg_18] =
  EXC.function_clause unit
erlps__check_reserved_entrypoints__1 args =
  EXC.badarity (ErlangFun 1 erlps__check_reserved_entrypoints__1)
    args

erlps__check_fundecl__2 :: ErlangFun
erlps__check_fundecl__2 [env_0,
                         (ErlangTuple [(ErlangAtom "fun_decl"), ann_1,
                                       id_3@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_2]),
                                       type_4@(ErlangTuple [(ErlangAtom "fun_t"),
                                                            _, _, _, _])])]
  =
  let matchExpr_10 = erlps__check_type__2 [env_0, type_4]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangAtom "fun_t"), _, named_7, args_8,
                    ret_9]) ->
        let   
          tup_el_14 =
            ErlangTuple
              [ErlangAtom "type_sig", ann_1, ErlangAtom "none", named_7,
               args_8, ret_9]
        in let tup_el_12 = ErlangTuple [name_2, tup_el_14]
        in let
          tup_el_21 =
            ErlangTuple [ErlangAtom "fun_decl", ann_1, id_3, matchExpr_10]
        in ErlangTuple [tup_el_12, tup_el_21]
      _ -> EXC.badmatch matchExpr_10
erlps__check_fundecl__2 [env_0,
                         (ErlangTuple [(ErlangAtom "fun_decl"), ann_1,
                                       id_3@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_2]),
                                       type_4])]
  =
  let   
    arg_5 =
      ErlangTuple
        [ErlangAtom "fundecl_must_have_funtype", ann_1, id_3, type_4]
  in let _ = erlps__type_error__1 [arg_5]
  in let
    tup_el_12 =
      ErlangTuple
        [ErlangAtom "type_sig", ann_1, ErlangAtom "none",
         ErlangEmptyList, ErlangEmptyList, type_4]
  in let tup_el_10 = ErlangTuple [name_2, tup_el_12]
  in let tup_el_19 = erlps__check_type__2 [env_0, type_4]
  in ErlangTuple [tup_el_10, tup_el_19]
erlps__check_fundecl__2 [arg_22, arg_23] =
  EXC.function_clause unit
erlps__check_fundecl__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_fundecl__2) args

erlps__infer_nonrec__2 :: ErlangFun
erlps__infer_nonrec__2 [env_0, letfun_1] =
  let    _ = erlps__create_constraints__0 []
  in let newletfun_4 = erlps__infer_letfun__2 [env_0, letfun_1]
  in let _ = erlps__check_special_funs__2 [env_0, newletfun_4]
  in let
    _ = erlps__destroy_and_report_unsolved_constraints__1 [env_0]
  in let matchExpr_10 = erlps__instantiate__1 [newletfun_4]
  in
    case matchExpr_10 of
      (ErlangTuple [typesig_9, _]) ->
        let _ = erlps__print_typesig__1 [typesig_9]
        in matchExpr_10
      _ -> EXC.badmatch matchExpr_10
erlps__infer_nonrec__2 [arg_13, arg_14] =
  EXC.function_clause unit
erlps__infer_nonrec__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_nonrec__2) args

erlps__check_special_funs__2 :: ErlangFun
erlps__check_special_funs__2 [env_0,
                              (ErlangTuple [(ErlangTuple [(ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangEmptyList))))),
                                                          type_5]),
                                            _])]
  | (ErlangInt num_1) == (toErl 105)
  , (ErlangInt num_2) == (toErl 110)
  , (ErlangInt num_3) == (toErl 105)
  , (ErlangInt num_4) == (toErl 116) =
  case type_5 of
    (ErlangTuple [(ErlangAtom "type_sig"), ann_6, _constr_7,
                  _named_8, _args_9, res_10]) ->
      let    tup_el_17 = toErl "state"
      in let
        arg_14 =
          ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_17]
      in let case_12 = erlps__lookup_type__2 [env_0, arg_14]
      in let
        state_29 =
          case case_12 of
            (ErlangAtom "false") ->
              let
                head_20 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
              in
                ErlangTuple
                  [ErlangAtom "tuple_t", ErlangCons head_20 ErlangEmptyList,
                   ErlangEmptyList]
            (ErlangTuple [s_25, _]) ->
              ErlangTuple [ErlangAtom "qid", ErlangEmptyList, s_25]
            something_else -> EXC.case_clause something_else
      in let
        arg_33 = ErlangTuple [ErlangAtom "checking_init_type", ann_6]
      in erlps__unify__4 [env_0, res_10, state_29, arg_33]
    _ -> EXC.badmatch type_5
erlps__check_special_funs__2 [_, _] = ErlangAtom "ok"
erlps__check_special_funs__2 [arg_0, arg_1] =
  EXC.function_clause unit
erlps__check_special_funs__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_special_funs__2) args

erlps__typesig_to_fun_t__1 :: ErlangFun
erlps__typesig_to_fun_t__1 [(ErlangTuple [(ErlangAtom "type_sig"),
                                          ann_0, _constr_1, named_2, args_3,
                                          res_4])]
  =
  ErlangTuple [ErlangAtom "fun_t", ann_0, named_2, args_3, res_4]
erlps__typesig_to_fun_t__1 [arg_10] = EXC.function_clause unit
erlps__typesig_to_fun_t__1 args =
  EXC.badarity (ErlangFun 1 erlps__typesig_to_fun_t__1) args

erlps__infer_letrec__2 :: ErlangFun
erlps__infer_letrec__2 [env_0, defs_1] =
  let    _ = erlps__create_constraints__0 []
  in let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangTuple [(ErlangAtom "letfun"), _,
                                   (ErlangTuple [(ErlangAtom "id"), ann_5,
                                                 name_6]),
                                   _, _, _])]
             =
             let tup_el_8 = erlps__fresh_uvar__1 [ann_5]
             in ErlangTuple [name_6, tup_el_8]
           lambda_3 [(ErlangTuple [(ErlangAtom "fun_clauses"), _,
                                   (ErlangTuple [(ErlangAtom "id"), ann_10,
                                                 name_11]),
                                   _, _])]
             =
             let tup_el_13 = erlps__fresh_uvar__1 [ann_10]
             in ErlangTuple [name_11, tup_el_13]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    funs_16 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_2, defs_1]
  in let extendenv_19 = erlps__bind_funs__2 [funs_16, env_0]
  in let
    inferred_55 =
      flmap
        (\ lc_22 ->
           let matchExpr_28 = erlps__infer_letfun__2 [extendenv_19, lc_22]
           in
             case matchExpr_28 of
               (ErlangTuple [(ErlangTuple [name_26, typesig_27]), _]) ->
                 let   
                   got_32 =
                     BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
                       [name_26, funs_16]
                 in let expect_34 = erlps__typesig_to_fun_t__1 [typesig_27]
                 in let
                   arg_38 =
                     ErlangTuple
                       [ErlangAtom "check_typesig", name_26, got_32, expect_34]
                 in let _ = erlps__unify__4 [env_0, got_32, expect_34, arg_38]
                 in let _ = erlps__solve_field_constraints__1 [env_0]
                 in let
                   arg_45 =
                     ErlangFun 0
                       (let
                          lambda_46 [] =
                            let    arg_47 = toErl "Checked ~s : ~s\n"
                            in let arg_52 = erlps__dereference_deep__1 [got_32]
                            in let head_51 = erlps__pp__1 [arg_52]
                            in
                              BIF.do_remote_fun_call "Erlang.Io"
                                "erlps__format__2"
                                [arg_47,
                                 ErlangCons name_26
                                   (ErlangCons head_51 ErlangEmptyList)]
                          lambda_46 [] = EXC.function_clause unit
                          lambda_46 args =
                            EXC.badarity (ErlangFun 0 lambda_46) args
                        in lambda_46)
                 in let
                   _ = erlps__when_option__2 [ErlangAtom "pp_types", arg_45]
                 in ErlangCons matchExpr_28 ErlangEmptyList
               _ -> EXC.badmatch matchExpr_28)
        defs_1
  in let
    _ = erlps__destroy_and_report_unsolved_constraints__1 [env_0]
  in let
    arg_57 =
      flmap
        (\ lc_60 ->
           case lc_60 of
             (ErlangTuple [sig_59, _]) -> ErlangCons sig_59 ErlangEmptyList
             _ -> ErlangEmptyList)
        inferred_55
  in let typesigs_62 = erlps__instantiate__1 [arg_57]
  in let
    arg_63 =
      flmap
        (\ lc_66 ->
           case lc_66 of
             (ErlangTuple [_, d_65]) -> ErlangCons d_65 ErlangEmptyList
             _ -> ErlangEmptyList)
        inferred_55
  in let newdefs_68 = erlps__instantiate__1 [arg_63]
  in let
    _ =
      flmap
        (\ lc_71 ->
           let lcRet_72 = erlps__print_typesig__1 [lc_71]
           in ErlangCons lcRet_72 ErlangEmptyList)
        typesigs_62
  in ErlangTuple [typesigs_62, newdefs_68]
erlps__infer_letrec__2 [arg_76, arg_77] =
  EXC.function_clause unit
erlps__infer_letrec__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_letrec__2) args

erlps__infer_letfun__2 :: ErlangFun
erlps__infer_letfun__2 [env_0,
                        (ErlangTuple [(ErlangAtom "fun_clauses"), ann_1,
                                      fun_3@(ErlangTuple [(ErlangAtom "id"), _,
                                                          name_2]),
                                      type_4, clauses_5])]
  =
  let    type1_8 = erlps__check_type__2 [env_0, type_4]
  in let
    arg_9 =
      flmap
        (\ lc_12 ->
           let lcRet_13 = erlps__infer_letfun1__2 [env_0, lc_12]
           in ErlangCons lcRet_13 ErlangEmptyList)
        clauses_5
  in let
    matchExpr_18 =
      BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [arg_9]
  in
    case matchExpr_18 of
      (ErlangTuple [namesigs_16, clauses1_17]) ->
        let
          matchExpr_22 =
            BIF.do_remote_fun_call "Lists" "erlps__unzip__1" [namesigs_16]
        in
          case matchExpr_22 of
            (ErlangTuple [_, sigs_21@(ErlangCons sig_20 _)]) ->
              let   
                matchExpr_37 =
                  flmap
                    (\ lc_25 ->
                       let    clauset_28 = erlps__typesig_to_fun_t__1 [lc_25]
                       in let
                         arg_32 =
                           ErlangTuple
                             [ErlangAtom "check_typesig", name_2, clauset_28,
                              type1_8]
                         lcRet_26 =
                           erlps__unify__4 [env_0, clauset_28, type1_8, arg_32]
                       in ErlangCons lcRet_26 ErlangEmptyList)
                    sigs_21
              in let tup_el_38 = ErlangTuple [name_2, sig_20]
              in let
                tup_el_41 =
                  erlps__desugar_clauses__4 [ann_1, fun_3, sig_20, clauses1_17]
              in ErlangTuple [tup_el_38, tup_el_41]
            _ -> EXC.badmatch matchExpr_22
      _ -> EXC.badmatch matchExpr_18
erlps__infer_letfun__2 [env_0,
                        letfun_3@(ErlangTuple [(ErlangAtom "letfun"), ann_1,
                                               fun_2, _, _, _])]
  =
  let matchExpr_9 = erlps__infer_letfun1__2 [env_0, letfun_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangTuple [name_6, sig_7]), clause_8]) ->
        let    tup_el_10 = ErlangTuple [name_6, sig_7]
        in let
          tup_el_13 =
            erlps__desugar_clauses__4
              [ann_1, fun_2, sig_7, ErlangCons clause_8 ErlangEmptyList]
        in ErlangTuple [tup_el_10, tup_el_13]
      _ -> EXC.badmatch matchExpr_9
erlps__infer_letfun__2 [arg_20, arg_21] =
  EXC.function_clause unit
erlps__infer_letfun__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_letfun__2) args

erlps__infer_letfun1__2 :: ErlangFun
erlps__infer_letfun1__2 [env0_0,
                         (ErlangTuple [(ErlangAtom "letfun"), attrib_1,
                                       fun_4@(ErlangTuple [(ErlangAtom "id"),
                                                           nameattrib_2,
                                                           name_3]),
                                       args_5, what_6, body_7])]
  =
  let   
    record_updt_9 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "stateful", attrib_1, ErlangAtom "false"]
  in let
    env_23 =
      case env0_0 of
        (ErlangTuple [(ErlangAtom "env"), scopes_14, vars_15,
                      typevars_16, fields_17, namespace_18, in_pattern_19,
                      stateful_20, current_function_21, what_22]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_14, vars_15, typevars_16, fields_17,
             namespace_18, in_pattern_19, record_updt_9, fun_4, what_22]
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    head_28 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let
    arg_25 =
      ErlangTuple
        [ErlangAtom "tuple", ErlangCons head_28 nameattrib_2, args_5]
  in let matchExpr_36 = erlps__infer_pattern__2 [env_23, arg_25]
  in
    case matchExpr_36 of
      (ErlangTuple [newenv_33,
                    (ErlangTuple [(ErlangAtom "typed"), _,
                                  (ErlangTuple [(ErlangAtom "tuple"), _,
                                                typedargs_34]),
                                  (ErlangTuple [(ErlangAtom "tuple_t"), _,
                                                argtypes_35])])]) ->
        let    arg_38 = erlps__arg_type__2 [nameattrib_2, what_6]
        in let expectedtype_41 = erlps__check_type__2 [env_23, arg_38]
        in let
          matchExpr_46 =
            erlps__check_expr__3 [newenv_33, body_7, expectedtype_41]
        in
          case matchExpr_46 of
            (ErlangTuple [(ErlangAtom "typed"), _, _, resulttype_45]) ->
              let   
                typesig_55 =
                  ErlangTuple
                    [ErlangAtom "type_sig", attrib_1, ErlangAtom "none",
                     ErlangEmptyList, argtypes_35, resulttype_45]
              in let tup_el_56 = ErlangTuple [name_3, typesig_55]
              in let
                tup_el_62 = ErlangTuple [ErlangAtom "id", nameattrib_2, name_3]
              in let
                tup_el_59 =
                  ErlangTuple
                    [ErlangAtom "letfun", attrib_1, tup_el_62, typedargs_34,
                     resulttype_45, matchExpr_46]
              in ErlangTuple [tup_el_56, tup_el_59]
            _ -> EXC.badmatch matchExpr_46
      _ -> EXC.badmatch matchExpr_36
erlps__infer_letfun1__2 [arg_69, arg_70] =
  EXC.function_clause unit
erlps__infer_letfun1__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_letfun1__2) args

erlps__desugar_clauses__4 :: ErlangFun
erlps__desugar_clauses__4 [ann_0, fun_1,
                           (ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                         argtypes_2, rettype_3]),
                           clauses_4]
  =
  let
    needdesugar_11 =
      case clauses_4 of
        (ErlangCons (ErlangTuple [(ErlangAtom "letfun"), _, _, as_6, _,
                                  _]) (ErlangEmptyList)) ->
          let
            arg_7 =
              ErlangFun 1
                (let
                   lambda_8 [(ErlangTuple [(ErlangAtom "typed"), _,
                                           (ErlangTuple [(ErlangAtom "id"), _,
                                                         _]),
                                           _])]
                     =
                     ErlangAtom "false"
                   lambda_8 [_] = ErlangAtom "true"
                   lambda_8 [arg_9] = EXC.function_clause unit
                   lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
                 in lambda_8)
          in BIF.do_remote_fun_call "Lists" "erlps__any__2" [arg_7, as_6]
        _ -> ErlangAtom "true"
  in
    case needdesugar_11 of
      (ErlangAtom "false") ->
        case clauses_4 of
          (ErlangCons clause_13 (ErlangEmptyList)) -> clause_13
          _ -> EXC.badmatch clauses_4
      (ErlangAtom "true") ->
        let   
          head_15 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
        in let arg_21 = toErl 1
        in let lcSrc_20 = erlps__indexed__2 [arg_21, argtypes_2]
        in let
          args_37 =
            flmap
              (\ lc_25 ->
                 case lc_25 of
                   (ErlangTuple [i_23, type_24]) ->
                     let    lop_33 = toErl "x#"
                     in let rop_34 = BIF.erlang__integer_to_list__1 [i_23]
                     in let tup_el_32 = BIF.erlang__op_append [lop_33, rop_34]
                     in let
                       tup_el_29 =
                         ErlangTuple
                           [ErlangAtom "id", ErlangCons head_15 ErlangEmptyList,
                            tup_el_32]
                     in let
                       lcRet_26 =
                         ErlangTuple
                           [ErlangAtom "typed",
                            ErlangCons head_15 ErlangEmptyList, tup_el_29,
                            type_24]
                     in ErlangCons lcRet_26 ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_20
        in let
          tuple_52 =
            ErlangFun 1
              (let
                 lambda_38 [(ErlangCons x_40 (ErlangEmptyList))] = x_40
                 lambda_38 [as_41] =
                   let   
                     tup_el_44 =
                       ErlangTuple
                         [ErlangAtom "tuple",
                          ErlangCons head_15 ErlangEmptyList, as_41]
                   in let
                     tup_el_48 =
                       ErlangTuple
                         [ErlangAtom "tuple_t",
                          ErlangCons head_15 ErlangEmptyList, argtypes_2]
                   in
                     ErlangTuple
                       [ErlangAtom "typed", ErlangCons head_15 ErlangEmptyList,
                        tup_el_44, tup_el_48]
                 lambda_38 [arg_39] = EXC.function_clause unit
                 lambda_38 args = EXC.badarity (ErlangFun 1 lambda_38) args
               in lambda_38)
        in let
          tup_el_64 =
            BIF.erlang__apply__2
              [tuple_52, ErlangCons args_37 ErlangEmptyList]
        in let
          tup_el_67 =
            flmap
              (\ lc_72 ->
                 case lc_72 of
                   (ErlangTuple [(ErlangAtom "letfun"), annc_69, _, argsc_70, _,
                                 body_71]) ->
                     let   
                       tup_el_76 =
                         BIF.erlang__apply__2
                           [tuple_52, ErlangCons argsc_70 ErlangEmptyList]
                     in let
                       lcRet_73 =
                         ErlangTuple
                           [ErlangAtom "case", annc_69, tup_el_76, body_71]
                     in ErlangCons lcRet_73 ErlangEmptyList
                   _ -> ErlangEmptyList)
              clauses_4
        in let
          tup_el_61 =
            ErlangTuple
              [ErlangAtom "switch", ErlangCons head_15 ErlangEmptyList,
               tup_el_64, tup_el_67]
        in let
          tup_el_58 =
            ErlangTuple
              [ErlangAtom "typed", ErlangCons head_15 ErlangEmptyList,
               tup_el_61, rettype_3]
        in
          ErlangTuple
            [ErlangAtom "letfun", ann_0, fun_1, args_37, rettype_3,
             tup_el_58]
      something_else -> EXC.case_clause something_else
erlps__desugar_clauses__4 [arg_81, arg_82, arg_83, arg_84] =
  EXC.function_clause unit
erlps__desugar_clauses__4 args =
  EXC.badarity (ErlangFun 4 erlps__desugar_clauses__4) args

erlps__print_typesig__1 :: ErlangFun
erlps__print_typesig__1 [(ErlangTuple [name_0, typesig_1])] =
  let
    arg_3 =
      ErlangFun 0
        (let
           lambda_4 [] =
             let    arg_5 = toErl "Inferred ~s : ~s\n"
             in let head_9 = erlps__pp__1 [typesig_1]
             in
               BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
                 [arg_5, ErlangCons name_0 (ErlangCons head_9 ErlangEmptyList)]
           lambda_4 [] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 0 lambda_4) args
         in lambda_4)
  in erlps__when_option__2 [ErlangAtom "pp_types", arg_3]
erlps__print_typesig__1 [arg_12] = EXC.function_clause unit
erlps__print_typesig__1 args =
  EXC.badarity (ErlangFun 1 erlps__print_typesig__1) args

erlps__arg_type__2 :: ErlangFun
erlps__arg_type__2 [argann_0,
                    (ErlangTuple [(ErlangAtom "id"), ann_1,
                                  (ErlangCons (ErlangInt num_2) (ErlangEmptyList))])]
  | (ErlangInt num_2) == (toErl 95) =
  let
    case_3 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "origin", ann_1, ErlangAtom "user"]
  in
    case case_3 of
      (ErlangAtom "system") -> erlps__fresh_uvar__1 [argann_0]
      (ErlangAtom "user") -> erlps__fresh_uvar__1 [ann_1]
      something_else -> EXC.case_clause something_else
erlps__arg_type__2 [argann_0,
                    (ErlangTuple [(ErlangAtom "app_t"), attrs_1, name_2,
                                  args_3])]
  =
  let
    tup_el_7 =
      flmap
        (\ lc_10 ->
           let lcRet_11 = erlps__arg_type__2 [argann_0, lc_10]
           in ErlangCons lcRet_11 ErlangEmptyList)
        args_3
  in ErlangTuple [ErlangAtom "app_t", attrs_1, name_2, tup_el_7]
erlps__arg_type__2 [_, t_0] = t_0
erlps__arg_type__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__arg_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__arg_type__2) args

erlps__app_t__3 :: ErlangFun
erlps__app_t__3 [_ann_0, name_1, (ErlangEmptyList)] = name_1
erlps__app_t__3 [ann_0, name_1, args_2] =
  ErlangTuple [ErlangAtom "app_t", ann_0, name_1, args_2]
erlps__app_t__3 [arg_7, arg_8, arg_9] = EXC.function_clause unit
erlps__app_t__3 args =
  EXC.badarity (ErlangFun 3 erlps__app_t__3) args

erlps__lookup_name__3 :: ErlangFun
erlps__lookup_name__3 [env_0, as_1, name_2] =
  erlps__lookup_name__4 [env_0, as_1, name_2, ErlangEmptyList]
erlps__lookup_name__3 [arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__lookup_name__3 args =
  EXC.badarity (ErlangFun 3 erlps__lookup_name__3) args

erlps__lookup_name__4 :: ErlangFun
erlps__lookup_name__4 [env_0, as_1, id_2, options_3] =
  let    arg_8 = erlps__qname__1 [id_2]
  in let
    case_4 =
      erlps__lookup_env__4 [env_0, ErlangAtom "term", as_1, arg_8]
  in
    case case_4 of
      (ErlangAtom "false") ->
        let    arg_10 = ErlangTuple [ErlangAtom "unbound_variable", id_2]
        in let _ = erlps__type_error__1 [arg_10]
        in let tup_el_14 = erlps__fresh_uvar__1 [as_1]
        in ErlangTuple [id_2, tup_el_14]
      (ErlangTuple [qid_16, (ErlangTuple [_, ty_17])]) ->
        let   
          freshen_21 =
            BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
              [ErlangAtom "freshen", options_3, ErlangAtom "false"]
        in let _ = erlps__check_stateful__3 [env_0, id_2, ty_17]
        in let
          ty1_30 =
            case ty_17 of
              (ErlangTuple [(ErlangAtom "type_sig"), _, _, _, _, _]) ->
                erlps__freshen_type_sig__2 [as_1, ty_17]
              _ | (ErlangAtom "true") == (falsifyErrors (\ _ -> freshen_21)) ->
                erlps__freshen_type__2 [as_1, ty_17]
              _ -> ty_17
        in let tup_el_31 = erlps__set_qname__2 [qid_16, id_2]
        in ErlangTuple [tup_el_31, ty1_30]
      something_else -> EXC.case_clause something_else
erlps__lookup_name__4 [arg_35, arg_36, arg_37, arg_38] =
  EXC.function_clause unit
erlps__lookup_name__4 args =
  EXC.badarity (ErlangFun 4 erlps__lookup_name__4) args

erlps__check_stateful__3 :: ErlangFun
erlps__check_stateful__3 [(ErlangTuple [(ErlangAtom "env"), _, _,
                                        _, _, _, _, (ErlangAtom "false"), fun_0,
                                        _]),
                          id_1,
                          type_2@(ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                               _, _])]
  =
  let
    case_3 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
        [ErlangAtom "stateful", type_2, ErlangAtom "false"]
  in
    case case_3 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      (ErlangAtom "true") ->
        let
          arg_7 =
            ErlangTuple [ErlangAtom "stateful_not_allowed", id_1, fun_0]
        in erlps__type_error__1 [arg_7]
      something_else -> EXC.case_clause something_else
erlps__check_stateful__3 [_env_0, _id_1, _type_2] =
  ErlangAtom "ok"
erlps__check_stateful__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__check_stateful__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_stateful__3) args

erlps__check_stateful_named_arg__3 :: ErlangFun
erlps__check_stateful_named_arg__3 [(ErlangTuple [(ErlangAtom "env"),
                                                  _, _, _, _, _, _,
                                                  (ErlangAtom "false"), fun_0,
                                                  _]),
                                    (ErlangTuple [(ErlangAtom "id"), _,
                                                  (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangCons (ErlangInt num_5) (ErlangEmptyList))))))]),
                                    default_6]
  | (ErlangInt num_1) == (toErl 118)
  , (ErlangInt num_2) == (toErl 97)
  , (ErlangInt num_3) == (toErl 108)
  , (ErlangInt num_4) == (toErl 117)
  , (ErlangInt num_5) == (toErl 101) =
  case default_6 of
    (ErlangTuple [(ErlangAtom "int"), _,
                  (ErlangInt num_8)]) | (ErlangInt num_8) == (toErl 0) ->
      ErlangAtom "ok"
    _ ->
      let
        arg_9 =
          ErlangTuple
            [ErlangAtom "value_arg_not_allowed", default_6, fun_0]
      in erlps__type_error__1 [arg_9]
erlps__check_stateful_named_arg__3 [_, _, _] = ErlangAtom "ok"
erlps__check_stateful_named_arg__3 [arg_0, arg_1, arg_2] =
  EXC.function_clause unit
erlps__check_stateful_named_arg__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_stateful_named_arg__3)
    args

erlps__check_state_dependencies__2 :: ErlangFun
erlps__check_state_dependencies__2 [env_0, defs_1] =
  let   
    top_5 =
      case env_0 of
        (ErlangTuple arr_4) | (DM.Just field_3) <- (arr_4 DA.!! 5) ->
          field_3
        _ -> EXC.badrecord (ErlangAtom "env")
  in let head_8 = toErl "state"
  in let
    getstate_10 =
      BIF.erlang__op_append [top_5, ErlangCons head_8 ErlangEmptyList]
  in let head_13 = toErl "put"
  in let
    setstate_15 =
      BIF.erlang__op_append [top_5, ErlangCons head_13 ErlangEmptyList]
  in let head_18 = toErl "init"
  in let
    init_20 =
      BIF.erlang__op_append [top_5, ErlangCons head_18 ErlangEmptyList]
  in let
    usednames_32 =
      ErlangFun 1
        (let
           lambda_21 [x_23] =
             let
               lcSrc_24 =
                 BIF.do_remote_fun_call "Aeso.Syntax.Utils" "erlps__used__1"
                   [x_23]
             in
               flmap
                 (\ lc_28 ->
                    case lc_28 of
                      (ErlangTuple [(ErlangTuple [(ErlangAtom "term"), xs_26]),
                                    ann_27]) ->
                        let lcRet_29 = ErlangTuple [xs_26, ann_27]
                        in ErlangCons lcRet_29 ErlangEmptyList
                      _ -> ErlangEmptyList)
                 lcSrc_24
           lambda_21 [arg_22] = EXC.function_clause unit
           lambda_21 args = EXC.badarity (ErlangFun 1 lambda_21) args
         in lambda_21)
  in let
    funs_47 =
      flmap
        (\ lc_39 ->
           case lc_39 of
             fun_38@(ErlangTuple [(ErlangAtom "letfun"), _,
                                  (ErlangTuple [(ErlangAtom "id"), _, name_34]),
                                  _args_35, _type_36, _body_37]) ->
               let   
                 tup_el_41 =
                   BIF.erlang__op_append
                     [top_5, ErlangCons name_34 ErlangEmptyList]
               in let lcRet_40 = ErlangTuple [tup_el_41, fun_38]
               in ErlangCons lcRet_40 ErlangEmptyList
             _ -> ErlangEmptyList)
        defs_1
  in let
    arg_48 =
      flmap
        (\ lc_52 ->
           case lc_52 of
             (ErlangTuple [name_50, def_51]) ->
               let   
                 tup_el_55 =
                   BIF.erlang__apply__2
                     [usednames_32, ErlangCons def_51 ErlangEmptyList]
               in let lcRet_53 = ErlangTuple [name_50, tup_el_55]
               in ErlangCons lcRet_53 ErlangEmptyList
             _ -> ErlangEmptyList)
        funs_47
  in let deps_58 = BIF.maps__from_list__1 [arg_48]
  in let
    case_59 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [init_20, deps_58, ErlangAtom "false"]
  in
    case case_59 of
      (ErlangAtom "false") -> ErlangAtom "ok"
      _ ->
        let   
          lcSrc_63 =
            erlps__get_call_chains__3 [deps_58, init_20, getstate_10]
        in let
          _ =
            flmap
              (\ lc_68 ->
                 let   
                   arg_70 =
                     ErlangTuple
                       [ErlangAtom "init_depends_on_state", ErlangAtom "state",
                        lc_68]
                 in let lcRet_69 = erlps__type_error__1 [arg_70]
                 in ErlangCons lcRet_69 ErlangEmptyList)
              lcSrc_63
        in let
          lcSrc_74 =
            erlps__get_call_chains__3 [deps_58, init_20, setstate_15]
        in let
          _ =
            flmap
              (\ lc_79 ->
                 let   
                   arg_81 =
                     ErlangTuple
                       [ErlangAtom "init_depends_on_state", ErlangAtom "put",
                        lc_79]
                 in let lcRet_80 = erlps__type_error__1 [arg_81]
                 in ErlangCons lcRet_80 ErlangEmptyList)
              lcSrc_74
        in ErlangAtom "ok"
erlps__check_state_dependencies__2 [arg_85, arg_86] =
  EXC.function_clause unit
erlps__check_state_dependencies__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_state_dependencies__2)
    args

erlps__get_call_chains__3 :: ErlangFun
erlps__get_call_chains__3 [graph_0, start_1, stop_2] =
  let    arg_4 = ErlangMap Map.empty
  in let
    head_7 = ErlangTuple [start_1, ErlangEmptyList, ErlangEmptyList]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Queue" "erlps__from_list__1"
        [ErlangCons head_7 ErlangEmptyList]
  in
    erlps__get_call_chains__5
      [graph_0, arg_4, arg_5, stop_2, ErlangEmptyList]
erlps__get_call_chains__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__get_call_chains__3 args =
  EXC.badarity (ErlangFun 3 erlps__get_call_chains__3) args

erlps__get_call_chains__5 :: ErlangFun
erlps__get_call_chains__5 [graph_0, visited_1, queue_2, stop_3,
                           acc_4]
  =
  let
    case_5 = BIF.do_remote_fun_call "Queue" "erlps__out__1" [queue_2]
  in
    case case_5 of
      (ErlangTuple [(ErlangAtom "empty"), _]) ->
        BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [acc_4]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "value"),
                                  (ErlangTuple [stop_8, ann_9, path_10])]),
                    queue1_11]) | stop_8 == stop_3 ->
        let    head_19 = ErlangTuple [stop_3, ann_9]
        in let
          head_17 =
            BIF.do_remote_fun_call "Lists" "erlps__reverse__1"
              [ErlangCons head_19 path_10]
        in
          erlps__get_call_chains__5
            [graph_0, visited_1, queue1_11, stop_3, ErlangCons head_17 acc_4]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "value"),
                                  (ErlangTuple [node_24, ann_25, path_26])]),
                    queue1_27]) ->
        let case_28 = BIF.maps__is_key__2 [node_24, visited_1]
        in
          case case_28 of
            (ErlangAtom "true") ->
              erlps__get_call_chains__5
                [graph_0, visited_1, queue1_27, stop_3, acc_4]
            (ErlangAtom "false") ->
              let   
                calls_39 =
                  BIF.do_remote_fun_call "Maps" "erlps__get__3"
                    [node_24, graph_0, ErlangEmptyList]
              in let
                arg_40 =
                  flmap
                    (\ lc_44 ->
                       case lc_44 of
                         (ErlangTuple [new_42, ann1_43]) ->
                           let    head_49 = ErlangTuple [node_24, ann_25]
                           in let
                             lcRet_45 =
                               ErlangTuple
                                 [new_42, ann1_43, ErlangCons head_49 path_26]
                           in ErlangCons lcRet_45 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    calls_39
              in let
                newq_53 =
                  BIF.do_remote_fun_call "Queue" "erlps__from_list__1" [arg_40]
              in let
                mapExt_59 =
                  ErlangMap (Map.singleton node_24 (ErlangAtom "true"))
              in let arg_55 = BIF.maps__merge__2 [visited_1, mapExt_59]
              in let
                arg_61 =
                  BIF.do_remote_fun_call "Queue" "erlps__join__2"
                    [queue1_27, newq_53]
              in
                erlps__get_call_chains__5
                  [graph_0, arg_55, arg_61, stop_3, acc_4]
            something_else -> EXC.case_clause something_else
      something_else -> EXC.case_clause something_else
erlps__get_call_chains__5 [arg_66, arg_67, arg_68, arg_69,
                           arg_70]
  =
  EXC.function_clause unit
erlps__get_call_chains__5 args =
  EXC.badarity (ErlangFun 5 erlps__get_call_chains__5) args

erlps__check_expr__3 :: ErlangFun
erlps__check_expr__3 [env_0, expr_1, type_2] =
  let matchExpr_8 = erlps__infer_expr__2 [env_0, expr_1]
  in
    case matchExpr_8 of
      (ErlangTuple [(ErlangAtom "typed"), ann_5, expr1_6, type1_7]) ->
        let   
          arg_12 =
            ErlangTuple [ErlangAtom "check_expr", expr_1, type1_7, type_2]
        in let _ = erlps__unify__4 [env_0, type1_7, type_2, arg_12]
        in ErlangTuple [ErlangAtom "typed", ann_5, expr1_6, type_2]
      _ -> EXC.badmatch matchExpr_8
erlps__check_expr__3 [arg_21, arg_22, arg_23] =
  EXC.function_clause unit
erlps__check_expr__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_expr__3) args

erlps__infer_expr__2 :: ErlangFun
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "bool"), as_1, _])]
  =
  let    tup_el_9 = toErl "bool"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "int"), as_1, _])]
  =
  let    tup_el_9 = toErl "int"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "char"), as_1, _])]
  =
  let    tup_el_9 = toErl "char"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "string"), as_1, _])]
  =
  let    tup_el_9 = toErl "string"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_3@(ErlangTuple [(ErlangAtom "bytes"), as_1, bin_2])]
  =
  let    tup_el_10 = BIF.erlang__byte_size__1 [bin_2]
  in let
    tup_el_7 = ErlangTuple [ErlangAtom "bytes_t", as_1, tup_el_10]
  in ErlangTuple [ErlangAtom "typed", as_1, body_3, tup_el_7]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "account_pubkey"), as_1,
                                           _])]
  =
  let    tup_el_9 = toErl "address"
  in let tup_el_6 = ErlangTuple [ErlangAtom "id", as_1, tup_el_9]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_6]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "oracle_pubkey"), as_1,
                                           _])]
  =
  let    q_4 = erlps__fresh_uvar__1 [as_1]
  in let r_6 = erlps__fresh_uvar__1 [as_1]
  in let tup_el_16 = toErl "oracle"
  in let tup_el_13 = ErlangTuple [ErlangAtom "id", as_1, tup_el_16]
  in let
    tup_el_10 =
      ErlangTuple
        [ErlangAtom "app_t", as_1, tup_el_13,
         ErlangCons q_4 (ErlangCons r_6 ErlangEmptyList)]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_10]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "oracle_query_id"), as_1,
                                           _])]
  =
  let    q_4 = erlps__fresh_uvar__1 [as_1]
  in let r_6 = erlps__fresh_uvar__1 [as_1]
  in let tup_el_16 = toErl "oracle_query"
  in let tup_el_13 = ErlangTuple [ErlangAtom "id", as_1, tup_el_16]
  in let
    tup_el_10 =
      ErlangTuple
        [ErlangAtom "app_t", as_1, tup_el_13,
         ErlangCons q_4 (ErlangCons r_6 ErlangEmptyList)]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, tup_el_10]
erlps__infer_expr__2 [_env_0,
                      body_2@(ErlangTuple [(ErlangAtom "contract_pubkey"), as_1,
                                           _])]
  =
  let    con_4 = erlps__fresh_uvar__1 [as_1]
  in let
    tup_el_9 = ErlangTuple [ErlangAtom "contract_literal", body_2]
  in let
    head_6 =
      ErlangTuple
        [ErlangAtom "is_contract_constraint", con_4, tup_el_9]
  in let
    _ = erlps__constrain__1 [ErlangCons head_6 ErlangEmptyList]
  in ErlangTuple [ErlangAtom "typed", as_1, body_2, con_4]
erlps__infer_expr__2 [_env_0,
                      body_3@(ErlangTuple [(ErlangAtom "id"), as_1,
                                           (ErlangCons (ErlangInt num_2) (ErlangEmptyList))])]
  | (ErlangInt num_2) == (toErl 95) =
  let tup_el_7 = erlps__fresh_uvar__1 [as_1]
  in ErlangTuple [ErlangAtom "typed", as_1, body_3, tup_el_7]
erlps__infer_expr__2 [env_0, id_3@(ErlangTuple [tag_1, as_2, _])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_14 = BIF.erlang__op_eq [tag_1, ErlangAtom "id"]
            in
              case lop_14 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [tag_1, ErlangAtom "qid"]
                _ -> EXC.badarg1 lop_14)) =
  let matchExpr_9 = erlps__lookup_name__3 [env_0, as_2, id_3]
  in
    case matchExpr_9 of
      (ErlangTuple [qname_7, type_8]) ->
        ErlangTuple [ErlangAtom "typed", as_2, qname_7, type_8]
      _ -> EXC.badmatch matchExpr_9
erlps__infer_expr__2 [env_0, id_3@(ErlangTuple [tag_1, as_2, _])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_17 = BIF.erlang__op_eq [tag_1, ErlangAtom "con"]
            in
              case lop_17 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [tag_1, ErlangAtom "qcon"]
                _ -> EXC.badarg1 lop_17)) =
  let
    matchExpr_12 =
      erlps__lookup_name__4
        [env_0, as_2, id_3,
         ErlangCons (ErlangAtom "freshen") ErlangEmptyList]
  in
    case matchExpr_12 of
      (ErlangTuple [qname_10, type_11]) ->
        ErlangTuple [ErlangAtom "typed", as_2, qname_10, type_11]
      _ -> EXC.badmatch matchExpr_12
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "tuple"), as_1, cpts_2])]
  =
  let   
    newcpts_9 =
      flmap
        (\ lc_5 ->
           let lcRet_6 = erlps__infer_expr__2 [env_0, lc_5]
           in ErlangCons lcRet_6 ErlangEmptyList)
        cpts_2
  in let
    cpttypes_14 =
      flmap
        (\ lc_12 ->
           case lc_12 of
             (ErlangTuple [(ErlangAtom "typed"), _, _, t_11]) ->
               ErlangCons t_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        newcpts_9
  in let
    tup_el_17 = ErlangTuple [ErlangAtom "tuple", as_1, newcpts_9]
  in let
    tup_el_21 = ErlangTuple [ErlangAtom "tuple_t", as_1, cpttypes_14]
  in ErlangTuple [ErlangAtom "typed", as_1, tup_el_17, tup_el_21]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list"), as_1, elems_2])]
  =
  let    elemtype_4 = erlps__fresh_uvar__1 [as_1]
  in let
    newelems_12 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__check_expr__3 [env_0, lc_7, elemtype_4]
           in ErlangCons lcRet_8 ErlangEmptyList)
        elems_2
  in let
    tup_el_15 = ErlangTuple [ErlangAtom "list", as_1, newelems_12]
  in let tup_el_25 = toErl "list"
  in let tup_el_22 = ErlangTuple [ErlangAtom "id", as_1, tup_el_25]
  in let
    tup_el_19 =
      ErlangTuple
        [ErlangAtom "app_t", as_1, tup_el_22,
         ErlangCons elemtype_4 ErlangEmptyList]
  in ErlangTuple [ErlangAtom "typed", as_1, tup_el_15, tup_el_19]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), as_1, yield_2,
                                    (ErlangEmptyList)])]
  =
  let typedyield_5 = erlps__infer_expr__2 [env_0, yield_2]
  in
    case typedyield_5 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, type_6]) ->
        let   
          tup_el_10 =
            ErlangTuple
              [ErlangAtom "list_comp", as_1, typedyield_5, ErlangEmptyList]
        in let tup_el_21 = toErl "list"
        in let tup_el_18 = ErlangTuple [ErlangAtom "id", as_1, tup_el_21]
        in let
          tup_el_15 =
            ErlangTuple
              [ErlangAtom "app_t", as_1, tup_el_18,
               ErlangCons type_6 ErlangEmptyList]
        in ErlangTuple [ErlangAtom "typed", as_1, tup_el_10, tup_el_15]
      _ -> EXC.badmatch typedyield_5
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), as_1, yield_2,
                                    (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_bind"),
                                                              pat_3,
                                                              bexpr_4]) rest_5)])]
  =
  let matchExpr_10 = erlps__infer_expr__2 [env_0, bexpr_4]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangAtom "typed"), as2_8, _, typebexpr_9]) ->
        let matchExpr_17 = erlps__infer_pattern__2 [env_0, pat_3]
        in
          case matchExpr_17 of
            (ErlangTuple [newe_14,
                          typedpat_16@(ErlangTuple [(ErlangAtom "typed"), _, _,
                                                    pattype_15])]) ->
              let    tup_el_26 = toErl "list"
              in let tup_el_23 = ErlangTuple [ErlangAtom "id", as_1, tup_el_26]
              in let
                arg_20 =
                  ErlangTuple
                    [ErlangAtom "app_t", as_1, tup_el_23,
                     ErlangCons pattype_15 ErlangEmptyList]
              in let tup_el_40 = toErl "list"
              in let tup_el_37 = ErlangTuple [ErlangAtom "id", as_1, tup_el_40]
              in let
                tup_el_34 =
                  ErlangTuple
                    [ErlangAtom "app_t", as2_8, tup_el_37,
                     ErlangCons pattype_15 ErlangEmptyList]
              in let
                arg_30 =
                  ErlangTuple
                    [ErlangAtom "list_comp", matchExpr_10, typebexpr_9,
                     tup_el_34]
              in let _ = erlps__unify__4 [env_0, typebexpr_9, arg_20, arg_30]
              in let
                arg_45 =
                  ErlangTuple [ErlangAtom "list_comp", as_1, yield_2, rest_5]
              in let matchExpr_53 = erlps__infer_expr__2 [newe_14, arg_45]
              in
                case matchExpr_53 of
                  (ErlangTuple [(ErlangAtom "typed"), _,
                                (ErlangTuple [(ErlangAtom "list_comp"), _,
                                              typedyield_50, typedrest_51]),
                                restype_52]) ->
                    let   
                      head_61 =
                        ErlangTuple
                          [ErlangAtom "comprehension_bind", typedpat_16,
                           matchExpr_10]
                    in let
                      tup_el_56 =
                        ErlangTuple
                          [ErlangAtom "list_comp", as_1, typedyield_50,
                           ErlangCons head_61 typedrest_51]
                    in
                      ErlangTuple
                        [ErlangAtom "typed", as_1, tup_el_56, restype_52]
                  _ -> EXC.badmatch matchExpr_53
            _ -> EXC.badmatch matchExpr_17
      _ -> EXC.badmatch matchExpr_10
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), attrsl_1, yield_2,
                                    (ErlangCons (ErlangTuple [(ErlangAtom "comprehension_if"),
                                                              attrsif_3,
                                                              cond_4]) rest_5)])]
  =
  let    tup_el_11 = toErl "bool"
  in let
    arg_8 = ErlangTuple [ErlangAtom "id", attrsif_3, tup_el_11]
  in let newcond_12 = erlps__check_expr__3 [env_0, cond_4, arg_8]
  in let
    arg_14 =
      ErlangTuple [ErlangAtom "list_comp", attrsl_1, yield_2, rest_5]
  in let matchExpr_22 = erlps__infer_expr__2 [env_0, arg_14]
  in
    case matchExpr_22 of
      (ErlangTuple [(ErlangAtom "typed"), _,
                    (ErlangTuple [(ErlangAtom "list_comp"), _, typedyield_19,
                                  typedrest_20]),
                    restype_21]) ->
        let   
          head_30 =
            ErlangTuple
              [ErlangAtom "comprehension_if", attrsif_3, newcond_12]
        in let
          tup_el_25 =
            ErlangTuple
              [ErlangAtom "list_comp", attrsl_1, typedyield_19,
               ErlangCons head_30 typedrest_20]
        in
          ErlangTuple [ErlangAtom "typed", attrsl_1, tup_el_25, restype_21]
      _ -> EXC.badmatch matchExpr_22
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), aslc_1, yield_2,
                                    (ErlangCons (ErlangTuple [(ErlangAtom "letval"),
                                                              aslv_3, pattern_4,
                                                              e_5]) rest_6)])]
  =
  let matchExpr_10 = erlps__infer_expr__2 [env_0, e_5]
  in
    case matchExpr_10 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, pattype_9]) ->
        let    blocktype_13 = erlps__fresh_uvar__1 [aslv_3]
        in let
          arg_18 =
            ErlangTuple [ErlangAtom "list_comp", aslc_1, yield_2, rest_6]
        in let
          matchExpr_26 =
            erlps__infer_case__6
              [env_0, aslc_1, pattern_4, pattype_9, arg_18, blocktype_13]
        in
          case matchExpr_26 of
            (ErlangTuple [(ErlangAtom "case"), _, newpattern_24,
                          newrest_25]) ->
              case newrest_25 of
                (ErlangTuple [(ErlangAtom "typed"), _,
                              (ErlangTuple [(ErlangAtom "list_comp"), _,
                                            typedyield_27, typedrest_28]),
                              restype_29]) ->
                  let   
                    head_38 =
                      ErlangTuple
                        [ErlangAtom "letval", aslv_3, newpattern_24,
                         matchExpr_10]
                  in let
                    tup_el_33 =
                      ErlangTuple
                        [ErlangAtom "list_comp", aslc_1, typedyield_27,
                         ErlangCons head_38 typedrest_28]
                  in
                    ErlangTuple
                      [ErlangAtom "typed", aslc_1, tup_el_33, restype_29]
                _ -> EXC.badmatch newrest_25
            _ -> EXC.badmatch matchExpr_26
      _ -> EXC.badmatch matchExpr_10
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "list_comp"), aslc_1, yield_2,
                                    (ErlangCons def_4@(ErlangTuple [(ErlangAtom "letfun"),
                                                                    aslf_3, _,
                                                                    _, _,
                                                                    _]) rest_5)])]
  =
  let matchExpr_11 = erlps__infer_letfun__2 [env_0, def_4]
  in
    case matchExpr_11 of
      (ErlangTuple [(ErlangTuple [name_8, typesig_9]), letfun_10]) ->
        let    funt_13 = erlps__typesig_to_fun_t__1 [typesig_9]
        in let arg_14 = ErlangTuple [ErlangAtom "id", aslf_3, name_8]
        in let newe_20 = erlps__bind_var__3 [arg_14, funt_13, env_0]
        in let
          arg_22 =
            ErlangTuple [ErlangAtom "list_comp", aslc_1, yield_2, rest_5]
        in let matchExpr_30 = erlps__infer_expr__2 [newe_20, arg_22]
        in
          case matchExpr_30 of
            (ErlangTuple [(ErlangAtom "typed"), _,
                          (ErlangTuple [(ErlangAtom "list_comp"), _,
                                        typedyield_27, typedrest_28]),
                          restype_29]) ->
              let
                tup_el_33 =
                  ErlangTuple
                    [ErlangAtom "list_comp", aslc_1, typedyield_27,
                     ErlangCons letfun_10 typedrest_28]
              in
                ErlangTuple [ErlangAtom "typed", aslc_1, tup_el_33, restype_29]
            _ -> EXC.badmatch matchExpr_30
      _ -> EXC.badmatch matchExpr_11
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "typed"), as_1, body_2,
                                    type_3])]
  =
  let    type1_6 = erlps__check_type__2 [env_0, type_3]
  in let
    matchExpr_12 = erlps__check_expr__3 [env_0, body_2, type1_6]
  in
    case matchExpr_12 of
      (ErlangTuple [(ErlangAtom "typed"), _, newbody_10,
                    newtype_11]) ->
        ErlangTuple [ErlangAtom "typed", as_1, newbody_10, newtype_11]
      _ -> EXC.badmatch matchExpr_12
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "app"), ann_1, fun_2, args0_3])]
  =
  let   
    namedargs_8 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             arg_5@(ErlangTuple [(ErlangAtom "named_arg"), _, _, _]) ->
               ErlangCons arg_5 ErlangEmptyList
             _ -> ErlangEmptyList)
        args0_3
  in let args_11 = BIF.erlang__op_unAppend [args0_3, namedargs_8]
  in let
    case_12 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__2"
        [ErlangAtom "format", ann_1]
  in
    case case_12 of
      (ErlangAtom "infix") ->
        let arg_19 = ErlangFun 1 erlps__infer_infix__1
        in erlps__infer_op__5 [env_0, ann_1, fun_2, args_11, arg_19]
      (ErlangAtom "prefix") ->
        let arg_24 = ErlangFun 1 erlps__infer_prefix__1
        in erlps__infer_op__5 [env_0, ann_1, fun_2, args_11, arg_24]
      _ ->
        let    namedargsvar_26 = erlps__fresh_uvar__1 [ann_1]
        in let
          namedargs1_34 =
            flmap
              (\ lc_29 ->
                 let
                   lcRet_30 =
                     erlps__infer_named_arg__3 [env_0, namedargsvar_26, lc_29]
                 in ErlangCons lcRet_30 ErlangEmptyList)
              namedargs_8
        in let matchExpr_38 = erlps__infer_expr__2 [env_0, fun_2]
        in
          case matchExpr_38 of
            (ErlangTuple [(ErlangAtom "typed"), _, _, funtype_37]) ->
              let   
                newargs_46 =
                  flmap
                    (\ lc_42 ->
                       let lcRet_43 = erlps__infer_expr__2 [env_0, lc_42]
                       in ErlangCons lcRet_43 ErlangEmptyList)
                    args_11
              in let
                argtypes_51 =
                  flmap
                    (\ lc_49 ->
                       case lc_49 of
                         (ErlangTuple [(ErlangAtom "typed"), _, _, t_48]) ->
                           ErlangCons t_48 ErlangEmptyList
                         _ -> ErlangEmptyList)
                    newargs_46
              in let resulttype_53 = erlps__fresh_uvar__1 [ann_1]
              in let
                arg_56 =
                  ErlangTuple
                    [ErlangAtom "fun_t", ErlangEmptyList, namedargsvar_26,
                     argtypes_51, resulttype_53]
              in let
                arg_62 =
                  ErlangTuple
                    [ErlangAtom "infer_app", fun_2, args_11, funtype_37,
                     argtypes_51]
              in let _ = erlps__unify__4 [env_0, funtype_37, arg_56, arg_62]
              in let
                tup_el_74 = BIF.erlang__op_append [namedargs1_34, newargs_46]
              in let
                tup_el_70 =
                  ErlangTuple [ErlangAtom "app", ann_1, matchExpr_38, tup_el_74]
              in let tup_el_77 = erlps__dereference__1 [resulttype_53]
              in ErlangTuple [ErlangAtom "typed", ann_1, tup_el_70, tup_el_77]
            _ -> EXC.badmatch matchExpr_38
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "if"), attrs_1, cond_2, then_3,
                                    else_4])]
  =
  let    tup_el_10 = toErl "bool"
  in let arg_7 = ErlangTuple [ErlangAtom "id", attrs_1, tup_el_10]
  in let newcond_11 = erlps__check_expr__3 [env_0, cond_2, arg_7]
  in let matchExpr_15 = erlps__infer_expr__2 [env_0, then_3]
  in
    case matchExpr_15 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, thentype_14]) ->
        let matchExpr_20 = erlps__infer_expr__2 [env_0, else_4]
        in
          case matchExpr_20 of
            (ErlangTuple [(ErlangAtom "typed"), _, _, elsetype_19]) ->
              let   
                arg_25 =
                  ErlangTuple
                    [ErlangAtom "if_branches", then_3, thentype_14, else_4,
                     elsetype_19]
              in let
                _ = erlps__unify__4 [env_0, thentype_14, elsetype_19, arg_25]
              in let
                tup_el_33 =
                  ErlangTuple
                    [ErlangAtom "if", attrs_1, newcond_11, matchExpr_15,
                     matchExpr_20]
              in
                ErlangTuple
                  [ErlangAtom "typed", attrs_1, tup_el_33, thentype_14]
            _ -> EXC.badmatch matchExpr_20
      _ -> EXC.badmatch matchExpr_15
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "switch"), attrs_1, expr_2,
                                    cases_3])]
  =
  let matchExpr_7 = erlps__infer_expr__2 [env_0, expr_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, exprtype_6]) ->
        let    switchtype_10 = erlps__fresh_uvar__1 [attrs_1]
        in let
          newcases_23 =
            flmap
              (\ lc_15 ->
                 case lc_15 of
                   (ErlangTuple [(ErlangAtom "case"), as_12, pattern_13,
                                 branch_14]) ->
                     let
                       lcRet_16 =
                         erlps__infer_case__6
                           [env_0, as_12, pattern_13, exprtype_6, branch_14,
                            switchtype_10]
                     in ErlangCons lcRet_16 ErlangEmptyList
                   _ -> ErlangEmptyList)
              cases_3
        in let
          tup_el_26 =
            ErlangTuple
              [ErlangAtom "switch", attrs_1, matchExpr_7, newcases_23]
        in
          ErlangTuple
            [ErlangAtom "typed", attrs_1, tup_el_26, switchtype_10]
      _ -> EXC.badmatch matchExpr_7
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record"), attrs_1, fields_2])]
  =
  let    recordtype_4 = erlps__fresh_uvar__1 [attrs_1]
  in let
    newfields_17 =
      flmap
        (\ lc_9 ->
           case lc_9 of
             (ErlangTuple [(ErlangAtom "field"), a_6, fieldname_7, expr_8]) ->
               let    tup_el_14 = erlps__infer_expr__2 [env_0, expr_8]
               in let
                 lcRet_10 =
                   ErlangTuple [ErlangAtom "field", a_6, fieldname_7, tup_el_14]
               in ErlangCons lcRet_10 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_2
  in let
    recordtype1_20 =
      erlps__unfold_types_in_type__2 [env_0, recordtype_4]
  in let
    op_arg_24 =
      case env_0 of
        (ErlangTuple arr_27) | (DM.Just field_26) <- (arr_27 DA.!! 6) ->
          field_26
        _ -> EXC.badrecord (ErlangAtom "env")
  in let cond_23 = BIF.erlang__not__1 [op_arg_24]
  in let
    lop_22 =
      case cond_23 of
        (ErlangAtom "true") ->
          let   
            tup_el_31 =
              flmap
                (\ lc_34 ->
                   case lc_34 of
                     (ErlangTuple [(ErlangAtom "field"), _,
                                   (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                             _,
                                                             fieldname_33]) (ErlangEmptyList)),
                                   _]) ->
                       ErlangCons fieldname_33 ErlangEmptyList
                     _ -> ErlangEmptyList)
                fields_2
          in let
            lcRet_28 =
              ErlangTuple
                [ErlangAtom "record_create_constraint", recordtype1_20,
                 tup_el_31, attrs_1]
          in ErlangCons lcRet_28 ErlangEmptyList
        _ -> ErlangEmptyList
  in let
    lcSrc_38 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [fields_2, newfields_17]
  in let
    rop_37 =
      flmap
        (\ lc_44 ->
           case lc_44 of
             (ErlangTuple [fld_41,
                           (ErlangTuple [(ErlangAtom "field"), _, lv_42,
                                         (ErlangTuple [(ErlangAtom "typed"), _,
                                                       _, t_43])])]) ->
               case lv_42 of
                 (ErlangCons (ErlangTuple [(ErlangAtom "proj"), _,
                                           fieldname_46]) (ErlangEmptyList)) ->
                   let
                     lcRet_45 =
                       ErlangTuple
                         [ErlangAtom "field_constraint", recordtype1_20,
                          fieldname_46, t_43, ErlangAtom "create", fld_41]
                   in ErlangCons lcRet_45 ErlangEmptyList
                 _ -> EXC.badmatch lv_42
             _ -> ErlangEmptyList)
        lcSrc_38
  in let arg_21 = BIF.erlang__op_append [lop_22, rop_37]
  in let _ = erlps__constrain__1 [arg_21]
  in let
    tup_el_56 =
      ErlangTuple [ErlangAtom "record", attrs_1, newfields_17]
  in
    ErlangTuple
      [ErlangAtom "typed", attrs_1, tup_el_56, recordtype_4]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record"), attrs_1, record_2,
                                    update_3])]
  =
  let matchExpr_7 = erlps__infer_expr__2 [env_0, record_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, recordtype_6]) ->
        let   
          newupdate_16 =
            flmap
              (\ lc_11 ->
                 let
                   lcRet_12 =
                     erlps__check_record_update__3 [env_0, recordtype_6, lc_11]
                 in ErlangCons lcRet_12 ErlangEmptyList)
              update_3
        in let
          tup_el_19 =
            ErlangTuple
              [ErlangAtom "record", attrs_1, matchExpr_7, newupdate_16]
        in
          ErlangTuple
            [ErlangAtom "typed", attrs_1, tup_el_19, recordtype_6]
      _ -> EXC.badmatch matchExpr_7
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "proj"), attrs_1, record_2,
                                    fieldname_3])]
  =
  let matchExpr_7 = erlps__infer_expr__2 [env_0, record_2]
  in
    case matchExpr_7 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, recordtype_6]) ->
        let    fieldtype_10 = erlps__fresh_uvar__1 [attrs_1]
        in let
          tup_el_14 = erlps__unfold_types_in_type__2 [env_0, recordtype_6]
        in let
          tup_el_20 =
            ErlangTuple [ErlangAtom "proj", attrs_1, record_2, fieldname_3]
        in let
          head_12 =
            ErlangTuple
              [ErlangAtom "field_constraint", tup_el_14, fieldname_3,
               fieldtype_10, ErlangAtom "project", tup_el_20]
        in let
          _ = erlps__constrain__1 [ErlangCons head_12 ErlangEmptyList]
        in let
          tup_el_28 =
            ErlangTuple
              [ErlangAtom "proj", attrs_1, matchExpr_7, fieldname_3]
        in
          ErlangTuple
            [ErlangAtom "typed", attrs_1, tup_el_28, fieldtype_10]
      _ -> EXC.badmatch matchExpr_7
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map_get"), attrs_1, map_2,
                                    key_3])]
  =
  let    keytype_5 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_7 = erlps__fresh_uvar__1 [attrs_1]
  in let
    maptype_11 = erlps__map_t__3 [attrs_1, keytype_5, valtype_7]
  in let map1_15 = erlps__check_expr__3 [env_0, map_2, maptype_11]
  in let key1_19 = erlps__check_expr__3 [env_0, key_3, keytype_5]
  in let
    tup_el_22 =
      ErlangTuple [ErlangAtom "map_get", attrs_1, map1_15, key1_19]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_22, valtype_7]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map_get"), attrs_1, map_2,
                                    key_3, val_4])]
  =
  let    keytype_6 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_8 = erlps__fresh_uvar__1 [attrs_1]
  in let
    maptype_12 = erlps__map_t__3 [attrs_1, keytype_6, valtype_8]
  in let map1_16 = erlps__check_expr__3 [env_0, map_2, maptype_12]
  in let key1_20 = erlps__check_expr__3 [env_0, key_3, keytype_6]
  in let val1_24 = erlps__check_expr__3 [env_0, val_4, valtype_8]
  in let
    tup_el_27 =
      ErlangTuple
        [ErlangAtom "map_get", attrs_1, map1_16, key1_20, val1_24]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_27, valtype_8]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map"), attrs_1, kvs_2])]
  =
  let    keytype_4 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_6 = erlps__fresh_uvar__1 [attrs_1]
  in let
    kvs1_20 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [k_8, v_9]) ->
               let    tup_el_12 = erlps__check_expr__3 [env_0, k_8, keytype_4]
               in let tup_el_16 = erlps__check_expr__3 [env_0, v_9, valtype_6]
               in let lcRet_11 = ErlangTuple [tup_el_12, tup_el_16]
               in ErlangCons lcRet_11 ErlangEmptyList
             _ -> ErlangEmptyList)
        kvs_2
  in let
    tup_el_23 = ErlangTuple [ErlangAtom "map", attrs_1, kvs1_20]
  in let
    tup_el_27 = erlps__map_t__3 [attrs_1, keytype_4, valtype_6]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_23, tup_el_27]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "map"), attrs_1, map_2,
                                    updates_3])]
  =
  let    keytype_5 = erlps__fresh_uvar__1 [attrs_1]
  in let valtype_7 = erlps__fresh_uvar__1 [attrs_1]
  in let
    maptype_11 = erlps__map_t__3 [attrs_1, keytype_5, valtype_7]
  in let map1_15 = erlps__check_expr__3 [env_0, map_2, maptype_11]
  in let
    updates1_24 =
      flmap
        (\ lc_18 ->
           let
             lcRet_19 =
               erlps__check_map_update__4 [env_0, lc_18, keytype_5, valtype_7]
           in ErlangCons lcRet_19 ErlangEmptyList)
        updates_3
  in let
    tup_el_27 =
      ErlangTuple [ErlangAtom "map", attrs_1, map1_15, updates1_24]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_27, maptype_11]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "block"), attrs_1, stmts_2])]
  =
  let    blocktype_4 = erlps__fresh_uvar__1 [attrs_1]
  in let
    newstmts_9 =
      erlps__infer_block__4 [env_0, attrs_1, stmts_2, blocktype_4]
  in let
    tup_el_12 = ErlangTuple [ErlangAtom "block", attrs_1, newstmts_9]
  in
    ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_12, blocktype_4]
erlps__infer_expr__2 [_env_0,
                      (ErlangTuple [(ErlangAtom "record_or_map_error"), attrs_1,
                                    fields_2])]
  =
  let   
    tup_el_5 = ErlangTuple [ErlangAtom "record", attrs_1, fields_2]
  in let
    arg_3 = ErlangTuple [ErlangAtom "mixed_record_and_map", tup_el_5]
  in let _ = erlps__type_error__1 [arg_3]
  in let type_10 = erlps__fresh_uvar__1 [attrs_1]
  in let
    tup_el_13 =
      ErlangTuple [ErlangAtom "record", attrs_1, ErlangEmptyList]
  in ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_13, type_10]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record_or_map_error"), attrs_1,
                                    expr_2, (ErlangEmptyList)])]
  =
  let   
    tup_el_5 =
      ErlangTuple
        [ErlangAtom "record", attrs_1, expr_2, ErlangEmptyList]
  in let
    arg_3 =
      ErlangTuple [ErlangAtom "empty_record_or_map_update", tup_el_5]
  in let _ = erlps__type_error__1 [arg_3]
  in erlps__infer_expr__2 [env_0, expr_2]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "record_or_map_error"), attrs_1,
                                    expr_2, fields_3])]
  =
  let   
    tup_el_6 =
      ErlangTuple [ErlangAtom "record", attrs_1, expr_2, fields_3]
  in let
    arg_4 = ErlangTuple [ErlangAtom "mixed_record_and_map", tup_el_6]
  in let _ = erlps__type_error__1 [arg_4]
  in erlps__infer_expr__2 [env_0, expr_2]
erlps__infer_expr__2 [env_0,
                      (ErlangTuple [(ErlangAtom "lam"), attrs_1, args_2,
                                    body_3])]
  =
  let   
    argtypes_9 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "arg"), as_5, _, _]) ->
               let lcRet_7 = erlps__fresh_uvar__1 [as_5]
               in ErlangCons lcRet_7 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_2
  in let
    argpatterns_22 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangAtom "arg"), as_11, pat_12, t_13]) ->
               let    tup_el_19 = erlps__check_type__2 [env_0, t_13]
               in let
                 lcRet_15 =
                   ErlangTuple [ErlangAtom "typed", as_11, pat_12, tup_el_19]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_2
  in let resulttype_24 = erlps__fresh_uvar__1 [attrs_1]
  in let
    arg_27 =
      ErlangTuple [ErlangAtom "tuple", attrs_1, argpatterns_22]
  in let
    arg_31 = ErlangTuple [ErlangAtom "tuple_t", attrs_1, argtypes_9]
  in let
    matchExpr_39 =
      erlps__infer_case__6
        [env_0, attrs_1, arg_27, arg_31, body_3, resulttype_24]
  in
    case matchExpr_39 of
      (ErlangTuple [(ErlangAtom "case"), _,
                    (ErlangTuple [(ErlangAtom "typed"), _,
                                  (ErlangTuple [(ErlangAtom "tuple"), _,
                                                newargpatterns_37]),
                                  _]),
                    newbody_38]) ->
        let   
          newargs_50 =
            flmap
              (\ lc_44 ->
                 case lc_44 of
                   (ErlangTuple [(ErlangAtom "typed"), as_41, newpat_42,
                                 newt_43]) ->
                     let
                       lcRet_45 =
                         ErlangTuple
                           [ErlangAtom "arg", as_41, newpat_42, newt_43]
                     in ErlangCons lcRet_45 ErlangEmptyList
                   _ -> ErlangEmptyList)
              newargpatterns_37
        in let
          tup_el_53 =
            ErlangTuple [ErlangAtom "lam", attrs_1, newargs_50, newbody_38]
        in let
          tup_el_58 =
            ErlangTuple
              [ErlangAtom "fun_t", attrs_1, ErlangEmptyList, argtypes_9,
               resulttype_24]
        in
          ErlangTuple [ErlangAtom "typed", attrs_1, tup_el_53, tup_el_58]
      _ -> EXC.badmatch matchExpr_39
erlps__infer_expr__2 [env_0,
                      let_2@(ErlangTuple [(ErlangAtom "letval"), attrs_1, _,
                                          _])]
  =
  let   
    arg_3 = ErlangTuple [ErlangAtom "missing_body_for_let", attrs_1]
  in let _ = erlps__type_error__1 [arg_3]
  in let arg_15 = toErl "missing body"
  in let head_13 = erlps__abort_expr__2 [attrs_1, arg_15]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "block", attrs_1,
         ErlangCons let_2 (ErlangCons head_13 ErlangEmptyList)]
  in erlps__infer_expr__2 [env_0, arg_7]
erlps__infer_expr__2 [env_0,
                      let_2@(ErlangTuple [(ErlangAtom "letfun"), attrs_1, _, _,
                                          _, _])]
  =
  let   
    arg_3 = ErlangTuple [ErlangAtom "missing_body_for_let", attrs_1]
  in let _ = erlps__type_error__1 [arg_3]
  in let arg_15 = toErl "missing body"
  in let head_13 = erlps__abort_expr__2 [attrs_1, arg_15]
  in let
    arg_7 =
      ErlangTuple
        [ErlangAtom "block", attrs_1,
         ErlangCons let_2 (ErlangCons head_13 ErlangEmptyList)]
  in erlps__infer_expr__2 [env_0, arg_7]
erlps__infer_expr__2 [arg_17, arg_18] = EXC.function_clause unit
erlps__infer_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_expr__2) args

erlps__infer_named_arg__3 :: ErlangFun
erlps__infer_named_arg__3 [env_0, namedargs_1,
                           (ErlangTuple [(ErlangAtom "named_arg"), ann_2, id_3,
                                         e_4])]
  =
  let matchExpr_8 = erlps__infer_expr__2 [env_0, e_4]
  in
    case matchExpr_8 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, argtype_7]) ->
        let    _ = erlps__check_stateful_named_arg__3 [env_0, id_3, e_4]
        in let
          arg_13 =
            ErlangTuple
              [ErlangAtom "named_argument_constraint", namedargs_1, id_3,
               argtype_7]
        in let _ = erlps__add_named_argument_constraint__1 [arg_13]
        in ErlangTuple [ErlangAtom "named_arg", ann_2, id_3, matchExpr_8]
      _ -> EXC.badmatch matchExpr_8
erlps__infer_named_arg__3 [arg_22, arg_23, arg_24] =
  EXC.function_clause unit
erlps__infer_named_arg__3 args =
  EXC.badarity (ErlangFun 3 erlps__infer_named_arg__3) args

erlps__check_map_update__4 :: ErlangFun
erlps__check_map_update__4 [env_0,
                            (ErlangTuple [(ErlangAtom "field"), ann_1,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    ann1_2,
                                                                    key_3]) (ErlangEmptyList)),
                                          val_4]),
                            keytype_5, valtype_6]
  =
  let    key1_10 = erlps__check_expr__3 [env_0, key_3, keytype_5]
  in let val1_14 = erlps__check_expr__3 [env_0, val_4, valtype_6]
  in let
    head_18 = ErlangTuple [ErlangAtom "map_get", ann1_2, key1_10]
  in
    ErlangTuple
      [ErlangAtom "field", ann_1, ErlangCons head_18 ErlangEmptyList,
       val1_14]
erlps__check_map_update__4 [_env_0,
                            upd_6@(ErlangTuple [(ErlangAtom "field"), _ann_1,
                                                (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                          _ann1_2,
                                                                          _key_3,
                                                                          _def_4]) (ErlangEmptyList)),
                                                _val_5]),
                            _keytype_7, _valtype_8]
  =
  let
    arg_9 =
      ErlangTuple [ErlangAtom "unnamed_map_update_with_default", upd_6]
  in erlps__type_error__1 [arg_9]
erlps__check_map_update__4 [env_0,
                            (ErlangTuple [(ErlangAtom "field"), ann_1,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    ann1_2,
                                                                    key_3]) (ErlangEmptyList)),
                                          id_4, val_5]),
                            keytype_6, valtype_7]
  =
  let   
    funtype_15 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_1, ErlangEmptyList,
         ErlangCons valtype_7 ErlangEmptyList, valtype_7]
  in let key1_19 = erlps__check_expr__3 [env_0, key_3, keytype_6]
  in let
    head_25 = ErlangTuple [ErlangAtom "arg", ann1_2, id_4, valtype_7]
  in let
    arg_21 =
      ErlangTuple
        [ErlangAtom "lam", ann1_2, ErlangCons head_25 ErlangEmptyList,
         val_5]
  in let fun_33 = erlps__check_expr__3 [env_0, arg_21, funtype_15]
  in let
    head_37 = ErlangTuple [ErlangAtom "map_get", ann1_2, key1_19]
  in
    ErlangTuple
      [ErlangAtom "field_upd", ann_1,
       ErlangCons head_37 ErlangEmptyList, fun_33]
erlps__check_map_update__4 [env_0,
                            (ErlangTuple [(ErlangAtom "field"), ann_1,
                                          (ErlangCons (ErlangTuple [(ErlangAtom "map_get"),
                                                                    ann1_2,
                                                                    key_3,
                                                                    def_4]) (ErlangEmptyList)),
                                          id_5, val_6]),
                            keytype_7, valtype_8]
  =
  let   
    funtype_16 =
      ErlangTuple
        [ErlangAtom "fun_t", ann_1, ErlangEmptyList,
         ErlangCons valtype_8 ErlangEmptyList, valtype_8]
  in let key1_20 = erlps__check_expr__3 [env_0, key_3, keytype_7]
  in let def1_24 = erlps__check_expr__3 [env_0, def_4, valtype_8]
  in let
    head_30 = ErlangTuple [ErlangAtom "arg", ann1_2, id_5, valtype_8]
  in let
    arg_26 =
      ErlangTuple
        [ErlangAtom "lam", ann1_2, ErlangCons head_30 ErlangEmptyList,
         val_6]
  in let fun_38 = erlps__check_expr__3 [env_0, arg_26, funtype_16]
  in let
    head_42 =
      ErlangTuple [ErlangAtom "map_get", ann1_2, key1_20, def1_24]
  in
    ErlangTuple
      [ErlangAtom "field_upd", ann_1,
       ErlangCons head_42 ErlangEmptyList, fun_38]
erlps__check_map_update__4 [_,
                            (ErlangTuple [(ErlangAtom "field"), ann_0, flds_1,
                                          _]),
                            _, _]
  =
  let
    arg_2 =
      ErlangTuple
        [ErlangAtom "nested_map_updates_not_implemented", ann_0, flds_1]
  in BIF.erlang__error__1 [arg_2]
erlps__check_map_update__4 [arg_6, arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__check_map_update__4 args =
  EXC.badarity (ErlangFun 4 erlps__check_map_update__4) args

erlps__check_record_update__3 :: ErlangFun
erlps__check_record_update__3 [env_0, recordtype_1, fld_2] =
  let matchExpr_9 = BIF.erlang__tuple_to_list__1 [fld_2]
  in
    case matchExpr_9 of
      (ErlangCons (ErlangAtom "field") (ErlangCons ann_4 (ErlangCons lv_7@(ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                                                                    ann1_5,
                                                                                                    fieldname_6]) (ErlangEmptyList)) val_8))) ->
        let    fldtype_11 = erlps__fresh_uvar__1 [ann_4]
        in let
          fld1_49 =
            case val_8 of
              (ErlangCons expr_13 (ErlangEmptyList)) ->
                let
                  tup_el_17 = erlps__check_expr__3 [env_0, expr_13, fldtype_11]
                in ErlangTuple [ErlangAtom "field", ann_4, lv_7, tup_el_17]
              (ErlangCons id_21 (ErlangCons expr_22 (ErlangEmptyList))) ->
                let   
                  head_26 =
                    ErlangTuple [ErlangAtom "arg", ann1_5, id_21, fldtype_11]
                in let
                  fun_33 =
                    ErlangTuple
                      [ErlangAtom "lam", ann1_5,
                       ErlangCons head_26 ErlangEmptyList, expr_22]
                in let
                  funtype_41 =
                    ErlangTuple
                      [ErlangAtom "fun_t", ann1_5, ErlangEmptyList,
                       ErlangCons fldtype_11 ErlangEmptyList, fldtype_11]
                in let
                  tup_el_45 = erlps__check_expr__3 [env_0, fun_33, funtype_41]
                in ErlangTuple [ErlangAtom "field_upd", ann_4, lv_7, tup_el_45]
              something_else -> EXC.case_clause something_else
        in let
          tup_el_53 = erlps__unfold_types_in_type__2 [env_0, recordtype_1]
        in let
          head_51 =
            ErlangTuple
              [ErlangAtom "field_constraint", tup_el_53, fieldname_6,
               fldtype_11, ErlangAtom "update", fld_2]
        in let
          _ = erlps__constrain__1 [ErlangCons head_51 ErlangEmptyList]
        in fld1_49
      _ -> EXC.badmatch matchExpr_9
erlps__check_record_update__3 [arg_61, arg_62, arg_63] =
  EXC.function_clause unit
erlps__check_record_update__3 args =
  EXC.badarity (ErlangFun 3 erlps__check_record_update__3) args

erlps__infer_op__5 :: ErlangFun
erlps__infer_op__5 [env_0, as_1, op_2, args_3, inferop_4] =
  let   
    typedargs_11 =
      flmap
        (\ lc_7 ->
           let lcRet_8 = erlps__infer_expr__2 [env_0, lc_7]
           in ErlangCons lcRet_8 ErlangEmptyList)
        args_3
  in let
    argtypes_16 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangAtom "typed"), _, _, t_13]) ->
               ErlangCons t_13 ErlangEmptyList
             _ -> ErlangEmptyList)
        typedargs_11
  in let
    matchExpr_21 =
      BIF.erlang__apply__2 [inferop_4, ErlangCons op_2 ErlangEmptyList]
  in
    case matchExpr_21 of
      (ErlangTuple [(ErlangAtom "fun_t"), _, _, operandtypes_19,
                    resulttype_20]) ->
        let   
          arg_26 =
            ErlangTuple
              [ErlangAtom "infer_app", op_2, args_3, matchExpr_21, argtypes_16]
        in let
          _ = erlps__unify__4 [env_0, argtypes_16, operandtypes_19, arg_26]
        in let
          tup_el_34 =
            ErlangTuple [ErlangAtom "app", as_1, op_2, typedargs_11]
        in
          ErlangTuple [ErlangAtom "typed", as_1, tup_el_34, resulttype_20]
      _ -> EXC.badmatch matchExpr_21
erlps__infer_op__5 [arg_40, arg_41, arg_42, arg_43, arg_44] =
  EXC.function_clause unit
erlps__infer_op__5 args =
  EXC.badarity (ErlangFun 5 erlps__infer_op__5) args

erlps__infer_pattern__2 :: ErlangFun
erlps__infer_pattern__2 [env_0, pattern_1] =
  let    vars_3 = erlps__free_vars__1 [pattern_1]
  in let
    names_11 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "id"), _, n_5]) ->
               let    rop_9 = toErl "_"
               in let cond_7 = BIF.erlang__op_neq [n_5, rop_9]
               in
                 case cond_7 of
                   (ErlangAtom "true") -> ErlangCons n_5 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        vars_3
  in let
    rop_14 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [names_11]
  in let case_12 = BIF.erlang__op_unAppend [names_11, rop_14]
  in let
    _ =
      case case_12 of
        (ErlangEmptyList) -> ErlangAtom "ok"
        nonlinear_16 ->
          let   
            tup_el_20 =
              BIF.do_remote_fun_call "Lists" "erlps__usort__1" [nonlinear_16]
          in let
            arg_17 =
              ErlangTuple
                [ErlangAtom "non_linear_pattern", pattern_1, tup_el_20]
          in erlps__type_error__1 [arg_17]
  in let
    arg_22 =
      flmap
        (\ lc_26 ->
           case lc_26 of
             var_25@(ErlangTuple [(ErlangAtom "id"), ann1_24, _]) ->
               let    tup_el_29 = erlps__fresh_uvar__1 [ann1_24]
               in let lcRet_27 = ErlangTuple [var_25, tup_el_29]
               in ErlangCons lcRet_27 ErlangEmptyList
             _ -> ErlangEmptyList)
        vars_3
  in let
    arg_31 =
      case env_0 of
        (ErlangTuple [(ErlangAtom "env"), scopes_34, vars_35,
                      typevars_36, fields_37, namespace_38, in_pattern_39,
                      stateful_40, current_function_41, what_42]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_34, vars_35, typevars_36, fields_37,
             namespace_38, ErlangAtom "true", stateful_40,
             current_function_41, what_42]
        _ -> EXC.badrecord (ErlangAtom "env")
  in let newenv_43 = erlps__bind_vars__2 [arg_22, arg_31]
  in let
    newpattern_46 = erlps__infer_expr__2 [newenv_43, pattern_1]
  in let
    record_updt_49 =
      case env_0 of
        (ErlangTuple arr_52) | (DM.Just field_51) <- (arr_52 DA.!! 6) ->
          field_51
        _ -> EXC.badrecord (ErlangAtom "env")
  in let
    tup_el_47 =
      case newenv_43 of
        (ErlangTuple [(ErlangAtom "env"), scopes_53, vars_54,
                      typevars_55, fields_56, namespace_57, in_pattern_58,
                      stateful_59, current_function_60, what_61]) ->
          ErlangTuple
            [ErlangAtom "env", scopes_53, vars_54, typevars_55, fields_56,
             namespace_57, record_updt_49, stateful_59, current_function_60,
             what_61]
        _ -> EXC.badrecord (ErlangAtom "env")
  in ErlangTuple [tup_el_47, newpattern_46]
erlps__infer_pattern__2 [arg_63, arg_64] =
  EXC.function_clause unit
erlps__infer_pattern__2 args =
  EXC.badarity (ErlangFun 2 erlps__infer_pattern__2) args

erlps__infer_case__6 :: ErlangFun
erlps__infer_case__6 [env_0, attrs_1, pattern_2, exprtype_3,
                      branch_4, switchtype_5]
  =
  let matchExpr_11 = erlps__infer_pattern__2 [env_0, pattern_2]
  in
    case matchExpr_11 of
      (ErlangTuple [newenv_8,
                    newpattern_10@(ErlangTuple [(ErlangAtom "typed"), _, _,
                                                pattype_9])]) ->
        let   
          arg_12 =
            case newenv_8 of
              (ErlangTuple [(ErlangAtom "env"), scopes_15, vars_16,
                            typevars_17, fields_18, namespace_19, in_pattern_20,
                            stateful_21, current_function_22, what_23]) ->
                ErlangTuple
                  [ErlangAtom "env", scopes_15, vars_16, typevars_17, fields_18,
                   namespace_19, ErlangAtom "false", stateful_21,
                   current_function_22, what_23]
              _ -> EXC.badrecord (ErlangAtom "env")
        in let
          newbranch_26 =
            erlps__check_expr__3 [arg_12, branch_4, switchtype_5]
        in let
          arg_30 =
            ErlangTuple
              [ErlangAtom "case_pat", pattern_2, pattype_9, exprtype_3]
        in let _ = erlps__unify__4 [env_0, pattype_9, exprtype_3, arg_30]
        in
          ErlangTuple
            [ErlangAtom "case", attrs_1, newpattern_10, newbranch_26]
      _ -> EXC.badmatch matchExpr_11
erlps__infer_case__6 [arg_39, arg_40, arg_41, arg_42, arg_43,
                      arg_44]
  =
  EXC.function_clause unit
erlps__infer_case__6 args =
  EXC.badarity (ErlangFun 6 erlps__infer_case__6) args

erlps__infer_block__4 :: ErlangFun
erlps__infer_block__4 [_env_0, attrs_1, (ErlangEmptyList),
                       blocktype_2]
  =
  let
    arg_3 =
      ErlangTuple
        [ErlangAtom "impossible", ErlangAtom "empty_block", attrs_1,
         blocktype_2]
  in BIF.erlang__error__1 [arg_3]
erlps__infer_block__4 [env_0, _,
                       (ErlangCons e_1 (ErlangEmptyList)), blocktype_2]
  =
  let head_3 = erlps__check_expr__3 [env_0, e_1, blocktype_2]
  in ErlangCons head_3 ErlangEmptyList
erlps__infer_block__4 [env_0, attrs_1,
                       (ErlangCons def_3@(ErlangTuple [(ErlangAtom "letfun"),
                                                       ann_2, _, _, _,
                                                       _]) rest_4),
                       blocktype_5]
  =
  let matchExpr_11 = erlps__infer_letfun__2 [env_0, def_3]
  in
    case matchExpr_11 of
      (ErlangTuple [(ErlangTuple [name_8, typesig_9]), letfun_10]) ->
        let    funt_13 = erlps__typesig_to_fun_t__1 [typesig_9]
        in let arg_14 = ErlangTuple [ErlangAtom "id", ann_2, name_8]
        in let newe_20 = erlps__bind_var__3 [arg_14, funt_13, env_0]
        in let
          tail_22 =
            erlps__infer_block__4 [newe_20, attrs_1, rest_4, blocktype_5]
        in ErlangCons letfun_10 tail_22
      _ -> EXC.badmatch matchExpr_11
erlps__infer_block__4 [env_0, _,
                       (ErlangCons (ErlangTuple [(ErlangAtom "letval"), attrs_1,
                                                 pattern_2, e_3]) rest_4),
                       blocktype_5]
  =
  let matchExpr_9 = erlps__infer_expr__2 [env_0, e_3]
  in
    case matchExpr_9 of
      (ErlangTuple [(ErlangAtom "typed"), _, _, pattype_8]) ->
        let    arg_15 = ErlangTuple [ErlangAtom "block", attrs_1, rest_4]
        in let
          matchExpr_22 =
            erlps__infer_case__6
              [env_0, attrs_1, pattern_2, pattype_8, arg_15, blocktype_5]
        in
          case matchExpr_22 of
            (ErlangTuple [(ErlangAtom "case"), _, newpattern_20,
                          (ErlangTuple [(ErlangAtom "typed"), _,
                                        (ErlangTuple [(ErlangAtom "block"), _,
                                                      newrest_21]),
                                        _])]) ->
              let
                head_23 =
                  ErlangTuple
                    [ErlangAtom "letval", attrs_1, newpattern_20, matchExpr_9]
              in ErlangCons head_23 newrest_21
            _ -> EXC.badmatch matchExpr_22
      _ -> EXC.badmatch matchExpr_9
erlps__infer_block__4 [env_0, attrs_1, (ErlangCons e_2 rest_3),
                       blocktype_4]
  =
  let    head_5 = erlps__infer_expr__2 [env_0, e_2]
  in let
    tail_8 =
      erlps__infer_block__4 [env_0, attrs_1, rest_3, blocktype_4]
  in ErlangCons head_5 tail_8
erlps__infer_block__4 [arg_13, arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__infer_block__4 args =
  EXC.badarity (ErlangFun 4 erlps__infer_block__4) args

erlps__infer_infix__1 :: ErlangFun
erlps__infer_infix__1 [(ErlangTuple [boolop_0, as_1])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_15 = BIF.erlang__op_exactEq [boolop_0, ErlangAtom "&&"]
            in
              case lop_15 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_exactEq [boolop_0, ErlangAtom "||"]
                _ -> EXC.badarg1 lop_15)) =
  let    tup_el_4 = toErl "bool"
  in let bool_5 = ErlangTuple [ErlangAtom "id", as_1, tup_el_4]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons bool_5 (ErlangCons bool_5 ErlangEmptyList), bool_5]
erlps__infer_infix__1 [(ErlangTuple [intop_0, as_1])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_19 = BIF.erlang__op_eq [intop_0, ErlangAtom "+"]
            in let
              lop_18 =
                case lop_19 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [intop_0, ErlangAtom "-"]
                  _ -> EXC.badarg1 lop_19
            in let
              lop_17 =
                case lop_18 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [intop_0, ErlangAtom "*"]
                  _ -> EXC.badarg1 lop_18
            in let
              lop_16 =
                case lop_17 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [intop_0, ErlangAtom "/"]
                  _ -> EXC.badarg1 lop_17
            in let
              lop_15 =
                case lop_16 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [intop_0, ErlangAtom "^"]
                  _ -> EXC.badarg1 lop_16
            in
              case lop_15 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [intop_0, ErlangAtom "mod"]
                _ -> EXC.badarg1 lop_15)) =
  let    tup_el_4 = toErl "int"
  in let int_5 = ErlangTuple [ErlangAtom "id", as_1, tup_el_4]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons int_5 (ErlangCons int_5 ErlangEmptyList), int_5]
erlps__infer_infix__1 [(ErlangTuple [relop_0, as_1])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_22 = BIF.erlang__op_eq [relop_0, ErlangAtom "=="]
            in let
              lop_21 =
                case lop_22 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [relop_0, ErlangAtom "!="]
                  _ -> EXC.badarg1 lop_22
            in let
              lop_20 =
                case lop_21 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [relop_0, ErlangAtom "<"]
                  _ -> EXC.badarg1 lop_21
            in let
              lop_19 =
                case lop_20 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [relop_0, ErlangAtom ">"]
                  _ -> EXC.badarg1 lop_20
            in let
              lop_18 =
                case lop_19 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [relop_0, ErlangAtom "<="]
                  _ -> EXC.badarg1 lop_19
            in let
              lop_17 =
                case lop_18 of
                  (ErlangAtom "true") -> ErlangAtom "true"
                  (ErlangAtom "false") ->
                    BIF.erlang__op_eq [relop_0, ErlangAtom "=<"]
                  _ -> EXC.badarg1 lop_18
            in
              case lop_17 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  BIF.erlang__op_eq [relop_0, ErlangAtom ">="]
                _ -> EXC.badarg1 lop_17)) =
  let    t_3 = erlps__fresh_uvar__1 [as_1]
  in let tup_el_6 = toErl "bool"
  in let bool_7 = ErlangTuple [ErlangAtom "id", as_1, tup_el_6]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons t_3 (ErlangCons t_3 ErlangEmptyList), bool_7]
erlps__infer_infix__1 [(ErlangTuple [(ErlangAtom ".."), as_0])] =
  let    tup_el_3 = toErl "int"
  in let int_4 = ErlangTuple [ErlangAtom "id", as_0, tup_el_3]
  in let tup_el_19 = toErl "list"
  in let tup_el_16 = ErlangTuple [ErlangAtom "id", as_0, tup_el_19]
  in let
    tup_el_13 =
      ErlangTuple
        [ErlangAtom "app_t", as_0, tup_el_16,
         ErlangCons int_4 ErlangEmptyList]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons int_4 (ErlangCons int_4 ErlangEmptyList), tup_el_13]
erlps__infer_infix__1 [(ErlangTuple [(ErlangAtom "::"), as_0])] =
  let    elemtype_2 = erlps__fresh_uvar__1 [as_0]
  in let tup_el_8 = toErl "list"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", as_0, tup_el_8]
  in let
    listtype_12 =
      ErlangTuple
        [ErlangAtom "app_t", as_0, tup_el_5,
         ErlangCons elemtype_2 ErlangEmptyList]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons elemtype_2 (ErlangCons listtype_12 ErlangEmptyList),
       listtype_12]
erlps__infer_infix__1 [(ErlangTuple [(ErlangAtom "++"), as_0])] =
  let    elemtype_2 = erlps__fresh_uvar__1 [as_0]
  in let tup_el_8 = toErl "list"
  in let tup_el_5 = ErlangTuple [ErlangAtom "id", as_0, tup_el_8]
  in let
    listtype_12 =
      ErlangTuple
        [ErlangAtom "app_t", as_0, tup_el_5,
         ErlangCons elemtype_2 ErlangEmptyList]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons listtype_12 (ErlangCons listtype_12 ErlangEmptyList),
       listtype_12]
erlps__infer_infix__1 [arg_22] = EXC.function_clause unit
erlps__infer_infix__1 args =
  EXC.badarity (ErlangFun 1 erlps__infer_infix__1) args

erlps__infer_prefix__1 :: ErlangFun
erlps__infer_prefix__1 [(ErlangTuple [(ErlangAtom "!"), as_0])] =
  let    tup_el_3 = toErl "bool"
  in let bool_4 = ErlangTuple [ErlangAtom "id", as_0, tup_el_3]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_0, ErlangEmptyList,
       ErlangCons bool_4 ErlangEmptyList, bool_4]
erlps__infer_prefix__1 [(ErlangTuple [intop_0, as_1])]
  | (==) intop_0 (ErlangAtom "-") =
  let    tup_el_4 = toErl "int"
  in let int_5 = ErlangTuple [ErlangAtom "id", as_1, tup_el_4]
  in
    ErlangTuple
      [ErlangAtom "fun_t", as_1, ErlangEmptyList,
       ErlangCons int_5 ErlangEmptyList, int_5]
erlps__infer_prefix__1 [arg_13] = EXC.function_clause unit
erlps__infer_prefix__1 args =
  EXC.badarity (ErlangFun 1 erlps__infer_prefix__1) args

erlps__abort_expr__2 :: ErlangFun
erlps__abort_expr__2 [ann_0, str_1] =
  let    tup_el_7 = toErl "abort"
  in let tup_el_4 = ErlangTuple [ErlangAtom "id", ann_0, tup_el_7]
  in let head_9 = ErlangTuple [ErlangAtom "string", ann_0, str_1]
  in
    ErlangTuple
      [ErlangAtom "app", ann_0, tup_el_4,
       ErlangCons head_9 ErlangEmptyList]
erlps__abort_expr__2 [arg_14, arg_15] = EXC.function_clause unit
erlps__abort_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__abort_expr__2) args

erlps__free_vars__1 :: ErlangFun
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "int"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "char"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "string"), _, _])]
  =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "bool"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [id_0@(ErlangTuple [(ErlangAtom "id"), _,
                                        _])]
  =
  ErlangCons id_0 ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "con"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "qcon"), _, _])] =
  ErlangEmptyList
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "tuple"), _,
                                   cpts_0])]
  =
  erlps__free_vars__1 [cpts_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "list"), _,
                                   elems_0])]
  =
  erlps__free_vars__1 [elems_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                   (ErlangTuple [(ErlangAtom "::"), _]),
                                   args_0])]
  =
  erlps__free_vars__1 [args_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                   (ErlangTuple [(ErlangAtom "con"), _, _]),
                                   args_0])]
  =
  erlps__free_vars__1 [args_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                   (ErlangTuple [(ErlangAtom "qcon"), _, _]),
                                   args_0])]
  =
  erlps__free_vars__1 [args_0]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "record"), _,
                                   fields_0])]
  =
  let
    arg_1 =
      flmap
        (\ lc_4 ->
           case lc_4 of
             (ErlangTuple [(ErlangAtom "field"), _, _, e_3]) ->
               ErlangCons e_3 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_0
  in erlps__free_vars__1 [arg_1]
erlps__free_vars__1 [(ErlangTuple [(ErlangAtom "typed"), _, a_0,
                                   _])]
  =
  erlps__free_vars__1 [a_0]
erlps__free_vars__1 [l_0] | isEList l_0 =
  flmap
    (\ lc_3 ->
       let lcSrc_4 = erlps__free_vars__1 [lc_3]
       in flmap (\ lc_7 -> ErlangCons lc_7 ErlangEmptyList) lcSrc_4)
    l_0
erlps__free_vars__1 [arg_9] = EXC.function_clause unit
erlps__free_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__free_vars__1) args

erlps__next_count__0 :: ErlangFun
erlps__next_count__0 [] =
  let    case_0 = BIF.erlang__get__1 [ErlangAtom "counter"]
  in let
    v_3 =
      case case_0 of
        (ErlangAtom "undefined") -> toErl 0
        x_2 -> x_2
  in let rop_7 = toErl 1
  in let arg_5 = BIF.erlang__op_plus [v_3, rop_7]
  in let _ = BIF.erlang__put__2 [ErlangAtom "counter", arg_5]
  in v_3
erlps__next_count__0 args =
  EXC.badarity (ErlangFun 0 erlps__next_count__0) args

erlps__ets_tables__0 :: ErlangFun
erlps__ets_tables__0 [] =
  ErlangCons (ErlangAtom "options")
    (ErlangCons (ErlangAtom "type_vars")
       (ErlangCons (ErlangAtom "type_defs")
          (ErlangCons (ErlangAtom "record_fields")
             (ErlangCons (ErlangAtom "named_argument_constraints")
                (ErlangCons (ErlangAtom "field_constraints")
                   (ErlangCons (ErlangAtom "freshen_tvars")
                      (ErlangCons (ErlangAtom "type_errors")
                         ErlangEmptyList)))))))
erlps__ets_tables__0 args =
  EXC.badarity (ErlangFun 0 erlps__ets_tables__0) args

erlps__clean_up_ets__0 :: ErlangFun
erlps__clean_up_ets__0 [] =
  let    lcSrc_0 = erlps__ets_tables__0 []
  in let
    _ =
      flmap
        (\ lc_2 ->
           let
             lcRet_3 =
               EXC.tryCatch (\ _ -> erlps__ets_delete__1 [lc_2])
                 (\ ex_6 ->
                    case ex_6 of
                      (ErlangTuple [(ErlangAtom "throw"), payload_8, _]) ->
                        payload_8
                      (ErlangTuple [(ErlangAtom "error"), payload_9,
                                    stack_10]) ->
                        let tup_el_12 = ErlangTuple [payload_9, stack_10]
                        in ErlangTuple [ErlangAtom "EXIT", tup_el_12]
                      (ErlangTuple [(ErlangAtom "exit"), payload_15, _]) ->
                        ErlangTuple [ErlangAtom "EXIT", payload_15]
                      ex_7 -> EXC.raise ex_7)
           in ErlangCons lcRet_3 ErlangEmptyList)
        lcSrc_0
  in ErlangAtom "ok"
erlps__clean_up_ets__0 args =
  EXC.badarity (ErlangFun 0 erlps__clean_up_ets__0) args

erlps__ets_init__0 :: ErlangFun
erlps__ets_init__0 [] =
  let arg_1 = ErlangMap Map.empty
  in BIF.erlang__put__2 [ErlangAtom "aeso_ast_infer_types", arg_1]
erlps__ets_init__0 args =
  EXC.badarity (ErlangFun 0 erlps__ets_init__0) args

erlps__ets_tabid__1 :: ErlangFun
erlps__ets_tabid__1 [name_0] =
  let
    matchExpr_4 =
      BIF.erlang__get__1 [ErlangAtom "aeso_ast_infer_types"]
  in
    case matchExpr_4 of
      (ErlangMap map_2) | (DM.Just tabid_3) <-
                            (Map.lookup name_0 map_2) ->
        tabid_3
      _ -> EXC.badmatch matchExpr_4
erlps__ets_tabid__1 [arg_5] = EXC.function_clause unit
erlps__ets_tabid__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_tabid__1) args

erlps__ets_new__2 :: ErlangFun
erlps__ets_new__2 [name_0, opts_1] =
  let   
    arg_3 =
      BIF.erlang__op_unAppend
        [opts_1, ErlangCons (ErlangAtom "named_table") ErlangEmptyList]
  in let
    tabid_8 =
      BIF.do_remote_fun_call "Ets" "erlps__new__2" [name_0, arg_3]
  in let
    tabs_10 = BIF.erlang__get__1 [ErlangAtom "aeso_ast_infer_types"]
  in let mapExt_16 = ErlangMap (Map.singleton name_0 tabid_8)
  in let arg_12 = BIF.maps__merge__2 [tabs_10, mapExt_16]
  in let
    _ =
      BIF.erlang__put__2 [ErlangAtom "aeso_ast_infer_types", arg_12]
  in name_0
erlps__ets_new__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__ets_new__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_new__2) args

erlps__ets_delete__1 :: ErlangFun
erlps__ets_delete__1 [name_0] =
  let
    tabs_2 = BIF.erlang__get__1 [ErlangAtom "aeso_ast_infer_types"]
  in
    case tabs_2 of
      (ErlangMap map_3) | (DM.Just tabid_4) <-
                            (Map.lookup name_0 map_3) ->
        let    arg_7 = BIF.maps__remove__2 [name_0, tabs_2]
        in let
          _ = BIF.erlang__put__2 [ErlangAtom "aeso_ast_infer_types", arg_7]
        in BIF.do_remote_fun_call "Ets" "erlps__delete__1" [tabid_4]
      _ -> EXC.badmatch tabs_2
erlps__ets_delete__1 [arg_11] = EXC.function_clause unit
erlps__ets_delete__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_delete__1) args

erlps__ets_insert__2 :: ErlangFun
erlps__ets_insert__2 [name_0, object_1] =
  let tabid_3 = erlps__ets_tabid__1 [name_0]
  in
    BIF.do_remote_fun_call "Ets" "erlps__insert__2"
      [tabid_3, object_1]
erlps__ets_insert__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__ets_insert__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_insert__2) args

erlps__ets_lookup__2 :: ErlangFun
erlps__ets_lookup__2 [name_0, key_1] =
  let tabid_3 = erlps__ets_tabid__1 [name_0]
  in
    BIF.do_remote_fun_call "Ets" "erlps__lookup__2" [tabid_3, key_1]
erlps__ets_lookup__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__ets_lookup__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_lookup__2) args

erlps__ets_tab2list__1 :: ErlangFun
erlps__ets_tab2list__1 [name_0] =
  let tabid_2 = erlps__ets_tabid__1 [name_0]
  in BIF.do_remote_fun_call "Ets" "erlps__tab2list__1" [tabid_2]
erlps__ets_tab2list__1 [arg_4] = EXC.function_clause unit
erlps__ets_tab2list__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_tab2list__1) args

erlps__ets_insert_ordered__2 :: ErlangFun
erlps__ets_insert_ordered__2 [_, (ErlangEmptyList)] =
  ErlangAtom "true"
erlps__ets_insert_ordered__2 [name_0, (ErlangCons h_1 t_2)] =
  let _ = erlps__ets_insert_ordered__2 [name_0, h_1]
  in erlps__ets_insert_ordered__2 [name_0, t_2]
erlps__ets_insert_ordered__2 [name_0, object_1] =
  let    count_2 = erlps__next_count__0 []
  in let tabid_4 = erlps__ets_tabid__1 [name_0]
  in let arg_6 = ErlangTuple [count_2, object_1]
  in
    BIF.do_remote_fun_call "Ets" "erlps__insert__2" [tabid_4, arg_6]
erlps__ets_insert_ordered__2 [arg_9, arg_10] =
  EXC.function_clause unit
erlps__ets_insert_ordered__2 args =
  EXC.badarity (ErlangFun 2 erlps__ets_insert_ordered__2) args

erlps__ets_tab2list_ordered__1 :: ErlangFun
erlps__ets_tab2list_ordered__1 [name_0] =
  let lcSrc_1 = erlps__ets_tab2list__1 [name_0]
  in
    flmap
      (\ lc_4 ->
         case lc_4 of
           (ErlangTuple [_, e_3]) -> ErlangCons e_3 ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_1
erlps__ets_tab2list_ordered__1 [arg_6] = EXC.function_clause unit
erlps__ets_tab2list_ordered__1 args =
  EXC.badarity (ErlangFun 1 erlps__ets_tab2list_ordered__1) args

erlps__create_options__1 :: ErlangFun
erlps__create_options__1 [options_0] =
  let   
    _ =
      erlps__ets_new__2
        [ErlangAtom "options",
         ErlangCons (ErlangAtom "set") ErlangEmptyList]
  in let
    tup_11 =
      ErlangFun 1
        (let
           lambda_5 [opt_7] | isEAtom opt_7 =
             ErlangTuple [opt_7, ErlangAtom "true"]
           lambda_5 [opt_10] | isETuple opt_10 = opt_10
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in let
    arg_13 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2"
        [tup_11, options_0]
  in erlps__ets_insert__2 [ErlangAtom "options", arg_13]
erlps__create_options__1 [arg_16] = EXC.function_clause unit
erlps__create_options__1 args =
  EXC.badarity (ErlangFun 1 erlps__create_options__1) args

erlps__get_option__2 :: ErlangFun
erlps__get_option__2 [key_0, default_1] =
  let case_2 = erlps__ets_lookup__2 [ErlangAtom "options", key_0]
  in
    case case_2 of
      (ErlangCons (ErlangTuple [key_5,
                                val_6]) (ErlangEmptyList)) | key_5 == key_0 ->
        val_6
      _ -> default_1
erlps__get_option__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__get_option__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_option__2) args

erlps__when_option__2 :: ErlangFun
erlps__when_option__2 [opt_0, do_1] =
  let lop_2 = erlps__get_option__2 [opt_0, ErlangAtom "false"]
  in
    case lop_2 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") ->
        BIF.erlang__apply__2 [do_1, ErlangEmptyList]
      _ -> EXC.badarg1 lop_2
erlps__when_option__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__when_option__2 args =
  EXC.badarity (ErlangFun 2 erlps__when_option__2) args

erlps__create_constraints__0 :: ErlangFun
erlps__create_constraints__0 [] =
  let    _ = erlps__create_named_argument_constraints__0 []
  in let _ = erlps__create_bytes_constraints__0 []
  in erlps__create_field_constraints__0 []
erlps__create_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_constraints__0) args

erlps__destroy_and_report_unsolved_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_constraints__1 [env_0] =
  let    _ = erlps__solve_named_argument_constraints__1 [env_0]
  in let _ = erlps__solve_bytes_constraints__1 [env_0]
  in let _ = erlps__solve_field_constraints__1 [env_0]
  in let
    _ =
      erlps__destroy_and_report_unsolved_field_constraints__1 [env_0]
  in let
    _ =
      erlps__destroy_and_report_unsolved_bytes_constraints__1 [env_0]
  in
    erlps__destroy_and_report_unsolved_named_argument_constraints__1
      [env_0]
erlps__destroy_and_report_unsolved_constraints__1 [arg_7] =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_constraints__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__destroy_and_report_unsolved_constraints__1)
    args

erlps__create_named_argument_constraints__0 :: ErlangFun
erlps__create_named_argument_constraints__0 [] =
  erlps__ets_new__2
    [ErlangAtom "named_argument_constraints",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_named_argument_constraints__0 args =
  EXC.badarity
    (ErlangFun 0 erlps__create_named_argument_constraints__0) args

erlps__destroy_named_argument_constraints__0 :: ErlangFun
erlps__destroy_named_argument_constraints__0 [] =
  erlps__ets_delete__1 [ErlangAtom "named_argument_constraints"]
erlps__destroy_named_argument_constraints__0 args =
  EXC.badarity
    (ErlangFun 0 erlps__destroy_named_argument_constraints__0) args

erlps__get_named_argument_constraints__0 :: ErlangFun
erlps__get_named_argument_constraints__0 [] =
  erlps__ets_tab2list_ordered__1
    [ErlangAtom "named_argument_constraints"]
erlps__get_named_argument_constraints__0 args =
  EXC.badarity
    (ErlangFun 0 erlps__get_named_argument_constraints__0) args

erlps__add_named_argument_constraint__1 :: ErlangFun
erlps__add_named_argument_constraint__1 [constraint_0] =
  let
    _ =
      erlps__ets_insert_ordered__2
        [ErlangAtom "named_argument_constraints", constraint_0]
  in ErlangAtom "ok"
erlps__add_named_argument_constraint__1 [arg_3] =
  EXC.function_clause unit
erlps__add_named_argument_constraint__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__add_named_argument_constraint__1) args

erlps__solve_named_argument_constraints__1 :: ErlangFun
erlps__solve_named_argument_constraints__1 [env_0] =
  let    arg_2 = erlps__get_named_argument_constraints__0 []
  in let
    unsolved_3 =
      erlps__solve_named_argument_constraints__2 [env_0, arg_2]
  in BIF.erlang__op_eq [unsolved_3, ErlangEmptyList]
erlps__solve_named_argument_constraints__1 [arg_6] =
  EXC.function_clause unit
erlps__solve_named_argument_constraints__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__solve_named_argument_constraints__1) args

erlps__solve_named_argument_constraints__2 :: ErlangFun
erlps__solve_named_argument_constraints__2 [env_0,
                                            constraints0_1]
  =
  let lcSrc_2 = erlps__dereference_deep__1 [constraints0_1]
  in
    flmap
      (\ lc_5 ->
         let   
           rop_8 = erlps__check_named_argument_constraint__2 [env_0, lc_5]
         in let cond_6 = BIF.erlang__op_eq [ErlangAtom "unsolved", rop_8]
         in
           case cond_6 of
             (ErlangAtom "true") -> ErlangCons lc_5 ErlangEmptyList
             _ -> ErlangEmptyList)
      lcSrc_2
erlps__solve_named_argument_constraints__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__solve_named_argument_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__solve_named_argument_constraints__2) args

erlps__check_named_argument_constraint__2 :: ErlangFun
erlps__check_named_argument_constraint__2 [_env_0,
                                           (ErlangTuple [(ErlangAtom "named_argument_constraint"),
                                                         (ErlangTuple [(ErlangAtom "uvar"),
                                                                       _, _]),
                                                         _, _])]
  =
  ErlangAtom "unsolved"
erlps__check_named_argument_constraint__2 [env_0,
                                           c_5@(ErlangTuple [(ErlangAtom "named_argument_constraint"),
                                                             args_1,
                                                             id_3@(ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                name_2]),
                                                             type_4])]
  =
  let
    case_6 =
      flmap
        (\ lc_10 ->
           case lc_10 of
             (ErlangTuple [(ErlangAtom "named_arg_t"), _,
                           (ErlangTuple [(ErlangAtom "id"), _, name1_8]), t_9,
                           _]) ->
               let cond_11 = BIF.erlang__op_eq [name1_8, name_2]
               in
                 case cond_11 of
                   (ErlangAtom "true") -> ErlangCons t_9 ErlangEmptyList
                   _ -> ErlangEmptyList
             _ -> ErlangEmptyList)
        args_1
  in
    case case_6 of
      (ErlangEmptyList) ->
        let   
          arg_15 =
            ErlangTuple [ErlangAtom "bad_named_argument", args_1, id_3]
        in let _ = erlps__type_error__1 [arg_15]
        in ErlangAtom "false"
      (ErlangCons t_19 (ErlangEmptyList)) ->
        let   
          arg_23 =
            ErlangTuple [ErlangAtom "check_named_arg_constraint", c_5]
        in let _ = erlps__unify__4 [env_0, t_19, type_4, arg_23]
        in ErlangAtom "true"
      something_else -> EXC.case_clause something_else
erlps__check_named_argument_constraint__2 [arg_26, arg_27] =
  EXC.function_clause unit
erlps__check_named_argument_constraint__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__check_named_argument_constraint__2) args

erlps__destroy_and_report_unsolved_named_argument_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_named_argument_constraints__1 [env_0]
  =
  let    arg_2 = erlps__get_named_argument_constraints__0 []
  in let
    unsolved_3 =
      erlps__solve_named_argument_constraints__2 [env_0, arg_2]
  in let
    _ =
      flmap
        (\ lc_6 ->
           let   
             arg_8 =
               ErlangTuple
                 [ErlangAtom "unsolved_named_argument_constraint", lc_6]
           in let lcRet_7 = erlps__type_error__1 [arg_8]
           in ErlangCons lcRet_7 ErlangEmptyList)
        unsolved_3
  in let _ = erlps__destroy_named_argument_constraints__0 []
  in ErlangAtom "ok"
erlps__destroy_and_report_unsolved_named_argument_constraints__1 [arg_11]
  =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_named_argument_constraints__1 args
  =
  EXC.badarity
    (ErlangFun 1
       erlps__destroy_and_report_unsolved_named_argument_constraints__1)
    args

erlps__create_bytes_constraints__0 :: ErlangFun
erlps__create_bytes_constraints__0 [] =
  erlps__ets_new__2
    [ErlangAtom "bytes_constraints",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_bytes_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_bytes_constraints__0)
    args

erlps__get_bytes_constraints__0 :: ErlangFun
erlps__get_bytes_constraints__0 [] =
  erlps__ets_tab2list_ordered__1 [ErlangAtom "bytes_constraints"]
erlps__get_bytes_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__get_bytes_constraints__0) args

erlps__add_bytes_constraint__1 :: ErlangFun
erlps__add_bytes_constraint__1 [constraint_0] =
  erlps__ets_insert_ordered__2
    [ErlangAtom "bytes_constraints", constraint_0]
erlps__add_bytes_constraint__1 [arg_3] = EXC.function_clause unit
erlps__add_bytes_constraint__1 args =
  EXC.badarity (ErlangFun 1 erlps__add_bytes_constraint__1) args

erlps__solve_bytes_constraints__1 :: ErlangFun
erlps__solve_bytes_constraints__1 [env_0] =
  let    lcSrc_1 = erlps__get_bytes_constraints__0 []
  in let
    _ =
      flmap
        (\ lc_3 ->
           let lcRet_4 = erlps__solve_bytes_constraint__2 [env_0, lc_3]
           in ErlangCons lcRet_4 ErlangEmptyList)
        lcSrc_1
  in ErlangAtom "ok"
erlps__solve_bytes_constraints__1 [arg_7] =
  EXC.function_clause unit
erlps__solve_bytes_constraints__1 args =
  EXC.badarity (ErlangFun 1 erlps__solve_bytes_constraints__1)
    args

erlps__solve_bytes_constraint__2 :: ErlangFun
erlps__solve_bytes_constraint__2 [_env_0,
                                  (ErlangTuple [(ErlangAtom "is_bytes"), _])]
  =
  ErlangAtom "ok"
erlps__solve_bytes_constraint__2 [env_0,
                                  (ErlangTuple [(ErlangAtom "add_bytes"), ann_1,
                                                _, a0_2, b0_3, c0_4])]
  =
  let    arg_6 = erlps__dereference__1 [a0_2]
  in let a_8 = erlps__unfold_types_in_type__2 [env_0, arg_6]
  in let arg_10 = erlps__dereference__1 [b0_3]
  in let b_12 = erlps__unfold_types_in_type__2 [env_0, arg_10]
  in let arg_14 = erlps__dereference__1 [c0_4]
  in let c_16 = erlps__unfold_types_in_type__2 [env_0, arg_14]
  in let case_17 = ErlangTuple [a_8, b_12, c_16]
  in
    case case_17 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "bytes_t"), _, m_21]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, n_22]), _]) ->
        let    tup_el_27 = BIF.erlang__op_plus [m_21, n_22]
        in let
          arg_24 = ErlangTuple [ErlangAtom "bytes_t", ann_1, tup_el_27]
        in let arg_31 = ErlangTuple [ErlangAtom "at", ann_1]
        in erlps__unify__4 [env_0, arg_24, c_16, arg_31]
      (ErlangTuple [(ErlangTuple [(ErlangAtom "bytes_t"), _, m_34]), _,
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, r_35])]) | weakGeq
                                                                          r_35
                                                                          m_34 ->
        let    tup_el_40 = BIF.erlang__op_minus [r_35, m_34]
        in let
          arg_37 = ErlangTuple [ErlangAtom "bytes_t", ann_1, tup_el_40]
        in let arg_44 = ErlangTuple [ErlangAtom "at", ann_1]
        in erlps__unify__4 [env_0, arg_37, b_12, arg_44]
      (ErlangTuple [_, (ErlangTuple [(ErlangAtom "bytes_t"), _, n_47]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, r_48])]) | weakGeq
                                                                          r_48
                                                                          n_47 ->
        let    tup_el_53 = BIF.erlang__op_minus [r_48, n_47]
        in let
          arg_50 = ErlangTuple [ErlangAtom "bytes_t", ann_1, tup_el_53]
        in let arg_57 = ErlangTuple [ErlangAtom "at", ann_1]
        in erlps__unify__4 [env_0, arg_50, a_8, arg_57]
      _ -> ErlangAtom "ok"
erlps__solve_bytes_constraint__2 [arg_60, arg_61] =
  EXC.function_clause unit
erlps__solve_bytes_constraint__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_bytes_constraint__2) args

erlps__destroy_bytes_constraints__0 :: ErlangFun
erlps__destroy_bytes_constraints__0 [] =
  erlps__ets_delete__1 [ErlangAtom "bytes_constraints"]
erlps__destroy_bytes_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__destroy_bytes_constraints__0)
    args

erlps__destroy_and_report_unsolved_bytes_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_bytes_constraints__1 [env_0] =
  let    constraints_1 = erlps__get_bytes_constraints__0 []
  in let
    inaddconstraint_22 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangAtom "add_bytes"), _, _, a_3, b_4, c_5]) ->
               flmap
                 (\ lc_15 ->
                    let    arg_18 = toErl 1
                    in let lop_17 = BIF.erlang__element__2 [arg_18, lc_15]
                    in let
                      cond_16 =
                        BIF.erlang__op_neq [lop_17, ErlangAtom "bytes_t"]
                    in
                      case cond_16 of
                        (ErlangAtom "true") -> ErlangCons lc_15 ErlangEmptyList
                        _ -> ErlangEmptyList)
                 (ErlangCons a_3
                    (ErlangCons b_4 (ErlangCons c_5 ErlangEmptyList)))
             _ -> ErlangEmptyList)
        constraints_1
  in let
    skip_28 =
      ErlangFun 1
        (let
           lambda_23 [(ErlangTuple [(ErlangAtom "is_bytes"), t_25])] =
             BIF.lists__member__2 [t_25, inaddconstraint_22]
           lambda_23 [_] = ErlangAtom "false"
           lambda_23 [arg_24] = EXC.function_clause unit
           lambda_23 args = EXC.badarity (ErlangFun 1 lambda_23) args
         in lambda_23)
  in let
    _ =
      flmap
        (\ lc_31 ->
           let   
             op_arg_33 =
               BIF.erlang__apply__2 [skip_28, ErlangCons lc_31 ErlangEmptyList]
           in let cond_32 = BIF.erlang__not__1 [op_arg_33]
           in
             case cond_32 of
               (ErlangAtom "true") ->
                 let lcRet_36 = erlps__check_bytes_constraint__2 [env_0, lc_31]
                 in ErlangCons lcRet_36 ErlangEmptyList
               _ -> ErlangEmptyList)
        constraints_1
  in erlps__destroy_bytes_constraints__0 []
erlps__destroy_and_report_unsolved_bytes_constraints__1 [arg_39]
  =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_bytes_constraints__1 args =
  EXC.badarity
    (ErlangFun 1
       erlps__destroy_and_report_unsolved_bytes_constraints__1)
    args

erlps__check_bytes_constraint__2 :: ErlangFun
erlps__check_bytes_constraint__2 [env_0,
                                  (ErlangTuple [(ErlangAtom "is_bytes"),
                                                type_1])]
  =
  let    arg_3 = erlps__instantiate__1 [type_1]
  in let type1_5 = erlps__unfold_types_in_type__2 [env_0, arg_3]
  in
    case type1_5 of
      (ErlangTuple [(ErlangAtom "bytes_t"), _, _]) -> ErlangAtom "ok"
      _ ->
        let
          arg_7 = ErlangTuple [ErlangAtom "unknown_byte_length", type_1]
        in erlps__type_error__1 [arg_7]
erlps__check_bytes_constraint__2 [env_0,
                                  (ErlangTuple [(ErlangAtom "add_bytes"), ann_1,
                                                fun_2, a0_3, b0_4, c0_5])]
  =
  let    arg_7 = erlps__instantiate__1 [a0_3]
  in let a_9 = erlps__unfold_types_in_type__2 [env_0, arg_7]
  in let arg_11 = erlps__instantiate__1 [b0_4]
  in let b_13 = erlps__unfold_types_in_type__2 [env_0, arg_11]
  in let arg_15 = erlps__instantiate__1 [c0_5]
  in let c_17 = erlps__unfold_types_in_type__2 [env_0, arg_15]
  in let case_18 = ErlangTuple [a_9, b_13, c_17]
  in
    case case_18 of
      (ErlangTuple [(ErlangTuple [(ErlangAtom "bytes_t"), _, _m_22]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, _n_23]),
                    (ErlangTuple [(ErlangAtom "bytes_t"), _, _r_24])]) ->
        ErlangAtom "ok"
      _ ->
        let
          arg_25 =
            ErlangTuple
              [ErlangAtom "unsolved_bytes_constraint", ann_1, fun_2, a_9, b_13,
               c_17]
        in erlps__type_error__1 [arg_25]
erlps__check_bytes_constraint__2 [arg_32, arg_33] =
  EXC.function_clause unit
erlps__check_bytes_constraint__2 args =
  EXC.badarity (ErlangFun 2 erlps__check_bytes_constraint__2) args

erlps__create_field_constraints__0 :: ErlangFun
erlps__create_field_constraints__0 [] =
  erlps__ets_new__2
    [ErlangAtom "field_constraints",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_field_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_field_constraints__0)
    args

erlps__destroy_field_constraints__0 :: ErlangFun
erlps__destroy_field_constraints__0 [] =
  erlps__ets_delete__1 [ErlangAtom "field_constraints"]
erlps__destroy_field_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__destroy_field_constraints__0)
    args

erlps__constrain__1 :: ErlangFun
erlps__constrain__1 [fieldconstraints_0] =
  erlps__ets_insert_ordered__2
    [ErlangAtom "field_constraints", fieldconstraints_0]
erlps__constrain__1 [arg_3] = EXC.function_clause unit
erlps__constrain__1 args =
  EXC.badarity (ErlangFun 1 erlps__constrain__1) args

erlps__get_field_constraints__0 :: ErlangFun
erlps__get_field_constraints__0 [] =
  erlps__ets_tab2list_ordered__1 [ErlangAtom "field_constraints"]
erlps__get_field_constraints__0 args =
  EXC.badarity (ErlangFun 0 erlps__get_field_constraints__0) args

erlps__solve_field_constraints__1 :: ErlangFun
erlps__solve_field_constraints__1 [env_0] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_constraint"), _, _, _,
                                   _, _])]
             =
             ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_4 = erlps__get_field_constraints__0 []
  in let
    fieldcs_5 =
      BIF.do_remote_fun_call "Lists" "erlps__filter__2" [arg_1, arg_4]
  in erlps__solve_field_constraints__2 [env_0, fieldcs_5]
erlps__solve_field_constraints__1 [arg_8] =
  EXC.function_clause unit
erlps__solve_field_constraints__1 args =
  EXC.badarity (ErlangFun 1 erlps__solve_field_constraints__1)
    args

erlps__check_record_create_constraints__2 :: ErlangFun
erlps__check_record_create_constraints__2 [_, (ErlangEmptyList)]
  =
  ErlangAtom "ok"
erlps__check_record_create_constraints__2 [env_0,
                                           (ErlangCons c_1 cs_2)]
  =
  case c_1 of
    (ErlangTuple [(ErlangAtom "record_create_constraint"), type_3,
                  fields_4, when_5]) ->
      let    arg_8 = erlps__instantiate__1 [type_3]
      in let type1_10 = erlps__unfold_types_in_type__2 [env_0, arg_8]
      in let
        _ =
          EXC.tryOfCatch
            (\ _ ->
               let arg_12 = erlps__record_type_name__1 [type1_10]
               in erlps__lookup_type__2 [env_0, arg_12])
            (\ of_14 ->
               case of_14 of
                 (ErlangTuple [_qid_17,
                               (ErlangTuple [_ann_18,
                                             (ErlangTuple [_args_19,
                                                           (ErlangTuple [(ErlangAtom "record_t"),
                                                                         recfields_20])])])]) ->
                   let   
                     actualnames_25 =
                       flmap
                         (\ lc_23 ->
                            case lc_23 of
                              (ErlangTuple [(ErlangAtom "field_t"), _,
                                            (ErlangTuple [(ErlangAtom "id"), _,
                                                          fld_22]),
                                            _]) ->
                                ErlangCons fld_22 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         recfields_20
                   in let
                     givennames_30 =
                       flmap
                         (\ lc_28 ->
                            case lc_28 of
                              (ErlangTuple [(ErlangAtom "id"), _, fld_27]) ->
                                ErlangCons fld_27 ErlangEmptyList
                              _ -> ErlangEmptyList)
                         fields_4
                   in let
                     case_31 =
                       BIF.erlang__op_unAppend [actualnames_25, givennames_30]
                   in
                     case case_31 of
                       (ErlangEmptyList) -> ErlangAtom "ok"
                       missing_34 ->
                         let
                           arg_35 =
                             ErlangTuple
                               [ErlangAtom "missing_fields", when_5, type1_10,
                                missing_34]
                         in erlps__type_error__1 [arg_35]
                 _ -> ErlangAtom "ok")
            (\ ex_15 ->
               case ex_15 of
                 (ErlangTuple [_, _, _]) -> ErlangAtom "ok"
                 ex_16 -> EXC.raise ex_16)
      in erlps__check_record_create_constraints__2 [env_0, cs_2]
    _ -> EXC.badmatch c_1
erlps__check_record_create_constraints__2 [arg_42, arg_43] =
  EXC.function_clause unit
erlps__check_record_create_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__check_record_create_constraints__2) args

erlps__check_is_contract_constraints__2 :: ErlangFun
erlps__check_is_contract_constraints__2 [_env_0,
                                         (ErlangEmptyList)]
  =
  ErlangAtom "ok"
erlps__check_is_contract_constraints__2 [env_0,
                                         (ErlangCons c_1 cs_2)]
  =
  case c_1 of
    (ErlangTuple [(ErlangAtom "is_contract_constraint"), type_3,
                  cxt_4]) ->
      let    arg_7 = erlps__instantiate__1 [type_3]
      in let type1_9 = erlps__unfold_types_in_type__2 [env_0, arg_7]
      in let arg_12 = erlps__record_type_name__1 [type1_9]
      in let case_10 = erlps__lookup_type__2 [env_0, arg_12]
      in let
        _ =
          case case_10 of
            (ErlangTuple [_,
                          (ErlangTuple [_ann_14,
                                        (ErlangTuple [(ErlangEmptyList),
                                                      (ErlangTuple [(ErlangAtom "contract_t"),
                                                                    _])])])]) ->
              ErlangAtom "ok"
            _ ->
              let
                arg_15 =
                  ErlangTuple [ErlangAtom "not_a_contract_type", type1_9, cxt_4]
              in erlps__type_error__1 [arg_15]
      in erlps__check_is_contract_constraints__2 [env_0, cs_2]
    _ -> EXC.badmatch c_1
erlps__check_is_contract_constraints__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__check_is_contract_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__check_is_contract_constraints__2) args

erlps__solve_field_constraints__2 :: ErlangFun
erlps__solve_field_constraints__2 [env_0, constraints_1] =
  let   
    isambiguous_40 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_constraint"),
                                   recordtype_4,
                                   field_7@(ErlangTuple [(ErlangAtom "id"),
                                                         _attrs_5,
                                                         fieldname_6]),
                                   fieldtype_8, kind_9, when_10])]
             =
             let
               case_11 =
                 erlps__lookup_record_field__3 [env_0, fieldname_6, kind_9]
             in
               case case_11 of
                 (ErlangEmptyList) ->
                   let   
                     arg_15 =
                       ErlangTuple [ErlangAtom "undefined_field", field_7]
                   in let _ = erlps__type_error__1 [arg_15]
                   in ErlangAtom "false"
                 (ErlangCons (ErlangTuple [(ErlangAtom "field_info"), _,
                                           fldtype_18, rectype_19,
                                           _]) (ErlangEmptyList)) ->
                   let    _ = erlps__create_freshen_tvars__0 []
                   in let freshfldtype_21 = erlps__freshen__1 [fldtype_18]
                   in let freshrectype_23 = erlps__freshen__1 [rectype_19]
                   in let _ = erlps__destroy_freshen_tvars__0 []
                   in let
                     arg_27 =
                       ErlangTuple
                         [ErlangAtom "field_constraint", freshfldtype_21,
                          fieldtype_8, when_10]
                   in let
                     _ =
                       erlps__unify__4
                         [env_0, freshfldtype_21, fieldtype_8, arg_27]
                   in let
                     arg_35 =
                       ErlangTuple
                         [ErlangAtom "record_constraint", freshrectype_23,
                          recordtype_4, when_10]
                   in let
                     _ =
                       erlps__unify__4
                         [env_0, freshrectype_23, recordtype_4, arg_35]
                   in ErlangAtom "false"
                 _ -> ErlangAtom "true"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let
    ambiguousconstraints_43 =
      BIF.do_remote_fun_call "Lists" "erlps__filter__2"
        [isambiguous_40, constraints_1]
  in
    erlps__solve_ambiguous_field_constraints__2
      [env_0, ambiguousconstraints_43]
erlps__solve_field_constraints__2 [arg_46, arg_47] =
  EXC.function_clause unit
erlps__solve_field_constraints__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_field_constraints__2)
    args

erlps__solve_ambiguous_field_constraints__2 :: ErlangFun
erlps__solve_ambiguous_field_constraints__2 [env_0,
                                             constraints_1]
  =
  let
    unknown_4 =
      erlps__solve_known_record_types__2 [env_0, constraints_1]
  in
    case ErlangAtom "true" of
      _ | weakEq unknown_4 ErlangEmptyList -> ErlangAtom "ok"
      _ | (ErlangAtom "true") ==
            (falsifyErrors
               (\ _ ->
                  let    lop_5 = BIF.erlang__length__1 [unknown_4]
                  in let rop_7 = BIF.erlang__length__1 [constraints_1]
                  in BIF.erlang__op_lesser [lop_5, rop_7])) ->
        erlps__solve_ambiguous_field_constraints__2 [env_0, unknown_4]
      _ ->
        let
          case_11 = erlps__solve_unknown_record_types__2 [env_0, unknown_4]
        in
          case case_11 of
            (ErlangAtom "true") ->
              erlps__solve_ambiguous_field_constraints__2 [env_0, unknown_4]
            _ -> ErlangAtom "ok"
erlps__solve_ambiguous_field_constraints__2 [arg_16, arg_17] =
  EXC.function_clause unit
erlps__solve_ambiguous_field_constraints__2 args =
  EXC.badarity
    (ErlangFun 2 erlps__solve_ambiguous_field_constraints__2) args

erlps__solve_unknown_record_types__2 :: ErlangFun
erlps__solve_unknown_record_types__2 [env_0, unknown_1] =
  let   
    arg_2 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             (ErlangTuple [(ErlangAtom "field_constraint"),
                           uvar_4@(ErlangTuple [(ErlangAtom "uvar"), _, _]), _,
                           _, _, _]) ->
               ErlangCons uvar_4 ErlangEmptyList
             _ -> ErlangEmptyList)
        unknown_1
  in let
    uvars_7 =
      BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_2]
  in let
    solutions_28 =
      flmap
        (\ lc_10 ->
           let   
             arg_14 =
               flmap
                 (\ lc_20 ->
                    case lc_20 of
                      (ErlangTuple [(ErlangAtom "field_constraint"), u_16,
                                    field_17, _, kind_18, when_19]) ->
                        let cond_21 = BIF.erlang__op_eq [u_16, lc_10]
                        in
                          case cond_21 of
                            (ErlangAtom "true") ->
                              let
                                lcRet_24 =
                                  ErlangTuple [kind_18, when_19, field_17]
                              in ErlangCons lcRet_24 ErlangEmptyList
                            _ -> ErlangEmptyList
                      _ -> ErlangEmptyList)
                 unknown_1
           in let lcRet_11 = erlps__solve_for_uvar__3 [env_0, lc_10, arg_14]
           in ErlangCons lcRet_11 ErlangEmptyList)
        uvars_7
  in let
    case_29 = BIF.lists__member__2 [ErlangAtom "true", solutions_28]
  in
    case case_29 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> solutions_28
      something_else -> EXC.case_clause something_else
erlps__solve_unknown_record_types__2 [arg_32, arg_33] =
  EXC.function_clause unit
erlps__solve_unknown_record_types__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_unknown_record_types__2)
    args

erlps__solve_known_record_types__2 :: ErlangFun
erlps__solve_known_record_types__2 [env_0, constraints_1] =
  let   
    derefconstraints_15 =
      flmap
        (\ lc_5 ->
           case lc_5 of
             c_4@(ErlangTuple [(ErlangAtom "field_constraint"), recordtype_3,
                               _, _, _, _]) ->
               let    record_updt_8 = erlps__dereference__1 [recordtype_3]
               in let
                 lcRet_6 =
                   case c_4 of
                     (ErlangTuple [(ErlangAtom "field_constraint"), record_t_10,
                                   field_11, field_t_12, kind_13,
                                   context_14]) ->
                       ErlangTuple
                         [ErlangAtom "field_constraint", record_updt_8,
                          field_11, field_t_12, kind_13, context_14]
                     _ -> EXC.badrecord (ErlangAtom "field_constraint")
               in ErlangCons lcRet_6 ErlangEmptyList
             _ -> ErlangEmptyList)
        constraints_1
  in let
    solvedconstraints_92 =
      flmap
        (\ lc_18 ->
           let   
             case_20 =
               case lc_18 of
                 (ErlangTuple arr_23) | (DM.Just field_22) <-
                                          (arr_23 DA.!! 1) ->
                   field_22
                 _ -> EXC.badrecord (ErlangAtom "field_constraint")
           in let
             cond_19 =
               case case_20 of
                 (ErlangTuple [(ErlangAtom "uvar"), _, _]) -> ErlangAtom "false"
                 _ -> ErlangAtom "true"
           in
             case cond_19 of
               (ErlangAtom "true") ->
                 case lc_18 of
                   (ErlangTuple [(ErlangAtom "field_constraint"), rectype_25,
                                 fieldname_26, fieldtype_27, _, when_28]) ->
                     let    recid_31 = erlps__record_type_name__1 [rectype_25]
                     in let
                       attrs_33 =
                         BIF.do_remote_fun_call "Aeso.Syntax"
                           "erlps__get_ann__1" [recid_31]
                     in let
                       case_34 = erlps__lookup_type__2 [env_0, recid_31]
                       lcRet_24 =
                         case case_34 of
                           (ErlangTuple [_,
                                         (ErlangTuple [_ann_37,
                                                       (ErlangTuple [formals_38,
                                                                     (ErlangTuple [what_39,
                                                                                   fields_40])])])]) | (ErlangAtom
                                                                                                          "true") ==
                                                                                                         (falsifyErrors
                                                                                                            (\ _ ->
                                                                                                               let
                                                                                                                 lop_41 =
                                                                                                                   BIF.erlang__op_exactEq
                                                                                                                     [what_39,
                                                                                                                      ErlangAtom
                                                                                                                        "record_t"]
                                                                                                               in
                                                                                                                 case lop_41 of
                                                                                                                   (ErlangAtom "true") ->
                                                                                                                     ErlangAtom
                                                                                                                       "true"
                                                                                                                   (ErlangAtom "false") ->
                                                                                                                     BIF.erlang__op_exactEq
                                                                                                                       [what_39,
                                                                                                                        ErlangAtom
                                                                                                                          "contract_t"]
                                                                                                                   _ ->
                                                                                                                     EXC.badarg1
                                                                                                                       lop_41)) ->
                             let
                               fieldtypes_53 =
                                 flmap
                                   (\ lc_49 ->
                                      case lc_49 of
                                        (ErlangTuple [(ErlangAtom "field_t"), _,
                                                      (ErlangTuple [(ErlangAtom "id"),
                                                                    _,
                                                                    name_47]),
                                                      type_48]) ->
                                          let
                                            lcRet_50 =
                                              ErlangTuple [name_47, type_48]
                                          in ErlangCons lcRet_50 ErlangEmptyList
                                        _ -> ErlangEmptyList)
                                   fields_40
                             in
                               case fieldname_26 of
                                 (ErlangTuple [(ErlangAtom "id"), _,
                                               fieldstring_54]) ->
                                   let
                                     case_56 =
                                       BIF.do_remote_fun_call "Proplists"
                                         "erlps__get_value__2"
                                         [fieldstring_54, fieldtypes_53]
                                   in
                                     case case_56 of
                                       (ErlangAtom "undefined") ->
                                         let   
                                           arg_59 =
                                             ErlangTuple
                                               [ErlangAtom "missing_field",
                                                fieldname_26, recid_31]
                                         in let
                                           _ = erlps__type_error__1 [arg_59]
                                         in ErlangAtom "not_solved"
                                       fldtype_63 ->
                                         let   
                                           _ = erlps__create_freshen_tvars__0 []
                                         in let
                                           freshfldtype_65 =
                                             erlps__freshen__1 [fldtype_63]
                                         in let
                                           arg_66 =
                                             erlps__app_t__3
                                               [attrs_33, recid_31, formals_38]
                                         in let
                                           freshrectype_70 =
                                             erlps__freshen__1 [arg_66]
                                         in let
                                           _ =
                                             erlps__destroy_freshen_tvars__0 []
                                         in let
                                           arg_74 =
                                             ErlangTuple
                                               [ErlangAtom "field_constraint",
                                                freshfldtype_65, fieldtype_27,
                                                when_28]
                                         in let
                                           _ =
                                             erlps__unify__4
                                               [env_0, freshfldtype_65,
                                                fieldtype_27, arg_74]
                                         in let
                                           arg_82 =
                                             ErlangTuple
                                               [ErlangAtom "record_constraint",
                                                freshrectype_70, rectype_25,
                                                when_28]
                                         in let
                                           _ =
                                             erlps__unify__4
                                               [env_0, freshrectype_70,
                                                rectype_25, arg_82]
                                         in lc_18
                                 _ -> EXC.badmatch fieldname_26
                           _ ->
                             let   
                               tup_el_89 = erlps__instantiate__1 [rectype_25]
                             in let
                               arg_87 =
                                 ErlangTuple
                                   [ErlangAtom "not_a_record_type", tup_el_89,
                                    when_28]
                             in let _ = erlps__type_error__1 [arg_87]
                             in ErlangAtom "not_solved"
                     in ErlangCons lcRet_24 ErlangEmptyList
                   _ -> EXC.badmatch lc_18
               _ -> ErlangEmptyList)
        derefconstraints_15
  in
    BIF.erlang__op_unAppend
      [derefconstraints_15, solvedconstraints_92]
erlps__solve_known_record_types__2 [arg_95, arg_96] =
  EXC.function_clause unit
erlps__solve_known_record_types__2 args =
  EXC.badarity (ErlangFun 2 erlps__solve_known_record_types__2)
    args

erlps__destroy_and_report_unsolved_field_constraints__1 :: ErlangFun
erlps__destroy_and_report_unsolved_field_constraints__1 [env_0] =
  let   
    arg_1 =
      ErlangFun 1
        (let
           lambda_2 [(ErlangTuple [(ErlangAtom "field_constraint"), _, _, _,
                                   _, _])]
             =
             ErlangAtom "true"
           lambda_2 [_] = ErlangAtom "false"
           lambda_2 [arg_3] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 1 lambda_2) args
         in lambda_2)
  in let arg_4 = erlps__get_field_constraints__0 []
  in let
    matchExpr_7 =
      BIF.do_remote_fun_call "Lists" "erlps__partition__2"
        [arg_1, arg_4]
  in
    case matchExpr_7 of
      (ErlangTuple [fieldcs_5, othercs_6]) ->
        let   
          arg_8 =
            ErlangFun 1
              (let
                 lambda_9 [(ErlangTuple [(ErlangAtom "record_create_constraint"),
                                         _, _, _])]
                   =
                   ErlangAtom "true"
                 lambda_9 [_] = ErlangAtom "false"
                 lambda_9 [arg_10] = EXC.function_clause unit
                 lambda_9 args = EXC.badarity (ErlangFun 1 lambda_9) args
               in lambda_9)
        in let
          matchExpr_14 =
            BIF.do_remote_fun_call "Lists" "erlps__partition__2"
              [arg_8, othercs_6]
        in
          case matchExpr_14 of
            (ErlangTuple [createcs_12, contractcs_13]) ->
              let   
                unknown_17 =
                  erlps__solve_known_record_types__2 [env_0, fieldcs_5]
              in let
                _ =
                  case ErlangAtom "true" of
                    _ | weakEq unknown_17 ErlangEmptyList -> ErlangAtom "ok"
                    _ ->
                      let
                        case_18 =
                          erlps__solve_unknown_record_types__2
                            [env_0, unknown_17]
                      in
                        case case_18 of
                          (ErlangAtom "true") -> ErlangAtom "ok"
                          errors_21 ->
                            flmap
                              (\ lc_24 ->
                                 let lcRet_25 = erlps__type_error__1 [lc_24]
                                 in ErlangCons lcRet_25 ErlangEmptyList)
                              errors_21
              in let
                _ =
                  erlps__check_record_create_constraints__2 [env_0, createcs_12]
              in let
                _ =
                  erlps__check_is_contract_constraints__2 [env_0, contractcs_13]
              in let _ = erlps__destroy_field_constraints__0 []
              in ErlangAtom "ok"
            _ -> EXC.badmatch matchExpr_14
      _ -> EXC.badmatch matchExpr_7
erlps__destroy_and_report_unsolved_field_constraints__1 [arg_31]
  =
  EXC.function_clause unit
erlps__destroy_and_report_unsolved_field_constraints__1 args =
  EXC.badarity
    (ErlangFun 1
       erlps__destroy_and_report_unsolved_field_constraints__1)
    args

erlps__record_type_name__1 :: ErlangFun
erlps__record_type_name__1 [(ErlangTuple [(ErlangAtom "app_t"),
                                          _attrs_0, recid_1, _args_2])]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    arg_5 = toErl 1
            in let lop_4 = BIF.erlang__element__2 [arg_5, recid_1]
            in let lop_3 = BIF.erlang__op_exactEq [lop_4, ErlangAtom "id"]
            in
              case lop_3 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  let    arg_10 = toErl 1
                  in let lop_9 = BIF.erlang__element__2 [arg_10, recid_1]
                  in let
                    lop_8 = BIF.erlang__op_exactEq [lop_9, ErlangAtom "qid"]
                  in
                    case lop_8 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") ->
                        let    arg_15 = toErl 1
                        in let lop_14 = BIF.erlang__element__2 [arg_15, recid_1]
                        in let
                          lop_13 =
                            BIF.erlang__op_exactEq [lop_14, ErlangAtom "con"]
                        in
                          case lop_13 of
                            (ErlangAtom "true") -> ErlangAtom "true"
                            (ErlangAtom "false") ->
                              let    arg_19 = toErl 1
                              in let
                                lop_18 =
                                  BIF.erlang__element__2 [arg_19, recid_1]
                              in
                                BIF.erlang__op_exactEq
                                  [lop_18, ErlangAtom "qcon"]
                            _ -> EXC.badarg1 lop_13
                      _ -> EXC.badarg1 lop_8
                _ -> EXC.badarg1 lop_3)) =
  recid_1
erlps__record_type_name__1 [recid_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    arg_3 = toErl 1
            in let lop_2 = BIF.erlang__element__2 [arg_3, recid_0]
            in let lop_1 = BIF.erlang__op_exactEq [lop_2, ErlangAtom "id"]
            in
              case lop_1 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  let    arg_8 = toErl 1
                  in let lop_7 = BIF.erlang__element__2 [arg_8, recid_0]
                  in let
                    lop_6 = BIF.erlang__op_exactEq [lop_7, ErlangAtom "qid"]
                  in
                    case lop_6 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") ->
                        let    arg_13 = toErl 1
                        in let lop_12 = BIF.erlang__element__2 [arg_13, recid_0]
                        in let
                          lop_11 =
                            BIF.erlang__op_exactEq [lop_12, ErlangAtom "con"]
                        in
                          case lop_11 of
                            (ErlangAtom "true") -> ErlangAtom "true"
                            (ErlangAtom "false") ->
                              let    arg_17 = toErl 1
                              in let
                                lop_16 =
                                  BIF.erlang__element__2 [arg_17, recid_0]
                              in
                                BIF.erlang__op_exactEq
                                  [lop_16, ErlangAtom "qcon"]
                            _ -> EXC.badarg1 lop_11
                      _ -> EXC.badarg1 lop_6
                _ -> EXC.badarg1 lop_1)) =
  recid_0
erlps__record_type_name__1 [_other_0] =
  let   
    head_3 = ErlangTuple [ErlangAtom "origin", ErlangAtom "system"]
  in let tup_el_7 = toErl "not_a_record_type"
  in
    ErlangTuple
      [ErlangAtom "id", ErlangCons head_3 ErlangEmptyList, tup_el_7]
erlps__record_type_name__1 [arg_8] = EXC.function_clause unit
erlps__record_type_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__record_type_name__1) args

erlps__solve_for_uvar__3 :: ErlangFun
erlps__solve_for_uvar__3 [env_0,
                          uvar_2@(ErlangTuple [(ErlangAtom "uvar"), attrs_1,
                                               _]),
                          fields0_3]
  =
  let
    fields_11 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [kind_5, _, fld_6]) ->
               let lcRet_8 = ErlangTuple [kind_5, fld_6]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields0_3
  in
    case fields0_3 of
      (ErlangCons (ErlangTuple [_, when_12, _]) _) ->
        let   
          arg_14 =
            flmap
              (\ lc_17 ->
                 case lc_17 of
                   (ErlangTuple [(ErlangAtom "create"),
                                 (ErlangTuple [(ErlangAtom "id"), _,
                                               name_16])]) ->
                     ErlangCons name_16 ErlangEmptyList
                   _ -> ErlangEmptyList)
              fields_11
        in let
          covering_19 =
            BIF.do_remote_fun_call "Lists" "erlps__usort__1" [arg_14]
        in let
          fieldnames_25 =
            flmap
              (\ lc_23 ->
                 case lc_23 of
                   (ErlangTuple [_kind_21,
                                 (ErlangTuple [(ErlangAtom "id"), _,
                                               name_22])]) ->
                     ErlangCons name_22 ErlangEmptyList
                   _ -> ErlangEmptyList)
              fields_11
        in let
          uniquefields_27 =
            BIF.do_remote_fun_call "Lists" "erlps__usort__1" [fieldnames_25]
        in let arg_30 = BIF.erlang__hd__1 [fieldnames_25]
        in let lcSrc_28 = erlps__lookup_record_field__2 [env_0, arg_30]
        in let
          candidates_35 =
            flmap
              (\ lc_33 ->
                 case lc_33 of
                   (ErlangTuple [(ErlangAtom "field_info"), _, _, rectype_32,
                                 _]) ->
                     ErlangCons rectype_32 ErlangEmptyList
                   _ -> ErlangEmptyList)
              lcSrc_28
        in let
          typesandfields_64 =
            flmap
              (\ lc_38 ->
                 let    arg_42 = erlps__record_type_name__1 [lc_38]
                 in let case_40 = erlps__lookup_type__2 [env_0, arg_42]
                 in let
                   lcRet_39 =
                     case case_40 of
                       (ErlangTuple [_,
                                     (ErlangTuple [_,
                                                   (ErlangTuple [_,
                                                                 (ErlangTuple [(ErlangAtom "record_t"),
                                                                               recfields_44])])])]) ->
                         let
                           tup_el_46 =
                             flmap
                               (\ lc_49 ->
                                  case lc_49 of
                                    (ErlangTuple [(ErlangAtom "field_t"), _,
                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                _, field_48]),
                                                  _]) ->
                                      ErlangCons field_48 ErlangEmptyList
                                    _ -> ErlangEmptyList)
                               recfields_44
                         in ErlangTuple [lc_38, tup_el_46]
                       (ErlangTuple [_,
                                     (ErlangTuple [_,
                                                   (ErlangTuple [_,
                                                                 (ErlangTuple [(ErlangAtom "contract_t"),
                                                                               confields_51])])])]) ->
                         let
                           tup_el_53 =
                             flmap
                               (\ lc_56 ->
                                  case lc_56 of
                                    (ErlangTuple [(ErlangAtom "field_t"), _,
                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                _, field_55]),
                                                  _]) ->
                                      ErlangCons field_55 ErlangEmptyList
                                    _ -> ErlangEmptyList)
                               confields_51
                         in ErlangTuple [lc_38, tup_el_53]
                       (ErlangAtom "false") ->
                         let    tup_el_60 = erlps__record_type_name__1 [lc_38]
                         in let
                           arg_58 =
                             ErlangTuple
                               [ErlangAtom "no_definition_for", tup_el_60,
                                ErlangAtom "in", env_0]
                         in BIF.erlang__error__1 [arg_58]
                       something_else -> EXC.case_clause something_else
                 in ErlangCons lcRet_39 ErlangEmptyList)
              candidates_35
        in let
          arg_65 =
            flmap
              (\ lc_69 ->
                 case lc_69 of
                   (ErlangTuple [rectype_67, recfields_68]) ->
                     let   
                       lop_71 =
                         BIF.erlang__op_unAppend [uniquefields_27, recfields_68]
                     in let
                       cond_70 = BIF.erlang__op_eq [lop_71, ErlangEmptyList]
                     in
                       case cond_70 of
                         (ErlangAtom "true") ->
                           let   
                             tup_el_77 =
                               case ErlangAtom "true" of
                                 _ | weakEq covering_19 ErlangEmptyList ->
                                   ErlangEmptyList
                                 _ ->
                                   BIF.erlang__op_unAppend
                                     [recfields_68, covering_19]
                           in let lcRet_75 = ErlangTuple [rectype_67, tup_el_77]
                           in ErlangCons lcRet_75 ErlangEmptyList
                         _ -> ErlangEmptyList
                   _ -> ErlangEmptyList)
              typesandfields_64
        in let
          partialsolutions_80 =
            BIF.do_remote_fun_call "Lists" "erlps__sort__1" [arg_65]
        in let
          solutions_85 =
            flmap
              (\ lc_83 ->
                 case lc_83 of
                   (ErlangTuple [recname_82, (ErlangEmptyList)]) ->
                     ErlangCons recname_82 ErlangEmptyList
                   _ -> ErlangEmptyList)
              partialsolutions_80
        in let case_86 = ErlangTuple [solutions_85, partialsolutions_80]
        in
          case case_86 of
            (ErlangTuple [(ErlangEmptyList), (ErlangEmptyList)]) ->
              ErlangTuple [ErlangAtom "no_records_with_all_fields", fields_11]
            (ErlangTuple [(ErlangEmptyList), _]) ->
              case partialsolutions_80 of
                (ErlangCons (ErlangTuple [rectype_92, missing_93]) _) ->
                  ErlangTuple
                    [ErlangAtom "missing_fields", when_12, rectype_92,
                     missing_93]
                something_else -> EXC.case_clause something_else
            (ErlangTuple [(ErlangCons rectype_98 (ErlangEmptyList)), _]) ->
              let    recname_100 = erlps__record_type_name__1 [rectype_98]
              in let matchExpr_105 = erlps__lookup_type__2 [env_0, recname_100]
              in
                case matchExpr_105 of
                  (ErlangTuple [_,
                                (ErlangTuple [_,
                                              (ErlangTuple [formals_103,
                                                            (ErlangTuple [_recorcon_104,
                                                                          _])])])]) ->
                    let    _ = erlps__create_freshen_tvars__0 []
                    in let
                      arg_106 =
                        erlps__app_t__3 [attrs_1, recname_100, formals_103]
                    in let freshrectype_110 = erlps__freshen__1 [arg_106]
                    in let _ = erlps__destroy_freshen_tvars__0 []
                    in let
                      arg_114 =
                        ErlangTuple
                          [ErlangAtom "solve_rec_type", uvar_2, fields_11]
                    in let
                      _ =
                        erlps__unify__4
                          [env_0, uvar_2, freshrectype_110, arg_114]
                    in ErlangAtom "true"
                  _ -> EXC.badmatch matchExpr_105
            (ErlangTuple [stillpossible_118, _]) ->
              ErlangTuple
                [ErlangAtom "ambiguous_record", fields_11, stillpossible_118]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch fields0_3
erlps__solve_for_uvar__3 [arg_122, arg_123, arg_124] =
  EXC.function_clause unit
erlps__solve_for_uvar__3 args =
  EXC.badarity (ErlangFun 3 erlps__solve_for_uvar__3) args

erlps__unfold_record_types__2 :: ErlangFun
erlps__unfold_record_types__2 [env_0, t_1] =
  erlps__unfold_types__3
    [env_0, t_1,
     ErlangCons (ErlangAtom "unfold_record_types") ErlangEmptyList]
erlps__unfold_record_types__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__unfold_record_types__2 args =
  EXC.badarity (ErlangFun 2 erlps__unfold_record_types__2) args

erlps__unfold_types__3 :: ErlangFun
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "typed"), attr_1, e_2,
                                      type_3]),
                        options_4]
  =
  let    tup_el_7 = erlps__unfold_types__3 [env_0, e_2, options_4]
  in let
    tup_el_11 =
      erlps__unfold_types_in_type__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "typed", attr_1, tup_el_7, tup_el_11]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "arg"), attr_1, id_2,
                                      type_3]),
                        options_4]
  =
  let
    tup_el_8 =
      erlps__unfold_types_in_type__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "arg", attr_1, id_2, tup_el_8]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "type_sig"), ann_1, constr_2,
                                      namedargs_3, args_4, ret_5]),
                        options_6]
  =
  let   
    tup_el_10 =
      erlps__unfold_types_in_type__3 [env_0, namedargs_3, options_6]
  in let
    tup_el_14 =
      erlps__unfold_types_in_type__3 [env_0, args_4, options_6]
  in let
    tup_el_18 =
      erlps__unfold_types_in_type__3 [env_0, ret_5, options_6]
  in
    ErlangTuple
      [ErlangAtom "type_sig", ann_1, constr_2, tup_el_10, tup_el_14,
       tup_el_18]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "type_def"), ann_1, name_2,
                                      args_3, def_4]),
                        options_5]
  =
  let
    tup_el_10 =
      erlps__unfold_types_in_type__3 [env_0, def_4, options_5]
  in
    ErlangTuple
      [ErlangAtom "type_def", ann_1, name_2, args_3, tup_el_10]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "fun_decl"), ann_1, name_2,
                                      type_3]),
                        options_4]
  =
  let tup_el_8 = erlps__unfold_types__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "fun_decl", ann_1, name_2, tup_el_8]
erlps__unfold_types__3 [env_0,
                        (ErlangTuple [(ErlangAtom "letfun"), ann_1, name_2,
                                      args_3, type_4, body_5]),
                        options_6]
  =
  let   
    tup_el_10 = erlps__unfold_types__3 [env_0, args_3, options_6]
  in let
    tup_el_14 =
      erlps__unfold_types_in_type__3 [env_0, type_4, options_6]
  in let
    tup_el_18 = erlps__unfold_types__3 [env_0, body_5, options_6]
  in
    ErlangTuple
      [ErlangAtom "letfun", ann_1, name_2, tup_el_10, tup_el_14,
       tup_el_18]
erlps__unfold_types__3 [env_0, t_1, options_2] | isETuple t_1 =
  let    arg_5 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_3 = erlps__unfold_types__3 [env_0, arg_5, options_2]
  in BIF.erlang__list_to_tuple__1 [arg_3]
erlps__unfold_types__3 [env_0, (ErlangCons h_1 t_2), options_3] =
  let    head_4 = erlps__unfold_types__3 [env_0, h_1, options_3]
  in let tail_8 = erlps__unfold_types__3 [env_0, t_2, options_3]
  in ErlangCons head_4 tail_8
erlps__unfold_types__3 [_env_0, x_1, _options_2] = x_1
erlps__unfold_types__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__unfold_types__3 args =
  EXC.badarity (ErlangFun 3 erlps__unfold_types__3) args

erlps__unfold_types_in_type__2 :: ErlangFun
erlps__unfold_types_in_type__2 [env_0, t_1] =
  erlps__unfold_types_in_type__3 [env_0, t_1, ErlangEmptyList]
erlps__unfold_types_in_type__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__unfold_types_in_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__unfold_types_in_type__2) args

erlps__unfold_types_in_type__3 :: ErlangFun
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "app_t"), ann_1,
                                              id_5@(ErlangTuple [(ErlangAtom "id"),
                                                                 _,
                                                                 (ErlangCons (ErlangInt num_2) (ErlangCons (ErlangInt num_3) (ErlangCons (ErlangInt num_4) (ErlangEmptyList))))]),
                                              args_7@(ErlangCons keytype0_6 (ErlangCons _ (ErlangEmptyList)))]),
                                options_8]
  | (ErlangInt num_2) == (toErl 109)
  , (ErlangInt num_3) == (toErl 97)
  , (ErlangInt num_4) == (toErl 112) =
  let
    matchExpr_13 =
      erlps__unfold_types_in_type__3 [env_0, args_7, options_8]
  in
    case matchExpr_13 of
      (ErlangCons keytype_12 (ErlangCons _ (ErlangEmptyList))) ->
        let    cond_15 = erlps__has_maps__1 [keytype_12]
        in let
          _ =
            case cond_15 of
              (ErlangAtom "true") ->
                let   
                  arg_18 = ErlangTuple [ErlangAtom "map_in_map_key", keytype0_6]
                in let lcRet_17 = erlps__type_error__1 [arg_18]
                in ErlangCons lcRet_17 ErlangEmptyList
              _ -> ErlangEmptyList
        in ErlangTuple [ErlangAtom "app_t", ann_1, id_5, matchExpr_13]
      _ -> EXC.badmatch matchExpr_13
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "app_t"), ann_1, id_2,
                                              args_3]),
                                options_4]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    arg_70 = toErl 1
            in let lop_69 = BIF.erlang__element__2 [arg_70, id_2]
            in let lop_68 = BIF.erlang__op_exactEq [lop_69, ErlangAtom "id"]
            in
              case lop_68 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  let    arg_75 = toErl 1
                  in let lop_74 = BIF.erlang__element__2 [arg_75, id_2]
                  in let
                    lop_73 = BIF.erlang__op_exactEq [lop_74, ErlangAtom "qid"]
                  in
                    case lop_73 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") ->
                        let    arg_80 = toErl 1
                        in let lop_79 = BIF.erlang__element__2 [arg_80, id_2]
                        in let
                          lop_78 =
                            BIF.erlang__op_exactEq [lop_79, ErlangAtom "con"]
                        in
                          case lop_78 of
                            (ErlangAtom "true") -> ErlangAtom "true"
                            (ErlangAtom "false") ->
                              let    arg_84 = toErl 1
                              in let
                                lop_83 = BIF.erlang__element__2 [arg_84, id_2]
                              in
                                BIF.erlang__op_exactEq
                                  [lop_83, ErlangAtom "qcon"]
                            _ -> EXC.badarg1 lop_78
                      _ -> EXC.badarg1 lop_73
                _ -> EXC.badarg1 lop_68)) =
  let   
    unfoldrecords_8 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_record_types", options_4, ErlangAtom "false"]
  in let
    unfoldvariants_12 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_variant_types", options_4,
         ErlangAtom "false"]
  in let case_13 = erlps__lookup_type__2 [env_0, id_2]
  in
    case case_13 of
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [formals_16,
                                                (ErlangTuple [(ErlangAtom "record_t"),
                                                              fields_17])])])]) | (ErlangAtom
                                                                                     "true") ==
                                                                                    (falsifyErrors
                                                                                       (\ _ ->
                                                                                          case unfoldrecords_8 of
                                                                                            (ErlangAtom "false") ->
                                                                                              ErlangAtom
                                                                                                "false"
                                                                                            (ErlangAtom "true") ->
                                                                                              let   
                                                                                                lop_19 =
                                                                                                  BIF.erlang__length__1
                                                                                                    [formals_16]
                                                                                              in let
                                                                                                rop_21 =
                                                                                                  BIF.erlang__length__1
                                                                                                    [args_3]
                                                                                              in
                                                                                                BIF.erlang__op_eq
                                                                                                  [lop_19,
                                                                                                   rop_21]
                                                                                            _ ->
                                                                                              EXC.badarg1
                                                                                                unfoldrecords_8)) ->
        let   
          arg_27 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2"
              [formals_16, args_3]
        in let arg_26 = erlps__subst_tvars__2 [arg_27, fields_17]
        in let
          tup_el_24 =
            erlps__unfold_types_in_type__3 [env_0, arg_26, options_4]
        in ErlangTuple [ErlangAtom "record_t", tup_el_24]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [formals_32,
                                                (ErlangTuple [(ErlangAtom "alias_t"),
                                                              type_33])])])]) | (ErlangAtom
                                                                                   "true") ==
                                                                                  (falsifyErrors
                                                                                     (\ _ ->
                                                                                        let   
                                                                                          lop_34 =
                                                                                            BIF.erlang__length__1
                                                                                              [formals_32]
                                                                                        in let
                                                                                          rop_36 =
                                                                                            BIF.erlang__length__1
                                                                                              [args_3]
                                                                                        in
                                                                                          BIF.erlang__op_eq
                                                                                            [lop_34,
                                                                                             rop_36])) ->
        let   
          arg_40 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2"
              [formals_32, args_3]
        in let arg_39 = erlps__subst_tvars__2 [arg_40, type_33]
        in erlps__unfold_types_in_type__3 [env_0, arg_39, options_4]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [formals_45,
                                                (ErlangTuple [(ErlangAtom "variant_t"),
                                                              constrs_46])])])]) | (ErlangAtom
                                                                                      "true") ==
                                                                                     (falsifyErrors
                                                                                        (\ _ ->
                                                                                           case unfoldvariants_12 of
                                                                                             (ErlangAtom "false") ->
                                                                                               ErlangAtom
                                                                                                 "false"
                                                                                             (ErlangAtom "true") ->
                                                                                               let   
                                                                                                 lop_48 =
                                                                                                   BIF.erlang__length__1
                                                                                                     [formals_45]
                                                                                               in let
                                                                                                 rop_50 =
                                                                                                   BIF.erlang__length__1
                                                                                                     [args_3]
                                                                                               in
                                                                                                 BIF.erlang__op_eq
                                                                                                   [lop_48,
                                                                                                    rop_50]
                                                                                             _ ->
                                                                                               EXC.badarg1
                                                                                                 unfoldvariants_12)) ->
        let   
          arg_56 =
            BIF.do_remote_fun_call "Lists" "erlps__zip__2"
              [formals_45, args_3]
        in let arg_55 = erlps__subst_tvars__2 [arg_56, constrs_46]
        in let
          tup_el_53 =
            erlps__unfold_types_in_type__3 [env_0, arg_55, options_4]
        in ErlangTuple [ErlangAtom "variant_t", tup_el_53]
      _ ->
        let
          tup_el_64 =
            erlps__unfold_types_in_type__3 [env_0, args_3, options_4]
        in ErlangTuple [ErlangAtom "app_t", ann_1, id_2, tup_el_64]
erlps__unfold_types_in_type__3 [env_0, id_1, options_2]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    arg_32 = toErl 1
            in let lop_31 = BIF.erlang__element__2 [arg_32, id_1]
            in let lop_30 = BIF.erlang__op_exactEq [lop_31, ErlangAtom "id"]
            in
              case lop_30 of
                (ErlangAtom "true") -> ErlangAtom "true"
                (ErlangAtom "false") ->
                  let    arg_37 = toErl 1
                  in let lop_36 = BIF.erlang__element__2 [arg_37, id_1]
                  in let
                    lop_35 = BIF.erlang__op_exactEq [lop_36, ErlangAtom "qid"]
                  in
                    case lop_35 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") ->
                        let    arg_42 = toErl 1
                        in let lop_41 = BIF.erlang__element__2 [arg_42, id_1]
                        in let
                          lop_40 =
                            BIF.erlang__op_exactEq [lop_41, ErlangAtom "con"]
                        in
                          case lop_40 of
                            (ErlangAtom "true") -> ErlangAtom "true"
                            (ErlangAtom "false") ->
                              let    arg_46 = toErl 1
                              in let
                                lop_45 = BIF.erlang__element__2 [arg_46, id_1]
                              in
                                BIF.erlang__op_exactEq
                                  [lop_45, ErlangAtom "qcon"]
                            _ -> EXC.badarg1 lop_40
                      _ -> EXC.badarg1 lop_35
                _ -> EXC.badarg1 lop_30)) =
  let   
    unfoldrecords_6 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_record_types", options_2, ErlangAtom "false"]
  in let
    unfoldvariants_10 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "unfold_variant_types", options_2,
         ErlangAtom "false"]
  in let case_11 = erlps__lookup_type__2 [env_0, id_1]
  in
    case case_11 of
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [(ErlangEmptyList),
                                                (ErlangTuple [(ErlangAtom "record_t"),
                                                              fields_14])])])]) | (ErlangAtom
                                                                                     "true") ==
                                                                                    (falsifyErrors
                                                                                       (\ _ ->
                                                                                          unfoldrecords_6)) ->
        let
          tup_el_16 =
            erlps__unfold_types_in_type__3 [env_0, fields_14, options_2]
        in ErlangTuple [ErlangAtom "record_t", tup_el_16]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [(ErlangEmptyList),
                                                (ErlangTuple [(ErlangAtom "variant_t"),
                                                              constrs_20])])])]) | (ErlangAtom
                                                                                      "true") ==
                                                                                     (falsifyErrors
                                                                                        (\ _ ->
                                                                                           unfoldvariants_10)) ->
        let
          tup_el_22 =
            erlps__unfold_types_in_type__3 [env_0, constrs_20, options_2]
        in ErlangTuple [ErlangAtom "variant_t", tup_el_22]
      (ErlangTuple [_,
                    (ErlangTuple [_,
                                  (ErlangTuple [(ErlangEmptyList),
                                                (ErlangTuple [(ErlangAtom "alias_t"),
                                                              type1_26])])])]) ->
        erlps__unfold_types_in_type__3 [env_0, type1_26, options_2]
      _ -> id_1
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "field_t"), attr_1,
                                              name_2, type_3]),
                                options_4]
  =
  let
    tup_el_8 =
      erlps__unfold_types_in_type__3 [env_0, type_3, options_4]
  in ErlangTuple [ErlangAtom "field_t", attr_1, name_2, tup_el_8]
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "constr_t"), ann_1,
                                              con_2, types_3]),
                                options_4]
  =
  let
    tup_el_8 =
      erlps__unfold_types_in_type__3 [env_0, types_3, options_4]
  in ErlangTuple [ErlangAtom "constr_t", ann_1, con_2, tup_el_8]
erlps__unfold_types_in_type__3 [env_0,
                                (ErlangTuple [(ErlangAtom "named_arg_t"), ann_1,
                                              con_2, types_3, default_4]),
                                options_5]
  =
  let
    tup_el_9 =
      erlps__unfold_types_in_type__3 [env_0, types_3, options_5]
  in
    ErlangTuple
      [ErlangAtom "named_arg_t", ann_1, con_2, tup_el_9, default_4]
erlps__unfold_types_in_type__3 [env_0, t_1, options_2]
  | isETuple t_1 =
  let    arg_5 = BIF.erlang__tuple_to_list__1 [t_1]
  in let
    arg_3 = erlps__unfold_types_in_type__3 [env_0, arg_5, options_2]
  in BIF.erlang__list_to_tuple__1 [arg_3]
erlps__unfold_types_in_type__3 [env_0, (ErlangCons h_1 t_2),
                                options_3]
  =
  let   
    head_4 = erlps__unfold_types_in_type__3 [env_0, h_1, options_3]
  in let
    tail_8 = erlps__unfold_types_in_type__3 [env_0, t_2, options_3]
  in ErlangCons head_4 tail_8
erlps__unfold_types_in_type__3 [_env_0, x_1, _options_2] = x_1
erlps__unfold_types_in_type__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__unfold_types_in_type__3 args =
  EXC.badarity (ErlangFun 3 erlps__unfold_types_in_type__3) args

erlps__has_maps__1 :: ErlangFun
erlps__has_maps__1 [(ErlangTuple [(ErlangAtom "app_t"), _,
                                  (ErlangTuple [(ErlangAtom "id"), _,
                                                (ErlangCons (ErlangInt num_0) (ErlangCons (ErlangInt num_1) (ErlangCons (ErlangInt num_2) (ErlangEmptyList))))]),
                                  _])]
  | (ErlangInt num_0) == (toErl 109)
  , (ErlangInt num_1) == (toErl 97)
  , (ErlangInt num_2) == (toErl 112) =
  ErlangAtom "true"
erlps__has_maps__1 [l_0] | isEList l_0 =
  let arg_1 = ErlangFun 1 erlps__has_maps__1
  in BIF.do_remote_fun_call "Lists" "erlps__any__2" [arg_1, l_0]
erlps__has_maps__1 [t_0] | isETuple t_0 =
  let arg_1 = BIF.erlang__tuple_to_list__1 [t_0]
  in erlps__has_maps__1 [arg_1]
erlps__has_maps__1 [_] = ErlangAtom "false"
erlps__has_maps__1 [arg_0] = EXC.function_clause unit
erlps__has_maps__1 args =
  EXC.badarity (ErlangFun 1 erlps__has_maps__1) args

erlps__subst_tvars__2 :: ErlangFun
erlps__subst_tvars__2 [env_0, type_1] =
  let
    arg_2 =
      flmap
        (\ lc_6 ->
           case lc_6 of
             (ErlangTuple [(ErlangTuple [(ErlangAtom "tvar"), _, v_4]),
                           t_5]) ->
               let lcRet_7 = ErlangTuple [v_4, t_5]
               in ErlangCons lcRet_7 ErlangEmptyList
             _ -> ErlangEmptyList)
        env_0
  in erlps__subst_tvars1__2 [arg_2, type_1]
erlps__subst_tvars__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__subst_tvars__2 args =
  EXC.badarity (ErlangFun 2 erlps__subst_tvars__2) args

erlps__subst_tvars1__2 :: ErlangFun
erlps__subst_tvars1__2 [env_0,
                        t_2@(ErlangTuple [(ErlangAtom "tvar"), _, name_1])]
  =
  BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
    [name_1, env_0, t_2]
erlps__subst_tvars1__2 [env_0, (ErlangCons h_1 t_2)] =
  let    head_3 = erlps__subst_tvars1__2 [env_0, h_1]
  in let tail_6 = erlps__subst_tvars1__2 [env_0, t_2]
  in ErlangCons head_3 tail_6
erlps__subst_tvars1__2 [env_0, type_1] | isETuple type_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [type_1]
  in let arg_2 = erlps__subst_tvars1__2 [env_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__subst_tvars1__2 [_env_0, x_1] = x_1
erlps__subst_tvars1__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__subst_tvars1__2 args =
  EXC.badarity (ErlangFun 2 erlps__subst_tvars1__2) args

erlps__unify__4 :: ErlangFun
erlps__unify__4 [_,
                 (ErlangTuple [(ErlangAtom "id"), _,
                               (ErlangCons (ErlangInt num_0) (ErlangEmptyList))]),
                 _, _when_1]
  | (ErlangInt num_0) == (toErl 95) =
  ErlangAtom "true"
erlps__unify__4 [_, _,
                 (ErlangTuple [(ErlangAtom "id"), _,
                               (ErlangCons (ErlangInt num_0) (ErlangEmptyList))]),
                 _when_1]
  | (ErlangInt num_0) == (toErl 95) =
  ErlangAtom "true"
erlps__unify__4 [env_0, a_1, b_2, when_3] =
  let    arg_4 = erlps__unfold_types_in_type__2 [env_0, a_1]
  in let a1_7 = erlps__dereference__1 [arg_4]
  in let arg_8 = erlps__unfold_types_in_type__2 [env_0, b_2]
  in let b1_11 = erlps__dereference__1 [arg_8]
  in erlps__unify1__4 [env_0, a1_7, b1_11, when_3]
erlps__unify__4 [arg_16, arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__unify__4 args =
  EXC.badarity (ErlangFun 4 erlps__unify__4) args

erlps__unify1__4 :: ErlangFun
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "uvar"), _, r_1]),
                  (ErlangTuple [(ErlangAtom "uvar"), _, r_2]), _when_3]
  | r_2 == r_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "uvar"), a_1, r_2]), t_3, when_4]
  =
  let case_5 = erlps__occurs_check__2 [r_2, t_3]
  in
    case case_5 of
      (ErlangAtom "true") ->
        let    arg_8 = ErlangTuple [ErlangAtom "uvar", a_1, r_2]
        in let _ = erlps__cannot_unify__3 [arg_8, t_3, when_4]
        in ErlangAtom "false"
      (ErlangAtom "false") ->
        let    arg_15 = ErlangTuple [r_2, t_3]
        in let _ = erlps__ets_insert__2 [ErlangAtom "type_vars", arg_15]
        in ErlangAtom "true"
      something_else -> EXC.case_clause something_else
erlps__unify1__4 [env_0, t_1,
                  (ErlangTuple [(ErlangAtom "uvar"), a_2, r_3]), when_4]
  =
  let arg_6 = ErlangTuple [ErlangAtom "uvar", a_2, r_3]
  in erlps__unify1__4 [env_0, arg_6, t_1, when_4]
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "tvar"), _, x_1]),
                  (ErlangTuple [(ErlangAtom "tvar"), _, x_2]), _when_3]
  | x_2 == x_1 =
  ErlangAtom "true"
erlps__unify1__4 [env_0, (ErlangCons a_1 b_2),
                  (ErlangCons c_3 d_4), when_5]
  =
  let lop_6 = erlps__unify__4 [env_0, a_1, c_3, when_5]
  in
    case lop_6 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") -> erlps__unify__4 [env_0, b_2, d_4, when_5]
      _ -> EXC.badarg1 lop_6
erlps__unify1__4 [_env_0, x_1, x_2, _when_3] | x_2 == x_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "id"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "id"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "con"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "con"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "qid"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "qid"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "qcon"), _, name_1]),
                  (ErlangTuple [(ErlangAtom "qcon"), _, name_2]), _when_3]
  | name_2 == name_1 =
  ErlangAtom "true"
erlps__unify1__4 [_env_0,
                  (ErlangTuple [(ErlangAtom "bytes_t"), _, len_1]),
                  (ErlangTuple [(ErlangAtom "bytes_t"), _, len_2]), _when_3]
  | len_2 == len_1 =
  ErlangAtom "true"
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "fun_t"), _, named1_1, args1_2,
                                result1_3]),
                  (ErlangTuple [(ErlangAtom "fun_t"), _, named2_4, args2_5,
                                result2_6]),
                  when_7]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_22 = BIF.erlang__length__1 [args1_2]
            in let rop_24 = BIF.erlang__length__1 [args2_5]
            in BIF.erlang__op_eq [lop_22, rop_24])) =
  let lop_8 = erlps__unify__4 [env_0, named1_1, named2_4, when_7]
  in
    case lop_8 of
      (ErlangAtom "false") -> ErlangAtom "false"
      (ErlangAtom "true") ->
        let lop_13 = erlps__unify__4 [env_0, args1_2, args2_5, when_7]
        in
          case lop_13 of
            (ErlangAtom "false") -> ErlangAtom "false"
            (ErlangAtom "true") ->
              erlps__unify__4 [env_0, result1_3, result2_6, when_7]
            _ -> EXC.badarg1 lop_13
      _ -> EXC.badarg1 lop_8
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "app_t"), _,
                                (ErlangTuple [tag_1, _, f_2]), args1_3]),
                  (ErlangTuple [(ErlangAtom "app_t"), _,
                                (ErlangTuple [tag_4, _, f_5]), args2_6]),
                  when_7]
  | tag_4 == tag_1
  , f_5 == f_2
  , (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_13 = BIF.erlang__length__1 [args1_3]
            in let rop_15 = BIF.erlang__length__1 [args2_6]
            in let lop_12 = BIF.erlang__op_eq [lop_13, rop_15]
            in
              case lop_12 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let lop_17 = BIF.erlang__op_eq [tag_1, ErlangAtom "id"]
                  in
                    case lop_17 of
                      (ErlangAtom "true") -> ErlangAtom "true"
                      (ErlangAtom "false") ->
                        BIF.erlang__op_eq [tag_1, ErlangAtom "qid"]
                      _ -> EXC.badarg1 lop_17
                _ -> EXC.badarg1 lop_12)) =
  erlps__unify__4 [env_0, args1_3, args2_6, when_7]
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "tuple_t"), _, as_1]),
                  (ErlangTuple [(ErlangAtom "tuple_t"), _, bs_2]), when_3]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let    lop_8 = BIF.erlang__length__1 [as_1]
            in let rop_10 = BIF.erlang__length__1 [bs_2]
            in BIF.erlang__op_eq [lop_8, rop_10])) =
  erlps__unify__4 [env_0, as_1, bs_2, when_3]
erlps__unify1__4 [env_0,
                  (ErlangTuple [(ErlangAtom "app_t"), _, t_1,
                                (ErlangEmptyList)]),
                  b_2, when_3]
  =
  erlps__unify__4 [env_0, t_1, b_2, when_3]
erlps__unify1__4 [env_0, a_1,
                  (ErlangTuple [(ErlangAtom "app_t"), _, t_2,
                                (ErlangEmptyList)]),
                  when_3]
  =
  erlps__unify__4 [env_0, a_1, t_2, when_3]
erlps__unify1__4 [_env_0, a_1, b_2, when_3] =
  let _ = erlps__cannot_unify__3 [a_1, b_2, when_3]
  in ErlangAtom "false"
erlps__unify1__4 [arg_7, arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__unify1__4 args =
  EXC.badarity (ErlangFun 4 erlps__unify1__4) args

erlps__dereference__1 :: ErlangFun
erlps__dereference__1 [t_1@(ErlangTuple [(ErlangAtom "uvar"), _,
                                         r_0])]
  =
  let case_2 = erlps__ets_lookup__2 [ErlangAtom "type_vars", r_0]
  in
    case case_2 of
      (ErlangEmptyList) -> t_1
      (ErlangCons (ErlangTuple [r_5,
                                type_6]) (ErlangEmptyList)) | r_5 == r_0 ->
        erlps__dereference__1 [type_6]
      something_else -> EXC.case_clause something_else
erlps__dereference__1 [t_0] = t_0
erlps__dereference__1 [arg_1] = EXC.function_clause unit
erlps__dereference__1 args =
  EXC.badarity (ErlangFun 1 erlps__dereference__1) args

erlps__dereference_deep__1 :: ErlangFun
erlps__dereference_deep__1 [type_0] =
  let case_1 = erlps__dereference__1 [type_0]
  in
    case case_1 of
      tup_3 | isETuple tup_3 ->
        let    arg_5 = BIF.erlang__tuple_to_list__1 [tup_3]
        in let arg_4 = erlps__dereference_deep__1 [arg_5]
        in BIF.erlang__list_to_tuple__1 [arg_4]
      (ErlangCons h_7 t_8) ->
        let    head_9 = erlps__dereference_deep__1 [h_7]
        in let tail_11 = erlps__dereference_deep__1 [t_8]
        in ErlangCons head_9 tail_11
      t_13 -> t_13
erlps__dereference_deep__1 [arg_14] = EXC.function_clause unit
erlps__dereference_deep__1 args =
  EXC.badarity (ErlangFun 1 erlps__dereference_deep__1) args

erlps__occurs_check__2 :: ErlangFun
erlps__occurs_check__2 [r_0, t_1] =
  let arg_3 = erlps__dereference__1 [t_1]
  in erlps__occurs_check1__2 [r_0, arg_3]
erlps__occurs_check__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__occurs_check__2 args =
  EXC.badarity (ErlangFun 2 erlps__occurs_check__2) args

erlps__occurs_check1__2 :: ErlangFun
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "uvar"), _, r1_1])]
  =
  BIF.erlang__op_eq [r_0, r1_1]
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "id"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "con"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "qid"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "qcon"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "tvar"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [_,
                         (ErlangTuple [(ErlangAtom "bytes_t"), _, _])]
  =
  ErlangAtom "false"
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "fun_t"), _, named_1, args_2,
                                       res_3])]
  =
  erlps__occurs_check__2
    [r_0, ErlangCons res_3 (ErlangCons named_1 args_2)]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "app_t"), _, t_1, ts_2])]
  =
  erlps__occurs_check__2 [r_0, ErlangCons t_1 ts_2]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "tuple_t"), _, ts_1])]
  =
  erlps__occurs_check__2 [r_0, ts_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "named_arg_t"), _, _, t_1,
                                       _])]
  =
  erlps__occurs_check__2 [r_0, t_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "record_t"), fields_1])]
  =
  erlps__occurs_check__2 [r_0, fields_1]
erlps__occurs_check1__2 [r_0,
                         (ErlangTuple [(ErlangAtom "field_t"), _, _, t_1])]
  =
  erlps__occurs_check__2 [r_0, t_1]
erlps__occurs_check1__2 [r_0, (ErlangCons h_1 t_2)] =
  let lop_3 = erlps__occurs_check__2 [r_0, h_1]
  in
    case lop_3 of
      (ErlangAtom "true") -> ErlangAtom "true"
      (ErlangAtom "false") -> erlps__occurs_check__2 [r_0, t_2]
      _ -> EXC.badarg1 lop_3
erlps__occurs_check1__2 [_, (ErlangEmptyList)] =
  ErlangAtom "false"
erlps__occurs_check1__2 [arg_0, arg_1] = EXC.function_clause unit
erlps__occurs_check1__2 args =
  EXC.badarity (ErlangFun 2 erlps__occurs_check1__2) args

erlps__fresh_uvar__1 :: ErlangFun
erlps__fresh_uvar__1 [(ErlangCons (ErlangTuple [(ErlangAtom "origin"),
                                                (ErlangAtom "system")]) (ErlangEmptyList))]
  =
  BIF.erlang__error__1 [ErlangAtom "oh_no_you_dont"]
erlps__fresh_uvar__1 [attrs_0] =
  let tup_el_3 = BIF.erlang__make_ref__0 []
  in ErlangTuple [ErlangAtom "uvar", attrs_0, tup_el_3]
erlps__fresh_uvar__1 [arg_4] = EXC.function_clause unit
erlps__fresh_uvar__1 args =
  EXC.badarity (ErlangFun 1 erlps__fresh_uvar__1) args

erlps__create_freshen_tvars__0 :: ErlangFun
erlps__create_freshen_tvars__0 [] =
  erlps__ets_new__2
    [ErlangAtom "freshen_tvars",
     ErlangCons (ErlangAtom "ordered_set") ErlangEmptyList]
erlps__create_freshen_tvars__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_freshen_tvars__0) args

erlps__destroy_freshen_tvars__0 :: ErlangFun
erlps__destroy_freshen_tvars__0 [] =
  erlps__ets_delete__1 [ErlangAtom "freshen_tvars"]
erlps__destroy_freshen_tvars__0 args =
  EXC.badarity (ErlangFun 0 erlps__destroy_freshen_tvars__0) args

erlps__freshen_type__2 :: ErlangFun
erlps__freshen_type__2 [ann_0, type_1] =
  let    _ = erlps__create_freshen_tvars__0 []
  in let type1_4 = erlps__freshen__2 [ann_0, type_1]
  in let _ = erlps__destroy_freshen_tvars__0 []
  in type1_4
erlps__freshen_type__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__freshen_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__freshen_type__2) args

erlps__freshen__1 :: ErlangFun
erlps__freshen__1 [type_0] =
  let
    arg_1 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [type_0]
  in erlps__freshen__2 [arg_1, type_0]
erlps__freshen__1 [arg_4] = EXC.function_clause unit
erlps__freshen__1 args =
  EXC.badarity (ErlangFun 1 erlps__freshen__1) args

erlps__freshen__2 :: ErlangFun
erlps__freshen__2 [ann_0,
                   (ErlangTuple [(ErlangAtom "tvar"), _, name_1])]
  =
  let   
    case_2 =
      erlps__ets_lookup__2 [ErlangAtom "freshen_tvars", name_1]
  in let
    newt_8 =
      case case_2 of
        (ErlangEmptyList) -> erlps__fresh_uvar__1 [ann_0]
        (ErlangCons (ErlangTuple [name_6,
                                  t_7]) (ErlangEmptyList)) | name_6 == name_1 ->
          t_7
        something_else -> EXC.case_clause something_else
  in let arg_10 = ErlangTuple [name_1, newt_8]
  in let
    _ = erlps__ets_insert__2 [ErlangAtom "freshen_tvars", arg_10]
  in newt_8
erlps__freshen__2 [ann_0,
                   (ErlangTuple [(ErlangAtom "bytes_t"), _,
                                 (ErlangAtom "any")])]
  =
  let    x_2 = erlps__fresh_uvar__1 [ann_0]
  in let arg_3 = ErlangTuple [ErlangAtom "is_bytes", x_2]
  in let _ = erlps__add_bytes_constraint__1 [arg_3]
  in x_2
erlps__freshen__2 [ann_0, t_1] | isETuple t_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_2 = erlps__freshen__2 [ann_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__freshen__2 [ann_0, (ErlangCons a_1 b_2)] =
  let    head_3 = erlps__freshen__2 [ann_0, a_1]
  in let tail_6 = erlps__freshen__2 [ann_0, b_2]
  in ErlangCons head_3 tail_6
erlps__freshen__2 [_, x_0] = x_0
erlps__freshen__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__freshen__2 args =
  EXC.badarity (ErlangFun 2 erlps__freshen__2) args

erlps__freshen_type_sig__2 :: ErlangFun
erlps__freshen_type_sig__2 [ann_0,
                            typesig_2@(ErlangTuple [(ErlangAtom "type_sig"), _,
                                                    constr_1, _, _, _])]
  =
  let    arg_4 = erlps__typesig_to_fun_t__1 [typesig_2]
  in let funt_6 = erlps__freshen_type__2 [ann_0, arg_4]
  in let
    _ = erlps__apply_typesig_constraint__3 [ann_0, constr_1, funt_6]
  in funt_6
erlps__freshen_type_sig__2 [arg_10, arg_11] =
  EXC.function_clause unit
erlps__freshen_type_sig__2 args =
  EXC.badarity (ErlangFun 2 erlps__freshen_type_sig__2) args

erlps__apply_typesig_constraint__3 :: ErlangFun
erlps__apply_typesig_constraint__3 [_ann_0, (ErlangAtom "none"),
                                    _funt_1]
  =
  ErlangAtom "ok"
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "address_to_contract"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _,
                                                  (ErlangEmptyList),
                                                  (ErlangCons _ (ErlangEmptyList)),
                                                  type_1])]
  =
  let   
    tup_el_6 = ErlangTuple [ErlangAtom "address_to_contract", ann_0]
  in let
    head_3 =
      ErlangTuple
        [ErlangAtom "is_contract_constraint", type_1, tup_el_6]
  in erlps__constrain__1 [ErlangCons head_3 ErlangEmptyList]
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "bytes_concat"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _,
                                                  (ErlangEmptyList),
                                                  (ErlangCons a_1 (ErlangCons b_2 (ErlangEmptyList))),
                                                  c_3])]
  =
  let
    arg_4 =
      ErlangTuple
        [ErlangAtom "add_bytes", ann_0, ErlangAtom "concat", a_1, b_2,
         c_3]
  in erlps__add_bytes_constraint__1 [arg_4]
erlps__apply_typesig_constraint__3 [ann_0,
                                    (ErlangAtom "bytes_split"),
                                    (ErlangTuple [(ErlangAtom "fun_t"), _,
                                                  (ErlangEmptyList),
                                                  (ErlangCons c_1 (ErlangEmptyList)),
                                                  (ErlangTuple [(ErlangAtom "tuple_t"),
                                                                _,
                                                                (ErlangCons a_2 (ErlangCons b_3 (ErlangEmptyList)))])])]
  =
  let
    arg_4 =
      ErlangTuple
        [ErlangAtom "add_bytes", ann_0, ErlangAtom "split", a_2, b_3,
         c_1]
  in erlps__add_bytes_constraint__1 [arg_4]
erlps__apply_typesig_constraint__3 [arg_11, arg_12, arg_13] =
  EXC.function_clause unit
erlps__apply_typesig_constraint__3 args =
  EXC.badarity (ErlangFun 3 erlps__apply_typesig_constraint__3)
    args

erlps__instantiate__1 :: ErlangFun
erlps__instantiate__1 [e_0] =
  let arg_1 = erlps__dereference__1 [e_0]
  in erlps__instantiate1__1 [arg_1]
erlps__instantiate__1 [arg_3] = EXC.function_clause unit
erlps__instantiate__1 args =
  EXC.badarity (ErlangFun 1 erlps__instantiate__1) args

erlps__instantiate1__1 :: ErlangFun
erlps__instantiate1__1 [(ErlangTuple [(ErlangAtom "uvar"),
                                      attr_0, r_1])]
  =
  let   
    arg_3 =
      erlps__ets_lookup__2 [ErlangAtom "type_vars", ErlangAtom "next"]
  in let arg_6 = toErl 0
  in let
    next_7 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "next", arg_3, arg_6]
  in let lop_11 = toErl "\'"
  in let rop_12 = erlps__integer_to_tvar__1 [next_7]
  in let tup_el_10 = BIF.erlang__op_append [lop_11, rop_12]
  in let
    tvar_14 = ErlangTuple [ErlangAtom "tvar", attr_0, tup_el_10]
  in let rop_21 = toErl 1
  in let tup_el_19 = BIF.erlang__op_plus [next_7, rop_21]
  in let head_17 = ErlangTuple [ErlangAtom "next", tup_el_19]
  in let head_23 = ErlangTuple [r_1, tvar_14]
  in let
    _ =
      erlps__ets_insert__2
        [ErlangAtom "type_vars",
         ErlangCons head_17 (ErlangCons head_23 ErlangEmptyList)]
  in tvar_14
erlps__instantiate1__1 [(ErlangTuple [(ErlangAtom "fun_t"),
                                      ann_0, named_1, args_2, ret_3])]
  =
  let case_4 = erlps__dereference__1 [named_1]
  in
    case case_4 of
      (ErlangTuple [(ErlangAtom "uvar"), _, r_6]) ->
        let    head_10 = ErlangTuple [r_6, ErlangEmptyList]
        in let
          _ =
            erlps__ets_insert__2
              [ErlangAtom "type_vars", ErlangCons head_10 ErlangEmptyList]
        in let tup_el_17 = erlps__instantiate__1 [args_2]
        in let tup_el_19 = erlps__instantiate__1 [ret_3]
        in
          ErlangTuple
            [ErlangAtom "fun_t", ann_0, ErlangEmptyList, tup_el_17,
             tup_el_19]
      named1_21 ->
        let    tup_el_24 = erlps__instantiate1__1 [named1_21]
        in let tup_el_26 = erlps__instantiate__1 [args_2]
        in let tup_el_28 = erlps__instantiate__1 [ret_3]
        in
          ErlangTuple
            [ErlangAtom "fun_t", ann_0, tup_el_24, tup_el_26, tup_el_28]
erlps__instantiate1__1 [t_0] | isETuple t_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [t_0]
  in let arg_1 = erlps__instantiate1__1 [arg_2]
  in BIF.erlang__list_to_tuple__1 [arg_1]
erlps__instantiate1__1 [(ErlangCons a_0 b_1)] =
  let    head_2 = erlps__instantiate__1 [a_0]
  in let tail_4 = erlps__instantiate__1 [b_1]
  in ErlangCons head_2 tail_4
erlps__instantiate1__1 [x_0] = x_0
erlps__instantiate1__1 [arg_1] = EXC.function_clause unit
erlps__instantiate1__1 args =
  EXC.badarity (ErlangFun 1 erlps__instantiate1__1) args

erlps__integer_to_tvar__1 :: ErlangFun
erlps__integer_to_tvar__1 [x_0] | weakLt x_0 (toErl 26) =
  let    lop_2 = toErl 97
  in let head_1 = BIF.erlang__op_plus [lop_2, x_0]
  in ErlangCons head_1 ErlangEmptyList
erlps__integer_to_tvar__1 [x_0] =
  let    rop_5 = toErl 26
  in let arg_3 = BIF.erlang__op_div_strict [x_0, rop_5]
  in let head_2 = erlps__integer_to_tvar__1 [arg_3]
  in let lop_9 = toErl 97
  in let rop_12 = toErl 26
  in let rop_10 = BIF.erlang__op_rem_strict [x_0, rop_12]
  in let head_8 = BIF.erlang__op_plus [lop_9, rop_10]
  in
    BIF.erlang__op_append
      [ErlangCons head_2 ErlangEmptyList,
       ErlangCons head_8 ErlangEmptyList]
erlps__integer_to_tvar__1 [arg_14] = EXC.function_clause unit
erlps__integer_to_tvar__1 args =
  EXC.badarity (ErlangFun 1 erlps__integer_to_tvar__1) args

erlps__cannot_unify__3 :: ErlangFun
erlps__cannot_unify__3 [a_0, b_1, when_2] =
  let
    arg_3 = ErlangTuple [ErlangAtom "cannot_unify", a_0, b_1, when_2]
  in erlps__type_error__1 [arg_3]
erlps__cannot_unify__3 [arg_8, arg_9, arg_10] =
  EXC.function_clause unit
erlps__cannot_unify__3 args =
  EXC.badarity (ErlangFun 3 erlps__cannot_unify__3) args

erlps__type_error__1 :: ErlangFun
erlps__type_error__1 [err_0] =
  erlps__ets_insert__2 [ErlangAtom "type_errors", err_0]
erlps__type_error__1 [arg_3] = EXC.function_clause unit
erlps__type_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__type_error__1) args

erlps__create_type_errors__0 :: ErlangFun
erlps__create_type_errors__0 [] =
  erlps__ets_new__2
    [ErlangAtom "type_errors",
     ErlangCons (ErlangAtom "bag") ErlangEmptyList]
erlps__create_type_errors__0 args =
  EXC.badarity (ErlangFun 0 erlps__create_type_errors__0) args

erlps__destroy_and_report_type_errors__1 :: ErlangFun
erlps__destroy_and_report_type_errors__1 [env_0] =
  let    arg_1 = erlps__ets_tab2list__1 [ErlangAtom "type_errors"]
  in let
    errors0_3 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [arg_1]
  in let _ = erlps__ets_delete__1 [ErlangAtom "type_errors"]
  in let
    errors_12 =
      flmap
        (\ lc_7 ->
           let    arg_9 = erlps__unqualify__2 [env_0, lc_7]
           in let lcRet_8 = erlps__mk_error__1 [arg_9]
           in ErlangCons lcRet_8 ErlangEmptyList)
        errors0_3
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__throw__1"
      [errors_12]
erlps__destroy_and_report_type_errors__1 [arg_14] =
  EXC.function_clause unit
erlps__destroy_and_report_type_errors__1 args =
  EXC.badarity
    (ErlangFun 1 erlps__destroy_and_report_type_errors__1) args

erlps__unqualify__2 :: ErlangFun
erlps__unqualify__2 [(ErlangTuple [(ErlangAtom "env"), _, _, _,
                                   _, ns_0, _, _, _, _]),
                     (ErlangTuple [(ErlangAtom "qid"), ann_1, xs_2])]
  =
  let arg_4 = erlps__unqualify1__2 [ns_0, xs_2]
  in erlps__qid__2 [ann_1, arg_4]
erlps__unqualify__2 [(ErlangTuple [(ErlangAtom "env"), _, _, _,
                                   _, ns_0, _, _, _, _]),
                     (ErlangTuple [(ErlangAtom "qcon"), ann_1, xs_2])]
  =
  let arg_4 = erlps__unqualify1__2 [ns_0, xs_2]
  in erlps__qcon__2 [ann_1, arg_4]
erlps__unqualify__2 [env_0, t_1] | isETuple t_1 =
  let    arg_4 = BIF.erlang__tuple_to_list__1 [t_1]
  in let arg_2 = erlps__unqualify__2 [env_0, arg_4]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__unqualify__2 [env_0, (ErlangCons h_1 t_2)] =
  let    head_3 = erlps__unqualify__2 [env_0, h_1]
  in let tail_6 = erlps__unqualify__2 [env_0, t_2]
  in ErlangCons head_3 tail_6
erlps__unqualify__2 [_env_0, x_1] = x_1
erlps__unqualify__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__unqualify__2 args =
  EXC.badarity (ErlangFun 2 erlps__unqualify__2) args

erlps__unqualify1__2 :: ErlangFun
erlps__unqualify1__2 [ns_0, xs_1] =
  EXC.tryOfCatch
    (\ _ ->
       let arg_2 = BIF.erlang__length__1 [ns_0]
       in
         BIF.do_remote_fun_call "Lists" "erlps__split__2" [arg_2, xs_1])
    (\ of_5 ->
       case of_5 of
         (ErlangTuple [ns_8, ys_9]) | ns_8 == ns_0 -> ys_9
         _ -> xs_1)
    (\ ex_6 ->
       case ex_6 of
         (ErlangTuple [_, _, _]) -> xs_1
         ex_7 -> EXC.raise ex_7)
erlps__unqualify1__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__unqualify1__2 args =
  EXC.badarity (ErlangFun 2 erlps__unqualify1__2) args

erlps__mk_t_err__2 :: ErlangFun
erlps__mk_t_err__2 [pos_0, msg_1] =
  let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [msg_1]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__3"
      [ErlangAtom "type_error", pos_0, arg_4]
erlps__mk_t_err__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__mk_t_err__2 args =
  EXC.badarity (ErlangFun 2 erlps__mk_t_err__2) args

erlps__mk_t_err__3 :: ErlangFun
erlps__mk_t_err__3 [pos_0, msg_1, ctxt_2] =
  let   
    arg_5 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [msg_1]
  in let
    arg_7 =
      BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [ctxt_2]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__new__4"
      [ErlangAtom "type_error", pos_0, arg_5, arg_7]
erlps__mk_t_err__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__mk_t_err__3 args =
  EXC.badarity (ErlangFun 3 erlps__mk_t_err__3) args

erlps__mk_error__1 :: ErlangFun
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "no_decls"),
                                  file_0])]
  =
  let    arg_2 = toErl 0
  in let arg_3 = toErl 0
  in let
    pos_4 =
      BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__3"
        [file_0, arg_2, arg_3]
  in let arg_6 = toErl "Empty contract\n"
  in erlps__mk_t_err__2 [pos_4, arg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "mismatched_decl_in_funblock"),
                                  name_0, decl_1])]
  =
  let   
    arg_2 =
      toErl
        "Mismatch in the function block. Expected implementation/type declaration of ~s function\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_1]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "higher_kinded_typevar"),
                                  t_0])]
  =
  let   
    arg_1 =
      toErl
        "Type ~s is a higher kinded type variable\n(takes another type as an argument)\n"
  in let arg_4 = erlps__instantiate__1 [t_0]
  in let head_3 = erlps__pp__1 [arg_4]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [t_0]
  in erlps__mk_t_err__2 [arg_8, msg_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "wrong_type_arguments"),
                                  x_0, aritygiven_1, arityreal_2])]
  =
  let   
    arg_3 =
      toErl "Arity for ~s doesn\'t match. Expected ~p, got ~p\n"
  in let arg_6 = erlps__instantiate__1 [x_0]
  in let head_5 = erlps__pp__1 [arg_6]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons arityreal_2
              (ErlangCons aritygiven_1 ErlangEmptyList))]
  in let arg_14 = erlps__pos__1 [x_0]
  in erlps__mk_t_err__2 [arg_14, msg_13]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unnamed_map_update_with_default"),
                                  upd_0])]
  =
  let    msg_1 = toErl "Invalid map update with default\n"
  in let arg_2 = erlps__pos__1 [upd_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "fundecl_must_have_funtype"),
                                  _ann_0, id_1, type_2])]
  =
  let   
    arg_3 =
      toErl
        "~s at ~s was declared with an invalid type ~s.\nEntrypoints and functions must have functional types"
  in let head_5 = erlps__pp__1 [id_1]
  in let head_8 = erlps__pp_loc__1 [id_1]
  in let arg_12 = erlps__instantiate__1 [type_2]
  in let head_11 = erlps__pp__1 [arg_12]
  in let
    msg_15 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
  in let arg_16 = erlps__pos__1 [id_1]
  in erlps__mk_t_err__2 [arg_16, msg_15]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "cannot_unify"),
                                  a_0, b_1, when_2])]
  =
  let    arg_3 = toErl "Cannot unify ~s\n         and ~s\n"
  in let arg_6 = erlps__instantiate__1 [a_0]
  in let head_5 = erlps__pp__1 [arg_6]
  in let arg_10 = erlps__instantiate__1 [b_1]
  in let head_9 = erlps__pp__1 [arg_10]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons head_5 (ErlangCons head_9 ErlangEmptyList)]
  in let matchExpr_17 = erlps__pp_when__1 [when_2]
  in
    case matchExpr_17 of
      (ErlangTuple [pos_15, ctxt_16]) ->
        erlps__mk_t_err__3 [pos_15, msg_13, ctxt_16]
      _ -> EXC.badmatch matchExpr_17
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unbound_variable"),
                                  id_0])]
  =
  let    arg_1 = toErl "Unbound variable ~s at ~s\n"
  in let head_3 = erlps__pp__1 [id_0]
  in let head_6 = erlps__pp_loc__1 [id_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in
    case id_0 of
      (ErlangTuple [(ErlangAtom "qid"), _,
                    (ErlangCons (ErlangCons (ErlangInt num_11) (ErlangCons (ErlangInt num_12) (ErlangCons (ErlangInt num_13) (ErlangCons (ErlangInt num_14) (ErlangCons (ErlangInt num_15) (ErlangEmptyList)))))) (ErlangCons (ErlangCons (ErlangInt num_16) (ErlangCons (ErlangInt num_17) (ErlangCons (ErlangInt num_18) (ErlangCons (ErlangInt num_19) (ErlangCons (ErlangInt num_20) (ErlangEmptyList)))))) (ErlangEmptyList)))]) | (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_11) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             67)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_12) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             104)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_13) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             97)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_14) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             105)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_15) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             110)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_16) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             101)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_17) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             118)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_18) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             101)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_19) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             110)
                                                                                                                                                                                                                                                                                                                                                                                                                                      , (ErlangInt
                                                                                                                                                                                                                                                                                                                                                                                                                                           num_20) ==
                                                                                                                                                                                                                                                                                                                                                                                                                                          (toErl
                                                                                                                                                                                                                                                                                                                                                                                                                                             116) ->
        let    cxt_21 = toErl "Did you forget to define the event type?"
        in let arg_22 = erlps__pos__1 [id_0]
        in erlps__mk_t_err__3 [arg_22, msg_9, cxt_21]
      _ ->
        let arg_26 = erlps__pos__1 [id_0]
        in erlps__mk_t_err__2 [arg_26, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "undefined_field"),
                                  id_0])]
  =
  let    arg_1 = toErl "Unbound field ~s at ~s\n"
  in let head_3 = erlps__pp__1 [id_0]
  in let head_6 = erlps__pp_loc__1 [id_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [id_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "not_a_record_type"),
                                  type_0, why_1])]
  =
  let    arg_2 = toErl "~s\n"
  in let arg_5 = toErl "Not a record type: "
  in let head_4 = erlps__pp_type__2 [arg_5, type_0]
  in let
    msg_8 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 ErlangEmptyList]
  in let matchExpr_12 = erlps__pp_why_record__1 [why_1]
  in
    case matchExpr_12 of
      (ErlangTuple [pos_10, ctxt_11]) ->
        erlps__mk_t_err__3 [pos_10, msg_8, ctxt_11]
      _ -> EXC.badmatch matchExpr_12
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "not_a_contract_type"),
                                  type_0, cxt_1])]
  =
  let   
    msg_9 =
      case type_0 of
        (ErlangTuple [(ErlangAtom "tvar"), _, _]) ->
          toErl "Unresolved contract type\n"
        _ ->
          let    arg_3 = toErl "The type ~s is not a contract type\n"
          in let arg_6 = toErl ""
          in let head_5 = erlps__pp_type__2 [arg_6, type_0]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_3, ErlangCons head_5 ErlangEmptyList]
  in let
    matchExpr_37 =
      case cxt_1 of
        (ErlangTuple [(ErlangAtom "contract_literal"), lit_11]) ->
          let    tup_el_12 = erlps__pos__1 [lit_11]
          in let
            arg_15 =
              toErl
                "when checking that the contract literal\n~s\nhas the type\n~s\n"
          in let arg_18 = toErl "  "
          in let head_17 = erlps__pp_expr__2 [arg_18, lit_11]
          in let arg_22 = toErl "  "
          in let head_21 = erlps__pp_type__2 [arg_22, type_0]
          in let
            tup_el_14 =
              BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                [arg_15,
                 ErlangCons head_17 (ErlangCons head_21 ErlangEmptyList)]
          in ErlangTuple [tup_el_12, tup_el_14]
        (ErlangTuple [(ErlangAtom "address_to_contract"), ann_25]) ->
          let    tup_el_26 = erlps__pos__1 [ann_25]
          in let
            arg_29 =
              toErl
                "when checking that the call to\n  Address.to_contract\nhas the type\n~s\n"
          in let arg_32 = toErl "  "
          in let head_31 = erlps__pp_type__2 [arg_32, type_0]
          in let
            tup_el_28 =
              BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                [arg_29, ErlangCons head_31 ErlangEmptyList]
          in ErlangTuple [tup_el_26, tup_el_28]
        something_else -> EXC.case_clause something_else
  in
    case matchExpr_37 of
      (ErlangTuple [pos_35, cxt1_36]) ->
        erlps__mk_t_err__3 [pos_35, msg_9, cxt1_36]
      _ -> EXC.badmatch matchExpr_37
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "non_linear_pattern"),
                                  pattern_0, nonlinear_1])]
  =
  let   
    arg_2 = toErl "Repeated name~s ~s in pattern\n~s (at ~s)\n"
  in let arg_5 = toErl ""
  in let arg_6 = toErl "s"
  in let head_4 = erlps__plural__3 [arg_5, arg_6, nonlinear_1]
  in let arg_11 = toErl ", "
  in let
    head_9 =
      BIF.do_remote_fun_call "String" "erlps__join__2"
        [nonlinear_1, arg_11]
  in let arg_14 = toErl "  "
  in let head_13 = erlps__pp_expr__2 [arg_14, pattern_0]
  in let head_17 = erlps__pp_loc__1 [pattern_0]
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_9
              (ErlangCons head_13 (ErlangCons head_17 ErlangEmptyList)))]
  in let arg_21 = erlps__pos__1 [pattern_0]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "ambiguous_record"),
                                  fields_1@(ErlangCons (ErlangTuple [_,
                                                                     first_0]) _),
                                  candidates_2])]
  =
  let   
    arg_3 =
      toErl
        "Ambiguous record type with field~s ~s (at ~s) could be one of\n~s"
  in let arg_6 = toErl ""
  in let arg_7 = toErl "s"
  in let head_5 = erlps__plural__3 [arg_6, arg_7, fields_1]
  in let
    arg_11 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [_, f_13]) ->
               let lcRet_15 = erlps__pp__1 [f_13]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_1
  in let arg_17 = toErl ", "
  in let
    head_10 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_11, arg_17]
  in let head_19 = erlps__pp_loc__1 [first_0]
  in let
    head_22 =
      flmap
        (\ lc_25 ->
           let    head_27 = toErl "  - "
           in let head_29 = erlps__pp__1 [lc_25]
           in let head_32 = toErl " (at "
           in let head_34 = erlps__pp_loc__1 [lc_25]
           in let head_37 = toErl ")\n"
           in
             ErlangCons
               (ErlangCons head_27
                  (ErlangCons head_29
                     (ErlangCons head_32
                        (ErlangCons head_34
                           (ErlangCons head_37 ErlangEmptyList)))))
               ErlangEmptyList)
        candidates_2
  in let
    msg_40 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_10
              (ErlangCons head_19 (ErlangCons head_22 ErlangEmptyList)))]
  in let arg_41 = erlps__pos__1 [first_0]
  in erlps__mk_t_err__2 [arg_41, msg_40]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "missing_field"),
                                  field_0, rec_1])]
  =
  let   
    arg_2 = toErl "Record type ~s does not have field ~s (at ~s)\n"
  in let head_4 = erlps__pp__1 [rec_1]
  in let head_7 = erlps__pp__1 [field_0]
  in let head_10 = erlps__pp_loc__1 [field_0]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList))]
  in let arg_14 = erlps__pos__1 [field_0]
  in erlps__mk_t_err__2 [arg_14, msg_13]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "missing_fields"),
                                  ann_0, rectype_1, fields_2])]
  =
  let   
    arg_3 =
      toErl
        "The field~s ~s ~s missing when constructing an element of type ~s (at ~s)\n"
  in let arg_6 = toErl ""
  in let arg_7 = toErl "s"
  in let head_5 = erlps__plural__3 [arg_6, arg_7, fields_2]
  in let arg_12 = toErl ", "
  in let
    head_10 =
      BIF.do_remote_fun_call "String" "erlps__join__2"
        [fields_2, arg_12]
  in let arg_15 = toErl "is"
  in let arg_16 = toErl "are"
  in let head_14 = erlps__plural__3 [arg_15, arg_16, fields_2]
  in let head_19 = erlps__pp__1 [rectype_1]
  in let head_22 = erlps__pp_loc__1 [ann_0]
  in let
    msg_25 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_10
              (ErlangCons head_14
                 (ErlangCons head_19 (ErlangCons head_22 ErlangEmptyList))))]
  in let arg_26 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_26, msg_25]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "no_records_with_all_fields"),
                                  fields_1@(ErlangCons (ErlangTuple [_,
                                                                     first_0]) _)])]
  =
  let    arg_2 = toErl "No record type with field~s ~s (at ~s)\n"
  in let arg_5 = toErl ""
  in let arg_6 = toErl "s"
  in let head_4 = erlps__plural__3 [arg_5, arg_6, fields_1]
  in let
    arg_10 =
      flmap
        (\ lc_13 ->
           case lc_13 of
             (ErlangTuple [_, f_12]) ->
               let lcRet_14 = erlps__pp__1 [f_12]
               in ErlangCons lcRet_14 ErlangEmptyList
             _ -> ErlangEmptyList)
        fields_1
  in let arg_16 = toErl ", "
  in let
    head_9 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_10, arg_16]
  in let head_18 = erlps__pp_loc__1 [first_0]
  in let
    msg_21 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_9 (ErlangCons head_18 ErlangEmptyList))]
  in let arg_22 = erlps__pos__1 [first_0]
  in erlps__mk_t_err__2 [arg_22, msg_21]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "recursive_types_not_implemented"),
                                  types_0])]
  =
  let    arg_1 = toErl " is"
  in let arg_2 = toErl "s are mutually"
  in let s_4 = erlps__plural__3 [arg_1, arg_2, types_0]
  in let
    arg_5 =
      toErl
        "The following type~s recursive, which is not yet supported:\n~s"
  in let
    head_9 =
      flmap
        (\ lc_12 ->
           let    arg_14 = toErl "  - ~s (at ~s)\n"
           in let head_16 = erlps__pp__1 [lc_12]
           in let head_19 = erlps__pp_loc__1 [lc_12]
           in let
             lcRet_13 =
               BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                 [arg_14,
                  ErlangCons head_16 (ErlangCons head_19 ErlangEmptyList)]
           in ErlangCons lcRet_13 ErlangEmptyList)
        types_0
  in let
    msg_23 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons s_4 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_25 = BIF.erlang__hd__1 [types_0]
  in let arg_24 = erlps__pos__1 [arg_25]
  in erlps__mk_t_err__2 [arg_24, msg_23]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "event_must_be_variant_type"),
                                  where_0])]
  =
  let   
    arg_1 = toErl "The event type must be a variant type (at ~s)\n"
  in let head_3 = erlps__pp_loc__1 [where_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [where_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "indexed_type_must_be_word"),
                                  type_0, type_1])]
  | type_1 == type_0 =
  let   
    arg_2 = toErl "The indexed type ~s (at ~s) is not a word type\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_type__2 [arg_5, type_0]
  in let head_8 = erlps__pp_loc__1 [type_0]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "indexed_type_must_be_word"),
                                  type_0, type1_1])]
  =
  let   
    arg_2 =
      toErl
        "The indexed type ~s (at ~s) equals ~s which is not a word type\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_type__2 [arg_5, type_0]
  in let head_8 = erlps__pp_loc__1 [type_0]
  in let arg_12 = toErl ""
  in let head_11 = erlps__pp_type__2 [arg_12, type1_1]
  in let
    msg_15 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
  in let arg_16 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_16, msg_15]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "event_0_to_3_indexed_values"),
                                  constr_0])]
  =
  let   
    arg_1 =
      toErl
        "The event constructor ~s (at ~s) has too many indexed values (max 3)\n"
  in let head_3 = erlps__name__1 [constr_0]
  in let head_6 = erlps__pp_loc__1 [constr_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [constr_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "event_0_to_1_string_values"),
                                  constr_0])]
  =
  let   
    arg_1 =
      toErl
        "The event constructor ~s (at ~s) has too many non-indexed values (max 1)\n"
  in let head_3 = erlps__name__1 [constr_0]
  in let head_6 = erlps__pp_loc__1 [constr_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [constr_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "repeated_constructor"),
                                  cs_0])]
  =
  let   
    arg_1 =
      toErl "Variant types must have distinct constructor names\n~s"
  in let
    head_3 =
      flmap
        (\ lc_7 ->
           case lc_7 of
             (ErlangTuple [c_5, t_6]) ->
               let    arg_9 = toErl "~s  (at ~s)\n"
               in let arg_12 = toErl "  - "
               in let head_11 = erlps__pp_typed__3 [arg_12, c_5, t_6]
               in let head_16 = erlps__pp_loc__1 [c_5]
               in let
                 lcRet_8 =
                   BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                     [arg_9,
                      ErlangCons head_11 (ErlangCons head_16 ErlangEmptyList)]
               in ErlangCons lcRet_8 ErlangEmptyList
             _ -> ErlangEmptyList)
        cs_0
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_23 = toErl 1
  in let arg_24 = BIF.erlang__hd__1 [cs_0]
  in let arg_22 = BIF.erlang__element__2 [arg_23, arg_24]
  in let arg_21 = erlps__pos__1 [arg_22]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "bad_named_argument"),
                                  (ErlangEmptyList), name_0])]
  =
  let   
    arg_1 =
      toErl
        "Named argument ~s (at ~s) supplied to function expecting no named arguments.\n"
  in let head_3 = erlps__pp__1 [name_0]
  in let head_6 = erlps__pp_loc__1 [name_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [name_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "bad_named_argument"),
                                  args_0, name_1])]
  =
  let   
    arg_2 =
      toErl
        "Named argument ~s (at ~s) is not one of the expected named arguments\n~s"
  in let head_4 = erlps__pp__1 [name_1]
  in let head_7 = erlps__pp_loc__1 [name_1]
  in let
    head_10 =
      flmap
        (\ lc_14 ->
           case lc_14 of
             (ErlangTuple [(ErlangAtom "named_arg_t"), _, arg_12, type_13,
                           _]) ->
               let    arg_16 = toErl "~s\n"
               in let arg_19 = toErl "  - "
               in let head_18 = erlps__pp_typed__3 [arg_19, arg_12, type_13]
               in let
                 lcRet_15 =
                   BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                     [arg_16, ErlangCons head_18 ErlangEmptyList]
               in ErlangCons lcRet_15 ErlangEmptyList
             _ -> ErlangEmptyList)
        args_0
  in let
    msg_24 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList))]
  in let arg_25 = erlps__pos__1 [name_1]
  in erlps__mk_t_err__2 [arg_25, msg_24]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unsolved_named_argument_constraint"),
                                  (ErlangTuple [(ErlangAtom "named_argument_constraint"),
                                                _, name_0, type_1])])]
  =
  let   
    arg_2 =
      toErl
        "Named argument ~s (at ~s) supplied to function with unknown named arguments.\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_typed__3 [arg_5, name_0, type_1]
  in let head_9 = erlps__pp_loc__1 [name_0]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [name_0]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "reserved_entrypoint"),
                                  name_0, def_1])]
  =
  let   
    arg_2 =
      toErl
        "The name \'~s\' is reserved and cannot be used for a\ntop-level contract function (at ~s).\n"
  in let head_6 = erlps__pp_loc__1 [def_1]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [def_1]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "duplicate_definition"),
                                  name_0, locs_1])]
  =
  let    arg_2 = toErl "Duplicate definitions of ~s at\n~s"
  in let
    head_6 =
      flmap
        (\ lc_9 ->
           let    head_11 = toErl "  - "
           in let head_13 = erlps__pp_loc__1 [lc_9]
           in let head_16 = toErl "\n"
           in
             ErlangCons
               (ErlangCons head_11
                  (ErlangCons head_13 (ErlangCons head_16 ErlangEmptyList)))
               ErlangEmptyList)
        locs_1
  in let
    msg_19 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_0 (ErlangCons head_6 ErlangEmptyList)]
  in let
    arg_21 = BIF.do_remote_fun_call "Lists" "erlps__last__1" [locs_1]
  in let arg_20 = erlps__pos__1 [arg_21]
  in erlps__mk_t_err__2 [arg_20, msg_19]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "duplicate_scope"),
                                  kind_0, name_1, otherkind_2, l_3])]
  =
  let   
    arg_4 =
      toErl "The ~p ~s (at ~s) has the same name as a ~p at ~s\n"
  in let head_8 = erlps__pp__1 [name_1]
  in let head_11 = erlps__pp_loc__1 [name_1]
  in let head_16 = erlps__pp_loc__1 [l_3]
  in let
    msg_19 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4,
         ErlangCons kind_0
           (ErlangCons head_8
              (ErlangCons head_11
                 (ErlangCons otherkind_2
                    (ErlangCons head_16 ErlangEmptyList))))]
  in let arg_20 = erlps__pos__1 [name_1]
  in erlps__mk_t_err__2 [arg_20, msg_19]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "include"), _,
                                  (ErlangTuple [(ErlangAtom "string"), pos_0,
                                                name_1])])]
  =
  let   
    arg_2 =
      toErl
        "Include of \'~s\' at ~s\nnot allowed, include only allowed at top level.\n"
  in let head_4 = BIF.erlang__binary_to_list__1 [name_1]
  in let head_7 = erlps__pp_loc__1 [pos_0]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons head_4 (ErlangCons head_7 ErlangEmptyList)]
  in let arg_11 = erlps__pos__1 [pos_0]
  in erlps__mk_t_err__2 [arg_11, msg_10]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "namespace"),
                                  _pos_0,
                                  (ErlangTuple [(ErlangAtom "con"), pos_1,
                                                name_2]),
                                  _def_3])]
  =
  let   
    arg_4 =
      toErl
        "Nested namespaces are not allowed\nNamespace \'~s\' at ~s not defined at top level.\n"
  in let head_8 = erlps__pp_loc__1 [pos_1]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons name_2 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [pos_1]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "contract"),
                                  _pos_0,
                                  (ErlangTuple [(ErlangAtom "con"), pos_1,
                                                name_2]),
                                  _def_3])]
  =
  let   
    arg_4 =
      toErl
        "Nested contracts are not allowed\nContract \'~s\' at ~s not defined at top level.\n"
  in let head_8 = erlps__pp_loc__1 [pos_1]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons name_2 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [pos_1]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "type_decl"), _,
                                  (ErlangTuple [(ErlangAtom "id"), pos_0,
                                                name_1]),
                                  _])]
  =
  let   
    arg_2 =
      toErl
        "Empty type declarations are not supported\nType ~s at ~s lacks a definition\n"
  in let head_6 = erlps__pp_loc__1 [pos_0]
  in let
    msg_9 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons name_1 (ErlangCons head_6 ErlangEmptyList)]
  in let arg_10 = erlps__pos__1 [pos_0]
  in erlps__mk_t_err__2 [arg_10, msg_9]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "letval"), _pos_0,
                                  (ErlangTuple [(ErlangAtom "id"), pos_1,
                                                name_2]),
                                  _def_3])]
  =
  let   
    arg_4 =
      toErl
        "Toplevel \"let\" definitions are not supported\nValue ~s at ~s could be replaced by 0-argument function\n"
  in let head_8 = erlps__pp_loc__1 [pos_1]
  in let
    msg_11 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons name_2 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_12 = erlps__pos__1 [pos_1]
  in erlps__mk_t_err__2 [arg_12, msg_11]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "stateful_not_allowed"),
                                  id_0, fun_1])]
  =
  let   
    arg_2 =
      toErl
        "Cannot reference stateful function ~s (at ~s)\nin the definition of non-stateful function ~s.\n"
  in let head_4 = erlps__pp__1 [id_0]
  in let head_7 = erlps__pp_loc__1 [id_0]
  in let head_10 = erlps__pp__1 [fun_1]
  in let
    msg_13 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList))]
  in let arg_14 = erlps__pos__1 [id_0]
  in erlps__mk_t_err__2 [arg_14, msg_13]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "value_arg_not_allowed"),
                                  value_0, fun_1])]
  =
  let   
    arg_2 =
      toErl
        "Cannot pass non-zero value argument ~s (at ~s)\nin the definition of non-stateful function ~s.\n"
  in let arg_5 = toErl ""
  in let head_4 = erlps__pp_expr__2 [arg_5, value_0]
  in let head_8 = erlps__pp_loc__1 [value_0]
  in let head_11 = erlps__pp__1 [fun_1]
  in let
    msg_14 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList))]
  in let arg_15 = erlps__pos__1 [value_0]
  in erlps__mk_t_err__2 [arg_15, msg_14]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "init_depends_on_state"),
                                  which_0, (ErlangCons _init_1 chain_2)])]
  =
  let   
    whichcalls_13 =
      ErlangFun 1
        (let
           lambda_3 [(ErlangCons (ErlangInt num_5) (ErlangCons (ErlangInt num_6) (ErlangCons (ErlangInt num_7) (ErlangEmptyList))))]
             | (ErlangInt num_5) == (toErl 112)
             , (ErlangInt num_6) == (toErl 117)
             , (ErlangInt num_7) == (toErl 116) =
             toErl ""
           lambda_3 [(ErlangCons (ErlangInt num_8) (ErlangCons (ErlangInt num_9) (ErlangCons (ErlangInt num_10) (ErlangCons (ErlangInt num_11) (ErlangCons (ErlangInt num_12) (ErlangEmptyList))))))]
             | (ErlangInt num_8) == (toErl 115)
             , (ErlangInt num_9) == (toErl 116)
             , (ErlangInt num_10) == (toErl 97)
             , (ErlangInt num_11) == (toErl 116)
             , (ErlangInt num_12) == (toErl 101) =
             toErl ""
           lambda_3 [_] = toErl ", which calls"
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in let
    arg_14 =
      toErl
        "The init function should return the initial state as its result and cannot ~s the state,\nbut it calls\n~s"
  in let
    head_16 =
      case ErlangAtom "true" of
        _ | weakEq which_0 (ErlangAtom "put") -> toErl "write"
        _ -> toErl "read"
  in let
    head_18 =
      flmap
        (\ lc_22 ->
           case lc_22 of
             (ErlangTuple [(ErlangCons _ (ErlangCons fun_20 (ErlangEmptyList))),
                           ann_21]) ->
               let    arg_24 = toErl "  - ~s (at ~s)~s\n"
               in let head_28 = erlps__pp_loc__1 [ann_21]
               in let
                 head_31 =
                   BIF.erlang__apply__2
                     [whichcalls_13, ErlangCons fun_20 ErlangEmptyList]
               in let
                 lcRet_23 =
                   BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                     [arg_24,
                      ErlangCons fun_20
                        (ErlangCons head_28
                           (ErlangCons head_31 ErlangEmptyList))]
               in ErlangCons lcRet_23 ErlangEmptyList
             _ -> ErlangEmptyList)
        chain_2
  in let
    msg_36 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_14, ErlangCons head_16 (ErlangCons head_18 ErlangEmptyList)]
  in let arg_39 = toErl 2
  in let arg_40 = BIF.erlang__hd__1 [chain_2]
  in let arg_38 = BIF.erlang__element__2 [arg_39, arg_40]
  in let arg_37 = erlps__pos__1 [arg_38]
  in erlps__mk_t_err__2 [arg_37, msg_36]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "missing_body_for_let"),
                                  ann_0])]
  =
  let   
    arg_1 =
      toErl "Let binding at ~s must be followed by an expression\n"
  in let head_3 = erlps__pp_loc__1 [ann_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "public_modifier_in_contract"),
                                  decl_0])]
  =
  let    decl1_2 = erlps__mk_entrypoint__1 [decl_0]
  in let
    arg_3 =
      toErl
        "Use \'entrypoint\' instead of \'function\' for public function ~s (at ~s):\n~s\n"
  in let arg_6 = toErl ""
  in let arg_8 = toErl 3
  in let arg_7 = BIF.erlang__element__2 [arg_8, decl_0]
  in let head_5 = erlps__pp_expr__2 [arg_6, arg_7]
  in let head_11 = erlps__pp_loc__1 [decl_0]
  in let arg_16 = toErl 2
  in let
    arg_17 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__decl__1" [decl1_2]
  in let
    arg_15 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_16, arg_17]
  in let
    head_14 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_15]
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_21 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "init_must_be_an_entrypoint"),
                                  decl_0])]
  =
  let    decl1_2 = erlps__mk_entrypoint__1 [decl_0]
  in let
    arg_3 =
      toErl "The init function (at ~s) must be an entrypoint:\n~s\n"
  in let head_5 = erlps__pp_loc__1 [decl_0]
  in let arg_10 = toErl 2
  in let
    arg_11 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__decl__1" [decl1_2]
  in let
    arg_9 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_10, arg_11]
  in let
    head_8 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_9]
  in let
    msg_14 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons head_5 (ErlangCons head_8 ErlangEmptyList)]
  in let arg_15 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_15, msg_14]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "init_must_not_be_payable"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "The init function (at ~s) cannot be payable.\nYou don\'t need the \'payable\' annotation to be able to attach\nfunds to the create contract transaction."
  in let head_3 = erlps__pp_loc__1 [decl_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "proto_must_be_entrypoint"),
                                  decl_0])]
  =
  let    decl1_2 = erlps__mk_entrypoint__1 [decl_0]
  in let
    arg_3 =
      toErl "Use \'entrypoint\' for declaration of ~s (at ~s):\n~s\n"
  in let arg_6 = toErl ""
  in let arg_8 = toErl 3
  in let arg_7 = BIF.erlang__element__2 [arg_8, decl_0]
  in let head_5 = erlps__pp_expr__2 [arg_6, arg_7]
  in let head_11 = erlps__pp_loc__1 [decl_0]
  in let arg_16 = toErl 2
  in let
    arg_17 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__decl__1" [decl1_2]
  in let
    arg_15 =
      BIF.do_remote_fun_call "Prettypr" "erlps__nest__2"
        [arg_16, arg_17]
  in let
    head_14 =
      BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_15]
  in let
    msg_20 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3,
         ErlangCons head_5
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_21 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_21, msg_20]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "proto_in_namespace"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl "Namespaces cannot contain function prototypes (at ~s).\n"
  in let head_3 = erlps__pp_loc__1 [decl_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "entrypoint_in_namespace"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "Namespaces cannot contain entrypoints (at ~s). Use \'function\' instead.\n"
  in let head_3 = erlps__pp_loc__1 [decl_0]
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "private_entrypoint"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "The entrypoint ~s (at ~s) cannot be private. Use \'function\' instead.\n"
  in let arg_4 = toErl ""
  in let arg_6 = toErl 3
  in let arg_5 = BIF.erlang__element__2 [arg_6, decl_0]
  in let head_3 = erlps__pp_expr__2 [arg_4, arg_5]
  in let head_9 = erlps__pp_loc__1 [decl_0]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "private_and_public"),
                                  decl_0])]
  =
  let   
    arg_1 =
      toErl
        "The function ~s (at ~s) cannot be both public and private.\n"
  in let arg_4 = toErl ""
  in let arg_6 = toErl 3
  in let arg_5 = BIF.erlang__element__2 [arg_6, decl_0]
  in let head_3 = erlps__pp_expr__2 [arg_4, arg_5]
  in let head_9 = erlps__pp_loc__1 [decl_0]
  in let
    msg_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList)]
  in let arg_13 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_13, msg_12]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "contract_has_no_entrypoints"),
                                  con_0])]
  =
  let   
    arg_1 =
      toErl
        "The contract ~s (at ~s) has no entrypoints. Since Sophia version 3.2, public\ncontract functions must be declared with the \'entrypoint\' keyword instead of\n\'function\'.\n"
  in let arg_4 = toErl ""
  in let head_3 = erlps__pp_expr__2 [arg_4, con_0]
  in let head_7 = erlps__pp_loc__1 [con_0]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList)]
  in let arg_11 = erlps__pos__1 [con_0]
  in erlps__mk_t_err__2 [arg_11, msg_10]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "definition_in_non_main_contract"),
                                  ann_0,
                                  (ErlangTuple [(ErlangAtom "id"), _, id_1])])]
  =
  let   
    msg_2 =
      toErl
        "Only the main contract can contain defined functions or entrypoints.\n"
  in let
    arg_3 =
      toErl
        "Fix: replace the definition of \'~s\' by a type signature.\n"
  in let
    cxt_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_3, ErlangCons id_1 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__3 [arg_8, msg_2, cxt_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unbound_type"),
                                  type_0])]
  =
  let    arg_1 = toErl "Unbound type ~s (at ~s).\n"
  in let arg_4 = toErl ""
  in let head_3 = erlps__pp_type__2 [arg_4, type_0]
  in let head_7 = erlps__pp_loc__1 [type_0]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 (ErlangCons head_7 ErlangEmptyList)]
  in let arg_11 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_11, msg_10]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "new_tuple_syntax"),
                                  ann_0, ts_1])]
  =
  let   
    arg_2 =
      toErl
        "Invalid type\n~s  (at ~s)\nThe syntax of tuple types changed in Sophia version 4.0. Did you mean\n~s\n"
  in let arg_5 = toErl "  "
  in let arg_6 = ErlangTuple [ErlangAtom "args_t", ann_0, ts_1]
  in let head_4 = erlps__pp_type__2 [arg_5, arg_6]
  in let head_11 = erlps__pp_loc__1 [ann_0]
  in let arg_15 = toErl "  "
  in let arg_16 = ErlangTuple [ErlangAtom "tuple_t", ann_0, ts_1]
  in let head_14 = erlps__pp_type__2 [arg_15, arg_16]
  in let
    msg_21 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2,
         ErlangCons head_4
           (ErlangCons head_11 (ErlangCons head_14 ErlangEmptyList))]
  in let arg_22 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_22, msg_21]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "map_in_map_key"),
                                  keytype_0])]
  =
  let    arg_1 = toErl "Invalid key type\n~s\n"
  in let arg_4 = toErl "  "
  in let head_3 = erlps__pp_type__2 [arg_4, keytype_0]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let cxt_8 = toErl "Map keys cannot contain other maps.\n"
  in let arg_9 = erlps__pos__1 [keytype_0]
  in erlps__mk_t_err__3 [arg_9, msg_7, cxt_8]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "cannot_call_init_function"),
                                  ann_0])]
  =
  let   
    msg_1 =
      toErl
        "The \'init\' function is called exclusively by the create contract transaction\nand cannot be called from the contract code.\n"
  in let arg_2 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_2, msg_1]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "contract_treated_as_namespace"),
                                  ann_0,
                                  qname_3@(ErlangCons con_1 (ErlangCons fun_2 (ErlangEmptyList)))])]
  =
  let   
    arg_4 = toErl "Invalid call to contract entrypoint \'~s\'.\n"
  in let arg_8 = toErl "."
  in let
    head_6 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [qname_3, arg_8]
  in let
    msg_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons head_6 ErlangEmptyList]
  in let
    arg_11 = toErl "It must be called as \'c.~s\' for some c : ~s.\n"
  in let
    cxt_17 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_11, ErlangCons fun_2 (ErlangCons con_1 ErlangEmptyList)]
  in let arg_18 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__3 [arg_18, msg_10, cxt_17]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "bad_top_level_decl"),
                                  decl_0])]
  =
  let    arg_2 = toErl 1
  in let case_1 = BIF.erlang__element__2 [arg_2, decl_0]
  in let
    what_4 =
      case case_1 of
        (ErlangAtom "letval") -> toErl "function or entrypoint"
        _ -> toErl "contract or namespace"
  in let arg_5 = toErl 3
  in let id_7 = BIF.erlang__element__2 [arg_5, decl_0]
  in let
    arg_8 =
      toErl "The definition of \'~s\' must appear inside a ~s.\n"
  in let arg_11 = toErl ""
  in let head_10 = erlps__pp_expr__2 [arg_11, id_7]
  in let
    msg_16 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_8, ErlangCons head_10 (ErlangCons what_4 ErlangEmptyList)]
  in let arg_17 = erlps__pos__1 [decl_0]
  in erlps__mk_t_err__2 [arg_17, msg_16]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unknown_byte_length"),
                                  type_0])]
  =
  let    arg_1 = toErl "Cannot resolve length of byte array.\n"
  in let
    msg_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangEmptyList]
  in let arg_4 = erlps__pos__1 [type_0]
  in erlps__mk_t_err__2 [arg_4, msg_3]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unsolved_bytes_constraint"),
                                  ann_0, (ErlangAtom "concat"), a_1, b_2, c_3])]
  =
  let   
    arg_4 =
      toErl
        "Failed to resolve byte array lengths in call to Bytes.concat with arguments of type\n~s  (at ~s)\n~s  (at ~s)\nand result type\n~s  (at ~s)\n"
  in let arg_7 = toErl "  - "
  in let head_6 = erlps__pp_type__2 [arg_7, a_1]
  in let head_10 = erlps__pp_loc__1 [a_1]
  in let arg_14 = toErl "  - "
  in let head_13 = erlps__pp_type__2 [arg_14, b_2]
  in let head_17 = erlps__pp_loc__1 [b_2]
  in let arg_21 = toErl "  - "
  in let head_20 = erlps__pp_type__2 [arg_21, c_3]
  in let head_24 = erlps__pp_loc__1 [c_3]
  in let
    msg_27 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4,
         ErlangCons head_6
           (ErlangCons head_10
              (ErlangCons head_13
                 (ErlangCons head_17
                    (ErlangCons head_20
                       (ErlangCons head_24 ErlangEmptyList)))))]
  in let arg_28 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_28, msg_27]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "unsolved_bytes_constraint"),
                                  ann_0, (ErlangAtom "split"), a_1, b_2, c_3])]
  =
  let   
    arg_4 =
      toErl
        "Failed to resolve byte array lengths in call to Bytes.split with argument of type\n~s  (at ~s)\nand result types\n~s  (at ~s)\n~s  (at ~s)\n"
  in let arg_7 = toErl "  - "
  in let head_6 = erlps__pp_type__2 [arg_7, c_3]
  in let head_10 = erlps__pp_loc__1 [c_3]
  in let arg_14 = toErl "  - "
  in let head_13 = erlps__pp_type__2 [arg_14, a_1]
  in let head_17 = erlps__pp_loc__1 [a_1]
  in let arg_21 = toErl "  - "
  in let head_20 = erlps__pp_type__2 [arg_21, b_2]
  in let head_24 = erlps__pp_loc__1 [b_2]
  in let
    msg_27 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4,
         ErlangCons head_6
           (ErlangCons head_10
              (ErlangCons head_13
                 (ErlangCons head_17
                    (ErlangCons head_20
                       (ErlangCons head_24 ErlangEmptyList)))))]
  in let arg_28 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_28, msg_27]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "failed_to_get_compiler_version"),
                                  err_0])]
  =
  let   
    arg_1 = toErl "Failed to get compiler version. Error:\n  ~p\n"
  in let
    msg_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons err_0 ErlangEmptyList]
  in let arg_7 = toErl 0
  in let arg_8 = toErl 0
  in let arg_6 = erlps__pos__2 [arg_7, arg_8]
  in erlps__mk_t_err__2 [arg_6, msg_5]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "compiler_version_mismatch"),
                                  ann_0, version_1, op_2, bound_3])]
  =
  let   
    printv_14 =
      ErlangFun 1
        (let
           lambda_4 [v_6] =
             let   
               arg_7 =
                 flmap
                   (\ lc_10 ->
                      let lcRet_11 = BIF.erlang__integer_to_list__1 [lc_10]
                      in ErlangCons lcRet_11 ErlangEmptyList)
                   v_6
             in let arg_13 = toErl "."
             in
               BIF.do_remote_fun_call "String" "erlps__join__2" [arg_7, arg_13]
           lambda_4 [arg_5] = EXC.function_clause unit
           lambda_4 args = EXC.badarity (ErlangFun 1 lambda_4) args
         in lambda_4)
  in let
    arg_15 =
      toErl
        "Cannot compile with this version of the compiler,\nbecause it does not satisfy the constraint ~s ~s ~s\n"
  in let
    head_17 =
      BIF.erlang__apply__2
        [printv_14, ErlangCons version_1 ErlangEmptyList]
  in let
    head_23 =
      BIF.erlang__apply__2
        [printv_14, ErlangCons bound_3 ErlangEmptyList]
  in let
    msg_27 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_15,
         ErlangCons head_17
           (ErlangCons op_2 (ErlangCons head_23 ErlangEmptyList))]
  in let arg_28 = erlps__pos__1 [ann_0]
  in erlps__mk_t_err__2 [arg_28, msg_27]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "empty_record_or_map_update"),
                                  expr_0])]
  =
  let    arg_1 = toErl "Empty record/map update\n~s"
  in let arg_4 = toErl "  "
  in let head_3 = erlps__pp_expr__2 [arg_4, expr_0]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [expr_0]
  in erlps__mk_t_err__2 [arg_8, msg_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "mixed_record_and_map"),
                                  expr_0])]
  =
  let    arg_1 = toErl "Mixed record fields and map keys in\n~s"
  in let arg_4 = toErl "  "
  in let head_3 = erlps__pp_expr__2 [arg_4, expr_0]
  in let
    msg_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons head_3 ErlangEmptyList]
  in let arg_8 = erlps__pos__1 [expr_0]
  in erlps__mk_t_err__2 [arg_8, msg_7]
erlps__mk_error__1 [(ErlangTuple [(ErlangAtom "conflicting_updates_for_field"),
                                  upd_0, key_1])]
  =
  let    arg_2 = toErl "Conflicting updates for field \'~s\'\n"
  in let
    msg_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_2, ErlangCons key_1 ErlangEmptyList]
  in let arg_7 = erlps__pos__1 [upd_0]
  in erlps__mk_t_err__2 [arg_7, msg_6]
erlps__mk_error__1 [err_0] =
  let    arg_1 = toErl "Unknown error: ~p\n"
  in let
    msg_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_1, ErlangCons err_0 ErlangEmptyList]
  in let arg_7 = toErl 0
  in let arg_8 = toErl 0
  in let arg_6 = erlps__pos__2 [arg_7, arg_8]
  in erlps__mk_t_err__2 [arg_6, msg_5]
erlps__mk_error__1 [arg_10] = EXC.function_clause unit
erlps__mk_error__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_error__1) args

erlps__mk_entrypoint__1 :: ErlangFun
erlps__mk_entrypoint__1 [decl_0] =
  let    arg_5 = toErl 1
  in let arg_8 = toErl 1
  in let
    arg_9 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__1" [decl_0]
  in let
    arg_6 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [ErlangAtom "private", arg_8, arg_9]
  in let
    lop_3 =
      BIF.do_remote_fun_call "Lists" "erlps__keydelete__3"
        [ErlangAtom "public", arg_5, arg_6]
  in let
    tail_2 =
      BIF.erlang__op_unAppend
        [lop_3,
         ErlangCons (ErlangAtom "public")
           (ErlangCons (ErlangAtom "private") ErlangEmptyList)]
  in
    BIF.do_remote_fun_call "Aeso.Syntax" "erlps__set_ann__2"
      [ErlangCons (ErlangAtom "entrypoint") tail_2, decl_0]
erlps__mk_entrypoint__1 [arg_19] = EXC.function_clause unit
erlps__mk_entrypoint__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_entrypoint__1) args

erlps__pp_when__1 :: ErlangFun
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "todo"), what_0])] =
  let    arg_2 = toErl 0
  in let arg_3 = toErl 0
  in let tup_el_1 = erlps__pos__2 [arg_2, arg_3]
  in let arg_5 = toErl "[TODO] ~p\n"
  in let
    tup_el_4 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_5, ErlangCons what_0 ErlangEmptyList]
  in ErlangTuple [tup_el_1, tup_el_4]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "at"), ann_0])] =
  let    tup_el_1 = erlps__pos__1 [ann_0]
  in let arg_4 = toErl "at ~s\n"
  in let head_6 = erlps__pp_loc__1 [ann_0]
  in let
    tup_el_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons head_6 ErlangEmptyList]
  in ErlangTuple [tup_el_1, tup_el_3]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "check_typesig"),
                                 name_0, inferred_1, given_2])]
  =
  let    tup_el_3 = erlps__pos__1 [given_2]
  in let
    arg_6 =
      toErl
        "when checking the definition of ~s (at ~s)\n  inferred type: ~s\n  given type:    ~s\n"
  in let head_10 = erlps__pp_loc__1 [given_2]
  in let arg_14 = erlps__instantiate__1 [inferred_1]
  in let head_13 = erlps__pp__1 [arg_14]
  in let arg_18 = erlps__instantiate__1 [given_2]
  in let head_17 = erlps__pp__1 [arg_18]
  in let
    tup_el_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_6,
         ErlangCons name_0
           (ErlangCons head_10
              (ErlangCons head_13 (ErlangCons head_17 ErlangEmptyList)))]
  in ErlangTuple [tup_el_3, tup_el_5]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "infer_app"), fun_0,
                                 args_1, inferred0_2, argtypes0_3])]
  =
  let    inferred_5 = erlps__instantiate__1 [inferred0_2]
  in let argtypes_7 = erlps__instantiate__1 [argtypes0_3]
  in let tup_el_8 = erlps__pos__1 [fun_0]
  in let
    arg_11 =
      toErl
        "when checking the application at ~s of\n~s\nto arguments\n~s"
  in let head_13 = erlps__pp_loc__1 [fun_0]
  in let arg_17 = toErl "  "
  in let head_16 = erlps__pp_typed__3 [arg_17, fun_0, inferred_5]
  in let
    lcSrc_22 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [args_1, argtypes_7]
  in let
    head_21 =
      flmap
        (\ lc_27 ->
           case lc_27 of
             (ErlangTuple [arg_25, argt_26]) ->
               let    arg_30 = toErl "  "
               in let head_29 = erlps__pp_typed__3 [arg_30, arg_25, argt_26]
               in let head_34 = toErl "\n"
               in
                 ErlangCons
                   (ErlangCons head_29 (ErlangCons head_34 ErlangEmptyList))
                   ErlangEmptyList
             _ -> ErlangEmptyList)
        lcSrc_22
  in let
    tup_el_10 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_11,
         ErlangCons head_13
           (ErlangCons head_16 (ErlangCons head_21 ErlangEmptyList))]
  in ErlangTuple [tup_el_8, tup_el_10]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "field_constraint"),
                                 fieldtype0_0, inferredtype0_1, fld_2])]
  =
  let    fieldtype_4 = erlps__instantiate__1 [fieldtype0_0]
  in let inferredtype_6 = erlps__instantiate__1 [inferredtype0_1]
  in let tup_el_7 = erlps__pos__1 [fld_2]
  in let
    tup_el_9 =
      case fld_2 of
        (ErlangTuple [(ErlangAtom "field"), _ann_11, lv_12, id_13,
                      e_14]) ->
          let   
            arg_15 =
              toErl
                "when checking the assignment of the field\n~s (at ~s)\nto the old value ~s and the new value\n~s\n"
          in let arg_18 = toErl "  "
          in let
            arg_19 =
              ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_12]
          in let head_17 = erlps__pp_typed__3 [arg_18, arg_19, fieldtype_4]
          in let head_25 = erlps__pp_loc__1 [fld_2]
          in let head_28 = erlps__pp__1 [id_13]
          in let arg_32 = toErl "  "
          in let
            head_31 = erlps__pp_typed__3 [arg_32, e_14, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_15,
               ErlangCons head_17
                 (ErlangCons head_25
                    (ErlangCons head_28 (ErlangCons head_31 ErlangEmptyList)))]
        (ErlangTuple [(ErlangAtom "field"), _ann_36, lv_37, e_38]) ->
          let   
            arg_39 =
              toErl
                "when checking the assignment of the field\n~s (at ~s)\nto the value\n~s\n"
          in let arg_42 = toErl "  "
          in let
            arg_43 =
              ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_37]
          in let head_41 = erlps__pp_typed__3 [arg_42, arg_43, fieldtype_4]
          in let head_49 = erlps__pp_loc__1 [fld_2]
          in let arg_53 = toErl "  "
          in let
            head_52 = erlps__pp_typed__3 [arg_53, e_38, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_39,
               ErlangCons head_41
                 (ErlangCons head_49 (ErlangCons head_52 ErlangEmptyList))]
        (ErlangTuple [(ErlangAtom "proj"), _ann_57, _rec_58, _fld_59]) ->
          let   
            arg_60 =
              toErl
                "when checking the record projection at ~s\n~s\nagainst the expected type\n~s\n"
          in let head_62 = erlps__pp_loc__1 [fld_2]
          in let arg_66 = toErl "  "
          in let head_65 = erlps__pp_typed__3 [arg_66, fld_2, fieldtype_4]
          in let arg_71 = toErl "  "
          in let head_70 = erlps__pp_type__2 [arg_71, inferredtype_6]
          in
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_60,
               ErlangCons head_62
                 (ErlangCons head_65 (ErlangCons head_70 ErlangEmptyList))]
        something_else -> EXC.case_clause something_else
  in ErlangTuple [tup_el_7, tup_el_9]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "record_constraint"),
                                 rectype0_0, inferredtype0_1, fld_2])]
  =
  let    rectype_4 = erlps__instantiate__1 [rectype0_0]
  in let inferredtype_6 = erlps__instantiate__1 [inferredtype0_1]
  in let matchExpr_10 = erlps__pp_why_record__1 [fld_2]
  in
    case matchExpr_10 of
      (ErlangTuple [pos_8, whyrec_9]) ->
        case fld_2 of
          (ErlangTuple [(ErlangAtom "field"), _ann_12, _lv_13, _id_14,
                        _e_15]) ->
            let   
              arg_18 =
                toErl
                  "when checking that the record type\n~s\n~s\nmatches the expected type\n~s\n"
            in let arg_21 = toErl "  "
            in let head_20 = erlps__pp_type__2 [arg_21, rectype_4]
            in let arg_27 = toErl "  "
            in let head_26 = erlps__pp_type__2 [arg_27, inferredtype_6]
            in let
              tup_el_17 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_18,
                   ErlangCons head_20
                     (ErlangCons whyrec_9 (ErlangCons head_26 ErlangEmptyList))]
            in ErlangTuple [pos_8, tup_el_17]
          (ErlangTuple [(ErlangAtom "field"), _ann_30, _lv_31, _e_32]) ->
            let   
              arg_35 =
                toErl
                  "when checking that the record type\n~s\n~s\nmatches the expected type\n~s\n"
            in let arg_38 = toErl "  "
            in let head_37 = erlps__pp_type__2 [arg_38, rectype_4]
            in let arg_44 = toErl "  "
            in let head_43 = erlps__pp_type__2 [arg_44, inferredtype_6]
            in let
              tup_el_34 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_35,
                   ErlangCons head_37
                     (ErlangCons whyrec_9 (ErlangCons head_43 ErlangEmptyList))]
            in ErlangTuple [pos_8, tup_el_34]
          (ErlangTuple [(ErlangAtom "proj"), _ann_47, rec_48,
                        _fldname_49]) ->
            let    tup_el_50 = erlps__pos__1 [rec_48]
            in let
              arg_53 =
                toErl
                  "when checking that the expression\n~s (at ~s)\nhas type\n~s\n~s\n"
            in let arg_56 = toErl "  "
            in let
              head_55 = erlps__pp_typed__3 [arg_56, rec_48, inferredtype_6]
            in let head_60 = erlps__pp_loc__1 [rec_48]
            in let arg_64 = toErl "  "
            in let head_63 = erlps__pp_type__2 [arg_64, rectype_4]
            in let
              tup_el_52 =
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_53,
                   ErlangCons head_55
                     (ErlangCons head_60
                        (ErlangCons head_63
                           (ErlangCons whyrec_9 ErlangEmptyList)))]
            in ErlangTuple [tup_el_50, tup_el_52]
          something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_10
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "if_branches"),
                                 then_0, thentype0_1, else_2, elsetype0_3])]
  =
  let    arg_4 = ErlangTuple [thentype0_1, elsetype0_3]
  in let matchExpr_9 = erlps__instantiate__1 [arg_4]
  in
    case matchExpr_9 of
      (ErlangTuple [thentype_7, elsetype_8]) ->
        let    head_10 = ErlangTuple [then_0, thentype_7]
        in let lcSrc_14 = erlps__if_branches__1 [else_2]
        in let
          tail_13 =
            flmap
              (\ lc_17 ->
                 let lcRet_18 = ErlangTuple [lc_17, elsetype_8]
                 in ErlangCons lcRet_18 ErlangEmptyList)
              lcSrc_14
        in let arg_24 = toErl 1
        in let arg_25 = BIF.erlang__hd__1 [ErlangCons head_10 tail_13]
        in let arg_23 = BIF.erlang__element__2 [arg_24, arg_25]
        in let tup_el_22 = erlps__pos__1 [arg_23]
        in let
          arg_28 = toErl "when comparing the types of the if-branches\n~s"
        in let
          head_30 =
            flmap
              (\ lc_34 ->
                 case lc_34 of
                   (ErlangTuple [b_32, btype_33]) ->
                     let    arg_36 = toErl "~s (at ~s)\n"
                     in let arg_39 = toErl "  - "
                     in let
                       head_38 = erlps__pp_typed__3 [arg_39, b_32, btype_33]
                     in let head_43 = erlps__pp_loc__1 [b_32]
                     in let
                       lcRet_35 =
                         BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                           [arg_36,
                            ErlangCons head_38
                              (ErlangCons head_43 ErlangEmptyList)]
                     in ErlangCons lcRet_35 ErlangEmptyList
                   _ -> ErlangEmptyList)
              (ErlangCons head_10 tail_13)
        in let
          tup_el_27 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_28, ErlangCons head_30 ErlangEmptyList]
        in ErlangTuple [tup_el_22, tup_el_27]
      _ -> EXC.badmatch matchExpr_9
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "case_pat"), pat_0,
                                 pattype0_1, exprtype0_2])]
  =
  let    arg_3 = ErlangTuple [pattype0_1, exprtype0_2]
  in let matchExpr_8 = erlps__instantiate__1 [arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [pattype_6, exprtype_7]) ->
        let    tup_el_9 = erlps__pos__1 [pat_0]
        in let
          arg_12 =
            toErl
              "when checking the type of the pattern at ~s\n~s\nagainst the expected type\n~s\n"
        in let head_14 = erlps__pp_loc__1 [pat_0]
        in let arg_18 = toErl "  "
        in let head_17 = erlps__pp_typed__3 [arg_18, pat_0, pattype_6]
        in let arg_23 = toErl "  "
        in let head_22 = erlps__pp_type__2 [arg_23, exprtype_7]
        in let
          tup_el_11 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_12,
               ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
        in ErlangTuple [tup_el_9, tup_el_11]
      _ -> EXC.badmatch matchExpr_8
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "check_expr"),
                                 expr_0, inferred0_1, expected0_2])]
  =
  let    arg_3 = ErlangTuple [inferred0_1, expected0_2]
  in let matchExpr_8 = erlps__instantiate__1 [arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [inferred_6, expected_7]) ->
        let    tup_el_9 = erlps__pos__1 [expr_0]
        in let
          arg_12 =
            toErl
              "when checking the type of the expression at ~s\n~s\nagainst the expected type\n~s\n"
        in let head_14 = erlps__pp_loc__1 [expr_0]
        in let arg_18 = toErl "  "
        in let head_17 = erlps__pp_typed__3 [arg_18, expr_0, inferred_6]
        in let arg_23 = toErl "  "
        in let head_22 = erlps__pp_type__2 [arg_23, expected_7]
        in let
          tup_el_11 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_12,
               ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
        in ErlangTuple [tup_el_9, tup_el_11]
      _ -> EXC.badmatch matchExpr_8
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "checking_init_type"),
                                 ann_0])]
  =
  let    tup_el_1 = erlps__pos__1 [ann_0]
  in let
    arg_4 =
      toErl
        "when checking that \'init\' returns a value of type \'state\' at ~s\n"
  in let head_6 = erlps__pp_loc__1 [ann_0]
  in let
    tup_el_3 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_4, ErlangCons head_6 ErlangEmptyList]
  in ErlangTuple [tup_el_1, tup_el_3]
erlps__pp_when__1 [(ErlangTuple [(ErlangAtom "list_comp"),
                                 bindexpr_0, inferred0_1, expected0_2])]
  =
  let    arg_3 = ErlangTuple [inferred0_1, expected0_2]
  in let matchExpr_8 = erlps__instantiate__1 [arg_3]
  in
    case matchExpr_8 of
      (ErlangTuple [inferred_6, expected_7]) ->
        let    tup_el_9 = erlps__pos__1 [bindexpr_0]
        in let
          arg_12 =
            toErl
              "when checking rvalue of list comprehension binding at ~s\n~s\nagainst type \n~s\n"
        in let head_14 = erlps__pp_loc__1 [bindexpr_0]
        in let arg_18 = toErl "  "
        in let
          head_17 = erlps__pp_typed__3 [arg_18, bindexpr_0, inferred_6]
        in let arg_23 = toErl "  "
        in let head_22 = erlps__pp_type__2 [arg_23, expected_7]
        in let
          tup_el_11 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_12,
               ErlangCons head_14
                 (ErlangCons head_17 (ErlangCons head_22 ErlangEmptyList))]
        in ErlangTuple [tup_el_9, tup_el_11]
      _ -> EXC.badmatch matchExpr_8
erlps__pp_when__1 [(ErlangAtom "unknown")] =
  let    arg_1 = toErl 0
  in let arg_2 = toErl 0
  in let tup_el_0 = erlps__pos__2 [arg_1, arg_2]
  in let tup_el_3 = toErl ""
  in ErlangTuple [tup_el_0, tup_el_3]
erlps__pp_when__1 [arg_4] = EXC.function_clause unit
erlps__pp_when__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_when__1) args

erlps__pp_why_record__1 :: ErlangFun
erlps__pp_why_record__1 [fld_4@(ErlangTuple [(ErlangAtom "field"),
                                             _ann_0, lv_1, _id_2, _e_3])]
  =
  let    tup_el_5 = erlps__pos__1 [fld_4]
  in let
    arg_8 =
      toErl "arising from an assignment of the field ~s (at ~s)"
  in let arg_11 = toErl ""
  in let
    arg_12 = ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_1]
  in let head_10 = erlps__pp_expr__2 [arg_11, arg_12]
  in let head_17 = erlps__pp_loc__1 [fld_4]
  in let
    tup_el_7 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_8, ErlangCons head_10 (ErlangCons head_17 ErlangEmptyList)]
  in ErlangTuple [tup_el_5, tup_el_7]
erlps__pp_why_record__1 [fld_3@(ErlangTuple [(ErlangAtom "field"),
                                             _ann_0, lv_1, _e_2])]
  =
  let    tup_el_4 = erlps__pos__1 [fld_3]
  in let
    arg_7 =
      toErl "arising from an assignment of the field ~s (at ~s)"
  in let arg_10 = toErl ""
  in let
    arg_11 = ErlangTuple [ErlangAtom "lvalue", ErlangEmptyList, lv_1]
  in let head_9 = erlps__pp_expr__2 [arg_10, arg_11]
  in let head_16 = erlps__pp_loc__1 [fld_3]
  in let
    tup_el_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_7, ErlangCons head_9 (ErlangCons head_16 ErlangEmptyList)]
  in ErlangTuple [tup_el_4, tup_el_6]
erlps__pp_why_record__1 [(ErlangTuple [(ErlangAtom "proj"),
                                       _ann_0, rec_1, fldname_2])]
  =
  let    tup_el_3 = erlps__pos__1 [rec_1]
  in let
    arg_6 =
      toErl "arising from the projection of the field ~s (at ~s)"
  in let head_8 = erlps__pp__1 [fldname_2]
  in let head_11 = erlps__pp_loc__1 [rec_1]
  in let
    tup_el_5 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_6, ErlangCons head_8 (ErlangCons head_11 ErlangEmptyList)]
  in ErlangTuple [tup_el_3, tup_el_5]
erlps__pp_why_record__1 [arg_14] = EXC.function_clause unit
erlps__pp_why_record__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_why_record__1) args

erlps__if_branches__1 :: ErlangFun
erlps__if_branches__1 [if_3@(ErlangTuple [(ErlangAtom "if"),
                                          ann_0, _, then_1, else_2])]
  =
  let
    case_4 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__2"
        [ErlangAtom "format", ann_0]
  in
    case case_4 of
      (ErlangAtom "elif") ->
        let tail_8 = erlps__if_branches__1 [else_2]
        in ErlangCons then_1 tail_8
      _ -> ErlangCons if_3 ErlangEmptyList
erlps__if_branches__1 [e_0] = ErlangCons e_0 ErlangEmptyList
erlps__if_branches__1 [arg_3] = EXC.function_clause unit
erlps__if_branches__1 args =
  EXC.badarity (ErlangFun 1 erlps__if_branches__1) args

erlps__pp_typed__3 :: ErlangFun
erlps__pp_typed__3 [label_0, e_1,
                    t_2@(ErlangTuple [(ErlangAtom "type_sig"), _, _, _, _, _])]
  =
  let arg_5 = erlps__typesig_to_fun_t__1 [t_2]
  in erlps__pp_typed__3 [label_0, e_1, arg_5]
erlps__pp_typed__3 [label_0,
                    (ErlangTuple [(ErlangAtom "typed"), _, expr_1, _]), type_2]
  =
  erlps__pp_typed__3 [label_0, expr_1, type_2]
erlps__pp_typed__3 [label_0, expr_1, type_2] =
  let
    arg_4 =
      ErlangTuple [ErlangAtom "typed", ErlangEmptyList, expr_1, type_2]
  in erlps__pp_expr__2 [label_0, arg_4]
erlps__pp_typed__3 [arg_9, arg_10, arg_11] =
  EXC.function_clause unit
erlps__pp_typed__3 args =
  EXC.badarity (ErlangFun 3 erlps__pp_typed__3) args

erlps__pp_expr__2 :: ErlangFun
erlps__pp_expr__2 [label_0, expr_1] =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [label_0]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__expr__2"
        [expr_1,
         ErlangCons (ErlangAtom "show_generated") ErlangEmptyList]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Prettypr" "erlps__beside__2"
        [arg_3, arg_5]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_2]
erlps__pp_expr__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__pp_expr__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_expr__2) args

erlps__pp_type__2 :: ErlangFun
erlps__pp_type__2 [label_0, type_1] =
  let   
    arg_3 =
      BIF.do_remote_fun_call "Prettypr" "erlps__text__1" [label_0]
  in let
    arg_5 =
      BIF.do_remote_fun_call "Aeso.Pretty" "erlps__type__2"
        [type_1,
         ErlangCons (ErlangAtom "show_generated") ErlangEmptyList]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Prettypr" "erlps__beside__2"
        [arg_3, arg_5]
  in BIF.do_remote_fun_call "Prettypr" "erlps__format__1" [arg_2]
erlps__pp_type__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__pp_type__2 args =
  EXC.badarity (ErlangFun 2 erlps__pp_type__2) args

erlps__src_file__1 :: ErlangFun
erlps__src_file__1 [t_0] =
  BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
    [ErlangAtom "file", t_0, ErlangAtom "no_file"]
erlps__src_file__1 [arg_4] = EXC.function_clause unit
erlps__src_file__1 args =
  EXC.badarity (ErlangFun 1 erlps__src_file__1) args

erlps__line_number__1 :: ErlangFun
erlps__line_number__1 [t_0] =
  let arg_3 = toErl 0
  in
    BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
      [ErlangAtom "line", t_0, arg_3]
erlps__line_number__1 [arg_4] = EXC.function_clause unit
erlps__line_number__1 args =
  EXC.badarity (ErlangFun 1 erlps__line_number__1) args

erlps__column_number__1 :: ErlangFun
erlps__column_number__1 [t_0] =
  let arg_3 = toErl 0
  in
    BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
      [ErlangAtom "col", t_0, arg_3]
erlps__column_number__1 [arg_4] = EXC.function_clause unit
erlps__column_number__1 args =
  EXC.badarity (ErlangFun 1 erlps__column_number__1) args

erlps__pos__1 :: ErlangFun
erlps__pos__1 [t_0] =
  let    arg_1 = erlps__src_file__1 [t_0]
  in let arg_3 = erlps__line_number__1 [t_0]
  in let arg_5 = erlps__column_number__1 [t_0]
  in
    BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__3"
      [arg_1, arg_3, arg_5]
erlps__pos__1 [arg_7] = EXC.function_clause unit
erlps__pos__1 args =
  EXC.badarity (ErlangFun 1 erlps__pos__1) args

erlps__pos__2 :: ErlangFun
erlps__pos__2 [l_0, c_1] =
  BIF.do_remote_fun_call "Aeso.Errors" "erlps__pos__2" [l_0, c_1]
erlps__pos__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__pos__2 args =
  EXC.badarity (ErlangFun 2 erlps__pos__2) args

erlps__loc__1 :: ErlangFun
erlps__loc__1 [t_0] =
  let    tup_el_1 = erlps__line_number__1 [t_0]
  in let tup_el_3 = erlps__column_number__1 [t_0]
  in ErlangTuple [tup_el_1, tup_el_3]
erlps__loc__1 [arg_5] = EXC.function_clause unit
erlps__loc__1 args =
  EXC.badarity (ErlangFun 1 erlps__loc__1) args

erlps__pp_loc__1 :: ErlangFun
erlps__pp_loc__1 [t_0] =
  let matchExpr_4 = erlps__loc__1 [t_0]
  in
    case matchExpr_4 of
      (ErlangTuple [line_2, col_3]) ->
        let case_5 = ErlangTuple [line_2, col_3]
        in
          case case_5 of
            (ErlangTuple [(ErlangInt num_8), (ErlangInt num_9)]) | (ErlangInt
                                                                      num_8) ==
                                                                     (toErl 0)
                                                                 , (ErlangInt
                                                                      num_9) ==
                                                                     (toErl
                                                                        0) ->
              toErl "(builtin location)"
            _ ->
              let arg_10 = toErl "line ~p, column ~p"
              in
                BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
                  [arg_10, ErlangCons line_2 (ErlangCons col_3 ErlangEmptyList)]
      _ -> EXC.badmatch matchExpr_4
erlps__pp_loc__1 [arg_16] = EXC.function_clause unit
erlps__pp_loc__1 args =
  EXC.badarity (ErlangFun 1 erlps__pp_loc__1) args

erlps__plural__3 :: ErlangFun
erlps__plural__3 [no_0, _yes_1, (ErlangCons _ (ErlangEmptyList))]
  =
  no_0
erlps__plural__3 [_no_0, yes_1, _] = yes_1
erlps__plural__3 [arg_2, arg_3, arg_4] = EXC.function_clause unit
erlps__plural__3 args =
  EXC.badarity (ErlangFun 3 erlps__plural__3) args

erlps__pp__1 :: ErlangFun
erlps__pp__1 [t_0@(ErlangTuple [(ErlangAtom "type_sig"), _, _, _,
                                _, _])]
  =
  let arg_1 = erlps__typesig_to_fun_t__1 [t_0]
  in erlps__pp__1 [arg_1]
erlps__pp__1 [(ErlangEmptyList)] = toErl ""
erlps__pp__1 [(ErlangCons t_0 (ErlangEmptyList))] =
  erlps__pp__1 [t_0]
erlps__pp__1 [(ErlangCons t_0 ts_1)] =
  let    head_2 = erlps__pp__1 [t_0]
  in let head_5 = toErl ", "
  in let tail_6 = erlps__pp__1 [ts_1]
  in ErlangCons head_2 (ErlangCons head_5 tail_6)
erlps__pp__1 [(ErlangTuple [(ErlangAtom "id"), _, name_0])] =
  name_0
erlps__pp__1 [(ErlangTuple [(ErlangAtom "qid"), _, name_0])] =
  let arg_2 = toErl "."
  in
    BIF.do_remote_fun_call "String" "erlps__join__2" [name_0, arg_2]
erlps__pp__1 [(ErlangTuple [(ErlangAtom "con"), _, name_0])] =
  name_0
erlps__pp__1 [(ErlangTuple [(ErlangAtom "qcon"), _, name_0])] =
  let arg_2 = toErl "."
  in
    BIF.do_remote_fun_call "String" "erlps__join__2" [name_0, arg_2]
erlps__pp__1 [(ErlangTuple [(ErlangAtom "uvar"), _, ref_0])] =
  let    head_1 = toErl "?u"
  in let arg_5 = toErl 16384
  in let arg_3 = BIF.erlang__phash2__2 [ref_0, arg_5]
  in let tail_2 = BIF.erlang__integer_to_list__1 [arg_3]
  in ErlangCons head_1 tail_2
erlps__pp__1 [(ErlangTuple [(ErlangAtom "tvar"), _, name_0])] =
  name_0
erlps__pp__1 [(ErlangTuple [(ErlangAtom "tuple_t"), _,
                            (ErlangEmptyList)])]
  =
  toErl "unit"
erlps__pp__1 [(ErlangTuple [(ErlangAtom "tuple_t"), _, cpts_0])]
  =
  let    head_1 = toErl "("
  in let arg_5 = ErlangFun 1 erlps__pp__1
  in let
    arg_4 =
      BIF.do_remote_fun_call "Lists" "erlps__map__2" [arg_5, cpts_0]
  in let arg_7 = toErl " * "
  in let
    head_3 =
      BIF.do_remote_fun_call "String" "erlps__join__2" [arg_4, arg_7]
  in let head_9 = toErl ")"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_9 ErlangEmptyList))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _,
                            (ErlangAtom "any")])]
  =
  toErl "bytes(_)"
erlps__pp__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _, len_0])] =
  let    head_1 = toErl "bytes("
  in let head_3 = BIF.erlang__integer_to_list__1 [len_0]
  in let head_6 = toErl ")"
  in
    ErlangCons head_1
      (ErlangCons head_3 (ErlangCons head_6 ErlangEmptyList))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "app_t"), _, t_0,
                            (ErlangEmptyList)])]
  =
  erlps__pp__1 [t_0]
erlps__pp__1 [(ErlangTuple [(ErlangAtom "app_t"), _, type_0,
                            args_1])]
  =
  let    head_2 = erlps__pp__1 [type_0]
  in let head_5 = toErl "("
  in let head_7 = erlps__pp__1 [args_1]
  in let head_10 = toErl ")"
  in
    ErlangCons head_2
      (ErlangCons head_5
         (ErlangCons head_7 (ErlangCons head_10 ErlangEmptyList)))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "named_arg_t"), _,
                            name_0, type_1, default_2])]
  =
  let    head_3 = erlps__pp__1 [name_0]
  in let head_6 = toErl " : "
  in let head_8 = erlps__pp__1 [type_1]
  in let head_11 = toErl " = "
  in let head_13 = erlps__pp__1 [default_2]
  in
    ErlangCons head_3
      (ErlangCons head_6
         (ErlangCons head_8
            (ErlangCons head_11 (ErlangCons head_13 ErlangEmptyList))))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "fun_t"), _,
                            named_0@(ErlangTuple [(ErlangAtom "uvar"), _, _]),
                            as_1, b_2])]
  =
  let    head_3 = toErl "("
  in let head_5 = erlps__pp__1 [named_0]
  in let head_8 = toErl " | "
  in let head_10 = erlps__pp__1 [as_1]
  in let head_13 = toErl ") => "
  in let head_15 = erlps__pp__1 [b_2]
  in
    ErlangCons head_3
      (ErlangCons head_5
         (ErlangCons head_8
            (ErlangCons head_10
               (ErlangCons head_13 (ErlangCons head_15 ErlangEmptyList)))))
erlps__pp__1 [(ErlangTuple [(ErlangAtom "fun_t"), _, named_0,
                            as_1, b_2])]
  | isEList named_0 =
  let    head_3 = toErl "("
  in let arg_6 = BIF.erlang__op_append [named_0, as_1]
  in let head_5 = erlps__pp__1 [arg_6]
  in let head_10 = toErl ") => "
  in let head_12 = erlps__pp__1 [b_2]
  in
    ErlangCons head_3
      (ErlangCons head_5
         (ErlangCons head_10 (ErlangCons head_12 ErlangEmptyList)))
erlps__pp__1 [other_0] =
  let arg_1 = toErl "~p"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_1, ErlangCons other_0 ErlangEmptyList]
erlps__pp__1 [arg_5] = EXC.function_clause unit
erlps__pp__1 args = EXC.badarity (ErlangFun 1 erlps__pp__1) args

erlps__desugar__1 :: ErlangFun
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "record"), ann_0,
                                 rec_1, updates_2])]
  =
  let tup_el_6 = erlps__desugar_updates__1 [updates_2]
  in ErlangTuple [ErlangAtom "record", ann_0, rec_1, tup_el_6]
erlps__desugar__1 [(ErlangTuple [(ErlangAtom "map"), ann_0,
                                 map_1, updates_2])]
  =
  let tup_el_6 = erlps__desugar_updates__1 [updates_2]
  in ErlangTuple [ErlangAtom "map", ann_0, map_1, tup_el_6]
erlps__desugar__1 [(ErlangCons h_0 t_1)] =
  let    head_2 = erlps__desugar__1 [h_0]
  in let tail_4 = erlps__desugar__1 [t_1]
  in ErlangCons head_2 tail_4
erlps__desugar__1 [t_0] | isETuple t_0 =
  let    arg_2 = BIF.erlang__tuple_to_list__1 [t_0]
  in let arg_1 = erlps__desugar__1 [arg_2]
  in BIF.erlang__list_to_tuple__1 [arg_1]
erlps__desugar__1 [x_0] = x_0
erlps__desugar__1 [arg_1] = EXC.function_clause unit
erlps__desugar__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar__1) args

erlps__desugar_updates__1 :: ErlangFun
erlps__desugar_updates__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__desugar_updates__1 [(ErlangCons upd_0 updates_1)] =
  let matchExpr_6 = erlps__update_key__1 [upd_0]
  in
    case matchExpr_6 of
      (ErlangTuple [key_3, makefield_4, rest_5]) ->
        let matchExpr_11 = erlps__updates_key__2 [key_3, updates_1]
        in
          case matchExpr_11 of
            (ErlangTuple [more_9, updates1_10]) ->
              let   
                arg_13 =
                  flmap
                    (\ lc_17 ->
                       case lc_17 of
                         (ErlangEmptyList) ->
                           ErlangCons ErlangEmptyList ErlangEmptyList
                         _ -> ErlangEmptyList)
                    (ErlangCons rest_5 more_9)
              in let case_12 = BIF.erlang__length__1 [arg_13]
              in let
                _ =
                  case case_12 of
                    n_19 | weakGt n_19 (toErl 1) ->
                      let
                        arg_20 =
                          ErlangTuple
                            [ErlangAtom "conflicting_updates_for_field", upd_0,
                             key_3]
                      in erlps__type_error__1 [arg_20]
                    _ -> ErlangAtom "ok"
              in let
                arg_25 =
                  BIF.do_remote_fun_call "Lists" "erlps__append__1"
                    [ErlangCons rest_5 more_9]
              in let
                head_24 =
                  BIF.erlang__apply__2
                    [makefield_4, ErlangCons arg_25 ErlangEmptyList]
              in let tail_30 = erlps__desugar_updates__1 [updates1_10]
              in ErlangCons head_24 tail_30
            _ -> EXC.badmatch matchExpr_11
      _ -> EXC.badmatch matchExpr_6
erlps__desugar_updates__1 [arg_32] = EXC.function_clause unit
erlps__desugar_updates__1 args =
  EXC.badarity (ErlangFun 1 erlps__desugar_updates__1) args

erlps__update_key__1 :: ErlangFun
erlps__update_key__1 [fld_1@(ErlangTuple [(ErlangAtom "field"),
                                          _,
                                          (ErlangCons elim_0 (ErlangEmptyList)),
                                          _])]
  =
  let    tup_el_2 = erlps__elim_key__1 [elim_0]
  in let
    tup_el_4 =
      ErlangFun 1
        (let
           lambda_5 [_] = fld_1
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in ErlangTuple [tup_el_2, tup_el_4, ErlangEmptyList]
erlps__update_key__1 [fld_1@(ErlangTuple [(ErlangAtom "field"),
                                          _,
                                          (ErlangCons elim_0 (ErlangEmptyList)),
                                          _, _])]
  =
  let    tup_el_2 = erlps__elim_key__1 [elim_0]
  in let
    tup_el_4 =
      ErlangFun 1
        (let
           lambda_5 [_] = fld_1
           lambda_5 [arg_6] = EXC.function_clause unit
           lambda_5 args = EXC.badarity (ErlangFun 1 lambda_5) args
         in lambda_5)
  in ErlangTuple [tup_el_2, tup_el_4, ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons p_2@(ErlangTuple [(ErlangAtom "proj"),
                                                                  _,
                                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                name_1])]) rest_3),
                                    value_4])]
  =
  let   
    tup_el_6 =
      ErlangFun 1
        (let
           lambda_7 [flds_9] =
             let    tup_el_18 = toErl "__x"
             in let
               tup_el_15 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_18]
             in let tup_el_25 = toErl "__x"
             in let
               arg_22 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_25]
             in let arg_20 = erlps__map_or_record__3 [ann_0, arg_22, flds_9]
             in let tup_el_19 = erlps__desugar__1 [arg_20]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons p_2 ErlangEmptyList,
                  tup_el_15, tup_el_19]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    head_28 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_3, value_4]
  in
    ErlangTuple
      [name_1, tup_el_6, ErlangCons head_28 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons p_2@(ErlangTuple [(ErlangAtom "proj"),
                                                                  _,
                                                                  (ErlangTuple [(ErlangAtom "id"),
                                                                                _,
                                                                                name_1])]) rest_3),
                                    id_4, value_5])]
  =
  let   
    tup_el_7 =
      ErlangFun 1
        (let
           lambda_8 [flds_10] =
             let    tup_el_19 = toErl "__x"
             in let
               tup_el_16 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_19]
             in let tup_el_26 = toErl "__x"
             in let
               arg_23 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_26]
             in let arg_21 = erlps__map_or_record__3 [ann_0, arg_23, flds_10]
             in let tup_el_20 = erlps__desugar__1 [arg_21]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons p_2 ErlangEmptyList,
                  tup_el_16, tup_el_20]
           lambda_8 [arg_9] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
         in lambda_8)
  in let
    head_29 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_3, id_4, value_5]
  in
    ErlangTuple
      [name_1, tup_el_7, ErlangCons head_29 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _,
                                                                  _]) rest_2),
                                    value_3])]
  =
  let   
    tup_el_5 =
      ErlangFun 1
        (let
           lambda_6 [flds_8] =
             let    tup_el_17 = toErl "__x"
             in let
               tup_el_14 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_17]
             in let tup_el_24 = toErl "__x"
             in let
               arg_21 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_24]
             in let arg_19 = erlps__map_or_record__3 [ann_0, arg_21, flds_8]
             in let tup_el_18 = erlps__desugar__1 [arg_19]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_14, tup_el_18]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    head_27 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, value_3]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_5,
       ErlangCons head_27 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _, _,
                                                                  _]) rest_2),
                                    value_3])]
  =
  let   
    tup_el_5 =
      ErlangFun 1
        (let
           lambda_6 [flds_8] =
             let    tup_el_17 = toErl "__x"
             in let
               tup_el_14 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_17]
             in let tup_el_24 = toErl "__x"
             in let
               arg_21 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_24]
             in let arg_19 = erlps__map_or_record__3 [ann_0, arg_21, flds_8]
             in let tup_el_18 = erlps__desugar__1 [arg_19]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_14, tup_el_18]
           lambda_6 [arg_7] = EXC.function_clause unit
           lambda_6 args = EXC.badarity (ErlangFun 1 lambda_6) args
         in lambda_6)
  in let
    head_27 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, value_3]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_5,
       ErlangCons head_27 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _, _,
                                                                  _]) rest_2),
                                    id_3, value_4])]
  =
  let   
    tup_el_6 =
      ErlangFun 1
        (let
           lambda_7 [flds_9] =
             let    tup_el_18 = toErl "__x"
             in let
               tup_el_15 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_18]
             in let tup_el_25 = toErl "__x"
             in let
               arg_22 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_25]
             in let arg_20 = erlps__map_or_record__3 [ann_0, arg_22, flds_9]
             in let tup_el_19 = erlps__desugar__1 [arg_20]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_15, tup_el_19]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    head_28 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, id_3, value_4]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_6,
       ErlangCons head_28 ErlangEmptyList]
erlps__update_key__1 [(ErlangTuple [(ErlangAtom "field"), ann_0,
                                    (ErlangCons k_1@(ErlangTuple [(ErlangAtom "map_get"),
                                                                  _,
                                                                  _]) rest_2),
                                    id_3, value_4])]
  =
  let   
    tup_el_6 =
      ErlangFun 1
        (let
           lambda_7 [flds_9] =
             let    tup_el_18 = toErl "__x"
             in let
               tup_el_15 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_18]
             in let tup_el_25 = toErl "__x"
             in let
               arg_22 =
                 ErlangTuple [ErlangAtom "id", ErlangEmptyList, tup_el_25]
             in let arg_20 = erlps__map_or_record__3 [ann_0, arg_22, flds_9]
             in let tup_el_19 = erlps__desugar__1 [arg_20]
             in
               ErlangTuple
                 [ErlangAtom "field", ann_0, ErlangCons k_1 ErlangEmptyList,
                  tup_el_15, tup_el_19]
           lambda_7 [arg_8] = EXC.function_clause unit
           lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
         in lambda_7)
  in let
    head_28 =
      ErlangTuple [ErlangAtom "field", ann_0, rest_2, id_3, value_4]
  in
    ErlangTuple
      [ErlangAtom "map_key", tup_el_6,
       ErlangCons head_28 ErlangEmptyList]
erlps__update_key__1 [arg_35] = EXC.function_clause unit
erlps__update_key__1 args =
  EXC.badarity (ErlangFun 1 erlps__update_key__1) args

erlps__map_or_record__3 :: ErlangFun
erlps__map_or_record__3 [ann_0, val_1,
                         flds_3@(ErlangCons fld_2 _)]
  =
  let    arg_5 = toErl 3
  in let case_4 = BIF.erlang__element__2 [arg_5, fld_2]
  in let
    kind_7 =
      case case_4 of
        (ErlangCons (ErlangTuple [(ErlangAtom "proj"), _, _]) _) ->
          ErlangAtom "record"
        (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), _, _]) _) ->
          ErlangAtom "map"
        (ErlangCons (ErlangTuple [(ErlangAtom "map_get"), _, _, _]) _) ->
          ErlangAtom "map"
        something_else -> EXC.case_clause something_else
  in ErlangTuple [kind_7, ann_0, val_1, flds_3]
erlps__map_or_record__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__map_or_record__3 args =
  EXC.badarity (ErlangFun 3 erlps__map_or_record__3) args

erlps__elim_key__1 :: ErlangFun
erlps__elim_key__1 [(ErlangTuple [(ErlangAtom "proj"), _,
                                  (ErlangTuple [(ErlangAtom "id"), _,
                                                name_0])])]
  =
  name_0
erlps__elim_key__1 [(ErlangTuple [(ErlangAtom "map_get"), _, _,
                                  _])]
  =
  ErlangAtom "map_key"
erlps__elim_key__1 [(ErlangTuple [(ErlangAtom "map_get"), _, _])]
  =
  ErlangAtom "map_key"
erlps__elim_key__1 [arg_0] = EXC.function_clause unit
erlps__elim_key__1 args =
  EXC.badarity (ErlangFun 1 erlps__elim_key__1) args

erlps__updates_key__2 :: ErlangFun
erlps__updates_key__2 [(ErlangAtom "map_key"), updates_0] =
  ErlangTuple [ErlangEmptyList, updates_0]
erlps__updates_key__2 [name_0, updates_1] =
  let   
    xs_18 =
      flmap
        (\ lc_4 ->
           let head_6 = erlps__update_key__1 [lc_4]
           in
             flmap
               (\ lc_11 ->
                  case lc_11 of
                    (ErlangTuple [name1_9, _, rest_10]) ->
                      let    tup_el_14 = BIF.erlang__op_eq [name1_9, name_0]
                      in let lcRet_12 = ErlangTuple [lc_4, tup_el_14, rest_10]
                      in ErlangCons lcRet_12 ErlangEmptyList
                    _ -> ErlangEmptyList)
               (ErlangCons head_6 ErlangEmptyList))
        updates_1
  in let
    updates1_23 =
      flmap
        (\ lc_21 ->
           case lc_21 of
             (ErlangTuple [upd_20, (ErlangAtom "false"), _]) ->
               ErlangCons upd_20 ErlangEmptyList
             _ -> ErlangEmptyList)
        xs_18
  in let
    more_28 =
      flmap
        (\ lc_26 ->
           case lc_26 of
             (ErlangTuple [_, (ErlangAtom "true"), rest_25]) ->
               ErlangCons rest_25 ErlangEmptyList
             _ -> ErlangEmptyList)
        xs_18
  in ErlangTuple [more_28, updates1_23]
erlps__updates_key__2 [arg_31, arg_32] = EXC.function_clause unit
erlps__updates_key__2 args =
  EXC.badarity (ErlangFun 2 erlps__updates_key__2) args

erlps__indexed__2 :: ErlangFun
erlps__indexed__2 [i_0, xs_1] =
  let    rop_7 = BIF.erlang__length__1 [xs_1]
  in let lop_5 = BIF.erlang__op_plus [i_0, rop_7]
  in let rop_9 = toErl 1
  in let arg_4 = BIF.erlang__op_minus [lop_5, rop_9]
  in let
    arg_2 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [i_0, arg_4]
  in BIF.do_remote_fun_call "Lists" "erlps__zip__2" [arg_2, xs_1]
erlps__indexed__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__indexed__2 args =
  EXC.badarity (ErlangFun 2 erlps__indexed__2) args