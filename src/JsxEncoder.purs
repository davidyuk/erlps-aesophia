module Jsx.Encoder(erlps__encoder__3, erlps__encode__1,
                   erlps__encode__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__encoder__3 :: ErlangFun
erlps__encoder__3 [handler_0, state_1, config_2] =
  let
    parser_6 =
      BIF.do_remote_fun_call "Jsx" "erlps__parser__3"
        [handler_0, state_1, config_2]
  in
    ErlangFun 1
      (let
         lambda_7 [term_9] =
           let    lop_11 = erlps__encode__1 [term_9]
           in let
             arg_10 =
               BIF.erlang__op_append
                 [lop_11, ErlangCons (ErlangAtom "end_json") ErlangEmptyList]
           in
             BIF.erlang__apply__2
               [parser_6, ErlangCons arg_10 ErlangEmptyList]
         lambda_7 [arg_8] = EXC.function_clause unit
         lambda_7 args = EXC.badarity (ErlangFun 1 lambda_7) args
       in lambda_7)
erlps__encoder__3 [arg_17, arg_18, arg_19] =
  EXC.function_clause unit
erlps__encoder__3 args =
  EXC.badarity (ErlangFun 3 erlps__encoder__3) args

erlps__encode__1 :: ErlangFun
erlps__encode__1 [term_0] =
  erlps__encode__2 [term_0, ErlangAtom "jsx_encoder"]
erlps__encode__1 [arg_3] = EXC.function_clause unit
erlps__encode__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode__1) args

erlps__encode__2 :: ErlangFun
erlps__encode__2 [map_0, _entrypoint_1]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let lop_6 = BIF.erlang__is_map__1 [map_0]
            in
              case lop_6 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let    lop_8 = BIF.erlang__map_size__1 [map_0]
                  in let rop_10 = toErl 1
                  in BIF.erlang__op_lesser [lop_8, rop_10]
                _ -> EXC.badarg1 lop_6)) =
  ErlangCons (ErlangAtom "start_object")
    (ErlangCons (ErlangAtom "end_object") ErlangEmptyList)
erlps__encode__2 [term_0, entrypoint_1] | isEMap term_0 =
  let rop_5 = erlps__unpack__2 [term_0, entrypoint_1]
  in
    BIF.erlang__op_append
      [ErlangCons (ErlangAtom "start_object") ErlangEmptyList, rop_5]
erlps__encode__2 [term_0, entrypoint_1] =
  erlps__encode___2 [term_0, entrypoint_1]
erlps__encode__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__encode__2 args =
  EXC.badarity (ErlangFun 2 erlps__encode__2) args

erlps__encode___2 :: ErlangFun
erlps__encode___2 [(ErlangEmptyList), _entrypoint_0] =
  ErlangCons (ErlangAtom "start_array")
    (ErlangCons (ErlangAtom "end_array") ErlangEmptyList)
erlps__encode___2 [(ErlangCons (ErlangTuple []) (ErlangEmptyList)),
                   _entrypoint_0]
  =
  ErlangCons (ErlangAtom "start_object")
    (ErlangCons (ErlangAtom "end_object") ErlangEmptyList)
erlps__encode___2 [(ErlangCons datetime_0@(ErlangTuple [(ErlangTuple [_,
                                                                      _, _]),
                                                        (ErlangTuple [_, _,
                                                                      _])]) rest_1),
                   entrypoint_2]
  =
  let    rop_10 = erlps__unhitch__2 [rest_1, entrypoint_2]
  in let
    rop_6 =
      BIF.erlang__op_append
        [ErlangCons datetime_0 ErlangEmptyList, rop_10]
  in
    BIF.erlang__op_append
      [ErlangCons (ErlangAtom "start_array") ErlangEmptyList, rop_6]
erlps__encode___2 [term_0@(ErlangCons (ErlangTuple [_, _]) _),
                   entrypoint_1]
  =
  let rop_5 = erlps__unzip__2 [term_0, entrypoint_1]
  in
    BIF.erlang__op_append
      [ErlangCons (ErlangAtom "start_object") ErlangEmptyList, rop_5]
erlps__encode___2 [term_0, entrypoint_1] | isEList term_0 =
  let rop_5 = erlps__unhitch__2 [term_0, entrypoint_1]
  in
    BIF.erlang__op_append
      [ErlangCons (ErlangAtom "start_array") ErlangEmptyList, rop_5]
erlps__encode___2 [else_0, _entrypoint_1] =
  ErlangCons else_0 ErlangEmptyList
erlps__encode___2 [arg_4, arg_5] = EXC.function_clause unit
erlps__encode___2 args =
  EXC.badarity (ErlangFun 2 erlps__encode___2) args

erlps__unzip__2 :: ErlangFun
erlps__unzip__2 [(ErlangCons (ErlangTuple [k_0, v_1]) rest_2),
                 entrypoint_3]
  | ((isEInt k_0) || (isEBinary k_0)) || (isEAtom k_0) =
  let   
    lop_8 =
      BIF.erlang__apply__3
        [entrypoint_3, ErlangAtom "encode",
         ErlangCons v_1 (ErlangCons entrypoint_3 ErlangEmptyList)]
  in let rop_16 = erlps__unzip__2 [rest_2, entrypoint_3]
  in let rop_7 = BIF.erlang__op_append [lop_8, rop_16]
  in BIF.erlang__op_append [ErlangCons k_0 ErlangEmptyList, rop_7]
erlps__unzip__2 [(ErlangEmptyList), _] =
  ErlangCons (ErlangAtom "end_object") ErlangEmptyList
erlps__unzip__2 [_, _] =
  BIF.erlang__error__1 [ErlangAtom "badarg"]
erlps__unzip__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__unzip__2 args =
  EXC.badarity (ErlangFun 2 erlps__unzip__2) args

erlps__unhitch__2 :: ErlangFun
erlps__unhitch__2 [(ErlangCons v_0 rest_1), entrypoint_2] =
  let   
    lop_3 =
      BIF.erlang__apply__3
        [entrypoint_2, ErlangAtom "encode",
         ErlangCons v_0 (ErlangCons entrypoint_2 ErlangEmptyList)]
  in let rop_11 = erlps__unhitch__2 [rest_1, entrypoint_2]
  in BIF.erlang__op_append [lop_3, rop_11]
erlps__unhitch__2 [(ErlangEmptyList), _] =
  ErlangCons (ErlangAtom "end_array") ErlangEmptyList
erlps__unhitch__2 [arg_2, arg_3] = EXC.function_clause unit
erlps__unhitch__2 args =
  EXC.badarity (ErlangFun 2 erlps__unhitch__2) args

erlps__unpack__2 :: ErlangFun
erlps__unpack__2 [map_0, entrypoint_1] =
  let arg_3 = BIF.maps__keys__1 [map_0]
  in erlps__unpack__3 [map_0, arg_3, entrypoint_1]
erlps__unpack__2 [arg_6, arg_7] = EXC.function_clause unit
erlps__unpack__2 args =
  EXC.badarity (ErlangFun 2 erlps__unpack__2) args

erlps__unpack__3 :: ErlangFun
erlps__unpack__3 [map_0, (ErlangCons k_1 rest_2), entrypoint_3]
  | ((isEInt k_1) || (isEBinary k_1)) || (isEAtom k_1) =
  let    head_12 = BIF.maps__get__2 [k_1, map_0]
  in let
    lop_8 =
      BIF.erlang__apply__3
        [entrypoint_3, ErlangAtom "encode",
         ErlangCons head_12 (ErlangCons entrypoint_3 ErlangEmptyList)]
  in let rop_18 = erlps__unpack__3 [map_0, rest_2, entrypoint_3]
  in let rop_7 = BIF.erlang__op_append [lop_8, rop_18]
  in BIF.erlang__op_append [ErlangCons k_1 ErlangEmptyList, rop_7]
erlps__unpack__3 [_, (ErlangEmptyList), _] =
  ErlangCons (ErlangAtom "end_object") ErlangEmptyList
erlps__unpack__3 [arg_2, arg_3, arg_4] = EXC.function_clause unit
erlps__unpack__3 args =
  EXC.badarity (ErlangFun 3 erlps__unpack__3) args