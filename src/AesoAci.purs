module Aeso.Aci(erlps__file__2, erlps__file__3,
                erlps__contract_interface__2, erlps__contract_interface__3,
                erlps__from_typed_ast__2, erlps__render_aci_json__1,
                erlps__json_encode_expr__1, erlps__json_encode_type__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__file__2 :: ErlangFun
erlps__file__2 [type_0, file_1] =
  erlps__file__3 [type_0, file_1, ErlangEmptyList]
erlps__file__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__file__2 args =
  EXC.badarity (ErlangFun 2 erlps__file__2) args

erlps__file__3 :: ErlangFun
erlps__file__3 [type_0, file_1, options0_2] =
  let   
    options_5 =
      BIF.do_remote_fun_call "Aeso.Compiler"
        "erlps__add_include_path__2" [file_1, options0_2]
  in let
    case_6 =
      BIF.do_remote_fun_call "File" "erlps__read_file__1" [file_1]
  in
    case case_6 of
      (ErlangTuple [(ErlangAtom "ok"), bincode_8]) ->
        let arg_10 = BIF.erlang__binary_to_list__1 [bincode_8]
        in erlps__do_contract_interface__3 [type_0, arg_10, options_5]
      err_13@(ErlangTuple [(ErlangAtom "error"), _]) -> err_13
      something_else -> EXC.case_clause something_else
erlps__file__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__file__3 args =
  EXC.badarity (ErlangFun 3 erlps__file__3) args

erlps__contract_interface__2 :: ErlangFun
erlps__contract_interface__2 [type_0, contractstring_1] =
  erlps__contract_interface__3
    [type_0, contractstring_1, ErlangEmptyList]
erlps__contract_interface__2 [arg_5, arg_6] =
  EXC.function_clause unit
erlps__contract_interface__2 args =
  EXC.badarity (ErlangFun 2 erlps__contract_interface__2) args

erlps__contract_interface__3 :: ErlangFun
erlps__contract_interface__3 [type_0, contractstring_1,
                              compileropts_2]
  =
  erlps__do_contract_interface__3
    [type_0, contractstring_1, compileropts_2]
erlps__contract_interface__3 [arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__contract_interface__3 args =
  EXC.badarity (ErlangFun 3 erlps__contract_interface__3) args

erlps__render_aci_json__1 :: ErlangFun
erlps__render_aci_json__1 [json_0] =
  erlps__do_render_aci_json__1 [json_0]
erlps__render_aci_json__1 [arg_2] = EXC.function_clause unit
erlps__render_aci_json__1 args =
  EXC.badarity (ErlangFun 1 erlps__render_aci_json__1) args

erlps__json_encode_expr__1 :: ErlangFun
erlps__json_encode_expr__1 [expr_0] =
  erlps__encode_expr__1 [expr_0]
erlps__json_encode_expr__1 [arg_2] = EXC.function_clause unit
erlps__json_encode_expr__1 args =
  EXC.badarity (ErlangFun 1 erlps__json_encode_expr__1) args

erlps__json_encode_type__1 :: ErlangFun
erlps__json_encode_type__1 [type_0] =
  erlps__encode_type__1 [type_0]
erlps__json_encode_type__1 [arg_2] = EXC.function_clause unit
erlps__json_encode_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__json_encode_type__1) args

erlps__do_contract_interface__3 :: ErlangFun
erlps__do_contract_interface__3 [type_0, contract_1, options_2]
  | isEBinary contract_1 =
  let arg_4 = BIF.erlang__binary_to_list__1 [contract_1]
  in erlps__do_contract_interface__3 [type_0, arg_4, options_2]
erlps__do_contract_interface__3 [type_0, contractstring_1,
                                 options_2]
  =
  EXC.tryCatch
    (\ _ ->
       let   
         ast_5 =
           BIF.do_remote_fun_call "Aeso.Compiler" "erlps__parse__2"
             [contractstring_1, options_2]
       in let
         matchExpr_11 =
           BIF.do_remote_fun_call "Aeso.Ast.Infer.Types" "erlps__infer__2"
             [ast_5, ErlangCons (ErlangAtom "dont_unfold") options_2]
       in
         case matchExpr_11 of
           (ErlangTuple [typedast_10, _]) ->
             erlps__from_typed_ast__2 [type_0, typedast_10]
           _ -> EXC.badmatch matchExpr_11)
    (\ ex_15 ->
       case ex_15 of
         (ErlangTuple [(ErlangAtom "throw"),
                       (ErlangTuple [(ErlangAtom "error"), errors_17]), _]) ->
           ErlangTuple [ErlangAtom "error", errors_17]
         ex_16 -> EXC.raise ex_16)
erlps__do_contract_interface__3 [arg_20, arg_21, arg_22] =
  EXC.function_clause unit
erlps__do_contract_interface__3 args =
  EXC.badarity (ErlangFun 3 erlps__do_contract_interface__3) args

erlps__from_typed_ast__2 :: ErlangFun
erlps__from_typed_ast__2 [type_0, typedast_1] =
  let
    jarray_7 =
      flmap
        (\ lc_4 ->
           let lcRet_5 = erlps__encode_contract__1 [lc_4]
           in ErlangCons lcRet_5 ErlangEmptyList)
        typedast_1
  in
    case type_0 of
      (ErlangAtom "json") -> ErlangTuple [ErlangAtom "ok", jarray_7]
      (ErlangAtom "string") -> erlps__do_render_aci_json__1 [jarray_7]
      something_else -> EXC.case_clause something_else
erlps__from_typed_ast__2 [arg_12, arg_13] =
  EXC.function_clause unit
erlps__from_typed_ast__2 args =
  EXC.badarity (ErlangFun 2 erlps__from_typed_ast__2) args

erlps__encode_contract__1 :: ErlangFun
erlps__encode_contract__1 [contract_2@(ErlangTuple [head_0, _,
                                                    (ErlangTuple [(ErlangAtom "con"),
                                                                  _, name_1]),
                                                    _])]
  | ((==) head_0 (ErlangAtom "contract_main")) ||
      (((==) head_0 (ErlangAtom "contract_interface")) ||
         ((==) head_0 (ErlangAtom "contract_child"))) =
  let    val_4 = erlps__encode_name__1 [name_1]
  in let c0_6 = ErlangMap (Map.singleton (ErlangAtom "name") val_4)
  in let arg_8 = erlps__contract_types__1 [contract_2]
  in let lcSrc_7 = erlps__sort_decls__1 [arg_8]
  in let
    tdefs0_14 =
      flmap
        (\ lc_11 ->
           let lcRet_12 = erlps__encode_typedef__1 [lc_11]
           in ErlangCons lcRet_12 ErlangEmptyList)
        lcSrc_7
  in let
    filtert_24 =
      ErlangFun 1
        (let
           lambda_15 [n_17] =
             ErlangFun 1
               (let
                  lambda_18 [(ErlangMap map_20)]
                    | (DM.Just n1_21) <-
                        (Map.lookup (ErlangAtom "name") map_20) =
                    BIF.erlang__op_eq [n_17, n1_21]
                  lambda_18 [arg_19] = EXC.function_clause unit
                  lambda_18 args = EXC.badarity (ErlangFun 1 lambda_18) args
                in lambda_18)
           lambda_15 [arg_16] = EXC.function_clause unit
           lambda_15 args = EXC.badarity (ErlangFun 1 lambda_15) args
         in lambda_15)
  in let
    arg_26 =
      ErlangBinary (BIN.fromInts (toErl "event") (toErl 8) 1 BIN.Big)
  in let
    arg_25 =
      BIF.erlang__apply__2
        [filtert_24, ErlangCons arg_26 ErlangEmptyList]
  in let
    matchExpr_31 =
      BIF.do_remote_fun_call "Lists" "erlps__partition__2"
        [arg_25, tdefs0_14]
  in
    case matchExpr_31 of
      (ErlangTuple [es_29, tdefs1_30]) ->
        let   
          arg_33 =
            ErlangBinary (BIN.fromInts (toErl "state") (toErl 8) 1 BIN.Big)
        in let
          arg_32 =
            BIF.erlang__apply__2
              [filtert_24, ErlangCons arg_33 ErlangEmptyList]
        in let
          matchExpr_38 =
            BIF.do_remote_fun_call "Lists" "erlps__partition__2"
              [arg_32, tdefs1_30]
        in
          case matchExpr_38 of
            (ErlangTuple [ss_36, tdefs_37]) ->
              let   
                mapExt_42 =
                  ErlangMap (Map.singleton (ErlangAtom "type_defs") tdefs_37)
              in let c1_44 = BIF.maps__merge__2 [c0_6, mapExt_42]
              in let
                c2_53 =
                  case es_29 of
                    (ErlangEmptyList) -> c1_44
                    (ErlangCons (ErlangMap map_46) (ErlangEmptyList)) | (DM.Just et_47) <-
                                                                          (Map.lookup
                                                                             (ErlangAtom
                                                                                "typedef")
                                                                             map_46) ->
                      let
                        mapExt_51 =
                          ErlangMap (Map.singleton (ErlangAtom "event") et_47)
                      in BIF.maps__merge__2 [c1_44, mapExt_51]
                    something_else -> EXC.case_clause something_else
              in let
                c3_62 =
                  case ss_36 of
                    (ErlangEmptyList) -> c2_53
                    (ErlangCons (ErlangMap map_55) (ErlangEmptyList)) | (DM.Just st_56) <-
                                                                          (Map.lookup
                                                                             (ErlangAtom
                                                                                "typedef")
                                                                             map_55) ->
                      let
                        mapExt_60 =
                          ErlangMap (Map.singleton (ErlangAtom "state") st_56)
                      in BIF.maps__merge__2 [c2_53, mapExt_60]
                    something_else -> EXC.case_clause something_else
              in let arg_64 = erlps__contract_funcs__1 [contract_2]
              in let lcSrc_63 = erlps__sort_decls__1 [arg_64]
              in let
                fdefs_72 =
                  flmap
                    (\ lc_67 ->
                       let cond_68 = erlps__is_entrypoint__1 [lc_67]
                       in
                         case cond_68 of
                           (ErlangAtom "true") ->
                             let lcRet_70 = erlps__encode_function__1 [lc_67]
                             in ErlangCons lcRet_70 ErlangEmptyList
                           _ -> ErlangEmptyList)
                    lcSrc_63
              in let val_81 = erlps__is_payable__1 [contract_2]
              in let
                mapExt_83 =
                  ErlangMap
                    (Map.fromFoldable
                       [DT.Tuple (ErlangAtom "kind") head_0,
                        DT.Tuple (ErlangAtom "functions") fdefs_72,
                        DT.Tuple (ErlangAtom "payable") val_81])
              in let val_74 = BIF.maps__merge__2 [c3_62, mapExt_83]
              in ErlangMap (Map.singleton (ErlangAtom "contract") val_74)
            _ -> EXC.badmatch matchExpr_38
      _ -> EXC.badmatch matchExpr_31
erlps__encode_contract__1 [namespace_1@(ErlangTuple [(ErlangAtom "namespace"),
                                                     _,
                                                     (ErlangTuple [(ErlangAtom "con"),
                                                                   _, name_0]),
                                                     _])]
  =
  let    arg_3 = erlps__contract_types__1 [namespace_1]
  in let lcSrc_2 = erlps__sort_decls__1 [arg_3]
  in let
    tdefs_9 =
      flmap
        (\ lc_6 ->
           let lcRet_7 = erlps__encode_typedef__1 [lc_6]
           in ErlangCons lcRet_7 ErlangEmptyList)
        lcSrc_2
  in let val_14 = erlps__encode_name__1 [name_0]
  in let
    val_11 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "name") val_14,
            DT.Tuple (ErlangAtom "type_defs") tdefs_9])
  in ErlangMap (Map.singleton (ErlangAtom "namespace") val_11)
erlps__encode_contract__1 [arg_17] = EXC.function_clause unit
erlps__encode_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_contract__1) args

erlps__encode_function__1 :: ErlangFun
erlps__encode_function__1 [fdef_3@(ErlangTuple [(ErlangAtom "letfun"),
                                                _,
                                                (ErlangTuple [(ErlangAtom "id"),
                                                              _, name_0]),
                                                args_1, type_2, _])]
  =
  let    val_9 = erlps__encode_name__1 [name_0]
  in let val_11 = erlps__encode_args__1 [args_1]
  in let val_13 = erlps__encode_type__1 [type_2]
  in let val_15 = erlps__is_stateful__1 [fdef_3]
  in let val_17 = erlps__is_payable__1 [fdef_3]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "name") val_9,
          DT.Tuple (ErlangAtom "arguments") val_11,
          DT.Tuple (ErlangAtom "returns") val_13,
          DT.Tuple (ErlangAtom "stateful") val_15,
          DT.Tuple (ErlangAtom "payable") val_17])
erlps__encode_function__1 [fdecl_3@(ErlangTuple [(ErlangAtom "fun_decl"),
                                                 _,
                                                 (ErlangTuple [(ErlangAtom "id"),
                                                               _, name_0]),
                                                 (ErlangTuple [(ErlangAtom "fun_t"),
                                                               _, _, args_1,
                                                               type_2])])]
  =
  let    val_9 = erlps__encode_name__1 [name_0]
  in let val_11 = erlps__encode_anon_args__1 [args_1]
  in let val_13 = erlps__encode_type__1 [type_2]
  in let val_15 = erlps__is_stateful__1 [fdecl_3]
  in let val_17 = erlps__is_payable__1 [fdecl_3]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "name") val_9,
          DT.Tuple (ErlangAtom "arguments") val_11,
          DT.Tuple (ErlangAtom "returns") val_13,
          DT.Tuple (ErlangAtom "stateful") val_15,
          DT.Tuple (ErlangAtom "payable") val_17])
erlps__encode_function__1 [arg_19] = EXC.function_clause unit
erlps__encode_function__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_function__1) args

erlps__encode_anon_args__1 :: ErlangFun
erlps__encode_anon_args__1 [types_0] =
  let    arg_2 = toErl 1
  in let arg_3 = BIF.erlang__length__1 [types_0]
  in let
    lcSrc_1 =
      BIF.do_remote_fun_call "Lists" "erlps__seq__2" [arg_2, arg_3]
  in let
    anons_12 =
      flmap
        (\ lc_6 ->
           let    lop_9 = toErl "_"
           in let rop_10 = BIF.erlang__integer_to_list__1 [lc_6]
           in let arg_8 = BIF.erlang__op_append [lop_9, rop_10]
           in let lcRet_7 = BIF.erlang__list_to_binary__1 [arg_8]
           in ErlangCons lcRet_7 ErlangEmptyList)
        lcSrc_1
  in let
    lcSrc_13 =
      BIF.do_remote_fun_call "Lists" "erlps__zip__2"
        [anons_12, types_0]
  in
    flmap
      (\ lc_18 ->
         case lc_18 of
           (ErlangTuple [v_16, t_17]) ->
             let    val_23 = erlps__encode_type__1 [t_17]
             in let
               lcRet_19 =
                 ErlangMap
                   (Map.fromFoldable
                      [DT.Tuple (ErlangAtom "name") v_16,
                       DT.Tuple (ErlangAtom "type") val_23])
             in ErlangCons lcRet_19 ErlangEmptyList
           _ -> ErlangEmptyList)
      lcSrc_13
erlps__encode_anon_args__1 [arg_25] = EXC.function_clause unit
erlps__encode_anon_args__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_anon_args__1) args

erlps__encode_args__1 :: ErlangFun
erlps__encode_args__1 [args_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__encode_arg__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    args_0
erlps__encode_args__1 [arg_6] = EXC.function_clause unit
erlps__encode_args__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_args__1) args

erlps__encode_arg__1 :: ErlangFun
erlps__encode_arg__1 [(ErlangTuple [(ErlangAtom "typed"), _,
                                    id_0, t_1])]
  =
  let    val_4 = erlps__encode_type__1 [id_0]
  in let val_6 = erlps__encode_type__1 [t_1]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "name") val_4,
          DT.Tuple (ErlangAtom "type") val_6])
erlps__encode_arg__1 [arg_8] = EXC.function_clause unit
erlps__encode_arg__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_arg__1) args

erlps__encode_typedef__1 :: ErlangFun
erlps__encode_typedef__1 [type_0] =
  let    name_2 = erlps__typedef_name__1 [type_0]
  in let vars_4 = erlps__typedef_vars__1 [type_0]
  in let def_6 = erlps__typedef_def__1 [type_0]
  in let val_10 = erlps__encode_name__1 [name_2]
  in let val_12 = erlps__encode_tvars__1 [vars_4]
  in let val_14 = erlps__encode_type__1 [def_6]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "name") val_10,
          DT.Tuple (ErlangAtom "vars") val_12,
          DT.Tuple (ErlangAtom "typedef") val_14])
erlps__encode_typedef__1 [arg_16] = EXC.function_clause unit
erlps__encode_typedef__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_typedef__1) args

erlps__encode_tvars__1 :: ErlangFun
erlps__encode_tvars__1 [vars_0] =
  flmap
    (\ lc_3 ->
       let    val_6 = erlps__encode_type__1 [lc_3]
       in let
         lcRet_4 = ErlangMap (Map.singleton (ErlangAtom "name") val_6)
       in ErlangCons lcRet_4 ErlangEmptyList)
    vars_0
erlps__encode_tvars__1 [arg_8] = EXC.function_clause unit
erlps__encode_tvars__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_tvars__1) args

erlps__encode_type__1 :: ErlangFun
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "tvar"), _,
                                     n_0])]
  =
  erlps__encode_name__1 [n_0]
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "id"), _, n_0])]
  =
  erlps__encode_name__1 [n_0]
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "con"), _,
                                     n_0])]
  =
  erlps__encode_name__1 [n_0]
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "qid"), _,
                                     ns_0])]
  =
  let    arg_2 = toErl "."
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_2, ns_0]
  in erlps__encode_name__1 [arg_1]
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "qcon"), _,
                                     ns_0])]
  =
  let    arg_2 = toErl "."
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_2, ns_0]
  in erlps__encode_name__1 [arg_1]
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "tuple_t"), _,
                                     as_0])]
  =
  let val_2 = erlps__encode_types__1 [as_0]
  in ErlangMap (Map.singleton (ErlangAtom "tuple") val_2)
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "bytes_t"), _,
                                     len_0])]
  =
  ErlangMap (Map.singleton (ErlangAtom "bytes") len_0)
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "record_t"),
                                     fs_0])]
  =
  let val_2 = erlps__encode_type_fields__1 [fs_0]
  in ErlangMap (Map.singleton (ErlangAtom "record") val_2)
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "app_t"), _,
                                     id_0, fs_1])]
  =
  let    key_2 = erlps__encode_type__1 [id_0]
  in let val_4 = erlps__encode_types__1 [fs_1]
  in ErlangMap (Map.singleton key_2 val_4)
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "variant_t"),
                                     cs_0])]
  =
  let val_2 = erlps__encode_types__1 [cs_0]
  in ErlangMap (Map.singleton (ErlangAtom "variant") val_2)
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "constr_t"), _,
                                     c_0, as_1])]
  =
  let    key_2 = erlps__encode_type__1 [c_0]
  in let val_4 = erlps__encode_types__1 [as_1]
  in ErlangMap (Map.singleton key_2 val_4)
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "alias_t"),
                                     type_0])]
  =
  erlps__encode_type__1 [type_0]
erlps__encode_type__1 [(ErlangTuple [(ErlangAtom "fun_t"), _, _,
                                     as_0, t_1])]
  =
  let    val_6 = erlps__encode_types__1 [as_0]
  in let val_8 = erlps__encode_type__1 [t_1]
  in let
    val_3 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "arguments") val_6,
            DT.Tuple (ErlangAtom "returns") val_8])
  in ErlangMap (Map.singleton (ErlangAtom "function") val_3)
erlps__encode_type__1 [arg_10] = EXC.function_clause unit
erlps__encode_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_type__1) args

erlps__encode_types__1 :: ErlangFun
erlps__encode_types__1 [ts_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__encode_type__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    ts_0
erlps__encode_types__1 [arg_6] = EXC.function_clause unit
erlps__encode_types__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_types__1) args

erlps__encode_type_fields__1 :: ErlangFun
erlps__encode_type_fields__1 [fs_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__encode_type_field__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    fs_0
erlps__encode_type_fields__1 [arg_6] = EXC.function_clause unit
erlps__encode_type_fields__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_type_fields__1) args

erlps__encode_type_field__1 :: ErlangFun
erlps__encode_type_field__1 [(ErlangTuple [(ErlangAtom "field_t"),
                                           _, id_0, t_1])]
  =
  let    val_4 = erlps__encode_type__1 [id_0]
  in let val_6 = erlps__encode_type__1 [t_1]
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "name") val_4,
          DT.Tuple (ErlangAtom "type") val_6])
erlps__encode_type_field__1 [arg_8] = EXC.function_clause unit
erlps__encode_type_field__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_type_field__1) args

erlps__encode_name__1 :: ErlangFun
erlps__encode_name__1 [name_0] | isEList name_0 =
  BIF.erlang__list_to_binary__1 [name_0]
erlps__encode_name__1 [name_0] | isEBinary name_0 = name_0
erlps__encode_name__1 [arg_1] = EXC.function_clause unit
erlps__encode_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_name__1) args

erlps__encode_exprs__1 :: ErlangFun
erlps__encode_exprs__1 [es_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__encode_expr__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    es_0
erlps__encode_exprs__1 [arg_6] = EXC.function_clause unit
erlps__encode_exprs__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_exprs__1) args

erlps__encode_expr__1 :: ErlangFun
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "id"), _, n_0])]
  =
  erlps__encode_name__1 [n_0]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "con"), _,
                                     n_0])]
  =
  erlps__encode_name__1 [n_0]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "qid"), _,
                                     ns_0])]
  =
  let    arg_2 = toErl "."
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_2, ns_0]
  in erlps__encode_name__1 [arg_1]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "qcon"), _,
                                     ns_0])]
  =
  let    arg_2 = toErl "."
  in let
    arg_1 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_2, ns_0]
  in erlps__encode_name__1 [arg_1]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "typed"), _,
                                     e_0])]
  =
  erlps__encode_expr__1 [e_0]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "bool"), _,
                                     b_0])]
  =
  b_0
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "int"), _,
                                     v_0])]
  =
  v_0
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "string"), _,
                                     s_0])]
  =
  s_0
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "tuple"), _,
                                     as_0])]
  =
  erlps__encode_exprs__1 [as_0]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "list"), _,
                                     as_0])]
  =
  erlps__encode_exprs__1 [as_0]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "bytes"), _,
                                     b_0])]
  =
  let digits_2 = BIF.erlang__byte_size__1 [b_0]
  in
    case b_0 of
      (ErlangBinary binSeg_3) | (ErlangInt size_4) <- (digits_2)
                              , (BIN.Ok n_6 bin_5) <-
                                  (BIN.chopInt binSeg_3 size_4 8 BIN.Big
                                     BIN.Unsigned)
                              , BIN.empty bin_5 ->
        let    arg_10 = toErl "#~*.16.0b"
        in let rop_14 = toErl 2
        in let head_12 = BIF.erlang__op_mult [digits_2, rop_14]
        in let
          arg_9 =
            BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
              [arg_10, ErlangCons head_12 (ErlangCons n_6 ErlangEmptyList)]
        in let
          arg_8 =
            BIF.do_remote_fun_call "Lists" "erlps__flatten__1" [arg_9]
        in BIF.erlang__list_to_binary__1 [arg_8]
      _ -> EXC.badmatch b_0
erlps__encode_expr__1 [(ErlangTuple [lit_0, _, l_1])]
  | (((weakEq lit_0 (ErlangAtom "oracle_pubkey")) ||
        (weakEq lit_0 (ErlangAtom "oracle_query_id"))) ||
       (weakEq lit_0 (ErlangAtom "contract_pubkey"))) ||
      (weakEq lit_0 (ErlangAtom "account_pubkey")) =
  BIF.do_remote_fun_call "Aeser.Api.Encoder" "erlps__encode__2"
    [lit_0, l_1]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "app"), _,
                                     (ErlangTuple [(ErlangAtom "-"), _]),
                                     (ErlangCons (ErlangTuple [(ErlangAtom "int"),
                                                               _,
                                                               n_0]) (ErlangEmptyList))])]
  =
  let    tup_el_4 = BIF.erlang__op_neg [n_0]
  in let
    arg_1 = ErlangTuple [ErlangAtom "int", ErlangEmptyList, tup_el_4]
  in erlps__encode_expr__1 [arg_1]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "app"), _, f_0,
                                     as_1])]
  =
  let    ef_3 = erlps__encode_expr__1 [f_0]
  in let eas_5 = erlps__encode_exprs__1 [as_1]
  in ErlangMap (Map.singleton ef_3 eas_5)
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "record"), _,
                                     flds_0])]
  =
  let arg_1 = erlps__encode_fields__1 [flds_0]
  in BIF.maps__from_list__1 [arg_1]
erlps__encode_expr__1 [(ErlangTuple [(ErlangAtom "map"), _,
                                     kvs_0])]
  =
  flmap
    (\ lc_4 ->
       case lc_4 of
         (ErlangTuple [k_2, v_3]) ->
           let    head_6 = erlps__encode_expr__1 [k_2]
           in let head_9 = erlps__encode_expr__1 [v_3]
           in
             ErlangCons
               (ErlangCons head_6 (ErlangCons head_9 ErlangEmptyList))
               ErlangEmptyList
         _ -> ErlangEmptyList)
    kvs_0
erlps__encode_expr__1 [(ErlangTuple [op_0, _ann_1])] =
  let arg_2 = ErlangTuple [ErlangAtom "encode_expr_todo", op_0]
  in BIF.erlang__error__1 [arg_2]
erlps__encode_expr__1 [arg_5] = EXC.function_clause unit
erlps__encode_expr__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_expr__1) args

erlps__encode_fields__1 :: ErlangFun
erlps__encode_fields__1 [flds_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__encode_field__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    flds_0
erlps__encode_fields__1 [arg_6] = EXC.function_clause unit
erlps__encode_fields__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_fields__1) args

erlps__encode_field__1 :: ErlangFun
erlps__encode_field__1 [(ErlangTuple [(ErlangAtom "field"), _,
                                      (ErlangCons (ErlangTuple [(ErlangAtom "proj"),
                                                                _,
                                                                (ErlangTuple [(ErlangAtom "id"),
                                                                              _,
                                                                              fld_0])]) (ErlangEmptyList)),
                                      val_1])]
  =
  let    tup_el_2 = erlps__encode_name__1 [fld_0]
  in let tup_el_4 = erlps__encode_expr__1 [val_1]
  in ErlangTuple [tup_el_2, tup_el_4]
erlps__encode_field__1 [arg_6] = EXC.function_clause unit
erlps__encode_field__1 args =
  EXC.badarity (ErlangFun 1 erlps__encode_field__1) args

erlps__do_render_aci_json__1 :: ErlangFun
erlps__do_render_aci_json__1 [json_0] =
  let   
    contracts_21 =
      case json_0 of
        jarray_2 | isEList jarray_2 -> jarray_2
        jobject_3 | isEMap jobject_3 ->
          ErlangCons jobject_3 ErlangEmptyList
        jtext_6 | isEBinary jtext_6 ->
          let   
            head_10 = ErlangTuple [ErlangAtom "labels", ErlangAtom "atom"]
          in let
            case_7 =
              BIF.do_remote_fun_call "Jsx" "erlps__decode__2"
                [json_0,
                 ErlangCons head_10
                   (ErlangCons (ErlangAtom "return_maps") ErlangEmptyList)]
          in
            case case_7 of
              jarray_16 | isEList jarray_16 -> jarray_16
              jobject_17 | isEMap jobject_17 ->
                ErlangCons jobject_17 ErlangEmptyList
              _ -> BIF.erlang__error__1 [ErlangAtom "bad_aci_json"]
        something_else -> EXC.case_clause something_else
  in let
    decodedcontracts_27 =
      flmap
        (\ lc_24 ->
           let lcRet_25 = erlps__decode_contract__1 [lc_24]
           in ErlangCons lcRet_25 ErlangEmptyList)
        contracts_21
  in let arg_32 = toErl "\n"
  in let
    arg_30 =
      BIF.do_remote_fun_call "String" "erlps__join__2"
        [decodedcontracts_27, arg_32]
  in let tup_el_29 = BIF.erlang__list_to_binary__1 [arg_30]
  in ErlangTuple [ErlangAtom "ok", tup_el_29]
erlps__do_render_aci_json__1 [arg_33] = EXC.function_clause unit
erlps__do_render_aci_json__1 args =
  EXC.badarity (ErlangFun 1 erlps__do_render_aci_json__1) args

erlps__decode_contract__1 :: ErlangFun
erlps__decode_contract__1 [(ErlangMap map_0)]
  | (DM.Just c_7@(ErlangMap map_1)) <-
      (Map.lookup (ErlangAtom "contract") map_0)
  , (DM.Just fs_6) <- (Map.lookup (ErlangAtom "functions") map_1)
  , (DM.Just ts0_5) <- (Map.lookup (ErlangAtom "type_defs") map_1)
  , (DM.Just payable_4) <-
      (Map.lookup (ErlangAtom "payable") map_1)
  , (DM.Just kind_3) <- (Map.lookup (ErlangAtom "kind") map_1)
  , (DM.Just name_2) <- (Map.lookup (ErlangAtom "name") map_1) =
  let   
    mktdef_19 =
      ErlangFun 2
        (let
           lambda_8 [n_11, t_12] =
             ErlangMap
               (Map.fromFoldable
                  [DT.Tuple (ErlangAtom "name") n_11,
                   DT.Tuple (ErlangAtom "vars") ErlangEmptyList,
                   DT.Tuple (ErlangAtom "typedef") t_12])
           lambda_8 [arg_9, arg_10] = EXC.function_clause unit
           lambda_8 args = EXC.badarity (ErlangFun 2 lambda_8) args
         in lambda_8)
  in let cond_21 = BIF.maps__is_key__2 [ErlangAtom "state", c_7]
  in let
    lop_20 =
      case cond_21 of
        (ErlangAtom "true") ->
          let   
            arg_25 =
              ErlangBinary (BIN.fromInts (toErl "state") (toErl 8) 1 BIN.Big)
          in let arg_26 = BIF.maps__get__2 [ErlangAtom "state", c_7]
          in let
            lcRet_24 =
              BIF.erlang__apply__2
                [mktdef_19,
                 ErlangCons arg_25 (ErlangCons arg_26 ErlangEmptyList)]
          in ErlangCons lcRet_24 ErlangEmptyList
        _ -> ErlangEmptyList
  in let cond_32 = BIF.maps__is_key__2 [ErlangAtom "event", c_7]
  in let
    lop_31 =
      case cond_32 of
        (ErlangAtom "true") ->
          let   
            arg_36 =
              ErlangBinary (BIN.fromInts (toErl "event") (toErl 8) 1 BIN.Big)
          in let arg_37 = BIF.maps__get__2 [ErlangAtom "event", c_7]
          in let
            lcRet_35 =
              BIF.erlang__apply__2
                [mktdef_19,
                 ErlangCons arg_36 (ErlangCons arg_37 ErlangEmptyList)]
          in ErlangCons lcRet_35 ErlangEmptyList
        _ -> ErlangEmptyList
  in let rop_30 = BIF.erlang__op_append [lop_31, ts0_5]
  in let ts_42 = BIF.erlang__op_append [lop_20, rop_30]
  in let head_43 = erlps__payable__1 [payable_4]
  in let
    head_46 =
      case kind_3 of
        (ErlangAtom "contract_main") -> toErl "main contract "
        (ErlangAtom "contract_child") -> toErl "contract "
        (ErlangAtom "contract_interface") -> toErl "contract interface "
        something_else -> EXC.case_clause something_else
  in let arg_50 = toErl "~s"
  in let
    head_49 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_50, ErlangCons name_2 ErlangEmptyList]
  in let head_55 = toErl " =\n"
  in let head_57 = erlps__decode_tdefs__1 [ts_42]
  in let head_60 = erlps__decode_funcs__1 [fs_6]
  in
    ErlangCons head_43
      (ErlangCons head_46
         (ErlangCons head_49
            (ErlangCons head_55
               (ErlangCons head_57 (ErlangCons head_60 ErlangEmptyList)))))
erlps__decode_contract__1 [(ErlangMap map_0)]
  | (DM.Just (ErlangMap map_1)) <-
      (Map.lookup (ErlangAtom "namespace") map_0)
  , (DM.Just ts_3) <- (Map.lookup (ErlangAtom "type_defs") map_1)
  , (DM.Just name_2) <- (Map.lookup (ErlangAtom "name") map_1)
  , weakNEq ts_3 ErlangEmptyList =
  let    head_4 = toErl "namespace "
  in let arg_7 = toErl "~s"
  in let
    head_6 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_7, ErlangCons name_2 ErlangEmptyList]
  in let head_12 = toErl " =\n"
  in let head_14 = erlps__decode_tdefs__1 [ts_3]
  in
    ErlangCons head_4
      (ErlangCons head_6
         (ErlangCons head_12 (ErlangCons head_14 ErlangEmptyList)))
erlps__decode_contract__1 [_] = ErlangEmptyList
erlps__decode_contract__1 [arg_0] = EXC.function_clause unit
erlps__decode_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_contract__1) args

erlps__decode_funcs__1 :: ErlangFun
erlps__decode_funcs__1 [fs_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__decode_func__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    fs_0
erlps__decode_funcs__1 [arg_6] = EXC.function_clause unit
erlps__decode_funcs__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_funcs__1) args

erlps__decode_func__1 :: ErlangFun
erlps__decode_func__1 [(ErlangMap map_0)]
  | (DM.Just t_4) <- (Map.lookup (ErlangAtom "returns") map_0)
  , (DM.Just as_3) <- (Map.lookup (ErlangAtom "arguments") map_0)
  , (DM.Just payable_2) <-
      (Map.lookup (ErlangAtom "payable") map_0)
  , (DM.Just name_1) <- (Map.lookup (ErlangAtom "name") map_0) =
  let    head_5 = toErl "  "
  in let head_7 = erlps__payable__1 [payable_2]
  in let head_10 = toErl "entrypoint "
  in let arg_13 = toErl "~s"
  in let
    head_12 =
      BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
        [arg_13, ErlangCons name_1 ErlangEmptyList]
  in let head_18 = toErl " : "
  in let head_20 = erlps__decode_args__1 [as_3]
  in let head_23 = toErl " => "
  in let head_25 = erlps__decode_type__1 [t_4]
  in let head_28 = toErl 10
  in
    ErlangCons head_5
      (ErlangCons head_7
         (ErlangCons head_10
            (ErlangCons head_12
               (ErlangCons head_18
                  (ErlangCons head_20
                     (ErlangCons head_23
                        (ErlangCons head_25
                           (ErlangCons head_28 ErlangEmptyList))))))))
erlps__decode_func__1 [arg_30] = EXC.function_clause unit
erlps__decode_func__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_func__1) args

erlps__decode_args__1 :: ErlangFun
erlps__decode_args__1 [as_0] =
  let   
    das_6 =
      flmap
        (\ lc_3 ->
           let lcRet_4 = erlps__decode_arg__1 [lc_3]
           in ErlangCons lcRet_4 ErlangEmptyList)
        as_0
  in let head_7 = toErl 40
  in let arg_10 = toErl ", "
  in let
    head_9 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_10, das_6]
  in let head_13 = toErl 41
  in
    ErlangCons head_7
      (ErlangCons head_9 (ErlangCons head_13 ErlangEmptyList))
erlps__decode_args__1 [arg_15] = EXC.function_clause unit
erlps__decode_args__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_args__1) args

erlps__decode_arg__1 :: ErlangFun
erlps__decode_arg__1 [(ErlangMap map_0)]
  | (DM.Just t_1) <- (Map.lookup (ErlangAtom "type") map_0) =
  erlps__decode_type__1 [t_1]
erlps__decode_arg__1 [arg_3] = EXC.function_clause unit
erlps__decode_arg__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_arg__1) args

erlps__decode_types__1 :: ErlangFun
erlps__decode_types__1 [ets_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__decode_type__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    ets_0
erlps__decode_types__1 [arg_6] = EXC.function_clause unit
erlps__decode_types__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_types__1) args

erlps__decode_type__1 :: ErlangFun
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just ets_1) <- (Map.lookup (ErlangAtom "tuple") map_0) =
  let ts_3 = erlps__decode_types__1 [ets_1]
  in
    case ts_3 of
      (ErlangEmptyList) ->
        let head_5 = toErl "unit"
        in ErlangCons head_5 ErlangEmptyList
      _ ->
        let    head_7 = toErl 40
        in let arg_10 = toErl " * "
        in let
          head_9 =
            BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_10, ts_3]
        in let head_13 = toErl 41
        in
          ErlangCons head_7
            (ErlangCons head_9 (ErlangCons head_13 ErlangEmptyList))
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just efs_1) <- (Map.lookup (ErlangAtom "record") map_0) =
  let    fs_3 = erlps__decode_fields__1 [efs_1]
  in let head_4 = toErl 123
  in let arg_7 = toErl ","
  in let
    head_6 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_7, fs_3]
  in let head_10 = toErl 125
  in
    ErlangCons head_4
      (ErlangCons head_6 (ErlangCons head_10 ErlangEmptyList))
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just (ErlangCons et_1 (ErlangEmptyList))) <-
      (Map.lookup (ErlangAtom "list") map_0) =
  let    t_3 = erlps__decode_type__1 [et_1]
  in let head_4 = toErl "list"
  in let head_6 = toErl 40
  in let head_10 = toErl 41
  in
    ErlangCons head_4
      (ErlangCons head_6
         (ErlangCons t_3 (ErlangCons head_10 ErlangEmptyList)))
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just ets_1) <- (Map.lookup (ErlangAtom "map") map_0) =
  let    ts_3 = erlps__decode_types__1 [ets_1]
  in let head_4 = toErl "map"
  in let head_6 = toErl 40
  in let arg_9 = toErl ","
  in let
    head_8 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_9, ts_3]
  in let head_12 = toErl 41
  in
    ErlangCons head_4
      (ErlangCons head_6
         (ErlangCons head_8 (ErlangCons head_12 ErlangEmptyList)))
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just len_1) <- (Map.lookup (ErlangAtom "bytes") map_0) =
  let    head_2 = toErl "bytes("
  in let head_4 = BIF.erlang__integer_to_list__1 [len_1]
  in let head_7 = toErl ")"
  in
    ErlangCons head_2
      (ErlangCons head_4 (ErlangCons head_7 ErlangEmptyList))
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just ets_1) <- (Map.lookup (ErlangAtom "variant") map_0) =
  let    ts_3 = erlps__decode_types__1 [ets_1]
  in let arg_4 = toErl " | "
  in BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_4, ts_3]
erlps__decode_type__1 [(ErlangMap map_0)]
  | (DM.Just (ErlangMap map_1)) <-
      (Map.lookup (ErlangAtom "function") map_0)
  , (DM.Just r_3) <- (Map.lookup (ErlangAtom "returns") map_1)
  , (DM.Just args_2) <-
      (Map.lookup (ErlangAtom "arguments") map_1) =
  let   
    arg_5 = ErlangMap (Map.singleton (ErlangAtom "tuple") args_2)
  in let head_4 = erlps__decode_type__1 [arg_5]
  in let head_9 = toErl " => "
  in let head_11 = erlps__decode_type__1 [r_3]
  in
    ErlangCons head_4
      (ErlangCons head_9 (ErlangCons head_11 ErlangEmptyList))
erlps__decode_type__1 [econs_0] | isEMap econs_0 =
  let matchExpr_4 = BIF.maps__to_list__1 [econs_0]
  in
    case matchExpr_4 of
      (ErlangCons (ErlangTuple [ec_2, ets_3]) (ErlangEmptyList)) ->
        let    appname_6 = erlps__decode_name__1 [ec_2]
        in let appargs_8 = erlps__decode_types__1 [ets_3]
        in
          case appargs_8 of
            (ErlangEmptyList) -> ErlangCons appname_6 ErlangEmptyList
            _ ->
              let    head_14 = toErl 40
              in let arg_17 = toErl ", "
              in let
                head_16 =
                  BIF.do_remote_fun_call "Lists" "erlps__join__2"
                    [arg_17, appargs_8]
              in let head_20 = toErl 41
              in
                ErlangCons appname_6
                  (ErlangCons head_14
                     (ErlangCons head_16 (ErlangCons head_20 ErlangEmptyList)))
      _ -> EXC.badmatch matchExpr_4
erlps__decode_type__1 [t_0] = erlps__decode_name__1 [t_0]
erlps__decode_type__1 [arg_2] = EXC.function_clause unit
erlps__decode_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_type__1) args

erlps__decode_name__1 :: ErlangFun
erlps__decode_name__1 [en_0] | isEAtom en_0 =
  BIF.erlang__atom_to_list__1 [en_0]
erlps__decode_name__1 [en_0] | isEBinary en_0 =
  BIF.erlang__binary_to_list__1 [en_0]
erlps__decode_name__1 [arg_2] = EXC.function_clause unit
erlps__decode_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_name__1) args

erlps__decode_fields__1 :: ErlangFun
erlps__decode_fields__1 [efs_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__decode_field__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    efs_0
erlps__decode_fields__1 [arg_6] = EXC.function_clause unit
erlps__decode_fields__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_fields__1) args

erlps__decode_field__1 :: ErlangFun
erlps__decode_field__1 [(ErlangMap map_0)]
  | (DM.Just et_2) <- (Map.lookup (ErlangAtom "type") map_0)
  , (DM.Just en_1) <- (Map.lookup (ErlangAtom "name") map_0) =
  let    name_4 = erlps__decode_name__1 [en_1]
  in let type_6 = erlps__decode_type__1 [et_2]
  in let head_9 = toErl " : "
  in
    ErlangCons name_4
      (ErlangCons head_9 (ErlangCons type_6 ErlangEmptyList))
erlps__decode_field__1 [arg_13] = EXC.function_clause unit
erlps__decode_field__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_field__1) args

erlps__decode_tdefs__1 :: ErlangFun
erlps__decode_tdefs__1 [ts_0] =
  flmap
    (\ lc_3 ->
       let lcRet_4 = erlps__decode_tdef__1 [lc_3]
       in ErlangCons lcRet_4 ErlangEmptyList)
    ts_0
erlps__decode_tdefs__1 [arg_6] = EXC.function_clause unit
erlps__decode_tdefs__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_tdefs__1) args

erlps__decode_tdef__1 :: ErlangFun
erlps__decode_tdef__1 [(ErlangMap map_0)]
  | (DM.Just t_3) <- (Map.lookup (ErlangAtom "typedef") map_0)
  , (DM.Just vs_2) <- (Map.lookup (ErlangAtom "vars") map_0)
  , (DM.Just name_1) <- (Map.lookup (ErlangAtom "name") map_0) =
  let    typedef_5 = erlps__decode_type__1 [t_3]
  in let deftype_7 = erlps__decode_deftype__1 [t_3]
  in let head_8 = toErl "  "
  in let head_12 = toErl " "
  in let head_14 = erlps__decode_name__1 [name_1]
  in let head_17 = erlps__decode_tvars__1 [vs_2]
  in let head_20 = toErl " = "
  in let head_24 = toErl 10
  in
    ErlangCons head_8
      (ErlangCons deftype_7
         (ErlangCons head_12
            (ErlangCons head_14
               (ErlangCons head_17
                  (ErlangCons head_20
                     (ErlangCons typedef_5
                        (ErlangCons head_24 ErlangEmptyList)))))))
erlps__decode_tdef__1 [arg_26] = EXC.function_clause unit
erlps__decode_tdef__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_tdef__1) args

erlps__decode_deftype__1 :: ErlangFun
erlps__decode_deftype__1 [(ErlangMap map_0)]
  | (DM.Just _efs_1) <- (Map.lookup (ErlangAtom "record") map_0) =
  toErl "record"
erlps__decode_deftype__1 [(ErlangMap map_0)]
  | (DM.Just _) <- (Map.lookup (ErlangAtom "variant") map_0) =
  toErl "datatype"
erlps__decode_deftype__1 [_t_0] = toErl "type"
erlps__decode_deftype__1 [arg_1] = EXC.function_clause unit
erlps__decode_deftype__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_deftype__1) args

erlps__decode_tvars__1 :: ErlangFun
erlps__decode_tvars__1 [(ErlangEmptyList)] = ErlangEmptyList
erlps__decode_tvars__1 [vs_0] =
  let   
    dvs_6 =
      flmap
        (\ lc_3 ->
           let lcRet_4 = erlps__decode_tvar__1 [lc_3]
           in ErlangCons lcRet_4 ErlangEmptyList)
        vs_0
  in let head_7 = toErl 40
  in let arg_10 = toErl ", "
  in let
    head_9 =
      BIF.do_remote_fun_call "Lists" "erlps__join__2" [arg_10, dvs_6]
  in let head_13 = toErl 41
  in
    ErlangCons head_7
      (ErlangCons head_9 (ErlangCons head_13 ErlangEmptyList))
erlps__decode_tvars__1 [arg_15] = EXC.function_clause unit
erlps__decode_tvars__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_tvars__1) args

erlps__decode_tvar__1 :: ErlangFun
erlps__decode_tvar__1 [(ErlangMap map_0)]
  | (DM.Just n_1) <- (Map.lookup (ErlangAtom "name") map_0) =
  let arg_2 = toErl "~s"
  in
    BIF.do_remote_fun_call "Io.Lib" "erlps__format__2"
      [arg_2, ErlangCons n_1 ErlangEmptyList]
erlps__decode_tvar__1 [arg_6] = EXC.function_clause unit
erlps__decode_tvar__1 args =
  EXC.badarity (ErlangFun 1 erlps__decode_tvar__1) args

erlps__payable__1 :: ErlangFun
erlps__payable__1 [(ErlangAtom "true")] = toErl "payable "
erlps__payable__1 [(ErlangAtom "false")] = toErl ""
erlps__payable__1 [arg_0] = EXC.function_clause unit
erlps__payable__1 args =
  EXC.badarity (ErlangFun 1 erlps__payable__1) args

erlps__contract_funcs__1 :: ErlangFun
erlps__contract_funcs__1 [(ErlangTuple [c_0, _, _, decls_1])]
  | (((==) c_0 (ErlangAtom "contract_main")) ||
       (((==) c_0 (ErlangAtom "contract_interface")) ||
          ((==) c_0 (ErlangAtom "contract_child")))) ||
      (weakEq c_0 (ErlangAtom "namespace")) =
  flmap
    (\ lc_4 ->
       let cond_5 = erlps__is_fun__1 [lc_4]
       in
         case cond_5 of
           (ErlangAtom "true") -> ErlangCons lc_4 ErlangEmptyList
           _ -> ErlangEmptyList)
    decls_1
erlps__contract_funcs__1 [arg_8] = EXC.function_clause unit
erlps__contract_funcs__1 args =
  EXC.badarity (ErlangFun 1 erlps__contract_funcs__1) args

erlps__contract_types__1 :: ErlangFun
erlps__contract_types__1 [(ErlangTuple [c_0, _, _, decls_1])]
  | (((==) c_0 (ErlangAtom "contract_main")) ||
       (((==) c_0 (ErlangAtom "contract_interface")) ||
          ((==) c_0 (ErlangAtom "contract_child")))) ||
      (weakEq c_0 (ErlangAtom "namespace")) =
  flmap
    (\ lc_4 ->
       let cond_5 = erlps__is_type__1 [lc_4]
       in
         case cond_5 of
           (ErlangAtom "true") -> ErlangCons lc_4 ErlangEmptyList
           _ -> ErlangEmptyList)
    decls_1
erlps__contract_types__1 [arg_8] = EXC.function_clause unit
erlps__contract_types__1 args =
  EXC.badarity (ErlangFun 1 erlps__contract_types__1) args

erlps__is_fun__1 :: ErlangFun
erlps__is_fun__1 [(ErlangTuple [(ErlangAtom "letfun"), _, _, _,
                                _, _])]
  =
  ErlangAtom "true"
erlps__is_fun__1 [(ErlangTuple [(ErlangAtom "fun_decl"), _, _,
                                _])]
  =
  ErlangAtom "true"
erlps__is_fun__1 [_] = ErlangAtom "false"
erlps__is_fun__1 [arg_0] = EXC.function_clause unit
erlps__is_fun__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_fun__1) args

erlps__is_type__1 :: ErlangFun
erlps__is_type__1 [(ErlangTuple [(ErlangAtom "type_def"), _, _,
                                 _, _])]
  =
  ErlangAtom "true"
erlps__is_type__1 [_] = ErlangAtom "false"
erlps__is_type__1 [arg_0] = EXC.function_clause unit
erlps__is_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_type__1) args

erlps__sort_decls__1 :: ErlangFun
erlps__sort_decls__1 [ds_0] =
  let
    sort_14 =
      ErlangFun 2
        (let
           lambda_1 [d1_4, d2_5] =
             let    arg_9 = toErl 0
             in let
               lop_6 =
                 BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                   [ErlangAtom "line", d1_4, arg_9]
             in let arg_13 = toErl 0
             in let
               rop_10 =
                 BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
                   [ErlangAtom "line", d2_5, arg_13]
             in BIF.erlang__op_lesserEq [lop_6, rop_10]
           lambda_1 [arg_2, arg_3] = EXC.function_clause unit
           lambda_1 args = EXC.badarity (ErlangFun 2 lambda_1) args
         in lambda_1)
  in
    BIF.do_remote_fun_call "Lists" "erlps__sort__2" [sort_14, ds_0]
erlps__sort_decls__1 [arg_17] = EXC.function_clause unit
erlps__sort_decls__1 args =
  EXC.badarity (ErlangFun 1 erlps__sort_decls__1) args

erlps__is_entrypoint__1 :: ErlangFun
erlps__is_entrypoint__1 [node_0] =
  BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
    [ErlangAtom "entrypoint", node_0, ErlangAtom "false"]
erlps__is_entrypoint__1 [arg_4] = EXC.function_clause unit
erlps__is_entrypoint__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_entrypoint__1) args

erlps__is_stateful__1 :: ErlangFun
erlps__is_stateful__1 [node_0] =
  BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
    [ErlangAtom "stateful", node_0, ErlangAtom "false"]
erlps__is_stateful__1 [arg_4] = EXC.function_clause unit
erlps__is_stateful__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_stateful__1) args

erlps__is_payable__1 :: ErlangFun
erlps__is_payable__1 [node_0] =
  BIF.do_remote_fun_call "Aeso.Syntax" "erlps__get_ann__3"
    [ErlangAtom "payable", node_0, ErlangAtom "false"]
erlps__is_payable__1 [arg_4] = EXC.function_clause unit
erlps__is_payable__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_payable__1) args

erlps__typedef_name__1 :: ErlangFun
erlps__typedef_name__1 [(ErlangTuple [(ErlangAtom "type_def"), _,
                                      (ErlangTuple [(ErlangAtom "id"), _,
                                                    name_0]),
                                      _, _])]
  =
  name_0
erlps__typedef_name__1 [arg_1] = EXC.function_clause unit
erlps__typedef_name__1 args =
  EXC.badarity (ErlangFun 1 erlps__typedef_name__1) args

erlps__typedef_vars__1 :: ErlangFun
erlps__typedef_vars__1 [(ErlangTuple [(ErlangAtom "type_def"), _,
                                      _, vars_0, _])]
  =
  vars_0
erlps__typedef_vars__1 [arg_1] = EXC.function_clause unit
erlps__typedef_vars__1 args =
  EXC.badarity (ErlangFun 1 erlps__typedef_vars__1) args

erlps__typedef_def__1 :: ErlangFun
erlps__typedef_def__1 [(ErlangTuple [(ErlangAtom "type_def"), _,
                                     _, _, def_0])]
  =
  def_0
erlps__typedef_def__1 [arg_1] = EXC.function_clause unit
erlps__typedef_def__1 args =
  EXC.badarity (ErlangFun 1 erlps__typedef_def__1) args