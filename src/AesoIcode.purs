module Aeso.Icode(erlps__new__1, erlps__pp__1,
                  erlps__set_name__2, erlps__set_namespace__2,
                  erlps__set_payable__2, erlps__enter_namespace__2,
                  erlps__get_namespace__1, erlps__in_main_contract__1,
                  erlps__qualify__2, erlps__set_functions__2,
                  erlps__map_typerep__2, erlps__option_typerep__1,
                  erlps__get_constructor_tag__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__pp__1 :: ErlangFun
erlps__pp__1 [icode_0] =
  let arg_1 = toErl "~p~n"
  in
    BIF.do_remote_fun_call "Erlang.Io" "erlps__format__2"
      [arg_1, ErlangCons icode_0 ErlangEmptyList]
erlps__pp__1 [arg_5] = EXC.function_clause unit
erlps__pp__1 args = EXC.badarity (ErlangFun 1 erlps__pp__1) args

erlps__new__1 :: ErlangFun
erlps__new__1 [options_0] =
  let    val_11 = toErl ""
  in let val_13 = erlps__new_env__0 []
  in let val_14 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
  in let val_17 = ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
  in let val_20 = erlps__builtin_types__0 []
  in let val_21 = ErlangMap Map.empty
  in let val_22 = erlps__builtin_constructors__0 []
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangAtom "contract_name") val_11,
          DT.Tuple (ErlangAtom "functions") ErlangEmptyList,
          DT.Tuple (ErlangAtom "env") val_13,
          DT.Tuple (ErlangAtom "state_type") val_14,
          DT.Tuple (ErlangAtom "event_type") val_17,
          DT.Tuple (ErlangAtom "types") val_20,
          DT.Tuple (ErlangAtom "type_vars") val_21,
          DT.Tuple (ErlangAtom "constructors") val_22,
          DT.Tuple (ErlangAtom "options") options_0,
          DT.Tuple (ErlangAtom "payable") (ErlangAtom "false")])
erlps__new__1 [arg_25] = EXC.function_clause unit
erlps__new__1 args =
  EXC.badarity (ErlangFun 1 erlps__new__1) args

erlps__builtin_types__0 :: ErlangFun
erlps__builtin_types__0 [] =
  let   
    word_2 =
      ErlangFun 1
        (let
           lambda_0 [(ErlangEmptyList)] = ErlangAtom "word"
           lambda_0 [arg_1] = EXC.function_clause unit
           lambda_0 args = EXC.badarity (ErlangFun 1 lambda_0) args
         in lambda_0)
  in let key_3 = toErl "bool"
  in let key_4 = toErl "int"
  in let key_5 = toErl "char"
  in let key_6 = toErl "bits"
  in let key_7 = toErl "string"
  in let key_8 = toErl "address"
  in let key_9 = toErl "hash"
  in let key_10 = toErl "unit"
  in let key_11 = toErl "signature"
  in let key_12 = toErl "oracle"
  in let key_13 = toErl "oracle_query"
  in let key_14 = toErl "list"
  in let key_15 = toErl "option"
  in let key_16 = toErl "map"
  in let head_18 = toErl "Chain"
  in let head_20 = toErl "ttl"
  in let head_23 = toErl "AENS"
  in let head_25 = toErl "pointee"
  in let
    val_31 =
      ErlangFun 1
        (let
           lambda_32 [(ErlangEmptyList)] = ErlangAtom "string"
           lambda_32 [arg_33] = EXC.function_clause unit
           lambda_32 args = EXC.badarity (ErlangFun 1 lambda_32) args
         in lambda_32)
  in let
    val_36 =
      ErlangFun 1
        (let
           lambda_37 [(ErlangEmptyList)] =
             ErlangTuple [ErlangAtom "tuple", ErlangEmptyList]
           lambda_37 [arg_38] = EXC.function_clause unit
           lambda_37 args = EXC.badarity (ErlangFun 1 lambda_37) args
         in lambda_37)
  in let
    val_41 =
      ErlangFun 1
        (let
           lambda_42 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "tuple",
                ErlangCons (ErlangAtom "word")
                  (ErlangCons (ErlangAtom "word") ErlangEmptyList)]
           lambda_42 [arg_43] = EXC.function_clause unit
           lambda_42 args = EXC.badarity (ErlangFun 1 lambda_42) args
         in lambda_42)
  in let
    val_50 =
      ErlangFun 1
        (let
           lambda_51 [(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))] =
             ErlangAtom "word"
           lambda_51 [arg_52] = EXC.function_clause unit
           lambda_51 args = EXC.badarity (ErlangFun 1 lambda_51) args
         in lambda_51)
  in let
    val_53 =
      ErlangFun 1
        (let
           lambda_54 [(ErlangCons _ (ErlangCons _ (ErlangEmptyList)))] =
             ErlangAtom "word"
           lambda_54 [arg_55] = EXC.function_clause unit
           lambda_54 args = EXC.badarity (ErlangFun 1 lambda_54) args
         in lambda_54)
  in let
    val_56 =
      ErlangFun 1
        (let
           lambda_57 [(ErlangCons a_59 (ErlangEmptyList))] =
             ErlangTuple [ErlangAtom "list", a_59]
           lambda_57 [arg_58] = EXC.function_clause unit
           lambda_57 args = EXC.badarity (ErlangFun 1 lambda_57) args
         in lambda_57)
  in let
    val_62 =
      ErlangFun 1
        (let
           lambda_63 [(ErlangCons a_65 (ErlangEmptyList))] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons ErlangEmptyList
                  (ErlangCons (ErlangCons a_65 ErlangEmptyList)
                     ErlangEmptyList)]
           lambda_63 [arg_64] = EXC.function_clause unit
           lambda_63 args = EXC.badarity (ErlangFun 1 lambda_63) args
         in lambda_63)
  in let
    val_74 =
      ErlangFun 1
        (let
           lambda_75 [(ErlangCons k_77 (ErlangCons v_78 (ErlangEmptyList)))]
             =
             erlps__map_typerep__2 [k_77, v_78]
           lambda_75 [arg_76] = EXC.function_clause unit
           lambda_75 args = EXC.badarity (ErlangFun 1 lambda_75) args
         in lambda_75)
  in let
    val_81 =
      ErlangFun 1
        (let
           lambda_82 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons (ErlangCons (ErlangAtom "word") ErlangEmptyList)
                  (ErlangCons (ErlangCons (ErlangAtom "word") ErlangEmptyList)
                     ErlangEmptyList)]
           lambda_82 [arg_83] = EXC.function_clause unit
           lambda_82 args = EXC.badarity (ErlangFun 1 lambda_82) args
         in lambda_82)
  in let
    val_94 =
      ErlangFun 1
        (let
           lambda_95 [(ErlangEmptyList)] =
             ErlangTuple
               [ErlangAtom "variant",
                ErlangCons (ErlangCons (ErlangAtom "word") ErlangEmptyList)
                  (ErlangCons (ErlangCons (ErlangAtom "word") ErlangEmptyList)
                     (ErlangCons
                        (ErlangCons (ErlangAtom "word") ErlangEmptyList)
                        ErlangEmptyList))]
           lambda_95 [arg_96] = EXC.function_clause unit
           lambda_95 args = EXC.badarity (ErlangFun 1 lambda_95) args
         in lambda_95)
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple key_3 word_2, DT.Tuple key_4 word_2,
          DT.Tuple key_5 word_2, DT.Tuple key_6 word_2,
          DT.Tuple key_7 val_31, DT.Tuple key_8 word_2,
          DT.Tuple key_9 word_2, DT.Tuple key_10 val_36,
          DT.Tuple key_11 val_41, DT.Tuple key_12 val_50,
          DT.Tuple key_13 val_53, DT.Tuple key_14 val_56,
          DT.Tuple key_15 val_62, DT.Tuple key_16 val_74,
          DT.Tuple
            (ErlangCons head_18 (ErlangCons head_20 ErlangEmptyList)) val_81,
          DT.Tuple
            (ErlangCons head_23 (ErlangCons head_25 ErlangEmptyList))
            val_94])
erlps__builtin_types__0 args =
  EXC.badarity (ErlangFun 0 erlps__builtin_types__0) args

erlps__builtin_constructors__0 :: ErlangFun
erlps__builtin_constructors__0 [] =
  let    head_1 = toErl "RelativeTTL"
  in let head_4 = toErl "FixedTTL"
  in let head_7 = toErl "None"
  in let head_10 = toErl "Some"
  in let head_13 = toErl "AccountPointee"
  in let head_16 = toErl "OraclePointee"
  in let head_19 = toErl "ContractPointee"
  in let val_21 = toErl 0
  in let val_22 = toErl 1
  in let val_23 = toErl 0
  in let val_24 = toErl 1
  in let val_25 = toErl 0
  in let val_26 = toErl 1
  in let val_27 = toErl 2
  in
    ErlangMap
      (Map.fromFoldable
         [DT.Tuple (ErlangCons head_1 ErlangEmptyList) val_21,
          DT.Tuple (ErlangCons head_4 ErlangEmptyList) val_22,
          DT.Tuple (ErlangCons head_7 ErlangEmptyList) val_23,
          DT.Tuple (ErlangCons head_10 ErlangEmptyList) val_24,
          DT.Tuple (ErlangCons head_13 ErlangEmptyList) val_25,
          DT.Tuple (ErlangCons head_16 ErlangEmptyList) val_26,
          DT.Tuple (ErlangCons head_19 ErlangEmptyList) val_27])
erlps__builtin_constructors__0 args =
  EXC.badarity (ErlangFun 0 erlps__builtin_constructors__0) args

erlps__map_typerep__2 :: ErlangFun
erlps__map_typerep__2 [k_0, v_1] =
  ErlangTuple [ErlangAtom "map", k_0, v_1]
erlps__map_typerep__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__map_typerep__2 args =
  EXC.badarity (ErlangFun 2 erlps__map_typerep__2) args

erlps__option_typerep__1 :: ErlangFun
erlps__option_typerep__1 [a_0] =
  ErlangTuple
    [ErlangAtom "variant",
     ErlangCons ErlangEmptyList
       (ErlangCons (ErlangCons a_0 ErlangEmptyList) ErlangEmptyList)]
erlps__option_typerep__1 [arg_9] = EXC.function_clause unit
erlps__option_typerep__1 args =
  EXC.badarity (ErlangFun 1 erlps__option_typerep__1) args

erlps__new_env__0 :: ErlangFun
erlps__new_env__0 [] = ErlangEmptyList
erlps__new_env__0 args =
  EXC.badarity (ErlangFun 0 erlps__new_env__0) args

erlps__set_name__2 :: ErlangFun
erlps__set_name__2 [name_0, icode_1] =
  BIF.maps__put__3 [ErlangAtom "contract_name", name_0, icode_1]
erlps__set_name__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__set_name__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_name__2) args

erlps__set_payable__2 :: ErlangFun
erlps__set_payable__2 [payable_0, icode_1] =
  BIF.maps__put__3 [ErlangAtom "payable", payable_0, icode_1]
erlps__set_payable__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__set_payable__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_payable__2) args

erlps__set_namespace__2 :: ErlangFun
erlps__set_namespace__2 [ns_0, icode_1] =
  let
    mapExt_5 =
      ErlangMap (Map.singleton (ErlangAtom "namespace") ns_0)
  in BIF.maps__merge__2 [icode_1, mapExt_5]
erlps__set_namespace__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__set_namespace__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_namespace__2) args

erlps__enter_namespace__2 :: ErlangFun
erlps__enter_namespace__2 [ns_0, icode_3@(ErlangMap map_1)]
  | (DM.Just ns1_2) <-
      (Map.lookup (ErlangAtom "namespace") map_1) =
  let   
    val_6 =
      BIF.do_remote_fun_call "Aeso.Syntax" "erlps__qualify__2"
        [ns1_2, ns_0]
  in let
    mapExt_9 =
      ErlangMap (Map.singleton (ErlangAtom "namespace") val_6)
  in BIF.maps__merge__2 [icode_3, mapExt_9]
erlps__enter_namespace__2 [ns_0, icode_1] =
  let
    mapExt_5 =
      ErlangMap (Map.singleton (ErlangAtom "namespace") ns_0)
  in BIF.maps__merge__2 [icode_1, mapExt_5]
erlps__enter_namespace__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__enter_namespace__2 args =
  EXC.badarity (ErlangFun 2 erlps__enter_namespace__2) args

erlps__in_main_contract__1 :: ErlangFun
erlps__in_main_contract__1 [(ErlangMap map_0)]
  | (DM.Just main_2) <-
      (Map.lookup (ErlangAtom "contract_name") map_0)
  , (DM.Just (ErlangTuple [(ErlangAtom "con"), _, main_1])) <-
      (Map.lookup (ErlangAtom "namespace") map_0)
  , main_2 == main_1 =
  ErlangAtom "true"
erlps__in_main_contract__1 [_icode_0] = ErlangAtom "false"
erlps__in_main_contract__1 [arg_1] = EXC.function_clause unit
erlps__in_main_contract__1 args =
  EXC.badarity (ErlangFun 1 erlps__in_main_contract__1) args

erlps__get_namespace__1 :: ErlangFun
erlps__get_namespace__1 [icode_0] =
  BIF.do_remote_fun_call "Maps" "erlps__get__3"
    [ErlangAtom "namespace", icode_0, ErlangAtom "false"]
erlps__get_namespace__1 [arg_4] = EXC.function_clause unit
erlps__get_namespace__1 args =
  EXC.badarity (ErlangFun 1 erlps__get_namespace__1) args

erlps__qualify__2 :: ErlangFun
erlps__qualify__2 [x_0, icode_1] =
  let case_2 = erlps__get_namespace__1 [icode_1]
  in
    case case_2 of
      (ErlangAtom "false") -> x_0
      ns_4 ->
        BIF.do_remote_fun_call "Aeso.Syntax" "erlps__qualify__2"
          [ns_4, x_0]
erlps__qualify__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__qualify__2 args =
  EXC.badarity (ErlangFun 2 erlps__qualify__2) args

erlps__set_functions__2 :: ErlangFun
erlps__set_functions__2 [newfuns_0, icode_1] =
  BIF.maps__put__3 [ErlangAtom "functions", newfuns_0, icode_1]
erlps__set_functions__2 [arg_5, arg_6] = EXC.function_clause unit
erlps__set_functions__2 args =
  EXC.badarity (ErlangFun 2 erlps__set_functions__2) args

erlps__get_constructor_tag__2 :: ErlangFun
erlps__get_constructor_tag__2 [name_0, (ErlangMap map_1)]
  | (DM.Just constructors_2) <-
      (Map.lookup (ErlangAtom "constructors") map_1) =
  let
    case_3 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [name_0, constructors_2, ErlangAtom "undefined"]
  in
    case case_3 of
      (ErlangAtom "undefined") ->
        let
          arg_7 = ErlangTuple [ErlangAtom "undefined_constructor", name_0]
        in BIF.erlang__error__1 [arg_7]
      tag_10 -> tag_10
erlps__get_constructor_tag__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__get_constructor_tag__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_constructor_tag__2) args