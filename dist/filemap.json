{
"aesophia/test/contracts/address_chain.aes":"contract Remote =\n  entrypoint main : (int) => unit\n\ncontract AddrChain =\n  type o_type = oracle(string, map(string, int))\n  type oq_type = oracle_query(string, map(string, int))\n\n  entrypoint is_o(a : address) =\n    Address.is_oracle(a)\n\n  entrypoint is_c(a : address) =\n    Address.is_contract(a)\n\n//   entrypoint get_o(a : address) : option(o_type) =\n//     Address.get_oracle(a)\n\n//   entrypoint get_c(a : address) : option(Remote) =\n//     Address.get_contract(a)\n\n  entrypoint check_o(o : o_type) =\n    Oracle.check(o)\n\n  entrypoint check_oq(o : o_type, oq : oq_type) =\n    Oracle.check_query(o, oq)\n\n//   entrypoint h_to_i(h : hash) : int =\n//     Hash.to_int(h)\n\n//   entrypoint a_to_i(a : address) : int =\n//     Address.to_int(a) mod 10 ^ 16\n\n  entrypoint c_creator() : address =\n    Contract.creator\n\n  entrypoint is_payable(a : address) : bool =\n    Address.is_payable(a)\n"
,
"aesophia/test/contracts/bad_unnamed_map_update_default.aes":"contract C =\n  entrypoint f() =\n    let z = 123\n    {}{ [1 = 0] = z + 1 }\n    2"
,
"aesophia/test/contracts/tuple_match.aes":"contract TuplesMatch =\n\n  function tuplify3() = (t) => switch(t)\n    (x, y, z) => 3\n\n  entrypoint fst(p : int * string) =\n    switch(p)\n      (x, y) => x\n  entrypoint fst'(p : int * string) =\n    switch(p)\n      (x, _) => x\n  entrypoint snd(p : int * string) =\n    switch(p)\n      (x, y) => y\n  entrypoint snd'(p : int * string) =\n    switch(p)\n      (_, y) => y\n  entrypoint sum(p) =\n    switch(p)\n      (x, y) => x + y\n  entrypoint swap(p : int * string) =\n    switch(p)\n      (x, y) => (y, x)\n  entrypoint id(p : int * int * string) =\n    switch(p)\n      (x, y, z) => (x, y, z)\n  entrypoint nest(p : (int * int) * string) =\n    switch(p)\n      (xy, z) => switch(xy) (x, y) => (x, y, z)\n  entrypoint deep(p : (int * int) * (int * int)) =\n    switch(p)\n      ((x, y), (z, w)) => (x, y, z, w)\n  entrypoint deep_sum(p : (int * int) * (int * int)) =\n    switch(p)\n      ((x, y), (z, w)) => x + y + z + w\n\n"
,
"aesophia/test/contracts/vsemi.aes":"contract VSemi =\n  record missing_brace = { x : int\n  entrypoint foo() = ()\n"
,
"aesophia/test/contracts/empty_typedecl.aes":"contract C =\n  type t\n  entrypoint f() = 123"
,
"aesophia/test/contracts/not_toplevel_contract.aes":"namespace BadNs =\n  contract Con =\n    entrypoint e : () => int\n\ncontract Con =\n  entrypoint foo() = 43\n"
,
"aesophia/test/contracts/bad_address_literals.aes":"\ncontract Remote =\n  entrypoint foo : () => unit\n\ncontract AddressLiterals =\n  entrypoint addr1() : bytes(32) =\n    ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt\n  entrypoint addr2() : Remote =\n    ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt\n  entrypoint addr3() : oracle(int, bool) =\n    ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt\n\n  entrypoint oracle1() : oracle_query(int, bool) =\n    ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5\n  entrypoint oracle2() : bytes(32) =\n    ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5\n  entrypoint oracle3() : Remote =\n    ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5\n\n  entrypoint query1() : oracle(int, bool) =\n    oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY\n  entrypoint query2() : bytes(32) =\n    oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY\n  entrypoint query3() : Remote =\n    oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY\n\n  entrypoint contr1() : address =\n    ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\n  entrypoint contr2() : oracle(int, bool) =\n    ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\n  entrypoint contr3() : bytes(32) =\n    ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\n  entrypoint contr4() : address =\n    Address.to_contract(Contract.address)\n\n"
,
"aesophia/test/contracts/maps.aes":"contract Maps =\n\n  record pt    = {x : int, y : int}\n  record state = { map_i : map(int, pt),\n                   map_s : map(string, pt) }\n\n  entrypoint init() = { map_i = {}, map_s = {} }\n\n  entrypoint get_state() = state\n\n  // {[k] = v}\n  entrypoint map_i() =\n    { [1] = {x = 1, y = 2},\n      [2] = {x = 3, y = 4},\n      [3] = {x = 5, y = 6} }\n  entrypoint map_s() =\n    { [\"one\"]   = {x = 1, y = 2},\n      [\"two\"]   = {x = 3, y = 4},\n      [\"three\"] = {x = 5, y = 6} }\n  stateful entrypoint map_state_i() = put(state{ map_i = map_i() })\n  stateful entrypoint map_state_s() = put(state{ map_s = map_s() })\n\n  // m[k]\n  entrypoint get_i(k, m : map(int,    pt)) = m[k]\n  entrypoint get_s(k, m : map(string, pt)) = m[k]\n  entrypoint get_state_i(k) = get_i(k, state.map_i)\n  entrypoint get_state_s(k) = get_s(k, state.map_s)\n\n  // m[k = v]\n  entrypoint get_def_i(k, v, m : map(int,    pt)) = m[k = v]\n  entrypoint get_def_s(k, v, m : map(string, pt)) = m[k = v]\n  entrypoint get_def_state_i(k, v) = get_def_i(k, v, state.map_i)\n  entrypoint get_def_state_s(k, v) = get_def_s(k, v, state.map_s)\n\n  // m{[k] = v}\n  entrypoint set_i(k, p, m : map(int,    pt)) = m{ [k] = p }\n  entrypoint set_s(k, p, m : map(string, pt)) = m{ [k] = p }\n  stateful entrypoint set_state_i(k, p) = put(state{ map_i = set_i(k, p, state.map_i) })\n  stateful entrypoint set_state_s(k, p) = put(state{ map_s = set_s(k, p, state.map_s) })\n\n  // m{f[k].x = v}\n  entrypoint setx_i(k, x, m : map(int,    pt)) = m{ [k].x = x }\n  entrypoint setx_s(k, x, m : map(string, pt)) = m{ [k].x = x }\n  stateful entrypoint setx_state_i(k, x) = put(state{ map_i[k].x = x })\n  stateful entrypoint setx_state_s(k, x) = put(state{ map_s[k].x = x })\n\n  // m{[k] @ x = v }\n  entrypoint addx_i(k, d, m : map(int,    pt)) = m{ [k].x @ x = x + d }\n  entrypoint addx_s(k, d, m : map(string, pt)) = m{ [k].x @ x = x + d }\n  stateful entrypoint addx_state_i(k, d) = put(state{ map_i[k].x @ x = x + d })\n  stateful entrypoint addx_state_s(k, d) = put(state{ map_s[k].x @ x = x + d })\n\n  // m{[k = def] @ x = v }\n  entrypoint addx_def_i(k, v, d, m : map(int,    pt)) = m{ [k = v].x @ x = x + d }\n  entrypoint addx_def_s(k, v, d, m : map(string, pt)) = m{ [k = v].x @ x = x + d }\n\n  // Map.member\n  entrypoint member_i(k, m : map(int,    pt)) = Map.member(k, m)\n  entrypoint member_s(k, m : map(string, pt)) = Map.member(k, m)\n  entrypoint member_state_i(k) = member_i(k, state.map_i)\n  entrypoint member_state_s(k) = member_s(k, state.map_s)\n\n  // Map.lookup\n  entrypoint lookup_i(k, m : map(int,    pt)) = Map.lookup(k, m)\n  entrypoint lookup_s(k, m : map(string, pt)) = Map.lookup(k, m)\n  entrypoint lookup_state_i(k) = lookup_i(k, state.map_i)\n  entrypoint lookup_state_s(k) = lookup_s(k, state.map_s)\n\n  // Map.lookup_default\n  entrypoint lookup_def_i(k, m : map(int,    pt), def : pt) =\n    Map.lookup_default(k, m, def)\n  entrypoint lookup_def_s(k, m : map(string, pt), def : pt) =\n    Map.lookup_default(k, m, def)\n  entrypoint lookup_def_state_i(k, def) = lookup_def_i(k, state.map_i, def)\n  entrypoint lookup_def_state_s(k, def) = lookup_def_s(k, state.map_s, def)\n\n  // Map.delete\n  entrypoint delete_i(k, m : map(int,    pt)) = Map.delete(k, m)\n  entrypoint delete_s(k, m : map(string, pt)) = Map.delete(k, m)\n  stateful entrypoint delete_state_i(k) = put(state{ map_i = delete_i(k, state.map_i) })\n  stateful entrypoint delete_state_s(k) = put(state{ map_s = delete_s(k, state.map_s) })\n\n  // Map.size\n  entrypoint size_i(m : map(int,    pt)) = Map.size(m)\n  entrypoint size_s(m : map(string, pt)) = Map.size(m)\n  entrypoint size_state_i() = size_i(state.map_i)\n  entrypoint size_state_s() = size_s(state.map_s)\n\n  // Map.to_list\n  entrypoint tolist_i(m : map(int,    pt)) = Map.to_list(m)\n  entrypoint tolist_s(m : map(string, pt)) = Map.to_list(m)\n  entrypoint tolist_state_i() = tolist_i(state.map_i)\n  entrypoint tolist_state_s() = tolist_s(state.map_s)\n\n  // Map.from_list\n  entrypoint fromlist_i(xs : list(int    * pt)) = Map.from_list(xs)\n  entrypoint fromlist_s(xs : list(string * pt)) = Map.from_list(xs)\n  stateful entrypoint fromlist_state_i(xs) = put(state{ map_i = fromlist_i(xs) })\n  stateful entrypoint fromlist_state_s(xs) = put(state{ map_s = fromlist_s(xs) })\n\n"
,
"aesophia/test/contracts/primitive_map.aes":"\ncontract MapServer =\n\n  function insert : (string, string, map(string, string)) => map(string, string)\n  function delete : (string, map(string, string)) => map(string, string)\n\ncontract PrimitiveMaps =\n\n  record state = { remote : MapServer,\n                   map    : map(string, string),\n                   map2   : map(string, string) }\n\n  function init(r) =\n    let m = {}\n    { remote = r, map = m, map2 = m }\n\n  function set_remote(r) = put(state{ remote = r })\n\n  function insert(k, v, m) : map(string, string) = m{ [k] = v }\n  function delete(k, m) : map(string, string) = Map.delete(k, m)\n\n  function remote_insert(k, v, m) =\n    state.remote.insert(k, v, m)\n\n  function remote_delete(k, m) =\n    state.remote.delete(k, m)\n\n  function get_state_map()  = state.map\n  function set_state_map(m) = put(state{ map = m })\n\n  function clone_state() = put(state{ map2 = state.map })\n\n  function insert_state(k, v) = put(state{ map @ m = m { [k] = v } })\n  function delete_state(k)    = put(state{ map @ m = Map.delete(k, m) })\n  function lookup_state(k)    = Map.lookup(k, state.map)\n\n  function double_insert_state(k, v1, v2) =\n    put(state{ map  @ m = m { [k] = v1 },\n               map2 @ m = m { [k] = v2 } })\n\n  function test() =\n    let m  = {} : map(string, string)\n    let m1 = m { [\"foo\"] = \"value_of_foo\",\n                 [\"bla\"] = \"value_of_bla\" }\n    let m2 = Map.delete(\"foo\", m1)\n    let m3 = m2 { [\"bla\"] = \"new_value_of_bla\" }\n    [Map.lookup(\"foo\", m),  Map.lookup(\"bla\", m),\n     Map.lookup(\"foo\", m1), Map.lookup(\"bla\", m1),\n     Map.lookup(\"foo\", m2), Map.lookup(\"bla\", m2),\n     Map.lookup(\"foo\", m3), Map.lookup(\"bla\", m3)]\n\n  function return_map() =\n    Map.delete(\"goo\", {[\"foo\"] = \"bar\", [\"goo\"] = \"gaa\"})\n\n  function argument_map(m : map(string, string)) =\n    m[\"foo\"]\n\n"
,
"aesophia/test/contracts/channel_on_chain_contract_name_resolution.aes":"contract ChannelOnChainContractNameResolution =\n\n  public function can_resolve(name: string, key: string) : bool =\n    switch(AENS.resolve(name, key) : option(string))\n      None           => false\n      Some(_address) => true\n\n"
,
"aesophia/test/contracts/channel_remote_on_chain_contract_name_resolution.aes":"contract Remote =\n  function get : () => int\n  function can_resolve : (string, string) => bool\n\ncontract RemoteCall =\n\n    function remote_resolve(r : Remote, name: string, key: string) : bool =\n        r.can_resolve(name, key)\n\n"
,
"aesophia/test/contracts/basic_auth.aes":"// Contract replicating \"normal\" Aeternity authentication\ncontract BasicAuth =\n  record state = { nonce : int, owner : address }\n\n  entrypoint init() = { nonce = 1, owner = Call.caller }\n\n  stateful entrypoint authorize(n : int, s : signature) : bool =\n    require(n >= state.nonce, \"Nonce too low\")\n    require(n =< state.nonce, \"Nonce too high\")\n    put(state{ nonce = n + 1 })\n    switch(Auth.tx_hash)\n      None          => abort(\"Not in Auth context\")\n      Some(tx_hash) => Crypto.verify_sig(to_sign(tx_hash, n), state.owner, s)\n\n  entrypoint to_sign(h : hash, n : int) =\n    Crypto.blake2b((h, n))\n\n  entrypoint weird_string() : string =\n    \"\\x19Weird String\\x42\\nMore\\n\"\n"
,
"aesophia/test/contracts/underscore_number_literals.aes":"\ncontract UnderscoreNumberLiterals =\n\n  entrypoint ints() : list(int) =\n    [ 1_999_000_000,\n      19_99_00_00_00,\n      0xfff_FFF_010 ]\n\n  entrypoint bytes() : list(bytes(4)) =\n    [ #abcd_ef_00,\n      #01_02_03_04,\n      #aaaa_FFFF ]\n\n"
,
"aesophia/test/contracts/double_include.aes":"include \"included.aes\"\ninclude \"../contracts/included.aes\"\n\ncontract Include =\n  entrypoint foo() =\n    Included.foo()\n\n"
,
"aesophia/test/contracts/name_clash.aes":"\ncontract NameClash =\n\n  entrypoint double_proto : () => int\n  entrypoint double_proto : () => int\n\n  entrypoint proto_and_def : int => int\n  entrypoint proto_and_def(n) = n + 1\n\n  entrypoint double_def(x) = x\n  entrypoint double_def(y) = 0\n\n  // abort, require, put and state are builtin\n  entrypoint abort() : int = 0\n  entrypoint require(b, err) = if(b) abort(err)\n  entrypoint put(x) = x\n  entrypoint state(x, y) = x + y\n"
,
"aesophia/test/contracts/included.aes":"namespace Included =\n  function foo() = 42\n"
,
"aesophia/test/contracts/manual_stdlib_include.aes":"// This should include Lists.aes implicitly, since Option.aes does.\ninclude \"Option.aes\"\n\ncontract Test =\n  entrypoint i_should_build() =\n    List.is_empty(Option.to_list(None))\n"
,
"aesophia/test/contracts/stack.aes":"// Testing more interesting state types\ncontract Stack =\n\n  type stack('a) = list('a)\n\n  record state = { stack : stack(string),\n                   size  : int }\n\n  entrypoint init(ss : list(string)) = { stack = ss, size = length(ss) }\n\n  function\n    length([])      = 0\n    length(_ :: xs) = length(xs) + 1\n\n  stateful entrypoint pop() : string =\n    switch(state.stack)\n      s :: ss =>\n        put(state{ stack = ss, size = state.size - 1 })\n        s\n\n  stateful entrypoint push(s) =\n    put(state{ stack = s :: state.stack, size = state.size + 1 })\n    state.size\n\n  entrypoint all() = state.stack\n\n  entrypoint size() = state.size\n\n"
,
"aesophia/test/contracts/cyclic_include_back.aes":"include \"cyclic_include_forth.aes\"\n\nnamespace Back =\n  function back() = 2\n"
,
"aesophia/test/contracts/operators.aes":"// - + * / mod \tarithmetic operators\n// ! && || \tlogical operators\n// == != < > =< >= \tcomparison operators\n// :: ++ \tlist operators\n\ncontract Operators =\n  function int_op(a : int, b : int, op : string) =\n    switch(op)\n      \"+\"    => a + b\n      \"-\"    => a - b\n      \"*\"    => a * b\n      \"/\"    => a / b\n      \"mod\"  => a mod b\n      \"^\"    => a ^ b\n\n  function bool_op(a : bool, b : bool, op : string) =\n    switch(op)\n      \"!\"  => !a\n      \"&&\" => a && b\n      \"||\" => a || b\n\n  function cmp_op(a : int, b : int, op : string) =\n    switch(op)\n      \"==\" => a == b\n      \"!=\" => a != b\n      \"<\"  => a < b\n      \">\"  => a > b\n      \"=<\" => a =< b\n      \">=\" => a >= b\n\n  function cons(a, l) = a :: l\n  function concat(l1, l2) = l1 ++ l2\n\n  function hash(s) = // String.sha3(s)\n    let x = String.sha3(s)\n    let y = String.sha3(s)\n    (x, y)\n"
,
"aesophia/test/contracts/fundme.aes":"/*\n * A simple crowd-funding example\n */\ncontract FundMe =\n\n  record spend_args = { recipient : address,\n                        amount    : int }\n\n  record state = { contributions : map(address, int),\n                   total         : int,\n                   beneficiary   : address,\n                   deadline      : int,\n                   goal          : int }\n\n  stateful function spend(args : spend_args) =\n    Chain.spend(args.recipient, args.amount)\n\n  entrypoint init(beneficiary, deadline, goal) : state =\n    { contributions = {},\n      beneficiary   = beneficiary,\n      deadline      = deadline,\n      total         = 0,\n      goal          = goal }\n\n  function is_contributor(addr) =\n    Map.member(addr, state.contributions)\n\n  stateful entrypoint contribute() =\n    if(Chain.block_height >= state.deadline)\n      spend({ recipient = Call.caller, amount = Call.value }) // Refund money\n      false\n    else\n      let amount =\n        Map.lookup_default(Call.caller, state.contributions, 0) + Call.value\n      put(state{ contributions[Call.caller] = amount,\n                 total @ tot = tot + Call.value })\n      true\n\n  stateful entrypoint withdraw() =\n    if(Chain.block_height < state.deadline)\n      abort(\"Cannot withdraw before deadline\")\n    if(Call.caller == state.beneficiary)\n      withdraw_beneficiary()\n    elif(is_contributor(Call.caller))\n      withdraw_contributor()\n    else\n      abort(\"Not a contributor or beneficiary\")\n\n  stateful function withdraw_beneficiary() =\n    require(state.total >= state.goal, \"Project was not funded\")\n    spend({recipient = state.beneficiary,\n           amount    = Contract.balance })\n    put(state{ beneficiary = ak_11111111111111111111111111111111273Yts })\n\n  stateful function withdraw_contributor() =\n    if(state.total >= state.goal)\n      abort(\"Project was funded\")\n    let to = Call.caller\n    spend({recipient = to,\n           amount    = state.contributions[to]})\n    put(state{ contributions @ c = Map.delete(to, c) })\n\n"
,
"aesophia/test/contracts/builtin_bug.aes":"\n// Compiler failed to detect the map lookup nested in the state update and\n// generate the appropriate builtin for it.\ncontract BuiltinBug =\n\n  record state = {proofs : map(address, list(string))}\n\n  entrypoint init() = {proofs = {}}\n\n  stateful entrypoint createProof(hash : string) =\n    put( state{ proofs[Call.caller] = hash :: state.proofs[Call.caller] } )\n\n"
,
"aesophia/test/contracts/bad_init_state_access.aes":"contract BadInit =\n\n  type state = int\n\n  entrypoint new_state(n) = state + n\n\n  stateful entrypoint roundabout(n) = put(n)\n  stateful entrypoint set_state(n) = roundabout(n)\n\n  stateful entrypoint init() =\n    set_state(4)\n    new_state(0)\n    state + state\n"
,
"aesophia/test/contracts/calling_init_function.aes":"contract CallingInitFunction =\n\n  type state = int * int\n\n  entrypoint init() = (1, 2)\n\n  entrypoint call_init() = init()\n"
,
"aesophia/test/contracts/variant_types.aes":"\ncontract VariantTypes =\n\n  datatype state = Started(started_state) | Stopped\n\n  record started_state = {owner : address, balance : int, color : color}\n\n  datatype color = Red | Green | Blue | Grey(int)\n\n  entrypoint init() = Stopped\n\n  stateful entrypoint start(bal : int) =\n    switch(state)\n      Stopped => put(Started({owner = Call.caller, balance = bal, color = Grey(0)}))\n\n  stateful entrypoint stop() =\n    switch(state)\n      Started(st) =>\n        require(Call.caller == st.owner, \"required\")\n        put(Stopped)\n        st.balance\n\n  entrypoint get_color()  = switch(state) Started(st) => st.color\n  stateful entrypoint set_color(c) = switch(state) Started(st) => put(Started(st{color = c}))\n\n  entrypoint get_state() = state\n\n"
,
"aesophia/test/contracts/events.aes":"contract Remote =\n  entrypoint dummy : () => unit\n\ncontract Events =\n\n  // Valid index types\n  type ix1 = int\n  type ix2 = bool\n  type ix3 = bits\n  type ix4 = bytes(12)\n  type ix5 = hash // bytes(32)\n  type ix6 = address\n  type ix7 = Remote\n  type ix8 = oracle(int, int)\n  type ix9 = oracle_query(int, int)\n\n  // Valid payload types\n  type data1 = string\n  type data2 = signature  // bytes(64)\n  type data3 = bytes(65)\n\n  datatype event\n    = Nodata0\n    | Nodata1(ix1)\n    | Nodata2(ix2, ix3)\n    | Nodata3(ix4, ix5, ix6)\n    | Data0(data1)\n    | Data1(data2, ix7)\n    | Data2(ix8, data3, ix9)\n    | Data3(ix1, ix2, ix5, data1)\n\n  entrypoint nodata0()                   = Chain.event(Nodata0)\n  entrypoint nodata1(ix1)                = Chain.event(Nodata1(ix1))\n  entrypoint nodata2(ix2, ix3)           = Chain.event(Nodata2(ix2, ix3))\n  entrypoint nodata3(ix4, ix5, ix6)      = Chain.event(Nodata3(ix4, ix5, ix6))\n  entrypoint data0(data1)                = Chain.event(Data0(data1))\n  entrypoint data1(data2, ix7)           = Chain.event(Data1(data2, ix7))\n  entrypoint data2(ix8, data3, ix9)      = Chain.event(Data2(ix8, data3, ix9))\n  entrypoint data3(ix1, ix2, ix5, data1) = Chain.event(Data3(ix1, ix2, ix5, data1))\n\n"
,
"aesophia/test/contracts/deadcode.aes":"\nnamespace MyList =\n\n  function map1(f : 'a => 'b, xs : list('a)) =\n    switch(xs)\n      [] => []\n      x :: xs => f(x) :: map1(f, xs)\n\n  function map2(f : 'a => 'b, xs : list('a)) =\n    switch(xs)\n      [] => []\n      x :: xs => f(x) :: map2(f, xs)\n\ncontract Deadcode =\n\n  entrypoint inc1(xs : list(int)) : list(int) =\n    MyList.map1((x) => x + 1, xs)\n\n  entrypoint inc2(xs : list(int)) : list(int) =\n    MyList.map1((x) => x + 1, xs)\n\n"
,
"aesophia/test/contracts/environment.aes":"\n// Testing primitives for accessing the block chain environment\ncontract Interface =\n  entrypoint contract_address : () => address\n  entrypoint call_origin      : () => address\n  entrypoint call_caller      : () => address\n  entrypoint call_value       : () => int\n\ncontract Environment =\n\n  record state = {remote : Interface}\n\n  entrypoint init(remote) = {remote = remote}\n\n  stateful entrypoint set_remote(remote) = put({remote = remote})\n\n  // -- Information about the this contract ---\n\n  // Address\n  entrypoint contract_address() : address = Contract.address\n  entrypoint nested_address(who) : address =\n    who.contract_address(gas = 1000)\n\n  // Balance\n  entrypoint contract_balance() : int = Contract.balance\n\n  // -- Information about the current call ---\n\n  // Origin\n  entrypoint call_origin()   : address = Call.origin\n  entrypoint nested_origin() : address =\n    state.remote.call_origin()\n\n  // Caller\n  entrypoint call_caller() : address = Call.caller\n  entrypoint nested_caller() : address =\n    state.remote.call_caller()\n\n  // Value\n  entrypoint call_value() : int = Call.value\n  stateful entrypoint nested_value(value : int) : int =\n    state.remote.call_value(value = value / 2)\n\n  // Gas price\n  entrypoint call_gas_price() : int = Call.gas_price\n\n  // -- Information about the chain ---\n\n  // Account balances\n  entrypoint get_balance(acct : address) : int = Chain.balance(acct)\n\n  // Block hash\n  entrypoint block_hash(height : int) : option(hash) = Chain.block_hash(height)\n\n  // Coinbase\n  entrypoint coinbase() : address = Chain.coinbase\n\n  // Block timestamp\n  entrypoint timestamp() : int = Chain.timestamp\n\n  // Block height\n  entrypoint block_height() : int = Chain.block_height\n\n  // Difficulty\n  entrypoint difficulty() : int = Chain.difficulty\n\n  // Gas limit\n  entrypoint gas_limit() : int = Chain.gas_limit\n\n"
,
"aesophia/test/contracts/bad_top_level_decl.aes":"function square(x) = x ^ 2\ncontract Main =\n  entrypoint main() = square(10)\n"
,
"aesophia/test/contracts/chain.aes":"// Test more advanced chain interactions\n\ncontract ChainTest =\n\n  record state = { last_bf : address }\n\n  function init() : state =\n    {last_bf = Contract.address}\n\n  function miner() = Chain.coinbase\n\n  function save_coinbase() =\n    put(state{last_bf = Chain.coinbase})\n"
,
"aesophia/test/contracts/contract_as_namespace.aes":"contract Foo =\n  entrypoint foo : () => int\n\ncontract Fail =\n  entrypoint bad() : int = Foo.foo()\n\n"
,
"aesophia/test/contracts/namespaces.aes":"\nnamespace Lib =\n\n  private function rev(xs, ys) =\n    switch(xs)\n      []      => ys\n      x :: xs => rev(xs, x :: ys)\n\n  function reverse(xs : list('a)) : list('a) = rev(xs, [])\n\n  function eqlist(xs : list(int), ys : list(int)) =\n    switch((xs, ys))\n      ([], [])           => true\n      (x :: xs, y :: ys) => x == y && eqlist(xs, ys)\n      _                  => false\n\ncontract TestNamespaces =\n\n  function palindrome(xs : list(int)) : bool =\n    Lib.eqlist(xs, Lib.reverse(xs))\n\n"
,
"aesophia/test/contracts/validation_test2.aes":"contract ValidationTest =\n  entrypoint attr_fail() = ()\n  entrypoint type_fail(x) = x\n  entrypoint code_fail(x) = x - 1\n"
,
"aesophia/test/contracts/bad_bytes_split.aes":"contract BytesSplit =\n\n  entrypoint test1(x) : bytes(10) * bytes(20) =\n    Bytes.split(x)\n\n  entrypoint test2(x : bytes(15)) : bytes(10) * _ =\n    Bytes.split(x)\n\n  entrypoint test3(x : bytes(25)) : _ * bytes(20) =\n    Bytes.split(x)\n\n  entrypoint fail1(x) : _ * bytes(20) =\n    Bytes.split(x)\n\n  entrypoint fail2(x : bytes(15)) : _ =\n    Bytes.split(x)\n\n  entrypoint fail3(x) : bytes(20) * _ =\n    Bytes.split(x)\n\n"
,
"aesophia/test/contracts/remote_call.aes":"\ncontract Remote1 =\n  entrypoint main : (int) => int\n\ncontract Remote2 =\n  entrypoint call : (Remote1, int) => int\n\ncontract Remote3 =\n  entrypoint get : () => int\n  entrypoint tick : () => unit\n\ncontract RemoteCall =\n\n    stateful entrypoint call(r : Remote1, x : int) : int =\n        r.main(gas = 10000, value = 10, x)\n\n    entrypoint staged_call(r1 : Remote1, r2 : Remote2, x : int) =\n        r2.call(r1, x)\n\n    entrypoint increment(r3 : Remote3) =\n        r3.tick()\n\n    entrypoint get(r3 : Remote3) =\n        r3.get()\n\n    entrypoint plus(x, y) = x + y\n\n"
,
"aesophia/test/contracts/init_type_error.aes":"\ncontract InitTypeError =\n\n  type state = map(int, int)\n\n  // Check that the compiler catches ill-typed init entrypoint\n  entrypoint init() = \"not the right type!\"\n\n"
,
"aesophia/test/contracts/not_toplevel_include.aes":"namespace BadNs =\n  include \"included.aes\"\n\ncontract Con =\n  entrypoint foo() = 43\n"
,
"aesophia/test/contracts/missing_event_type.aes":"contract MissingEventType =\n  entrypoint main() =\n    Chain.event(\"MAIN\")\n"
,
"aesophia/test/contracts/state_handling.aes":"contract Remote =\n  record rstate = { i : int, s : string, m : map(int, int) }\n\n  entrypoint look_at : (rstate) => unit\n  entrypoint return_s : (bool) => string\n  entrypoint return_m : (bool) => map(int, int)\n  entrypoint get : (rstate) => rstate\n  entrypoint get_i : (rstate) => int\n  entrypoint get_s : (rstate) => string\n  entrypoint get_m : (rstate) => map(int, int)\n\n  entrypoint fun_update_i  : (rstate, int)           => rstate\n  entrypoint fun_update_s  : (rstate, string)        => rstate\n  entrypoint fun_update_m  : (rstate, map(int, int)) => rstate\n  entrypoint fun_update_mk : (rstate, int, int)      => rstate\n\ncontract StateHandling =\n\n  type state = Remote.rstate\n\n  entrypoint init(r : Remote, i : int) =\n    let state0 = { i = 0, s = \"undefined\", m = {} }\n    r.fun_update_i(state0, i)\n\n  entrypoint read() = state\n  entrypoint read_i() = state.i\n  entrypoint read_s() = state.s\n  entrypoint read_m() = state.m\n\n  stateful entrypoint update(new_state : state) = put(new_state)\n  stateful entrypoint update_i(new_i) = put(state{ i = new_i })\n  stateful entrypoint update_s(new_s) = put(state{ s = new_s })\n  stateful entrypoint update_m(new_m) = put(state{ m = new_m })\n\n  entrypoint pass_it(r : Remote) = r.look_at(state)\n  stateful entrypoint nop(r : Remote) = put(state{ i = state.i })\n  entrypoint return_it_s(r : Remote, big : bool) =\n    let x = r.return_s(big)\n    String.length(x)\n  entrypoint return_it_m(r : Remote, big : bool) =\n    let x = r.return_m(big)\n    Map.size(x)\n\n  entrypoint pass(r : Remote) = r.get(state)\n  entrypoint pass_i(r : Remote) = r.get_i(state)\n  entrypoint pass_s(r : Remote) = r.get_s(state)\n  entrypoint pass_m(r : Remote) = r.get_m(state)\n\n  entrypoint pass_update_i(r : Remote, i) = r.fun_update_i(state, i)\n  entrypoint pass_update_s(r : Remote, s) = r.fun_update_s(state, s)\n  entrypoint pass_update_m(r : Remote, m) = r.fun_update_m(state, m)\n\n  stateful entrypoint remote_update_i (r : Remote, i)    = put(r.fun_update_i(state, i))\n  stateful entrypoint remote_update_s (r : Remote, s)    = put(r.fun_update_s(state, s))\n  stateful entrypoint remote_update_m (r : Remote, m)    = put(r.fun_update_m(state, m))\n  stateful entrypoint remote_update_mk(r : Remote, k, v) = put(r.fun_update_mk(state, k, v))\n\n  // remote called\n  entrypoint look_at(s : state) = ()\n\n  entrypoint get(s : state) = s\n  entrypoint get_i(s : state) = s.i\n  entrypoint get_s(s : state) = s.s\n  entrypoint get_m(s : state) = s.m\n\n  entrypoint fun_update_i(st, ni) = st{ i = ni }\n  entrypoint fun_update_s(st, ns) = st{ s = ns }\n  entrypoint fun_update_m(st, nm) = st{ m = nm }\n  entrypoint fun_update_mk(st, k, v) = st{ m = st.m{[k] = v} }\n\n"
,
"aesophia/test/contracts/strings.aes":"contract Strings =\n    entrypoint str_len(s) = String.length(s)\n    entrypoint str_concat(s1, s2) = String.concat(s1, s2)\n\n"
,
"aesophia/test/contracts/remote_value_on_err.aes":"contract ValueOnErr =\n  function err : () => int\n  function ok  : () => int\n\ncontract RemoteValueOnErr =\n\n  public function callErr(\n    r : ValueOnErr,\n    value : int) : int =\n    r.err(value = value)\n\n  public function callErrLimitGas(\n    r : ValueOnErr,\n    value : int,\n    gas : int) : int =\n    r.err(value = value, gas = gas)\n\n  public function callOk(\n    r : ValueOnErr,\n    value : int) : int =\n    r.ok(value = value)\n"
,
"aesophia/test/contracts/chess.aes":"\ncontract Chess =\n\n  type board = map(int, map(int, string))\n  type state = board\n\n  private function get_row(r, m : board) =\n    Map.lookup_default(r, m, {})\n\n  private function set_piece(r, c, p, m : board) =\n    m { [r] = get_row(r, m) { [c] = p } }\n\n  private function get_piece(r, c, m : board) =\n    Map.lookup(c, get_row(r, m))\n\n  private function from_list(xs, m : board) =\n    switch(xs)\n      []              => m\n      (r, c, p) :: xs => from_list(xs, set_piece(r, c, p, m))\n\n  function init() =\n    from_list([ (2, 1, \"white pawn\"),   (7, 1, \"black pawn\")\n              , (2, 2, \"white pawn\"),   (7, 2, \"black pawn\")\n              , (2, 3, \"white pawn\"),   (7, 3, \"black pawn\")\n              , (2, 4, \"white pawn\"),   (7, 4, \"black pawn\")\n              , (2, 5, \"white pawn\"),   (7, 5, \"black pawn\")\n              , (2, 6, \"white pawn\"),   (7, 6, \"black pawn\")\n              , (2, 7, \"white pawn\"),   (7, 7, \"black pawn\")\n              , (2, 8, \"white pawn\"),   (7, 8, \"black pawn\")\n              , (1, 1, \"white rook\"),   (8, 1, \"black rook\")\n              , (1, 2, \"white knight\"), (8, 2, \"black knight\")\n              , (1, 3, \"white bishop\"), (8, 3, \"black bishop\")\n              , (1, 4, \"white queen\"),  (8, 4, \"black queen\")\n              , (1, 5, \"white king\"),   (8, 5, \"black king\")\n              , (1, 6, \"white bishop\"), (8, 6, \"black bishop\")\n              , (1, 7, \"white knight\"), (8, 7, \"black knight\")\n              , (1, 8, \"white rook\"),   (8, 8, \"black rook\")\n              ], {})\n\n  function piece(r, c) = get_piece(r, c, state)\n\n  function move_piece(r, c, r1, c1) =\n    switch(piece(r, c))\n      Some(p) => put(set_piece(r1, c1, p, state))\n\n  function destroy_piece(r, c) =\n    put(state{ [r] = Map.delete(c, get_row(r, state)) })\n\n  function delete_row(r) =\n    put(Map.delete(r, state))\n\n"
,
"aesophia/test/contracts/wrong_compiler_version.aes":"@compiler < 1.0\n@compiler == 9.9.9\n@compiler >= 0.1\n@compiler =< 100.0.1\n\ncontract Fail =\n  entrypoint foo() = ()\n"
,
"aesophia/test/contracts/all_syntax.aes":"// Try to cover all syntactic constructs.\n@compiler > 0\n@compiler =< 10.1.1.1.1.1.2.3.4\n\n\nnamespace Ns =\n  datatype d('a) = D | S(int) | M('a, list('a), int)\n  private function fff() = 123\n\n  stateful entrypoint\n    f (1, x) = (_) => x\n\npayable contract AllSyntaxType =\n  /** Multi-\n    * line\n    * comment\n    */\n  stateful function foo : _\n  entrypoint bar : int => (int * 'a)\n\n\ncontract AllSyntax =\n\n  datatype mickiewicz = Adam | Mickiewicz\n  record goethe('a, 'b) = {\n    johann : int,\n    wolfgang : 'a,\n    von : 'a * 'b * int,\n    goethe : unit\n    }\n  type dante = Ns.d(int)\n  type shakespeare('a) = goethe('a, 'a)\n\n  type state = shakespeare(int)\n\n  entrypoint init() = {\n    johann = 1000,\n    wolfgang = -10,\n    von = (2 + 2, 0, List.sum([x | k <- [1,2,3]\n                                 , let l = k + 1\n                                 , if(l < 10)\n                                 , let f(x) = x + 100\n                                 , Adam <- [Adam, Mickiewicz]\n                                 , let x = f(l)\n                                 ])),\n    goethe = () }\n\n  function f() =\n     let kp = \"nietzsche\"\n     let p = \"Пушкин\"\n     let k(x : bytes(8)) : bytes(8) = Bytes.to_int(#fedcba9876543210)\n\n     let f : () => address = () => ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt\n     if(Bits.test(Bits.all, 10))\n       abort(\"ohno\")\n     if(true && false)\n       require(true, \"ohyes\")\n     elif(false || 2 == 2)\n       ()\n     else\n       ()\n     if(true) f(1,2)((1,2))\n     else switch(1::[1,2,3])\n       [] => 1\n       a::b => 123\n       1::2::3 => 123123\n       [2,3,4] => 1\n       _ => 13\n       1::[2] => 2138\n     put(state{johann = 1})\n     \n     let m = {[\"foo\"] = 19, /*hey wanna talk about inlined comments?*/ [\"bar\"] = 42}\n     let n = {}\n     m{ [\"x\" = 0] @ z = z + state.johann }\n\n     let sh : shakespeare(shakespeare(int)) =\n       {wolfgang = state}\n     sh{wolfgang.wolfgang = sh.wolfgang} // comment\n"
,
"aesophia/test/contracts/included2.aes":"namespace Included2a =\n  function bar() = 43\n\nnamespace Included2b =\n  function foo() = 44\n"
,
"aesophia/test/contracts/list_comp.aes":"contract ListComp =\n\n    entrypoint sample1() = [1,2,3]\n    entrypoint sample2() = [4,5]\n\n    entrypoint l1() = [x | x <- sample1()]\n    entrypoint l1_true() = [1,2,3]\n\n    entrypoint l2() = [x + y | x <- sample1(), y <- sample2()]\n    entrypoint l2_true() = [5,6,6,7,7,8]\n\n    entrypoint l3() = [x ++ y | x <- [[\":)\"] | x <- [1,2]]\n                              , y <- [[\":(\"]]]\n    entrypoint l3_true() = [[\":)\", \":(\"], [\":)\", \":(\"]]\n\n    entrypoint l4() = [(a, b, c) | let is_pit(a, b, c) = a*a + b*b == c*c\n                                 , let base = [1..10]\n                                 , a <- base\n                                 , b <- base, if (b >= a)\n                                 , c <- base, if (c >= b)\n                                 , if (is_pit(a, b, c))\n                                 ]\n    entrypoint l4_true() = [(3, 4, 5), (6, 8, 10)]\n"
,
"aesophia/test/contracts/cyclic_include_forth.aes":"include \"cyclic_include_back.aes\"\n\nnamespace Forth =\n  function forth() = 3\n"
,
"aesophia/test/contracts/list_comp_not_a_list.aes":"contract ListCompBad =\n  entrypoint failing() = [x | x <- 1]\n"
,
"aesophia/test/contracts/remote_state.aes":"contract RemoteState =\n  record rstate = { i : int, s : string, m : map(int, int) }\n\n  function look_at(s : rstate) = ()\n  function return_s(big : bool) =\n    let x = \"short\"\n    let y = \"______longer_string_at_least_32_bytes_long___________longer_string_at_least_32_bytes_long___________longer_string_at_least_32_bytes_long_____\"\n    if(big) y else x\n  function return_m(big : bool) =\n    let x = { [1] = 2 }\n    let y = { [1] = 2, [3] = 4, [5] = 6 }\n    if(big) y else x\n\n  function get(s : rstate) = s\n  function get_i(s : rstate) = s.i\n  function get_s(s : rstate) = s.s\n  function get_m(s : rstate) = s.m\n\n  function fun_update_i(s : rstate, ni) = s{ i = ni }\n  function fun_update_s(s : rstate, ns) = s{ s = ns }\n  function fun_update_m(s : rstate, nm) = s{ m = nm }\n  function fun_update_mk(s : rstate, k, v) = s{ m = s.m{[k] = v} }\n\n"
,
"aesophia/test/contracts/oracles.aes":"contract Oracles =\n\n  type fee = int\n  type ttl = Chain.ttl\n\n  type query_t  = string\n  type answer_t = int\n\n  type oracle_id = oracle(query_t, answer_t)\n  type query_id  = oracle_query(query_t, answer_t)\n\n  stateful entrypoint registerOracle(acct : address,\n                          qfee : fee,\n                          ttl  : ttl) : oracle_id =\n     Oracle.register(acct, qfee, ttl)\n\n  stateful entrypoint registerIntIntOracle(acct : address,\n                                qfee : fee,\n                                ttl  : ttl) : oracle(int, int) =\n     Oracle.register(acct, qfee, ttl)\n\n  stateful entrypoint registerStringStringOracle(acct : address,\n                                      qfee : fee,\n                                      ttl  : ttl) : oracle(string, string) =\n     Oracle.register(acct, qfee, ttl)\n\n  stateful entrypoint signedRegisterOracle(acct : address,\n                                sign : signature,\n                                qfee : fee,\n                                ttl  : ttl) : oracle_id =\n     Oracle.register(acct, qfee, ttl, signature = sign)\n\n  entrypoint queryFee(o : oracle_id) : fee =\n    Oracle.query_fee(o)\n\n  stateful entrypoint createQuery(o    : oracle_id,\n                       q    : query_t,\n                       qfee : fee,\n                       qttl : ttl,\n                       rttl : ttl) : query_id =\n    require(qfee =< Call.value, \"insufficient value for qfee\")\n    Oracle.query(o, q, qfee, qttl, rttl)\n\n  // Do not use in production!\n  stateful entrypoint unsafeCreateQuery(o    : oracle_id,\n                       q    : query_t,\n                       qfee : fee,\n                       qttl : ttl,\n                       rttl : ttl) : query_id =\n    Oracle.query(o, q, qfee, qttl, rttl)\n\n  // Do not use in production!\n  stateful entrypoint unsafeCreateQueryThenErr(o    : oracle_id,\n                       q    : query_t,\n                       qfee : fee,\n                       qttl : ttl,\n                       rttl : ttl) : query_id =\n    let res = Oracle.query(o, q, qfee, qttl, rttl)\n    require(qfee >= 100000000000000000, \"causing a late error\")\n    res\n\n  stateful entrypoint extendOracle(o    : oracle_id,\n                        ttl  : ttl) : unit =\n    Oracle.extend(o, ttl)\n\n  stateful entrypoint signedExtendOracle(o    : oracle_id,\n                              sign : signature,   // Signed oracle address\n                              ttl  : ttl) : unit =\n    Oracle.extend(o, signature = sign, ttl)\n\n  stateful entrypoint respond(o    : oracle_id,\n                   q    : query_id,\n                   r    : answer_t) : unit =\n    Oracle.respond(o, q, r)\n\n  stateful entrypoint signedRespond(o    : oracle_id,\n                         q    : query_id,\n                         sign : signature,\n                         r    : answer_t) : unit =\n    Oracle.respond(o, q, signature = sign, r)\n\n  entrypoint getQuestion(o : oracle_id,\n                       q : query_id) : query_t =\n    Oracle.get_question(o, q)\n\n  entrypoint hasAnswer(o : oracle_id,\n                     q : query_id) =\n    switch(Oracle.get_answer(o, q))\n      None    => false\n      Some(_) => true\n\n  entrypoint getAnswer(o : oracle_id,\n                     q : query_id) : option(answer_t) =\n    Oracle.get_answer(o, q)\n\n  datatype complexQuestion = Why(int) | How(string)\n  datatype complexAnswer   = NoAnswer | Answer(complexQuestion, string, int)\n\n  stateful entrypoint complexOracle(question) =\n    let o = Oracle.register(Contract.address, 0, FixedTTL(1000)) : oracle(complexQuestion, complexAnswer)\n    let q = Oracle.query(o, question, 0, RelativeTTL(100), RelativeTTL(100))\n    Oracle.respond(o, q, Answer(question, \"magic\", 1337))\n    Oracle.get_answer(o, q)\n\n  stateful entrypoint signedComplexOracle(question, sig) =\n    let o = Oracle.register(signature = sig, Contract.address, 0, FixedTTL(1000)) : oracle(complexQuestion, complexAnswer)\n    let q = Oracle.query(o, question, 0, RelativeTTL(100), RelativeTTL(100))\n    Oracle.respond(o, q, Answer(question, \"magic\", 1337), signature = sig)\n    Oracle.get_answer(o, q)\n\n"
,
"aesophia/test/contracts/oracles_err.aes":"contract OraclesErr =\n\n  public function unsafeCreateQueryThenErr(\n    o    : oracle(string, int),\n    q    : string,\n    qfee  : int,\n    qttl : Chain.ttl,\n    rttl : Chain.ttl) : oracle_query(string, int) =\n    let x = Oracle.query(o, q, qfee, qttl, rttl)\n    switch(0) 1 => ()\n    x // Never reached.\n"
,
"aesophia/test/contracts/bitcoin_auth.aes":"contract BitcoinAuth =\n  record state = { nonce : int, owner : bytes(20) }\n\n  entrypoint init(owner' : bytes(20)) = { nonce = 1, owner = owner' }\n\n  stateful entrypoint authorize(n : int, s : bytes(65)) : bool =\n    require(n >= state.nonce, \"Nonce too low\")\n    require(n =< state.nonce, \"Nonce too high\")\n    put(state{ nonce = n + 1 })\n    switch(Auth.tx_hash)\n      None          => abort(\"Not in Auth context\")\n      Some(tx_hash) => Crypto.ecverify_secp256k1(to_sign(tx_hash, n), state.owner, s)\n\n  entrypoint to_sign(h : hash, n : int) : hash =\n    Crypto.blake2b((h, n))\n\n"
,
"aesophia/test/contracts/validation_test3.aes":"payable contract ValidationTest =\n  payable entrypoint attr_fail() = ()\n  entrypoint type_fail(x : int) = x\n  entrypoint code_fail(x) = x + 1\n"
,
"aesophia/test/contracts/not_toplevel_namespace.aes":"contract BadCon =\n  namespace Foo =\n    function foo() = 42\n\n  entrypoint foo() = 43\n"
,
"aesophia/test/contracts/field_parse_error.aes":"\ncontract Fail =\n  record pt = {x : int, y : int}\n  record r  = {p : pt}\n  function fail() = {p.x = 0, p.y = 0}\n"
,
"aesophia/test/contracts/lhs_matching.aes":"contract LHSMatching =\n\n  function from_some(Some(x)) = x\n\n  function\n    length : list('a) => int\n    length([])      = 0\n    length(_ :: xs) = 1 + length(xs)\n\n  function\n    append([], ys)      = ys\n    append(x :: xs, ys) = x :: append(xs, ys)\n\n  function local_match(xs : list('a)) =\n    let null([])     = true\n    let null(_ :: _) = false\n    !null(xs)\n\n  entrypoint main() =\n    from_some(Some([0]))\n      ++ append([length([true]), 2, 3], [4, 5, 6])\n      ++ [7 | if (local_match([false]))]\n"
,
"aesophia/test/contracts/bad_function_block.aes":"contract C =\n  function\n    g(1) = 2\n    f(2) = 3\n    h(1) = 123"
,
"aesophia/test/contracts/builtin_map_get_bug.aes":"contract TestContract =\n  record state = {_allowed : map(address, map(address, int))}\n\n  entrypoint init() = {_allowed = {}}\n\n  stateful entrypoint approve(spender: address, value: int) : bool =\n    put(state{_allowed[Call.caller][spender] = value})\n    true\n"
,
"aesophia/test/contracts/remote_type_check.aes":"contract Remote =\n  function id : ('a) => 'a\n  function missing : ('a) => 'a\n  function wrong_type : (string) => string\n\ncontract Main =\n\n  function id(x : int) =\n    x\n\n  function wrong_type(x : int) =\n    x\n\n  function remote_id(r : Remote, x) =\n    r.id(x)\n\n  function remote_missing(r : Remote, x) =\n    r.missing(x)\n\n  function remote_wrong_type(r : Remote, x) =\n    r.wrong_type(x)\n\n"
,
"aesophia/test/contracts/identity.aes":"\ncontract Identity =\n  entrypoint main (x:int) = x\n"
,
"aesophia/test/contracts/factorial.aes":"// An implementation of the factorial function where each recursive\n// call is to another contract. Not the cheapest way to compute factorial.\ncontract FactorialServer =\n  entrypoint fac : (int) => int\n\ncontract Factorial =\n\n  record state = {worker : FactorialServer}\n\n  entrypoint init(worker) = {worker = worker}\n\n  stateful entrypoint set_worker(worker) = put(state{worker = worker})\n\n  entrypoint\n    fac : int => int\n    fac(0) = 1\n    fac(x) = x * state.worker.fac(x - 1)\n"
,
"aesophia/test/contracts/simple.aes":"\ncontract Simple =\n  type t = int => int\n  entrypoint dummy() = ()\n"
,
"aesophia/test/contracts/init_error.aes":"contract Remote =\n  function missing : (int) => int\n\ncontract Init_error =\n\n  record state = {value : int}\n\n  function init(r : Remote, x : int) =\n    {value = r.missing(x)}\n"
,
"aesophia/test/contracts/Makefile":"\n## Requires ocaml >= 4.02, < 4.06\n## and reason-3.0.0 (opam install reason).\n\ndefault : voting_test\n\n%.ml : %.re\n\trefmt -p ml $< > $@\n\n\nvoting_test : rte.ml voting.ml voting_test.ml\n\tocamlopt -o $@ $^\n\nclean :\n\trm -f *.cmi *.cmx *.ml *.o voting_test\n"
,
"aesophia/test/contracts/abort_test.aes":"// A simple test of the abort built-in function.\n\ncontract AbortTest =\n\n  record state = { value : int }\n\n  public function init(v : int) =\n    { value = v }\n\n  // Aborting\n  public function do_abort(v : int, s : string) : unit =\n    put_value(v)\n    revert_abort(s)\n\n  // Accessing the value\n  public function get_value() = state.value\n  public function put_value(v : int) = put(state{value = v})\n  public function get_values() : list(int) = [state.value]\n  public function put_values(v : int) = put(state{value = v})\n\n  // Some basic statistics\n  public function get_stats(acct : address) =\n    ( Contract.balance, Chain.balance(acct) )\n\n  // Abort functions.\n  private function revert_abort(s : string) =\n    abort(s)\n\n  // This is still legal but will be stripped out.\n  // TODO: This function confuses the type inference, so it cannot be present.\n  //private function abort(s : string) = 42\n"
,
"aesophia/test/contracts/abort_test_int.aes":"contract Interface =\n  function do_abort : (int, string) => unit\n  function get_value : () => int\n  function put_value : (int) => unit\n  function get_values : () => list(int)\n  function put_values : (int) => unit\n\ncontract AbortTestInt =\n\n  record state = {r : Interface, value : int}\n\n  public function init(r : Interface, value : int) =\n    {r = r, value = value}\n\n  // Aborting\n  public function do_abort(v : int, s : string) =\n    put_value(v)\n    state.r.do_abort(v + 100, s)\n\n  // Accessing the value\n  public function put_value(v : int) = put(state{value = v})\n  public function get_value() = state.value\n  public function get_values() : list(int) =\n    state.value :: state.r.get_values()\n  public function put_values(v : int) =\n    put_value(v)\n    state.r.put_values(v + 1000)\n"
,
"aesophia/test/contracts/include.aes":"include \"included.aes\"\ninclude \"../contracts/included2.aes\"\n\ncontract Include =\n  entrypoint foo() =\n    Included.foo() < Included2a.bar()\n\n  entrypoint bar() =\n    Included2b.foo() > Included.foo()\n"
,
"aesophia/test/contracts/counter.aes":"\ncontract Counter =\n\n  record state = { value : int }\n\n  entrypoint init(val) = { value = val }\n  entrypoint get()     = state.value\n  stateful entrypoint tick()    = put(state{ value = state.value + 1 })\n\n"
,
"aesophia/test/contracts/bytes_to_x.aes":"\ncontract BytesToX =\n\n  entrypoint to_int(b : bytes(42)) : int = Bytes.to_int(b)\n  entrypoint to_str(b : bytes(12)) : string =\n    String.concat(Bytes.to_str(b), Bytes.to_str(#ffff))\n  entrypoint to_str_big(b : bytes(65)) : string =\n    Bytes.to_str(b)\n"
,
"aesophia/test/contracts/complex_types.aes":"\ncontract Remote =\n  entrypoint up_to       : (int)               => list(int)\n  entrypoint sum         : (list(int))         => int\n  entrypoint some_string : ()                  => string\n  entrypoint pair        : (int, string)       => int * string\n  entrypoint squares     : (int)               => list(int * int)\n  entrypoint filter_some : (list(option(int))) => list(int)\n  entrypoint all_some    : (list(option(int))) => option(list(int))\n\ncontract ComplexTypes =\n\n  record state = { worker : Remote }\n\n  entrypoint init(worker) = {worker = worker}\n\n  entrypoint sum_acc(xs, n) =\n    switch(xs)\n      []      => n\n      x :: xs => sum_acc(xs, x + n)\n\n  // Sum a list of integers\n  entrypoint sum(xs : list(int)) =\n    sum_acc(xs, 0)\n\n  entrypoint up_to_acc(n, xs) =\n    switch(n)\n      0 => xs\n      _ => up_to_acc(n - 1, n :: xs)\n\n  entrypoint up_to(n) = up_to_acc(n, [])\n\n  record answer('a) = {label : string, result : 'a}\n\n  entrypoint remote_triangle(worker, n) : answer(int) =\n    let xs = worker.up_to(gas = 100000, n)\n    let t  = worker.sum(xs)\n    { label = \"answer:\", result = t }\n\n  entrypoint remote_list(n) : list(int) =\n    state.worker.up_to(n)\n\n  entrypoint some_string() = \"string\"\n\n  entrypoint remote_string() : string =\n    state.worker.some_string()\n\n  entrypoint pair(x : int, y : string) = (x, y)\n\n  entrypoint remote_pair(n : int, s : string) : int * string =\n    state.worker.pair(gas = 10000, n, s)\n\n  function map(f, xs) =\n    switch(xs)\n      []      => []\n      x :: xs => f(x) :: map(f, xs)\n\n  entrypoint squares(n) =\n    map((i) => (i, i * i), up_to(n))\n\n  entrypoint remote_squares(n) : list(int * int) =\n    state.worker.squares(n)\n\n  // option types\n\n  entrypoint filter_some(xs : list(option(int))) : list(int) =\n    switch(xs)\n      []            => []\n      None    :: ys => filter_some(ys)\n      Some(x) :: ys => x :: filter_some(ys)\n\n  entrypoint remote_filter_some(xs : list(option(int))) : list(int) =\n    state.worker.filter_some(xs)\n\n  entrypoint all_some(xs : list(option(int))) : option(list(int)) =\n    switch(xs)\n      []         => Some([])\n      None :: ys => None\n      Some(x) :: ys =>\n        switch(all_some(ys))\n          Some(xs) => Some(x :: xs)\n          None     => None\n\n  entrypoint remote_all_some(xs : list(option(int))) : option(list(int)) =\n    state.worker.all_some(gas = 10000, xs)\n\n"
,
"aesophia/test/contracts/missing_fields_in_record_expression.aes":"contract MissingFieldsInRecordExpr =\n\n  record r('a) = {x : int, y : string, z : 'a}\n  type alias('a) = r('a)\n\n  entrypoint fail1()               = { x = 0 }\n  entrypoint fail2(z : 'a) : r('a) = { y = \"string\", z = z }\n  entrypoint fail3() : alias(int)  = { x = 0, z = 1 }\n"
,
"aesophia/test/contracts/namespace_clash.aes":"\n// You can't shadow existing contracts or namespaces.\n\ncontract Call =\n  entrypoint whatever() = ()\n"
,
"aesophia/test/contracts/oracles_gas.aes":"contract OraclesGas =\n\n  type fee = int\n  type question_t = string\n  type answer_t = int\n\n  public function happyPathWithAllBuiltinsAtSameHeight(\n    qfee : fee,\n    ottl : Chain.ttl,\n    ettl : Chain.ttl,\n    qttl : Chain.ttl,\n    rttl : Chain.ttl\n    ) =\n    let question = \"why\"\n    let answer = 42\n    let o = Oracle.register(Contract.address, qfee, ottl) : oracle(question_t, answer_t)\n    Oracle.extend(o, ettl)\n    require(qfee =< Call.value, \"insufficient value for qfee\")\n    let q = Oracle.query(o, question, qfee, qttl, rttl)\n    Oracle.respond(o, q, answer)\n    ()\n\n"
,
"aesophia/test/contracts/stateful.aes":"\ncontract Remote =\n  stateful entrypoint remote_spend : (address, int) => unit\n  entrypoint remote_pure : int => int\n\ncontract Stateful =\n\n  function pure(x) = x + 1\n  stateful function local_spend(a) =\n    Chain.spend(a, 1000)\n\n  // Non-stateful functions cannot mention stateful functions\n  entrypoint fail1(a : address) = Chain.spend(a, 1000)\n  entrypoint fail2(a : address) = local_spend(a)\n  entrypoint fail3(a : address) =\n    let foo = Chain.spend\n    foo(a, 1000)\n\n  // Private functions must also be annotated\n  private function fail4(a) = Chain.spend(a, 1000)\n\n  // If annotated, stateful functions are allowed\n  stateful entrypoint ok1(a : address) = Chain.spend(a, 1000)\n\n  // And pure functions are always allowed\n  stateful entrypoint ok2(a : address) = pure(5)\n  stateful entrypoint ok3(a : address) =\n    let foo = pure\n    foo(5)\n\n  // No error here (fail4 is annotated as not stateful)\n  entrypoint ok4(a : address) = fail4(a)\n\n  // Lamdbas are checked at the construction site\n  function fail5() : address => unit = (a) => Chain.spend(a, 1000)\n\n  // .. so you can pass a stateful lambda to a non-stateful higher-order\n  // function:\n  function apply(f : 'a => 'b, x) = f(x)\n  stateful entrypoint ok5(a : address) =\n    apply((val) => Chain.spend(a, val), 1000)\n\n  // It doesn't matter if remote calls are stateful or not\n  entrypoint ok6(r : Remote) = r.remote_spend(Contract.address, 1000)\n  entrypoint ok7(r : Remote) = r.remote_pure(5)\n\n  // But you can't send any tokens if not stateful\n  entrypoint fail6(r : Remote) = r.remote_spend(value = 1000, Contract.address, 1000)\n  entrypoint fail7(r : Remote) = r.remote_pure(value = 1000, 5)\n  entrypoint fail8(r : Remote) =\n    let foo = r.remote_pure\n    foo(value = 1000, 5)\n  entrypoint ok8(r : Remote) = r.remote_spend(Contract.address, 1000, value = 0)\n\n"
,
"aesophia/test/contracts/bytes_equality.aes":"\ncontract BytesEquality =\n\n  entrypoint eq16(a : bytes(16), b) = a == b\n  entrypoint ne16(a : bytes(16), b) = a != b\n\n  entrypoint eq32(a : bytes(32), b) = a == b\n  entrypoint ne32(a : bytes(32), b) = a != b\n\n  entrypoint eq47(a : bytes(47), b) = a == b\n  entrypoint ne47(a : bytes(47), b) = a != b\n\n  entrypoint eq64(a : bytes(64), b) = a == b\n  entrypoint ne64(a : bytes(64), b) = a != b\n\n  entrypoint eq65(a : bytes(65), b) = a == b\n  entrypoint ne65(a : bytes(65), b) = a != b\n\n"
,
"aesophia/test/contracts/lc_record_bug.aes":"contract Foo =\n  record r = {x : int}\n  // Crashed in the backend due to missing type annotation on the lc body.\n  entrypoint lc(xs) = [ {x = x} | x <- xs ]\n"
,
"aesophia/test/contracts/channel_env.aes":"contract ChannelEnv =\n  public function coinbase() : address = Chain.coinbase\n\n  public function timestamp() : int = Chain.timestamp\n\n  public function block_height() : int = Chain.block_height\n\n  public function difficulty() : int = Chain.difficulty\n"
,
"aesophia/test/contracts/polymorphism_test.aes":"\ncontract Identity =\n\n  function zip_with(f, xs, ys) =\n    switch((xs, ys))\n      (x :: xs, y :: ys) => f(x, y) :: zip_with(f, xs, ys)\n      _ => []\n\n  // Check that we can use zip_with at different types\n\n  function foo() =\n    zip_with((x, y) => x + y, [1, 2, 3], [4, 5, 6, 7])\n\n  function bar() =\n    zip_with((x, y) => if(x) y else 0, [true, false, true, false], [1, 2, 3])\n\n"
,
"aesophia/test/contracts/voting.aes":"contract Voting =\n\n  // Types\n  record proposal =\n    { name : string\n    , voteCount : uint\n    }\n\n  datatype vote = NotVoted | Voted(int) | Delegated(address)\n\n  record voter =\n    { weight : int\n    , vote : vote\n    }\n\n  record state =\n    { chairPerson : address\n    , voters : map(address, voter)\n    , proposals : list(proposal)\n    }\n\n  // Initialization\n  function init(proposalNames: list(string)): state =\n    { chairPerson = caller(),\n      voters      = Map.empty,\n      proposals   = MyList.map((name) => {name = name, voteCount = 0}, proposalNames) }\n\n  function initVoter() = { weight = 1, vote = NotVoted}\n\n  function giveRightToVote(voter: address) =\n    require(caller() == state.chairPerson)\n    require(!Map.mem(voter, state.voters))\n    put(state{ voters = Map.add(voter, initVoter(), state.voters) })\n\n  function delegateChain(delegate: address) =\n    require(delegate != caller()) /* Delegation loop! */\n    let voter = Map.find(delegate, state.voters)\n    switch(voter.vote)\n      Delegated(d) => delegateChain(d)\n      _            => delegate\n\n  function addVote(candidate, weight) =\n    let proposal = MyList.nth(state.proposals, candidate)\n    proposal{ voteCount = proposal.voteCount + weight }\n\n  function delegateVote(delegateTo: address, weight: uint) =\n    let voter = Map.find(delegateTo, state.voters)\n    switch(voter.vote)\n      Voted(vote)  => addVote(vote, weight)\n      Delegated(_) => abort(\"impossible\")   // impossible\n      NotVoted     => voter{ weight = voter.weight + weight }\n\n  function delegate(delegateTo: address) =\n    require(delegateTo != caller())\n    let voter = Map.find(caller(), state.voters)\n    require(voter.vote == NotVoted)\n    let finalDelegate = delegateChain(delegateTo)\n    let voter' = voter{ vote = Delegated(finalDelegate) }\n    delegateVote(finalDelegate, voter.weight)\n\n  function vote(candidate: uint) =\n    let voter = Map.find(caller(), state.voters)\n    require(voter.vote == NotVoted)\n    let voter' = voter{ vote = Voted(candidate) }\n    addVote(candidate, voter.weight)\n\n  function winningProposal'(current, rest) =\n    switch(rest)\n      []      => current\n      p :: ps => winningProposal'(if (p.voteCount > current.voteCount) p else current, ps)\n\n  // const\n  function winningProposal() : proposal =\n    switch(state.proposals)\n      []      => abort(\"none\")\n      p :: ps => winningProposal'(p, ps)\n\n  // const\n  function winnerName() = winningProposal().name\n\n  // const\n  function currentTally() =\n    MyList.map((p) => (p.name, p.voteCount), state.proposals)\n\n"
,
"aesophia/test/contracts/simple_storage.aes":"/* Example from Solidity by Example\n   http://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html\n\n   The Solidity code:\n\n   contract SimpleStorage {\n       uint storedData\n\n       entrypoint set(uint x) {\n           storedData = x\n       }\n\n       entrypoint get() constant returns (uint) {\n           return storedData\n       }\n   }\n*/\n\ncontract SimpleStorage =\n\n  record state = { data : int }\n\n  entrypoint init(value : int) : state = { data = value }\n\n  entrypoint get() : int = state.data\n\n  stateful entrypoint set(value : int) =\n      put(state{data = value})\n"
,
"aesophia/test/contracts/bad_arity.aes":"contract C =\n  type id('a) = 'a\n  entrypoint f() : id = 123\n  entrypoint g() : id(int, int) = 123"
,
"aesophia/test/contracts/05_greeter.aes":"/* https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/05_greeter.sol\n\n   /*\n\tThe following is an extremely basic example of a solidity contract.\n\tIt takes a string upon creation and then repeats it when greet() is called.\n   */\n\n  contract Greeter         // The contract definition. A constructor of the same name will be automatically called on contract creation.\n  {\n    address creator;     // At first, an empty \"address\"-type variable of the name \"creator\". Will be set in the constructor.\n    string greeting;     // At first, an empty \"string\"-type variable of the name \"greeting\". Will be set in constructor and can be changed.\n\n    function Greeter(string _greeting) public   // The constructor. It accepts a string input and saves it to the contract's \"greeting\" variable.\n    {\n        creator = msg.sender\n        greeting = _greeting\n    }\n\n    function greet() constant returns (string)\n    {\n        return greeting\n    }\n\n    function getBlockNumber() constant returns (uint) // this doesn't have anything to do with the act of greeting\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t// just demonstrating return of some global variable\n        return block.number\n    }\n\n    function setGreeting(string _newgreeting)\n    {\n        greeting = _newgreeting\n    }\n\n     /**********\n     Standard kill() function to recover funds\n     **********/\n\n    function kill()\n    {\n        if (msg.sender == creator)  // only allow this action if the account sending the signal is the creator\n            suicide(creator);       // kills this contract and sends remaining funds back to creator\n    }\n\n  }\n\n*/\n\ncontract Greeter =\n\n\n     /* The creator of the contract will automatically\n       be set in creator() by the transaction creating the contract. */\n    function blockheight : unit => uint\n    record transaction = { tx : string }\n    record state = { greeting: string }\n    record retval = { state: state,\n                    transactions: list(transaction)}\n\n    let state = { greeting = \"Hello\" }\n\n    function setGreeting(greeting: string) =\n            state{ greeting = greeting }\n\n\n\n    /* this doesn't have anything to do with the act of greeting\n       just demonstrating return of some global variable */\n    function getBlockNumber() = blockheight()\n\n    /* There is no suicide functionallity in Sophia */\n    function kill() =\n      if ((caller() == creator()) /* only allow this action if the account sending the signal is the creator */\n          && (balance() > 0)) /* only creata a transaction if there is something to send */\n          state{ transactions = [spend_tx(creator(), balance())] }\n      else state\n\n"
,
"aesophia/test/contracts/bytes_concat.aes":"contract BytesConcat =\n  entrypoint rot(a : bytes(3)) =\n    switch (Bytes.split(a))\n      (b, c) => Bytes.concat(c : bytes(2), b)\n"
,
"aesophia/test/contracts/qualified_constructor.aes":"namespace Foo =\n  datatype x = A | B(int)\n\ncontract Bar =\n  entrypoint f(a : Foo.x) =\n    switch(a)\n      Foo.A     => 0\n      Foo.B(n)  => n\n"
,
"aesophia/test/contracts/exploits.aes":"\ncontract Exploits =\n\n  // We'll hack the bytecode of this changing the return type to string.\n  function pair(n : int) = (n, 0)\n\n"
,
"aesophia/test/contracts/higher_kinded_type.aes":"contract IWantToBelieve =\n  type stateT('s, 'm, 'a) = 's => 'm('a * 's)\n  entrypoint s() = 123"
,
"aesophia/test/contracts/multiple_contracts.aes":"contract ContractOne =\n  entrypoint foo() = \"foo\"\n\ncontract ContractTwo =\n  entrypoint bar() = \"bar\"\n"
,
"aesophia/test/contracts/cyclic_include.aes":"include \"cyclic_include_forth.aes\"\n\ncontract CI =\n  entrypoint ci() = Back.back() + Forth.forth()\n"
,
"aesophia/test/contracts/bad_state.aes":"contract C =\n  record state = { foo : int }\n  entrypoint init(i : int) =\n    state{ foo = i,\n           foo = 42 }\n"
,
"aesophia/test/contracts/funargs.aes":"\ncontract FunctionArguments =\n\n  entrypoint sum(n : int, m: int) =\n    n + m\n\n  entrypoint append(xs : list(string)) =\n     switch(xs)\n      []      => \"\"\n      y :: ys => String.concat(y, append(ys))\n\n  entrypoint menot(b) =\n    !b\n\n  entrypoint bitsum(b : bits) =\n    Bits.sum(b)\n\n  record answer('a) = {label : string, result : 'a}\n\n  entrypoint read(a : answer(int)) =\n     a.result\n\n  entrypoint sjutton(b : bytes(17)) =\n     b\n\n  entrypoint sextiosju(b : bytes(67)) =\n     b\n\n  entrypoint trettiotva(b : bytes(32)) =\n     b\n\n  entrypoint find_oracle(o : oracle(int, bool)) =\n     true\n\n  entrypoint find_query(q : oracle_query(int, bool)) =\n     true\n\n  datatype colour() = Green | Yellow | Red | Pantone(int)\n\n  entrypoint traffic_light(c : colour) =\n     Red\n\n  entrypoint tuples(t : unit) =\n     t\n\n  entrypoint due(t : Chain.ttl) =\n     true\n\n  record singleton_r = { x : int }\n\n  entrypoint singleton_rec(r : singleton_r) =\n    r.x\n"
,
"aesophia/test/contracts/type_errors.aes":"\ncontract Test =\n\n  record r = { x : map(string, string), y : int }\n  record r' = { y : string }\n  record r2 = { z : int, w : int }\n  record r3 = { x : int, z : int }\n\n  entrypoint set_x(r : r, z) = r{ x[\"foo\"] @ x = x + 1 }\n\n  entrypoint bla(m : map(string, int)) = { [0] = \"bla\", [\"foo\"] = \"\" }\n\n  entrypoint foo(r) = r { y = 0 }\n  entrypoint bar() = { y = \"foo\", z = 0 }\n  entrypoint baz() = { y = \"foo\", w = 0 }\n\n  entrypoint foo1() = zz\n\n  entrypoint test1() : string = { y = 0 }\n  entrypoint test2(x : string) = x { y = 0 }\n  entrypoint test3(x : string) = x { y @ y = y + 1 }\n  entrypoint test4(x : string) : int = x.y\n\n  entrypoint test5(xs) =\n    switch(xs)\n      x :: x => x\n      [] => 0\n\n  entrypoint case_pat(xs) =\n    switch(xs)\n      [] => 0\n      x :: xs => \"x\"\n\n  entrypoint foo2(m : map(string, int)) = m{ [1] = \"bla\" }\n\n  entrypoint bad_if(x, y : int, w : int, z : string) =\n    if(x) y\n    elif(x) w\n    else z\n\n  entrypoint type_error(r, x) =\n    set_x(set_x(x, r), x)\n\n  entrypoint repeated_arg(x : int, y, x : string, y : bool) : string = x\n\n  entrypoint missing1() =\n    let x = 0\n\n  entrypoint missing_fun1() =\n    let f(x) = x\n\n  entrypoint missing2() =\n    let x = 0\n    let y = 0\n\n  entrypoint missing_fun2() =\n    let f() = 0\n    let g() = f()\n\n  function id(x : 'a) : 'a = x\n\n  entrypoint wrong_return(n : int) : bool =\n    id(n)\n\n"
,
"aesophia/test/contracts/__call.aes":"\ncontract Identity =\n  function main (x:int) = x\n\n  function __call() = 12\n"
,
"aesophia/test/contracts/bad_events2.aes":"contract Events =\n  type alias_int = int\n  type alias_address = address\n  type alias_string = string\n\n  datatype event =\n      Event1(indexed alias_int, indexed int, string)\n    | Event2(alias_string, indexed alias_address)\n    | BadEvent1(string, string)\n    | BadEvent2(indexed int, indexed int, indexed int, indexed address)\n\n  entrypoint f1(x : int, y : string) =\n    Chain.event(Event1(x, x+1, y))\n\n  entrypoint f2(s : string) =\n    Chain.event(Event2(s, Call.caller))\n\n  entrypoint f3(x : int) =\n    Chain.event(Event1(x, x + 2, Int.to_str(x + 7)))\n\n  entrypoint i2s(i : int) = Int.to_str(i)\n  entrypoint a2s(a : address) = Address.to_str(a)\n\n"
,
"aesophia/test/contracts/contract_types.aes":"\ncontract OtherContract =\n\n  function multiply : (int, int) => int\n\ncontract ThisContract =\n\n  record state = { server : OtherContract, n : int }\n\n  function init(server : OtherContract) =\n    { server = server, n = 2 }\n\n  function square() =\n    put(state{ n @ n = state.server.multiply(value = 100, n, n) })\n\n  function get_n() = state.n\n\n  function tip_server() =\n    Chain.spend(state.server.address, Call.value)\n\n"
,
"aesophia/test/contracts/map_as_map_key.aes":"contract MapAsMapKey =\n  type t('key) = map('key, int)\n  type lm = list(map(int, int))\n\n  entrypoint foo(m) : t(map(int, int)) = {[m] = 0}\n  entrypoint bar(m) : t(lm) = Map.delete(m, {})\n"
,
"aesophia/test/contracts/upfront_charges.aes":"contract UpfrontCharges =\n  record state = { b : int } // For enabling retrieval of sender balance observed inside init.\n  public function init() : state = { b = b() }\n  public function initialSenderBalance() : int = state.b\n  public function senderBalance() : int = b()\n  private function b() = Chain.balance(Call.origin)\n"
,
"aesophia/test/contracts/channel_on_chain_contract_oracle.aes":"contract ChannelOnChainContractOracle =\n\n  type query_t  = string\n  type answer_t = string\n  type oracle_id = oracle(query_t, answer_t)\n  type query_id = oracle_query(query_t, answer_t)\n\n  record state = { oracle        : oracle_id,\n                   question      : string,\n                   bets          : map(string, address)\n                   }\n\n\n  public function init(oracle: oracle_id, question: string) : state =\n    { oracle   = oracle,\n      question = question,\n      bets     = {}\n      }\n\n  public stateful function place_bet(answer: string) = \n    switch(Map.lookup(answer, state.bets))\n      None =>\n        put(state{ bets = state.bets{[answer] = Call.caller}})\n        \"ok\"\n      Some(_value) =>\n        \"bet_already_taken\"\n\n  public function query_fee() =\n    Oracle.query_fee(state.oracle)\n\n  public function get_question(q: query_id) =\n    Oracle.get_question(state.oracle, q)\n\n  public stateful function resolve(q: query_id) =\n    switch(Oracle.get_answer(state.oracle, q))\n      None         =>\n        \"no response\"\n      Some(result) => \n        if(state.question == Oracle.get_question(state.oracle, q))\n            switch(Map.lookup(result, state.bets))\n              None         =>\n                \"no winning bet\"\n              Some(winner) =>\n                Chain.spend(winner, Contract.balance)\n                \"ok\"\n        else\n          \"different question\"\n\n"
,
"aesophia/test/contracts/namespace_bug.aes":"\nnamespace Foo =\n\n  record bla = {x : int, y : bool}\n\n  function bar() : Foo.bla = {x = 17, y = true}\n\ncontract Bug =\n\n  // Crashed the type checker\n  entrypoint foo() = Foo.bar()\n\n  // Also crashed the type checker\n  type t = Foo.bla\n\n  entrypoint test() =\n    let x : t = Foo.bar()\n    x\n"
,
"aesophia/test/contracts/let_patterns.aes":"contract LetPatterns =\n\n  record r = {x : int, y : int, b : bool}\n\n  entrypoint test() = foo([1, 0], (2, 3), Some(4), {x = 5, y = 6, b = false})\n\n  entrypoint foo(xs : list(int), p : int * int, some : option(int), r : r) =\n    let x :: _  = xs\n    let (a, b)  = p\n    let Some(n) = some\n    let {x = i, y = j} = r\n    x + a + b + n + i + j\n\n  entrypoint lc(xs : list(option(int))) : list(int) =\n    [ x | Some(x) <- xs ]\n"
,
"aesophia/test/contracts/missing_state_type.aes":"\ncontract MissingStateType =\n\n  // Check that we get a type error also for implicit state\n  entrypoint init() = \"should be ()\"\n\n"
,
"aesophia/test/contracts/stdlib_include.aes":"include \"List.aes\"\ninclude \"Func.aes\"\n\ncontract StdInc =\n  entrypoint test() = List.map((x) => Func.id(x), [1,2,3,4])\n\n"
,
"aesophia/test/contracts/payable.aes":"payable contract Test =\n  payable entrypoint foo(x : int) = ()\n  function bar() = 42\n"
,
"aesophia/test/contracts/oracles_no_vm.aes":"contract Oracles =\n\n  type fee = int\n  type ttl = Chain.ttl\n\n  type query_t  = string\n  type answer_t = string\n\n  type oracle_id = oracle(query_t, answer_t)\n  type query_id  = oracle_query(query_t, answer_t)\n\n  function createQuery(o    : oracle_id,\n                       q    : query_t,\n                       qfee : fee,\n                       qttl : ttl,\n                       rttl : ttl) : query_id =\n    require(qfee =< Call.value, \"insufficient value for qfee\")\n    Oracle.query(o, q, qfee, qttl, rttl)\n\n\n  function respond(o    : oracle_id,\n                   q    : query_id,\n                   sign : signature,\n                   r    : answer_t) : unit =\n    Oracle.respond(o, q, signature = sign, r)\n\n\n  function getQuestion(o : oracle_id,\n                       q : query_id) : query_t =\n    Oracle.get_question(o, q)\n\n  function getAnswer(o : oracle_id,\n                     q : query_id) : option(answer_t) =\n    Oracle.get_answer(o, q)\n\n"
,
"aesophia/test/contracts/test.aes":"\ncontract Identity =\n  // type xy = {x:int, y:int}\n  // type xz = {x:int, z:int}\n  // type yz = {y:int, z:int}\n  record point = {x:int,y:int}\n  record cp('a) = {color: string, p:'a}\n  //type intpoint = point(int)\n  //   //if (x==42) 1 else (x*x)\n  // }\n  //let baz() = {age:3, name:(4:int)}\n  //let foo(a,b,c) = c\n  // let rec fac(n) = if((n:int)==0) 1 else (n*fac(n-1))\n  //    and main(x) = x::[x+1]\n  // let lentr(l) = lent(0,l)\n  // let rec len(l) =\n  //    switch(l) {\n  //     | [] => 0\n  //     | x::xs => 1+len(xs)\n  //     }\n  // let lent(n,l) =\n  //   switch (l) {\n  //   | [] => n\n  //   | (x::xs) => lent(n+1,xs)\n  //   }\n  //  let rec app(a,b) =\n  //     switch(a) {\n  //     | [] => b\n  //     | (x::xs) => x::app(xs,b)\n  //     }\n  // let rec revt(l,r) =\n  //   switch(l) {\n  //   | [] => r\n  //   | x::xs => revt(xs,x::r)\n  //   }\n  // let rev(l) = revt(l,[])\n  // let main(x:int) = {\n  //   switch(rev([1,2,3])) {\n  //   | h::_ => h\n  //   }\n  //   }\n  //let fac(n:int) = {\n  //  if (n==0) 1 else (n*fac(n-1))\n  //}\n  //let main(x) = switch((12,34)) {\n  //| (13,_) => x\n  //| (_,a) => x+a\n  //    | y => y+1\n  //  }\n  //let main(x) = ({y:0>1, x:x==0}:point(bool))\n  //let main(x) = x\n  //let main(x) = len(1::2::[])\n  //let main(x) = ((x,x):list('a))\n  // let main(x) = switch(\"a\") {\n  //    \t  |  \"b\" => 0\n  // \t  |  \"a\" => 1\n  // \t  |  \"c\" => 2\n  // \t  }\n  //let main(x) = x.color+1\n  //let main(x) = switch(({x:x, y:x+1}:cp(int))) {\n  //              | {y:xx} => xx\n  //\t\t}\n  //let main(x) = {x:0, y:1, z:2}\n  // let id(x) = x\n  // let double(x) = x+x\n  // let pair(x) = (1,2)\n  // let unit(x) = ()\n  // let tuples(x) = ((1,x),(2,3,4))\n  // let singleton(x) = [x]\n  // let rec seq(n) = if (n==0) [] else (app(seq(n-1),[n]))\n  // let idString(s:string) = s\n  // let pairString(s:string) = (s,s)\n  // let revStrings(ss:list(string))=rev(ss)\n  // let makePoint(x,y) = {x:x, y:y}\n  // let getx(x) = x.x\n  // let updatex(p,x) = p{x:x}\n  // let quad(x) = {let y=x+x; let z=y+y; z;}\n //  let noblock(x) = {x; x}\n //  let unit(x) = ()\n  // let foo(x) = switch (x) {\n  //     \t       | y => y+1\n// \t       }\n  // let p(x) = {color:\"blue\", p:{x:x, y:x+1}}\n  //let twice(f,x) = f(f(x))\n  // let twice(f,x) = f(f(x))\n  // let double(x) = x+x\n  // let main(x) = twice((y=>y+y),x)\n  // let rec map(f,xs) = switch(xs) {\n  // | [] => []\n  // | (x::ys) => f(x)::map(f,ys)\n  // }\n  // let id(x) = x\n  // let main(xs) = map(double,xs)\n  function z(f,x) = x\n  function s(n) = (f,x)=>f(n(f,x))\n  function add(m,n) = (f,x)=>m(f,n(f,x))\n\n  entrypoint main() =\n    let three=s(s(s(z)))\n    add(three,three)\n       (((i)=>i+1),0)\n\n"
,
"aesophia/test/contracts/modifier_checks.aes":"\nnamespace Lib =\n  entrypoint foo() = ()\n\ncontract Remote =\n  public function foo : () => unit\n  function bla() = ()\n\ncontract Contract =\n  public function foo() = ()\n  public private stateful function all_the_things() = ()\n  private entrypoint wha() = ()\n"
,
"aesophia/test/contracts/maps_benchmark.aes":"\ncontract MapUpdater =\n  function update_map : (int, string, map(int, string)) => map(int, string)\n\ncontract Benchmark =\n\n  record state = { updater : MapUpdater,\n                   map     : map(int, string) }\n\n  function init(u, m) = { updater = u, map = m }\n\n  function set_updater(u) = put(state{ updater = u })\n\n  function update_map(k : int, v : string, m) = m{ [k] = v }\n\n  function update(a : int, b : int, v : string) =\n    if (a > b) ()\n    else\n      put(state{ map[a] = v })\n      update(a + 1, b, v)\n\n  function get(k) = state.map[k]\n  function noop() = ()\n\n  function benchmark(k, v) =\n    let m = state.updater.update_map(k, v, state.map)\n    put(state{ map = m })\n    m\n\n"
,
"aesophia/test/contracts/bad_number_of_args.aes":"contract Test =\n  entrypoint f() = ()\n  entrypoint g(x : int, y : string) = f(1)\n  entrypoint h() = g(1)\n  entrypoint i() = g(\"Litwo, ojczyzno moja\")\n  \n"
,
"aesophia/test/contracts/list_comp_if_not_bool.aes":"contract BadComp =\n  entrypoint failing() = [x | x <- [], if (3)] \n"
,
"aesophia/test/contracts/hermetization_turnoff.aes":"namespace M =\n  function mf() = mg()\n  function mg() = mf()\n\nnamespace N =\n  function nf() = ng() + M.mf() + M.mg()\n  private function ng() = nf() + M.mf() + M.mg()\n\ncontract C =\n  entrypoint f() = N.ng() + N.nf() + g()\n  function g() = N.ng() + N.nf() + f()\n"
,
"aesophia/test/contracts/unapplied_builtins.aes":"// Builtins without named arguments can appear unapplied in both AEVM and FATE.\n// Named argument builtins are:\n//    Oracle.register\n//    Oracle.respond\n//    AENS.preclaim\n//    AENS.claim\n//    AENS.transfer\n//    AENS.revoke\n//    Oracle.extend\ncontract UnappliedBuiltins =\n  entrypoint main() = ()\n  type o = oracle(int, int)\n  type t = list(int * string)\n  type m = map(int, int)\n  datatype event = Event(int)\n  stateful function chain_spend()        = Chain.spend\n  function chain_event()                 = Chain.event\n  function chain_balance()               = Chain.balance\n  function chain_block_hash()            = Chain.block_hash\n  function call_gas_left()               = Call.gas_left\n  function b_abort()                     = abort\n  function b_require()                   = require\n  function oracle_query_fee()            = Oracle.query_fee\n  stateful function oracle_query()       = Oracle.query        : (o, _, _, _, _) => _\n  function oracle_get_question()         = Oracle.get_question : (o, _) => _\n  function oracle_get_answer()           = Oracle.get_answer   : (o, _) => _\n  function oracle_check()                = Oracle.check        : o => _\n  function oracle_check_query()          = Oracle.check_query  : (o, _) => _\n  function aens_resolve()                = AENS.resolve        : (_, _) => option(string)\n  function map_lookup()                  = Map.lookup          : (_, m) => _\n  function map_lookup_default()          = Map.lookup_default  : (_, m, _) => _\n  function map_member()                  = Map.member          : (_, m) => _\n  function map_size()                    = Map.size : m => _\n  function map_delete()                  = Map.delete : (_, m) => _\n  function map_from_list()               = Map.from_list : _ => m\n  function map_to_list()                 = Map.to_list : m => _\n  function crypto_verify_sig()           = Crypto.verify_sig\n  function crypto_verify_sig_secp256k1() = Crypto.verify_sig_secp256k1\n  function crypto_ecverify_secp256k1()   = Crypto.ecverify_secp256k1\n  function crypto_ecrecover_secp256k1()  = Crypto.ecrecover_secp256k1\n  function crypto_sha3()                 = Crypto.sha3    : t => _\n  function crypto_sha256()               = Crypto.sha256  : t => _\n  function crypto_blake2b()              = Crypto.blake2b : t => _\n  function string_sha256()               = String.sha256\n  function string_blake2b()              = String.blake2b\n  function string_length()               = String.length\n  function string_concat()               = String.concat\n  function string_sha3()                 = String.sha3\n  function bits_test()                   = Bits.test\n  function bits_set()                    = Bits.set\n  function bits_clear()                  = Bits.clear\n  function bits_union()                  = Bits.union\n  function bits_intersection()           = Bits.intersection\n  function bits_difference()             = Bits.difference\n  function bits_sum()                    = Bits.sum\n  function int_to_str()                  = Int.to_str\n  function address_to_str()              = Address.to_str\n  function address_is_oracle()           = Address.is_oracle\n  function address_is_contract()         = Address.is_contract\n  function address_is_payable()          = Address.is_payable\n  function bytes_to_int()                = Bytes.to_int : bytes(10) => int\n  function bytes_to_str()                = Bytes.to_str : bytes(99) => string\n\n"
,
"aesophia/test/contracts/bad_records.aes":"contract BadRecord =\n  entrypoint foo() =\n    let r = {x = 0, [0] = 1}\n    r{x = 0, [0] = 1}\n    r{}\n"
,
"aesophia/test/contracts/functions.aes":"contract Functions =\n  function curry(f : ('a, 'b) => 'c) =\n    (x) => (y) => f(x, y)\n  function map(f : 'a => 'b, xs : list('a)) =\n    switch(xs)\n      [] => []\n      x :: xs => f(x) :: map(f, xs)\n  function map'() = map\n  function plus(x, y) = x + y\n  entrypoint test1(xs : list(int)) = map(curry(plus)(5), xs)\n  entrypoint test2(xs : list(int)) = map'()(((x) => (y) => ((x, y) => x + y)(x, y))(100), xs)\n  entrypoint test3(xs : list(int)) =\n    let m(f, xs) = map(f, xs)\n    m((x) => x + 1, xs)\n\n"
,
"aesophia/test/contracts/list_comp_bad_shadow.aes":"contract BadComp =\n  entrypoint failing() = [x + 1 | x <- [1,2,3], let x = \"XD\"]\n"
,
"aesophia/test/contracts/vclose.aes":"contract VClose =\n  entrypoint missing_bracket() =\n    let x = [1, 2, 3\n  entrypoint bar() = ()\n"
,
"aesophia/test/contracts/local_poly_fail.aes":"\ncontract Fail =\n\n  entrypoint tttt() : bool * int =\n    let f(x : 'a) : 'a = x\n    (f(true), f(1))\n\n"
,
"aesophia/test/contracts/aeproof.aes":"/*\ncontract AeToken {\n\tfunction balanceOf(address addr) returns (uint256)\n}\n\ncontract AEProof {\n\n\tAeToken aeToken\n\tmapping (bytes32 => Proof) private proofs\n\tmapping (address => bytes32[]) private proofsByOwner\n\n\tfunction AEProof(address tokenAddress) {\n\t\taeToken = AeToken(tokenAddress)\n\t}\n\n\tstruct Proof {\n\t\taddress owner\n\t\tuint timestamp\n\t\tuint proofBlock\n\t\tstring comment\n\t\tstring ipfsHash\n\t\tstring document\n\t}\n\n\tfunction notarize(string document, string comment, string ipfsHash) onlyTokenHolder {\n\t\tvar proofHash = calculateHash(document)\n\t\tvar proof = proofs[proofHash]\n\t\trequire(proof.owner == address(0))\n\t\tproof.owner = msg.sender\n\t\tproof.timestamp = block.timestamp\n\t\tproof.proofBlock = block.number\n\t\tproof.comment = comment\n\t\tproof.ipfsHash = ipfsHash\n\t\tproof.document = document\n\n\t\tproofsByOwner[msg.sender].push(proofHash)\n\t}\n\n\tfunction calculateHash(string document) constant returns (bytes32) {\n\t\treturn sha256(document)\n\t}\n\n\tfunction getProof(string document) constant returns (address owner, uint timestamp, uint proofBlock, string comment, string ipfsHash, string storedDocument) {\n\t\tvar calcHash = calculateHash(document)\n\t\tvar proof = proofs[calcHash]\n\t\trequire(proof.owner != address(0))\n\t\towner = proof.owner\n\t\ttimestamp = proof.timestamp\n\t\tproofBlock = proof.proofBlock\n\t\tcomment = proof.comment\n\t\tipfsHash = proof.ipfsHash\n\t\tstoredDocument = proof.document\n\t}\n\n\tfunction getProofByHash(bytes32 hash) constant returns (address owner, uint timestamp, uint proofBlock, string comment, string ipfsHash, string storedDocument) {\n\t\tvar proof = proofs[hash]\n\t\trequire(proof.owner != address(0))\n\t\towner = proof.owner\n\t\ttimestamp = proof.timestamp\n\t\tproofBlock = proof.proofBlock\n\t\tcomment = proof.comment\n\t\tipfsHash = proof.ipfsHash\n\t\tstoredDocument = proof.document\n\t}\n\n\tfunction hasProof(string document) constant returns (bool) {\n\t\tvar calcHash = calculateHash(document)\n\t\tvar storedProof = proofs[calcHash]\n\t\tif (storedProof.owner == address(0)) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tfunction getProofsByOwner(address owner) constant returns (bytes32[]) {\n\t\treturn proofsByOwner[owner]\n\t}\n\n\tmodifier onlyTokenHolder() {\n\t\tuint balance = aeToken.balanceOf(msg.sender)\n\t\trequire(balance > 0)\n\t\t_\n\t}\n}\n*/\n\n// No imports yet\n// import contract aetoken\n// fun balanceOf(addr : Address) : uint\n\ncontract AEProof =\n\n    record proof = { owner: address\n                   , timestamp: uint\n                   , proofBlock: uint\n                   , comment: string\n                   , ipfsHash: string\n                   , document: string\n                   }\n\n\n    record state = { aeToken : aetoken,\n                     proofs  : map(uint, proof),\n                     proofsByOwner : map(address, array(uint)) }\n\n    function notarize(document:string, comment:string, ipfsHash:hash) =\n        let _ = require(aetoken.balanceOf(caller()) > 0, \"false\")\n        let proofHash: uint = calculateHash(document)\n        let proof : proof = Map.get_(proofHash, state().proofs)\n        let _ = require(proof.owner == #0, \"false\")\n        let proof' : proof = proof { owner = caller()\n                                   , timestamp = block().timestamp\n                                   , proofBlock = block().height\n                                   , comment = comment\n                                   , ipfsHash = ipfsHash\n                                   , document = document\n                                   }\n        state{ proofsByOwner = Map.insert(caller, proofHash, state.proofsByOwner),\n               proofs = Map.insert(proofHash, proof', state.proofs) }\n\n\n    function calculateHash(document: string) : uint = sha256(document)\n\n    function getProof(document) : proof =\n        let calcHash = calculateHash(document)\n        let proof = Map.get_(calcHash, state().proofs)\n        let _ = require(proof.owner != #0, \"false\")\n        proof\n\n    function getProofByHash(hash: uint) : proof =\n        let proof = Map.get_(hash, state().proofs)\n        let _ = require(proof.owner != #0, \"false\")\n        proof\n\n\n    function hasProof(document: string) : bool =\n        let calcHash = calculateHash(document)\n        let storedProof = Map.get_(calcHash, state().proofs)\n        storedProof.owner != #0\n\n    function getProofsByOwner(owner: address): array(uint) =\n        Map.get(owner, state())\n\n"
,
"aesophia/test/contracts/minimal_init.aes":"contract MinimalInit =\n\n  record state = {foo : int}\n\n  function init() =\n    { foo = 0 }\n"
,
"aesophia/test/contracts/just_an_empty_file.aes":""
,
"aesophia/test/contracts/validation_test1.aes":"contract ValidationTest =\n  payable entrypoint attr_fail() = ()\n  entrypoint type_fail(x : int) = x\n  entrypoint code_fail(x) = x + 1\n"
,
"aesophia/test/contracts/bad_bytes_concat.aes":"contract BytesConcat =\n\n  entrypoint test1(x : bytes(10), y : bytes(20)) =\n    Bytes.concat(x, y)\n\n  entrypoint test2(x : bytes(10), y) : bytes(15) =\n    Bytes.concat(x, y)\n\n  entrypoint test3(x, y : bytes(20)) : bytes(25) =\n    Bytes.concat(x, y)\n\n  entrypoint fail1(x, y) : bytes(10) = Bytes.concat(x, y)\n  entrypoint fail2(x, y) = Bytes.concat(x, y)\n  entrypoint fail3(x : bytes(6), y : bytes(20)) : bytes(25) =\n    Bytes.concat(x, y)\n  entrypoint fail4(x : bytes(6), y) : _ =\n    Bytes.concat(x, y)\n\n  entrypoint fail5(x) = Bytes.to_str(x)\n"
,
"aesophia/test/contracts/stub.aes":"contract Stub =\n  entrypoint foo : (int) => int\n"
,
"aesophia/test/contracts/map_of_maps.aes":"\ncontract MapOfMaps =\n\n  type board = map(int, map(int, string))\n  type map2('a, 'b, 'c) = map('a, map('b, 'c))\n\n  record state = { big1   : map2(string, string, string),\n                   big2   : map2(string, string, string),\n                   small1 : map(string, string),\n                   small2 : map(string, string)  }\n\n  private function empty_state() =\n    { big1   = {}, big2   = {},\n      small1 = {}, small2 = {} }\n\n  function init() = empty_state()\n\n  function setup_state() =\n    let small = {[\"key\"] = \"val\"}\n    put({ big1 = {[\"one\"] = small},\n          big2 = {[\"two\"] = small},\n          small1 = small,\n          small2 = small })\n\n  // -- Garbage collection of inner map when outer map is garbage collected\n  function test1_setup() =\n    let inner = {[\"key\"] = \"val\"}\n    put(empty_state() { big1 = {[\"one\"] = inner} })\n\n  function test1_execute() =\n    put(state{ big1 = {} })\n\n  function test1_check() =\n    state.big1\n\n\n"
,
"aesophia/test/contracts/spend_test.aes":"\ncontract SpendContract =\n  entrypoint withdraw : (int) => int\n\ncontract SpendTest =\n\n  stateful entrypoint spend(to, amount) =\n    let total = Contract.balance\n    Chain.spend(to, amount)\n    total - amount\n\n  stateful entrypoint withdraw(amount) : int =\n    spend(Call.caller, amount)\n\n  stateful entrypoint withdraw_from(account, amount) =\n    account.withdraw(amount)\n    withdraw(amount)\n\n  stateful entrypoint spend_from(from, to, amount) =\n    from.withdraw(amount)\n    Chain.spend(to, amount)\n    Chain.balance(to)\n\n  entrypoint get_balance() = Contract.balance\n  entrypoint get_balance_of(a) = Chain.balance(a)\n\n"
,
"aesophia/test/contracts/dutch_auction.aes":"//\n// Dutch auction example\n//\ncontract DutchAuction =\n\n  record state = { start_amount : int,\n                   start_height : int,\n                   dec          : int,\n                   beneficiary  : address,\n                   sold         : bool }\n\n  // Add to work around current lack of predefined functions\n  stateful function spend(to, amount) =\n    let total = Contract.balance\n    Chain.spend(to, amount)\n    total - amount\n\n  // TTL set by user on posting contract, typically (start - end ) div dec\n  entrypoint init(beneficiary, start, decrease) : state =\n    require(start > 0 && decrease > 0, \"bad args\")\n    { start_amount = start,\n      start_height = Chain.block_height,\n      beneficiary  = beneficiary,\n      dec          = decrease,\n      sold         = false }\n\n  // -- API\n\n  // We are the buyer... interesting case to buy for someone else and keep 10%\n  stateful entrypoint bid() =\n    require( !(state.sold), \"sold\")\n    let cost =\n      state.start_amount - (Chain.block_height - state.start_height) * state.dec\n    require( Contract.balance >= cost, \"no money\")\n\n//    transaction(SpendTx({recipient = state.beneficiary,\n//                         amount    = cost }))  // or self.balance ** burn money **\n    spend(state.beneficiary, cost)\n    spend(Call.caller, Contract.balance)\n    put(state{sold = true})\n"
,
"aesophia/test/contracts/bad_events.aes":"contract Events =\n  type alias_int = int\n  type alias_address = address\n  type alias_string = string\n\n  datatype event =\n      Event1(indexed alias_int, indexed int, string)\n    | Event2(alias_string, indexed alias_address)\n    | BadEvent1(indexed string)\n    | BadEvent2(indexed alias_string)\n\n  entrypoint f1(x : int, y : string) =\n    Chain.event(Event1(x, x+1, y))\n\n  entrypoint f2(s : string) =\n    Chain.event(Event2(s, Call.caller))\n\n  entrypoint f3(x : int) =\n    Chain.event(Event1(x, x + 2, Int.to_str(x + 7)))\n\n  entrypoint i2s(i : int) = Int.to_str(i)\n  entrypoint a2s(a : address) = Address.to_str(a)\n\n"
,
"aesophia/test/contracts/multi_sig.aes":"/* Multi-signature wallet from\n   https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol\n\n*/\n\ncontract MultiSig =\n\n    record pending_state = { yetNeeded : int, ownersDone : bits, index : int }\n\n    datatype event =\n        Confirmation (address, hash)    // of { .owner : Address, .operation : Hash }\n      | Revoke       (address, hash)    // of { .owner : Address, .operation : Hash }\n      | OwnerChanged (address, address) // of { .oldOwner : Address, .newOwner : Address }\n      | OwnerAdded   (address)          // of { .newOwner : Address }\n      | OwnerRemoved (address)          // of { .removedOwner : Address }\n      | ReqChanged   (int)             // of { .newReq : int }\n\n    function maxOwners() : int = 250\n\n    record state = { nRequired    : int\n                 , nOwners      : int\n                 , owners       : map(int, address)\n                 , ownerIndex   : map(address, int)\n                 , pending      : map(hash, pending_state)\n                 , pendingIndex : list(address) }\n\n    function init (owners : list(address), nRequired : int) : state =\n      let n = length(owners) + 1\n      { nRequired  = nRequired,\n        nOwners    = n,\n        owners     = Map.from_list(MyList.zip([1..n], caller() :: owners)),\n        ownerIndex = Map.from_list(MyList.zip(caller() :: owners, [1..n])) }\n\n    function lookup(map, key) =\n      switch(Map.get(key, map))\n        None        => abort(\"not found\")\n        Some(value) => value\n\n    function revoke(operation : hash) =\n      let ownerIx = lookup(state.ownerIndex, caller())\n      let pending = lookup(state.pendingIndex, operation)\n      let _ = require(Bits.test(pending.ownersDone, ownerIx))\n      let pending' = pending { yetNeeded  = pending.yetNeeded + 1\n                             , ownersDone = Bits.clear(pending.ownersDone, ownerIx - 1) }\n      put(state{ pendingIndex.operator = pending' })\n      event(Revoke(caller, operation))\n\n\n    datatype check_pending = CheckOk(state) | CheckFail(state)\n\n    function changeOwner(fromOwner : address, toOwner : address) =\n      switch(check_pending(callhash()))\n        CheckFail(state') => { state = state' }\n        CheckOk(state') =>\n            if(isOwner(toOwner)) put(state')\n            else\n              switch(Map.get(fromOwner, state.ownerIndex))\n                None => { state = state' }\n                Some(ownerIx) =>\n                    { state = state' { owners = Map.insert(ownerIx, toOwner, state'.owners)\n                                    , ownerIndex = Map.delete(fromOwner, Map.insert(toOwner, ownerIx, state'.ownerIndex))\n                                    , pending = Map.empty\n                                    , pendingIx = [] },\n                      events = [OwnerChanged(fromOwner, toOwner)] }\n\n    function addOwner(newOwner : address) =\n      let _ = require (!isOwner(newOwner))\n      switch(check_pending(callhash()))\n        CheckFail(state') => { state = state' }\n        CheckOk(state') =>\n            if(state.nOwners >= maxOwners()) () /* TODO */\n            else\n              let nOwners' = state'.nOwners + 1\n              { state = state' { owners    = Map.insert(nOwners', newOwner, state'.owners)\n                              , ownerIndex = Map.insert(newOwner, nOwners', state'.ownerIndex)\n                              , pending    = Map.empty\n                              , pendingIx  = [] },\n                event = [OwnerAdded(newOwner)] }\n\n    function removeOwner(oldOwner : address) =\n      let _ = require(isOwner(oldOwner))\n      let _ = require(state.nRequired > state.nOwners - 1)\n      switch(check_pending(callhash()))\n        CheckFail(state') => { state = state' }\n        CheckOk(state') =>\n            let ownerIx = lookup(state'.ownerIndex, oldOwner)\n            { state = state' { owners = Map.delete(ownerIx, state'.owners)\n                             , ownerIndex = Map.delete(newOwner, state'.ownerIndex)\n                             , pending = Map.empty\n                             , pendingIx = [] },\n              event = [OwnerRemoved(oldOwner)] }\n\n    function changeRequirement(newReq : int) =\n      let _ = require(newReq =< state.nOwners)\n      switch(check_pending(callhash()))\n        CheckFail(state') => { state = state' }\n        CheckOk(state') =>\n          { state = state' { nRequired = newReq\n                           , pending = Map.empty\n                           , pendingIx = [] },\n            event = [ReqChanged(newReq)] }\n\n\n    function getOwner(ownerIx0 : int) =\n      lookup(state.owners, ownerIx0 + 1)\n\n    function isOwner(owner : address) =\n      switch(Map.get(owner, state.ownerIndex))\n        None    => false\n        Some(_) => true\n\n    function hasConfirmed(operation : hash, owner : address) =\n      switch(Map.get(operation, state.pending))\n        None => false\n        Some(pending) =>\n          let _ = require(isOwner(owner))\n          let ownerIx = lookup(state.ownerIndex, owner)\n          Bits.test(pending.ownersDone, ownerIx - 1)\n\n    /* Leave the rest for now... */\n\n"
,
"aesophia/test/contracts/type_clash.aes":"\ncontract Remote =\n\n  type themap = map(int, string)\n  entrypoint foo : () => themap\n\ncontract Main =\n\n  type themap = map(string, int)\n\n  // Should fail\n  entrypoint foo(r : Remote) : themap = r.foo()\n\n"
,
"aesophia/test/contracts/toplevel_let.aes":"contract C =\n  let this_is_illegal = 2/0\n  entrypoint this_is_legal() = 2/0"
,
"aesophia/test/contracts/erc20_token.aes":"contract ERC20Token =\n  record state = {\n    totalSupply : int,\n    decimals : int,\n    name : string,\n    symbol : string,\n    balances : map(address, int),\n    allowed : map(address, map(address,int)),\n    // Logs, remove when native Events are there\n    transfer_log : list((address,address,int)),\n    approval_log : list((address,address,int))}\n\n  // init(100000000, 10, \"Token Name\", \"TKN\")\n  public stateful function init(_totalSupply : int, _decimals : int, _name : string, _symbol : string ) = {\n    totalSupply = _totalSupply,\n    decimals = _decimals,\n    name = _name,\n    symbol = _symbol,\n    balances = {[Call.caller] = _totalSupply }, // creator gets all Tokens\n    allowed = {},\n    // Logs, remove when native Events are there\n    transfer_log = [],\n    approval_log = []}\n\n  public stateful function totalSupply() : int = state.totalSupply\n  public stateful function decimals() : int = state.decimals\n  public stateful function name() : string = state.name\n  public stateful function symbol() : string = state.symbol\n\n  public stateful function balanceOf(tokenOwner : address ) : int =\n    Map.lookup_default(tokenOwner, state.balances, 0)\n\n  public stateful function transfer(to : address, tokens : int) =\n    put( state{balances[Call.caller] = sub(state.balances[Call.caller], tokens) })\n    put( state{balances[to] = add(Map.lookup_default(to, state.balances, 0), tokens) })\n    transferEvent(Call.caller, to, tokens)\n    true\n\n  public stateful function approve(spender : address, tokens : int) =\n    // allowed[Call.caller] field must have a value!\n    ensure_allowed(Call.caller)\n    put( state{allowed[Call.caller][spender] = tokens} )\n    approvalEvent(Call.caller, spender, tokens)\n    true\n\n  public stateful function transferFrom(from : address, to : address, tokens : int) =\n    put( state{ balances[from] = sub(state.balances[from], tokens) })\n    put( state{ allowed[from][Call.caller] = sub(state.allowed[from][Call.caller], tokens) })\n    put( state{ balances[to] = add(balanceOf(to), tokens) })\n    transferEvent(from, to, tokens)\n    true\n\n  public function allowance(_owner : address, _spender : address) : int =\n    state.allowed[_owner][_spender]\n\n  public stateful function getTransferLog() : list((address,address,int)) =\n    state.transfer_log\n  public stateful function getApprovalLog() : list((address,address,int)) =\n    state.approval_log\n\n  //\n  // Private Functions\n  //\n\n  private function ensure_allowed(key : address) =\n    switch(Map.lookup(key, state.allowed))\n      None => put(state{allowed[key] = {}})\n      Some(_) => ()\n\n  private function transferEvent(from : address, to : address, tokens : int) =\n    let e = (from, to, tokens)\n    put( state{transfer_log = e :: state.transfer_log })\n    e\n\n  private function approvalEvent(from : address, to : address, tokens : int) =\n    let e = (from, to, tokens)\n    put( state{approval_log = e :: state.approval_log })\n    e\n\n  private function sub(_a : int, _b : int) : int =\n    require(_b =< _a, \"Error\")\n    _a - _b\n\n  private function add(_a : int, _b : int) : int =\n    let c : int = _a + _b\n    require(c >= _a, \"Error\")\n    c\n"
,
"aesophia/test/contracts/value_on_err.aes":"contract ValueOnErr =\n\n  public function err() : int =\n    switch(0) 1 => 5\n\n  public function ok() : int =\n    11\n"
,
"aesophia/test/contracts/multiplication_server.aes":"\ncontract MultiplicationServer =\n\n  function multiply(x : int, y : int) =\n    switch(Call.value >= 100)\n      true => x * y\n\n"
,
"aesophia/test/contracts/non_functional_entrypoint.aes":"contract C1 =\n  entrypoint f : int\n\ncontract C =\n  entrypoint f() = 123"
,
"aesophia/test/contracts/nodeadcode.aes":"\nnamespace MyList =\n\n  function map1(f : 'a => 'b, xs : list('a)) =\n    switch(xs)\n      [] => []\n      x :: xs => f(x) :: map1(f, xs)\n\n  function map2(f : 'a => 'b, xs : list('a)) =\n    switch(xs)\n      [] => []\n      x :: xs => f(x) :: map2(f, xs)\n\ncontract Deadcode =\n\n  entrypoint inc1(xs : list(int)) : list(int) =\n    MyList.map1((x) => x + 1, xs)\n\n  entrypoint inc2(xs : list(int)) : list(int) =\n    MyList.map2((x) => x + 1, xs)\n\n"
,
"aesophia/test/contracts/aens.aes":"// AENS tests\ncontract AENSTest =\n\n  // Name resolution\n\n  stateful entrypoint resolve_word(name : string, key : string) : option(address) =\n    AENS.resolve(name, key)\n\n  stateful entrypoint resolve_string(name : string, key : string) : option(string) =\n    AENS.resolve(name, key)\n\n  // Transactions\n\n  stateful entrypoint preclaim(addr  : address,     // Claim on behalf of this account (can be Contract.address)\n                             chash : hash) : unit = // Commitment hash\n    AENS.preclaim(addr, chash)\n\n  stateful entrypoint signedPreclaim(addr  : address, // Claim on behalf of this account (can be Contract.address)\n                                   chash : hash,             // Commitment hash\n                                   sign  : signature) : unit = // Signed by addr (if not Contract.address)\n    AENS.preclaim(addr, chash, signature = sign)\n\n  stateful entrypoint claim(addr : address,\n                          name : string,\n                          salt : int,\n                          name_fee : int) : unit =\n    AENS.claim(addr, name, salt, name_fee)\n\n  stateful entrypoint signedClaim(addr : address,\n                                name : string,\n                                salt : int,\n                                name_fee : int,\n                                sign : signature) : unit =\n    AENS.claim(addr, name, salt, name_fee, signature = sign)\n\n  // TODO: update() -- how to handle pointers?\n\n  stateful entrypoint transfer(owner     : address,\n                             new_owner : address,\n                             name      : string) : unit =\n    AENS.transfer(owner, new_owner, name)\n\n  stateful entrypoint signedTransfer(owner     : address,\n                                     new_owner : address,\n                                     name      : string,\n                                     sign      : signature) : unit =\n    AENS.transfer(owner, new_owner, name, signature = sign)\n\n  stateful entrypoint revoke(owner     : address,\n                           name      : string) : unit =\n    AENS.revoke(owner, name)\n\n  stateful entrypoint signedRevoke(owner     : address,\n                                   name      : string,\n                                   sign      : signature) : unit =\n    AENS.revoke(owner, name, signature = sign)\n"
,
"aesophia/test/contracts/address_literals.aes":"\ncontract Remote =\n  entrypoint foo : () => unit\n\ncontract AddressLiterals =\n  entrypoint addr() : address =\n    ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt\n  entrypoint oracle() : oracle(int, bool) =\n    ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5\n  entrypoint query() : oracle_query(int, bool) =\n    oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY\n  entrypoint contr() : Remote =\n    ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ\n  entrypoint contr_addr() : Remote =\n    Address.to_contract(addr())\n\n"
,
"aesophia/test/contracts/indent_fail.aes":"contract IndentFail =\n  entrypoint twoSpace() = ()\n entrypoint oneSpace() = ()\n"
,
"aesophia/test/contracts/remote_gas_test.aes":"contract Remote1 =\n  function set : (int) => int\n\ncontract RemoteCall =\n    record state = { i : int }\n\n    function init(x) = { i = x }\n\n    function set( x : int) : int =\n        let old = state.i\n        put(state{ i = x })\n        old\n\n    function call(r : Remote1, x : int, g : int) : int =\n        r.set(gas = g, value = 10, x)\n\n    function get() = state.i\n\n\n\n"
,
"aesophia/test/contracts/code_errors/complex_compare.aes":"contract ComplexCompare =\n\n  entrypoint test(x : string * int) =\n    (\"foo\", 1) != x\n"
,
"aesophia/test/contracts/code_errors/higher_order_response_type.aes":"contract HigherOrderResponseType =\n  stateful function foo(o, q : oracle_query(string, _)) =\n    Oracle.respond(o, q, (x) => x + 1)\n\n  entrypoint main() = ()\n"
,
"aesophia/test/contracts/code_errors/parameterised_state.aes":"contract ParameterisedState =\n\n  type state('a) = list('a)\n\n"
,
"aesophia/test/contracts/code_errors/parameterised_event.aes":"contract ParameterisedEvent =\n\n  datatype event('a) = Event(int)\n\n"
,
"aesophia/test/contracts/code_errors/polymorphic_entrypoint.aes":"contract PolymorphicEntrypoint =\n  entrypoint id(x : 'a) : 'a = x\n\n"
,
"aesophia/test/contracts/code_errors/unapplied_contract_call.aes":"contract Remote =\n  entrypoint foo : int => int\n\ncontract UnappliedContractCall =\n\n  function f(r) = r.foo\n\n  entrypoint test(r) = f(r)(0)\n\n"
,
"aesophia/test/contracts/code_errors/higher_order_query_type.aes":"contract HigherOrderQueryType =\n  stateful function foo(o) : oracle_query(_, string ) =\n    Oracle.query(o, (x) => x + 1, 100, RelativeTTL(100), RelativeTTL(100))\n\n  entrypoint main() = ()\n"
,
"aesophia/test/contracts/code_errors/higher_order_map_keys.aes":"contract MapAsMapKey =\n  type t('key) = map('key, int)\n\n  function foo(m) : t(int => int) = {[m] = 0}\n\n  entrypoint main() = ()\n"
,
"aesophia/test/contracts/code_errors/polymorphic_entrypoint_return.aes":"contract PolymorphicEntrypoint =\n  entrypoint fail() : 'a = abort(\"fail\")\n\n"
,
"aesophia/test/contracts/code_errors/last_declaration_must_be_contract.aes":"namespace LastDeclarationIsNotAContract =\n  function add(x, y) = x + y\n"
,
"aesophia/test/contracts/code_errors/higher_order_state.aes":"contract HigherOrderState =\n\n  record state = {f : int => int}\n\n  entrypoint init() = {f = (x) => x}\n  entrypoint apply(n) = state.f(n)\n  stateful entrypoint inc() = put(state{ f = (x) => state.f(x + 1) })\n"
,
"aesophia/test/contracts/code_errors/missing_definition.aes":"contract MissingDefinition =\n  entrypoint foo : int => int\n  entrypoint main() = foo(0)\n"
,
"aesophia/test/contracts/code_errors/polymorphic_aens_resolve.aes":"contract PolymorphicAENSresolve =\n\n  function fail() : option('a) =\n    AENS.resolve(\"foo.aet\", \"whatever\")\n\n  entrypoint main() = ()\n\n"
,
"aesophia/test/contracts/code_errors/unapplied_named_arg_builtin.aes":"contract UnappliedNamedArgBuiltin =\n  // Allowed in FATE, but not AEVM\n  stateful entrypoint main(s) =\n    let reg = Oracle.register\n    reg(signature = s, Contract.address, 100, RelativeTTL(100)) : oracle(int, int)\n"
,
"aesophia/test/contracts/code_errors/polymorphic_compare.aes":"contract PolymorphicCompare =\n\n  function cmp(x : 'a, y : 'a) : bool =\n    x == y\n\n  entrypoint test() =\n    cmp(4, 6) && cmp(true, false)\n"
,
"aesophia/test/contracts/code_errors/higher_order_entrypoint.aes":"contract HigherOrderEntrypoint =\n  entrypoint apply(f : int => int, x : int) = f(x)\n"
,
"aesophia/test/contracts/code_errors/polymorphic_response_type.aes":"contract PolymorphicResponseType =\n  function is_oracle(o : oracle(string, 'r)) =\n    Oracle.check(o)\n\n  entrypoint main(o : oracle(string, int)) = is_oracle(o)\n"
,
"aesophia/test/contracts/code_errors/higher_order_entrypoint_return.aes":"contract HigherOrderEntrypoint =\n  entrypoint add(x : int) = (y) => x + y\n"
,
"aesophia/test/contracts/code_errors/complex_compare_leq.aes":"contract ComplexCompare =\n\n  entrypoint test(x : int) =\n    (1, 2) =< (x, x + 1)\n"
,
"aesophia/test/contracts/code_errors/higher_order_compare.aes":"contract HigherOrderCompare =\n\n  function cmp(x : int => int, y) : bool =\n    x < y\n\n  entrypoint test() =\n    let f(x) = (y) => x + y\n    cmp(f(1), f(2))\n"
,
"aesophia/test/contracts/code_errors/missing_init_function.aes":"contract MissingInitFunction =\n  type state = int * int\n\n"
,
"aesophia/test/contracts/code_errors/bad_aens_resolve.aes":"contract BadAENSresolve =\n\n  type t('a) = option(list('a))\n\n  function fail() : t(int) =\n    AENS.resolve(\"foo.aet\", \"whatever\")\n\n  entrypoint main() = ()\n\n"
,
"aesophia/test/contracts/code_errors/polymorphic_map_keys.aes":"contract MapAsMapKey =\n  type t('key) = map('key, int)\n\n  function foo(m) : t('a) = {[m] = 0}\n\n  entrypoint main() = ()\n"
,
"aesophia/test/contracts/code_errors/polymorphic_query_type.aes":"contract PolymorphicQueryType =\n  stateful function is_oracle(o) =\n    Oracle.check(o)\n\n  entrypoint main() = ()\n"
,
"aesophia/priv/stdlib/Pair.aes":"namespace Pair =\n\n  function fst(t : ('a * 'b)) : 'a = switch(t)\n    (x, _) => x\n\n  function snd(t : ('a * 'b)) : 'b = switch(t)\n    (_, y) => y\n\n/** Map over first\n */\n  function map1(f : 'a => 'c, t : ('a * 'b)) : ('c * 'b) = switch(t)\n    (x, y) => (f(x), y)\n\n/** Map over second\n */\n  function map2(f : 'b => 'c, t : ('a * 'b)) : ('a * 'c) = switch(t)\n    (x, y) => (x, f(y))\n\n/** Map over both\n */\n  function bimap(f : 'a => 'c, g : 'b => 'd, t : ('a * 'b)) : ('c * 'd) = switch(t)\n    (x, y) => (f(x), g(y))\n\n  function swap(t : ('a * 'b)) : ('b * 'a) = switch(t)\n    (x, y) => (y, x)\n\n"
,
"aesophia/priv/stdlib/List.aes":"include \"ListInternal.aes\"\n\nnamespace List =\n\n  function is_empty(l : list('a)) : bool = switch(l)\n    [] => true\n    _  => false\n\n  function first(l : list('a)) : option('a) = switch(l)\n    []   => None\n    h::_ => Some(h)\n\n  function tail(l : list('a)) : option(list('a)) = switch(l)\n    []   => None\n    _::t => Some(t)\n\n  function last(l : list('a)) : option('a) = switch(l)\n    []   => None\n    [x]  => Some(x)\n    _::t => last(t)\n\n  function contains(e : 'a, l : list('a)) = switch(l)\n    []   => false\n    h::t => h == e || contains(e, t)\n\n/** Finds first element of `l` fulfilling predicate `p` as `Some` or `None`\n * if no such element exists.\n */\n  function find(p : 'a => bool, l : list('a)) : option('a) = switch(l)\n    []   => None\n    h::t => if(p(h)) Some(h) else find(p, t)\n\n/** Returns list of all indices of elements from `l` that fulfill the predicate `p`.\n */\n  function find_indices(p : 'a => bool, l : list('a)) : list(int) = find_indices_(p, l, 0, [])\n  private function find_indices_( p : 'a => bool\n                                , l : list('a)\n                                , n : int\n                                , acc : list(int)\n                                ) : list(int) = switch(l)\n    []   => reverse(acc)\n    h::t => find_indices_(p, t, n+1, if(p(h)) n::acc else acc)\n\n  function nth(n : int, l : list('a)) : option('a) =\n    switch(l)\n      []   => None\n      h::t => if(n == 0) Some(h) else nth(n-1, t)\n\n  /* Unsafe version of `nth` */\n  function get(n : int, l : list('a)) : 'a =\n    switch(l)\n      [] => abort(if(n < 0) \"Negative index get\" else \"Out of index get\")\n      h::t => if(n == 0) h else get(n-1, t)\n\n\n  function length(l : list('a)) : int = length_(l, 0)\n  private function length_(l : list('a), acc : int) : int = switch(l)\n    []   => acc\n    _::t => length_(t, acc + 1)\n\n\n/** Creates an ascending sequence of all integer numbers\n * between `a` and `b` (including `a` and `b`)\n */\n  function from_to(a : int, b : int) : list(int) = [a..b]\n\n/** Creates an ascending sequence of integer numbers betweeen\n * `a` and `b` jumping by given `step`. Includes `a` and takes\n * `b` only if `(b - a) mod step == 0`. `step` should be bigger than 0.\n */\n  function from_to_step(a : int, b : int, s : int) : list(int) = from_to_step_(a, b, s, [])\n  private function from_to_step_(a, b, s, acc) =\n    if (a > b) reverse(acc) else from_to_step_(a + s, b, s, a :: acc)\n\n\n/** Unsafe. Replaces `n`th element of `l` with `e`. Crashes on over/underflow\n */\n  function replace_at(n : int, e : 'a, l : list('a)) : list('a) =\n    if(n<0) abort(\"insert_at underflow\") else replace_at_(n, e, l, [])\n  private function replace_at_(n : int, e : 'a, l : list('a), acc : list('a)) : list('a) =\n   switch(l)\n     []   => abort(\"replace_at overflow\")\n     h::t => if (n == 0) reverse(e::acc) ++ t\n             else replace_at_(n-1, e, t, h::acc)\n\n/** Unsafe. Adds `e` to `l` to be its `n`th element. Crashes on over/underflow\n */\n  function insert_at(n : int, e : 'a, l : list('a)) : list('a) =\n    if(n<0) abort(\"insert_at underflow\") else insert_at_(n, e, l, [])\n  private function insert_at_(n : int, e : 'a, l : list('a), acc : list('a)) : list('a) =\n   if (n == 0) reverse(e::acc) ++ l\n   else switch(l)\n     []   => abort(\"insert_at overflow\")\n     h::t => insert_at_(n-1, e, t, h::acc)\n\n/** Assuming that cmp represents `<` comparison, inserts `x` before\n * the first element in the list `l` which is greater than it\n */\n  function insert_by(cmp : (('a, 'a) => bool), x : 'a, l : list('a)) : list('a) =\n    insert_by_(cmp, x, l, [])\n  private function insert_by_(cmp : (('a, 'a) => bool), x : 'a, l : list('a), acc : list('a)) : list('a) =\n    switch(l)\n      []   => reverse(x::acc)\n      h::t =>\n        if(cmp(x, h)) // x < h\n          reverse(acc) ++ (x::l)\n        else\n          insert_by_(cmp, x, t, h::acc)\n\n\n  function foldr(cons : ('a, 'b) => 'b, nil : 'b, l : list('a)) : 'b = switch(l)\n    []   => nil\n    h::t => cons(h, foldr(cons, nil, t))\n\n  function foldl(rcons : ('b, 'a) => 'b, acc : 'b, l : list('a)) : 'b = switch(l)\n    []   => acc\n    h::t => foldl(rcons, rcons(acc, h), t)\n\n  function foreach(l : list('a), f : 'a => unit) : unit =\n    switch(l)\n     []    => ()\n     e::l' =>\n       f(e)\n       foreach(l', f)\n\n  function reverse(l : list('a)) : list('a) = foldl((lst, el) => el :: lst, [], l)\n\n  function map(f : 'a => 'b, l : list('a)) : list('b) = map_(f, l, [])\n  private function map_(f : 'a => 'b, l : list('a), acc : list('b)) : list('b) = switch(l)\n    []   => reverse(acc)\n    h::t => map_(f, t, f(h)::acc)\n\n/** Effectively composition of `map` and `flatten`\n */\n  function flat_map(f : 'a => list('b), l : list('a)) : list('b) =\n    ListInternal.flat_map(f, l)\n\n  function filter(p : 'a => bool, l : list('a)) : list('a) = filter_(p, l, [])\n  private function filter_(p : 'a => bool, l : list('a), acc : list('a)) : list('a) = switch(l)\n    []   => reverse(acc)\n    h::t => filter_(p, t, if(p(h)) h::acc else acc)\n\n/** Take `n` first elements\n */\n  function take(n : int, l : list('a)) : list('a) =\n    if(n < 0) abort(\"Take negative number of elements\") else take_(n, l, [])\n  private function take_(n : int, l : list('a), acc : list('a)) : list('a) =\n    if(n == 0) reverse(acc)\n    else switch(l)\n      []   => reverse(acc)\n      h::t => take_(n-1, t, h::acc)\n\n/** Drop `n` first elements\n */\n  function drop(n : int, l : list('a)) : list('a) =\n   if(n < 0) abort(\"Drop negative number of elements\")\n   elif (n == 0) l\n   else switch(l)\n      []   => []\n      h::t => drop(n-1, t)\n\n/** Get the longest prefix of a list in which every element\n * matches predicate `p`\n */\n  function take_while(p : 'a => bool, l : list('a)) : list('a) = take_while_(p, l, [])\n  private function take_while_(p : 'a => bool, l : list('a), acc : list('a)) : list('a) = switch(l)\n    []   => reverse(acc)\n    h::t => if(p(h)) take_while_(p, t, h::acc) else reverse(acc)\n\n/** Drop elements from `l` until `p` holds\n */\n  function drop_while(p : 'a => bool, l : list('a)) : list('a) = switch(l)\n    []   => []\n    h::t => if(p(h)) drop_while(p, t) else l\n\n/** Splits list into two lists of elements that respectively\n * match and don't match predicate `p`\n */\n  function partition(p : 'a => bool, l : list('a)) : (list('a) * list('a)) = partition_(p, l, [], [])\n  private function partition_( p : 'a => bool\n                             , l : list('a)\n                             , acc_t : list('a)\n                             , acc_f : list('a)\n                             ) : (list('a) * list('a)) = switch(l)\n    []   => (reverse(acc_t), reverse(acc_f))\n    h::t => if(p(h)) partition_(p, t, h::acc_t, acc_f) else partition_(p, t, acc_t, h::acc_f)\n\n/** Flattens list of lists into a single list\n */\n  function flatten(ll : list(list('a))) : list('a) = foldr((l1, l2) => l1 ++ l2, [], ll)\n\n  function all(p : 'a => bool, l : list('a)) : bool = switch(l)\n    []   => true\n    h::t => if(p(h)) all(p, t) else false\n\n  function any(p : 'a => bool, l : list('a)) : bool = switch(l)\n    []   => false\n    h::t => if(p(h)) true else any(p, t)\n\n  function sum(l : list(int)) : int = foldl ((a, b) => a + b, 0, l)\n\n  function product(l : list(int)) : int = foldl((a, b) => a * b, 1, l)\n\n\n/** Zips two list by applying bimapping function on respective elements.\n * Drops longer tail.\n */\n  function zip_with(f : ('a, 'b) => 'c, l1 : list('a), l2 : list('b)) : list('c) = zip_with_(f, l1, l2, [])\n  private function zip_with_( f : ('a, 'b) => 'c\n                            , l1 : list('a)\n                            , l2 : list('b)\n                            , acc : list('c)\n                            ) : list('c) = switch ((l1, l2))\n    (h1::t1, h2::t2) => zip_with_(f, t1, t2, f(h1, h2)::acc)\n    _ => reverse(acc)\n\n/** Zips two lists into list of pairs. Drops longer tail.\n */\n  function zip(l1 : list('a), l2 : list('b)) : list('a * 'b) = zip_with((a, b) => (a, b), l1, l2)\n\n  function unzip(l : list('a * 'b)) : list('a) * list('b) = unzip_(l, [], [])\n  private function unzip_( l     : list('a * 'b)\n                         , acc_l : list('a)\n                         , acc_r : list('b)\n                         ) : (list('a) * list('b)) = switch(l)\n    []               => (reverse(acc_l), reverse(acc_r))\n    (left, right)::t => unzip_(t, left::acc_l, right::acc_r)\n\n\n  // TODO: Improve?\n  function sort(lesser_cmp : ('a, 'a) => bool, l : list('a)) : list('a) = switch(l)\n    []   => []\n    h::t => switch (partition((x) => lesser_cmp(x, h), t))\n      (lesser, bigger) => sort(lesser_cmp, lesser) ++ h::sort(lesser_cmp, bigger)\n\n/** Puts `delim` between every two members of the list\n */\n  function intersperse(delim : 'a, l : list('a)) : list('a) = intersperse_(delim, l, [])\n  private function intersperse_(delim : 'a, l : list('a), acc : list('a)) : list('a) = switch(l)\n    []   => reverse(acc)\n    [e]  => reverse(e::acc)\n    h::t => intersperse_(delim, t, delim::h::acc)\n\n\n/** Effectively a zip with an infinite sequence of natural numbers\n */\n  function enumerate(l : list('a)) : list(int * 'a) = enumerate_(l, 0, [])\n  private function enumerate_(l : list('a), n : int, acc : list(int * 'a)) : list(int * 'a) = switch(l)\n    []   => reverse(acc)\n    h::t => enumerate_(t, n + 1, (n, h)::acc)\n\n"
,
"aesophia/priv/stdlib/Triple.aes":"namespace Triple =\n\n  function fst(t : ('a * 'b * 'c)) : 'a = switch(t)\n    (x, _, _) => x\n\n  function snd(t : ('a * 'b * 'c)) : 'b = switch(t)\n    (_, y, _) => y\n\n  function thd(t : ('a * 'b * 'c)) : 'c = switch(t)\n    (_, _, z) => z\n\n\n/** Map over first\n */\n  function map1(f : 'a => 'm, t : ('a * 'b * 'c)) : ('m * 'b * 'c) = switch(t)\n    (x, y, z) => (f(x), y, z)\n\n/** Map over second\n */\n  function map2(f : 'b => 'm, t : ('a * 'b * 'c)) : ('a * 'm * 'c) = switch(t)\n    (x, y, z) => (x, f(y), z)\n\n/** Map over third\n */\n  function map3(f : 'c => 'm, t : ('a * 'b * 'c)) : ('a * 'b * 'm) = switch(t)\n    (x, y, z) => (x, y, f(z))\n\n/** Map over all elements\n */\n  function trimap( f : 'a => 'x\n                 , g : 'b => 'y\n                 , h : 'c => 'z\n                 , t : ('a * 'b * 'c)\n                 ) : ('x * 'y * 'z) = switch(t)\n    (x, y, z) => (f(x), g(y), h(z))\n\n  function swap(t : ('a * 'b * 'c)) : ('c * 'b * 'a) = switch(t)\n    (x, y, z) => (z, y, x)\n\n/** Right rotation\n */\n  function rotr(t : ('a * 'b * 'c)) : ('c * 'a * 'b) = switch(t)\n    (x, y, z) => (z, x, y)\n\n/** Left rotation\n */\n  function rotl(t : ('a * 'b * 'c)) : ('b * 'c * 'a) = switch(t)\n    (x, y, z) => (y, z, x)\n\n"
,
"aesophia/priv/stdlib/Func.aes":"namespace Func =\n\n  function id(x : 'a) : 'a = x\n\n  function const(x : 'a) : 'b => 'a = (y) => x\n\n  function flip(f : ('a, 'b) => 'c) : ('b, 'a) => 'c = (b, a) => f(a, b)\n\n  function comp(f : 'b => 'c, g : 'a => 'b) : 'a => 'c = (x) => f(g(x))\n\n  function pipe(f : 'a => 'b, g : 'b => 'c) : 'a => 'c = (x) => g(f(x))\n\n  function rapply(x : 'a, f : 'a => 'b) : 'b = f(x)\n\n/** The Z combinator - replacement for local and anonymous recursion.\n  */\n  function recur(f : ('arg => 'res, 'arg) => 'res) : 'arg => 'res =\n    (x) => f(recur(f), x)\n\n/** n-times composition with itself\n */\n  function iter(n : int, f : 'a => 'a) : 'a => 'a = iter_(n, f, (x) => x)\n  private function iter_(n : int, f : 'a => 'a, acc : 'a => 'a) : 'a => 'a =\n    if(n == 0) acc\n    elif(n == 1) comp(f, acc)\n    else iter_(n / 2, comp(f, f), if(n mod 2 == 0) acc else comp(f, acc))\n\n/** Turns an ugly, bad and disgusting arity-n function into\n * a beautiful and sweet function taking the first argument\n * and returning a function watiting for the remaining ones\n * in the same manner\n */\n  function curry2(f : ('a, 'b) => 'x) : 'a => ('b => 'x) =\n    (x) => (y) => f(x, y)\n  function curry3(f : ('a, 'b, 'c) => 'x) : 'a => ('b => ('c => 'x)) =\n    (x) => (y) => (z) => f(x, y, z)\n  function curry4(f : ('a, 'b, 'c, 'd) => 'x) : 'a => ('b => ('c => ('d => 'x))) =\n    (x) => (y) => (z) => (w) => f(x, y, z, w)\n  function curry5(f : ('a, 'b, 'c, 'd, 'e) => 'x) : 'a => ('b => ('c => ('d => ('e => 'x)))) =\n    (x) => (y) => (z) => (w) => (q) => f(x, y, z, w, q)\n\n/** Opposite of curry. Gross\n */\n  function uncurry2(f : 'a => ('b => 'x)) : ('a, 'b) => 'x =\n    (x, y) => f(x)(y)\n  function uncurry3(f : 'a => ('b => ('c => 'x))) : ('a, 'b, 'c) => 'x =\n    (x, y, z) => f(x)(y)(z)\n  function uncurry4(f : 'a => ('b => ('c => ('d => 'x)))) : ('a, 'b, 'c, 'd) => 'x =\n    (x, y, z, w) => f(x)(y)(z)(w)\n  function uncurry5(f : 'a => ('b => ('c => ('d => ('e => 'x))))) : ('a, 'b, 'c, 'd, 'e) => 'x =\n    (x, y, z, w, q) => f(x)(y)(z)(w)(q)\n\n/** Turns an arity-n function into a function taking n-tuple\n */\n  function tuplify2(f : ('a, 'b) => 'x) : (('a * 'b)) => 'x =\n    (t) => switch(t)\n      (x, y) => f(x, y)\n  function tuplify3(f : ('a, 'b, 'c) => 'x) : 'a * 'b * 'c => 'x =\n    (t) => switch(t)\n      (x, y, z) => f(x, y, z)\n  function tuplify4(f : ('a, 'b, 'c, 'd) => 'x) : 'a * 'b * 'c * 'd => 'x =\n    (t) => switch(t)\n      (x, y, z, w) => f(x, y, z, w)\n  function tuplify5(f : ('a, 'b, 'c, 'd, 'e) => 'x) : 'a * 'b * 'c * 'd * 'e => 'x =\n    (t) => switch(t)\n      (x, y, z, w, q) => f(x, y, z, w, q)\n\n/** Opposite of tuplify\n */\n  function untuplify2(f : 'a * 'b => 'x) : ('a, 'b) => 'x =\n    (x, y) => f((x, y))\n  function untuplify3(f : 'a * 'b * 'c => 'x) : ('a, 'b, 'c) => 'x =\n    (x, y, z) => f((x, y, z))\n  function untuplify4(f : 'a * 'b * 'c * 'd => 'x) : ('a, 'b, 'c, 'd) => 'x =\n    (x, y, z, w) => f((x, y, z, w))\n  function untuplify5(f : 'a * 'b * 'c * 'd * 'e => 'x) : ('a, 'b, 'c, 'd, 'e) => 'x =\n    (x, y, z, w, q) => f((x, y, z, w, q))\n"
,
"aesophia/priv/stdlib/ListInternal.aes":"namespace ListInternal =\n\n  // -- Flatmap ----------------------------------------------------------------\n\n  function flat_map(f : 'a => list('b), xs : list('a)) : list('b) =\n    switch(xs)\n      []      => []\n      x :: xs => f(x) ++ flat_map(f, xs)\n\n  // -- From..to ---------------------------------------------------------------\n\n  function from_to(a : int, b : int) : list(int) = from_to_(a, b, [])\n\n  private function from_to_(a, b, acc) =\n    if (a > b) acc else from_to_(a, b - 1, b :: acc)\n\n"
,
"aesophia/priv/stdlib/Frac.aes":"namespace Frac =\n\n  private function gcd(a : int, b : int) =\n    if (b == 0) a else gcd(b, a mod b)\n\n  private function abs_int(a : int) = if (a < 0) -a else a\n\n  datatype frac = Pos(int, int) | Zero | Neg(int, int)\n\n/** Checks if the internal representation is correct.\n  * Numerator and denominator must be positive.\n  * Exposed for debug purposes\n  */\n  function is_sane(f : frac) : bool = switch(f)\n    Pos(n, d) => n > 0 && d > 0\n    Zero => true\n    Neg(n, d) => n > 0 && d > 0\n\n  function num(f : frac) : int = switch(f)\n    Pos(n, _) => n\n    Neg(n, _) => -n\n    Zero      => 0\n\n  function den(f : frac) : int = switch(f)\n    Pos(_, d) => d\n    Neg(_, d) => d\n    Zero      => 1\n\n  function to_pair(f : frac) : int * int = switch(f)\n    Pos(n, d) => (n, d)\n    Neg(n, d) => (-n, d)\n    Zero      => (0, 1)\n\n  function sign(f : frac) : int = switch(f)\n    Pos(_, _) => 1\n    Neg(_, _) => -1\n    Zero      => 0\n\n  function to_str(f : frac) : string = switch(f)\n    Pos(n, d) => String.concat(Int.to_str(n), if (d == 1) \"\" else String.concat(\"/\", Int.to_str(d)))\n    Neg(n, d) => String.concat(\"-\", to_str(Pos(n, d)))\n    Zero      => \"0\"\n\n/** Reduce fraction to normal form\n */\n  function simplify(f : frac) : frac =\n    switch(f)\n      Neg(n, d) =>\n        let cd = gcd(n, d)\n        Neg(n / cd, d / cd)\n      Zero  => Zero\n      Pos(n, d)  =>\n        let cd = gcd(n, d)\n        Pos(n / cd, d / cd)\n\n/** Integer to rational division\n */\n  function make_frac(n : int, d : int) : frac =\n    if (d == 0) abort(\"Zero denominator\")\n    elif (n == 0) Zero\n    elif ((n < 0) == (d < 0)) simplify(Pos(abs_int(n), abs_int(d)))\n    else simplify(Neg(abs_int(n), abs_int(d)))\n\n  function one() : frac = Pos(1, 1)\n  function zero() : frac = Zero\n\n  function eq(a : frac, b : frac) : bool =\n    let (na, da) = to_pair(a)\n    let (nb, db) = to_pair(b)\n    (na == nb && da == db) || na * db == nb * da // they are more likely to be normalized\n\n  function neq(a : frac, b : frac) : bool =\n    let (na, da) = to_pair(a)\n    let (nb, db) = to_pair(b)\n    (na != nb || da != db) && na * db != nb * da\n\n  function geq(a : frac, b : frac) : bool = num(a) * den(b) >= num(b) * den(a)\n\n  function leq(a : frac, b : frac) : bool = num(a) * den(b) =< num(b) * den(a)\n\n  function gt(a : frac, b : frac) : bool = num(a) * den(b) > num(b) * den(a)\n\n  function lt(a : frac, b : frac) : bool = num(a) * den(b) < num(b) * den(a)\n\n  function min(a : frac, b : frac) : frac = if (leq(a, b)) a else b \n\n  function max(a : frac, b : frac) : frac = if (geq(a, b)) a else b \n\n  function abs(f : frac) : frac = switch(f)\n    Pos(n, d) => Pos(n, d)\n    Zero      => Zero\n    Neg(n, d) => Pos(n, d)\n\n  function from_int(n : int) : frac =\n    if   (n > 0) Pos(n, 1)\n    elif (n < 0) Neg(-n, 1)\n    else Zero\n\n  function floor(f : frac) : int = switch(f)\n    Pos(n, d) => n / d\n    Zero      => 0\n    Neg(n, d) => -(n + d - 1) / d\n\n  function ceil(f : frac) : int = switch(f)\n    Pos(n, d) => (n + d - 1) / d\n    Zero      => 0\n    Neg(n, d) => -n / d\n  \n  function round_to_zero(f : frac) : int = switch(f)\n    Pos(n, d) => n / d\n    Zero      => 0\n    Neg(n, d) => -n / d\n\n  function round_from_zero(f : frac) : int = switch(f)\n    Pos(n, d) => (n + d - 1) / d\n    Zero      => 0\n    Neg(n, d) => -(n + d - 1) / d\n\n/** Round towards nearest integer. If two integers are in the same\n * distance, choose the even one.\n */\n  function round(f : frac) : int =\n    let fl = floor(f)\n    let cl = ceil(f)\n    let dif_fl = abs(sub(f, from_int(fl)))\n    let dif_cl = abs(sub(f, from_int(cl)))\n    if   (gt(dif_fl, dif_cl)) cl\n    elif (gt(dif_cl, dif_fl)) fl\n    elif (fl mod 2 == 0) fl\n    else cl\n\n  function add(a : frac, b : frac) : frac =\n    let (na, da) = to_pair(a)\n    let (nb, db) = to_pair(b)\n    if   (da == db) make_frac(na + nb, da)\n    else make_frac(na * db + nb * da, da * db)\n\n  function neg(a : frac) : frac = switch(a)\n    Neg(n, d) => Pos(n, d)\n    Zero      => Zero\n    Pos(n, d) => Neg(n, d)\n\n  function sub(a : frac, b : frac) : frac = add(a, neg(b))\n\n  function inv(a : frac) : frac = switch(a)\n    Neg(n, d) => Neg(d, n)\n    Zero      => abort(\"Inversion of zero\")\n    Pos(n, d) => Pos(d, n)\n\n  function mul(a : frac, b : frac) : frac = make_frac(num(a) * num(b), den(a) * den(b))\n\n  function div(a : frac, b : frac) : frac = switch(b)\n    Neg(n, d) => mul(a, Neg(d, n))\n    Zero      => abort(\"Division by zero\")\n    Pos(n, d) => mul(a, Pos(d, n))\n\n/** `b` to the power of `e`\n */\n  function int_exp(b : frac, e : int) : frac =\n    if (sign(b) == 0 && e == 0) abort(\"Zero to the zero exponentation\")\n    elif (e < 0) inv(int_exp_(b, -e))\n    else int_exp_(b, e)\n  private function int_exp_(b : frac, e : int) =\n      if (e == 0) from_int(1)\n      elif (e == 1) b\n      else\n        let half = int_exp_(b, e / 2)\n        if (e mod 2 == 1) mul(mul(half, half), b)\n        else mul(half, half)\n\n/** Reduces the fraction's in-memory size by dividing its components by two until the\n * the error is bigger than `loss` value\n */\n  function optimize(f : frac, loss : frac) : frac =\n    require(geq(loss, Zero), \"negative loss optimize\")\n    let s = sign(f)\n    mul(from_int(s), run_optimize(abs(f), abs(f), loss))\n  private function run_optimize(orig : frac, f : frac, loss : frac) : frac =\n    let (n, d) = to_pair(f)\n    let t = make_frac((n+1)/2, (d+1)/2)\n    if(gt(abs(sub(t, orig)), loss)) f\n    elif (eq(t, f)) f\n    else run_optimize(orig, t, loss)\n"
,
"aesophia/priv/stdlib/Option.aes":"include \"List.aes\"\n\nnamespace Option =\n\n  function is_none(o : option('a)) : bool = switch(o)\n    None => true\n    Some(_) => false\n\n  function is_some(o : option('a)) : bool = switch(o)\n    None => false\n    Some(_) => true\n\n/** Catamorphism on `option`. Also known as inlined pattern matching.\n */\n  function match(n : 'b, s : 'a => 'b, o : option('a)) : 'b = switch(o)\n    None => n\n    Some(x) => s(x)\n\n/** Escape option providing default if `None`\n */\n  function default(def : 'a, o : option('a)) : 'a = match(def, (x) => x, o)\n\n/** Assume it is `Some`\n */\n  function force(o : option('a)) : 'a = switch(o)\n    None    => abort(\"Forced None value\")\n    Some(x) => x\n\n  function contains(e : 'a, o : option('a)) = o == Some(e)\n\n  function on_elem(o : option('a), f : 'a => unit) : unit = match((), f, o)\n\n  function map(f : 'a => 'b, o : option('a)) : option('b) = switch(o)\n    None => None\n    Some(x) => Some(f(x))\n\n  function map2(f : ('a, 'b) => 'c\n               , o1 : option('a)\n               , o2 : option('b)\n               ) : option('c) = switch((o1, o2))\n    (Some(x1), Some(x2)) => Some(f(x1, x2))\n    _ => None\n\n  function map3( f : ('a, 'b, 'c) => 'd\n               , o1 : option('a)\n               , o2 : option('b)\n               , o3 : option('c)\n               ) : option('d) = switch((o1, o2, o3))\n    (Some(x1), Some(x2), Some(x3)) => Some(f(x1, x2, x3))\n    _ => None\n\n/** Like `map`, but the function is in `option`\n */\n  function app_over(f : option ('a => 'b), o : option('a)) : option('b) = switch((f, o))\n    (Some(ff), Some(xx)) => Some(ff(xx))\n    _ => None\n\n/** Monadic bind\n */\n  function flat_map(f : 'a => option('b), o : option('a)) : option('b) = switch(o)\n    None => None\n    Some(x) => f(x)\n\n\n  function to_list(o : option('a)) : list('a) = switch(o)\n    None => []\n    Some(x) => [x]\n\n/** Turns list of options into a list of elements that are under `Some`s.\n * Safe.\n */\n  function filter_options(l : list(option('a))) : list('a) = filter_options_(l, [])\n  private function filter_options_(l : list (option('a)), acc : list('a)) : list('a) = switch(l)\n    []         => List.reverse(acc)\n    None::t    => filter_options_(t, acc)\n    Some(x)::t => filter_options_(t, x::acc)\n\n/** Just like `filter_options` but requires all elements to be `Some` and returns\n * None if any of them is not\n */\n  function seq_options(l : list (option('a))) : option (list('a)) = seq_options_(l, [])\n  private function seq_options_(l : list (option('a)), acc : list('a)) : option(list('a)) = switch(l)\n    []         => Some(List.reverse(acc))\n    None::t    => None\n    Some(x)::t => seq_options_(t, x::acc)\n\n/** Choose `Some` out of two if possible\n */\n  function choose(o1 : option('a), o2 : option('a)) : option('a) =\n    if(is_some(o1)) o1 else o2\n\n/** Choose `Some` from list of options if possible\n */\n  function choose_first(l : list(option('a))) : option('a) = switch(l)\n    [] => None\n    None::t    => choose_first(t)\n    Some(x)::_ => Some(x)\n\n"
,
"":null}
